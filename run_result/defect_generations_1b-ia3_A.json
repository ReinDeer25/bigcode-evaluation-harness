[[{"ID": 0, "prediction": "0", "true_label": "0", "raw_text": "_get_extradata(codec, pb, size) < 0)\n\n            return AVERROR(ENOMEM);\n\n        nb_streams         = AV_RL16(codec->extradata + 4);\n\n        codec->sample_rate = AV_RL32(codec->extradata + 12);\n\n        codec->channels    = 0;\n\n        bitrate            = 0;\n\n        if (size < 8 + nb_streams * 20)\n\n            return AVERROR_INVALIDDATA;\n\n        for (i = 0; i < nb_streams; i++)\n\n            codec->channels += codec->extradata[8 + i * 20 + 17];\n\n    }\n\n\n\n    if (bitrate > INT_MAX) {\n\n        if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The bitrate %\"PRIu64\" is too large.\\n\",\n\n                    bitrate);\n\n            return AVERROR_INVALIDDATA;\n\n        } else {\n\n            av_log(s, AV_LOG_WARNING,\n\n                   \"The bitrate %\"PRIu64\" is too large, resetting to 0.\",\n\n                   bitrate);\n\n            codec->bit_rate = 0;\n\n        }\n\n    } else {\n\n        codec->bit_rate = bitrate;\n\n    }\n\n\n\n    if (codec->sample_rate <= 0) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"Invalid sample rate: %d\\n\", codec->sample_rate);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (codec->codec_id == AV_CODEC_ID_AAC_LATM) {\n\n        /* Channels and sample_rate values are those prior to applying SBR\n\n         * and/or PS. */\n\n        codec->channels    = 0;\n\n        codec->sample_rate = 0;\n\n    }\n\n    /* override bits_per_coded_sample for G.726 */\n\n    if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate)\n\n        codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1, "prediction": "-1", "true_label": "1", "raw_text": "9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2, "prediction": "0", "true_label": "1", "raw_text": "Question: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,\n\n                                int pred_order)\n\n{\n\n    int p, porder, psize;\n\n    int i, part_end;\n\n    int count = 0;\n\n\n\n    /* subframe header */\n\n    count += 8;\n\n\n\n    /* subframe */\n\n    if (sub->type == FLAC_SUBFRAME_CONSTANT) {\n\n        count += sub->obits;\n\n    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {\n\n        count += s->frame.blocksize * sub->obits;\n\n    } else {\n\n        /* warm-up samples */\n\n        count += pred_order * sub->obits;\n\n\n\n        /* LPC coefficients */\n\n        if (sub->type == FLAC_SUBFRAME_LPC)\n\n            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;\n\n\n\n        /* rice-encoded block */\n\n        count += 2;\n\n\n\n        /* partition order */\n\n        porder = sub->rc.porder;\n\n        psize  = s->frame.blocksize >> porder;\n\n        count += 4;\n\n\n\n        /* residual */\n\n        i        = pred_order;\n\n        part_end = psize;\n\n        for (p = 0; p < 1 << porder; p++) {\n\n            int k = sub->rc.params[p];\n\n            count += 4;\n\n            count += rice_count_exact(&sub->residual[i], part_end - i, k);\n\n            i = part_end;\n\n            part_end = FFMIN(s->frame.blocksize, part_end + psize);\n\n        }\n\n    }\n\n\n\n    return count;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 3, "prediction": "0", "true_label": "0", "raw_text": ") {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size < 0) {\n\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    spapr->entry_point = 0x100;\n\n\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\n\n                                            initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            boot_device, kernel_cmdline,\n\n                                            spapr->epow_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 4, "prediction": "0", "true_label": "0", "raw_text": "a_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 5, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 6, "prediction": "1", "true_label": "1", "raw_text": "Question: static void scsi_read_request(SCSIDiskReq *r)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    if (r->sector_count == (uint32_t)-1) {\n\n        DPRINTF(\"Read buf_len=%zd\\n\", r->iov.iov_len);\n\n        r->sector_count = 0;\n\n        scsi_req_data(&r->req, r->iov.iov_len);\n\n        return;\n\n    }\n\n    DPRINTF(\"Read sector_count=%d\\n\", r->sector_count);\n\n    if (r->sector_count == 0) {\n\n        scsi_command_complete(r, GOOD, NO_SENSE);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    n = r->sector_count;\n\n    if (n > SCSI_DMA_BUF_SIZE / 512)\n\n        n = SCSI_DMA_BUF_SIZE / 512;\n\n\n\n    r->iov.iov_len = n * 512;\n\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,\n\n                              scsi_read_complete, r);\n\n    if (r->req.aiocb == NULL) {\n\n        scsi_read_complete(r, -EIO);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 7, "prediction": "0", "true_label": "1", "raw_text": "size,\n\n                          dinfo ? blk_by_legacy_dinfo(dinfo) : NULL,\n\n                          flash_sector_size, flash_size / flash_sector_size,\n\n                          1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0));\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init(serial_hds[1]);\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, EM_LATTICEMICO32, 0, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 8, "prediction": "0", "true_label": "0", "raw_text": ")\n\n\t\treturn command_usage(&aio_write_cmd);\n\n\n\n\tctx->offset = cvtnum(argv[optind]);\n\n\tif (ctx->offset < 0) {\n\n\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n\t\treturn 0;\n\n\t}\n\n\toptind++;\n\n\n\n\tif (ctx->offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)ctx->offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (count & 0x1ff) {\n\n\t\tprintf(\"count %d is not sector aligned\\n\",\n\n\t\t\tcount);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tfor (i = optind; i < argc; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tcount += len;\n\n\t}\n\n\n\n\tnr_iov = argc - optind;\n\n\tqemu_iovec_init(&ctx->qiov, nr_iov);\n\n\tctx->buf = p = qemu_io_alloc(count, pattern);\n\n\tfor (i = 0; i < nr_iov; i++) {\n\n\t        size_t len;\n\n\n\n\t\tlen = cvtnum(argv[optind]);\n\n\t\tif (len < 0) {\n\n\t\t\tprintf(\"non-numeric length argument -- %s\\n\",\n\n\t\t\t\targv[optind]);\n\n\t\t\treturn 0;\n\n\t\t}\n\n\n\n\t\tqemu_iovec_add(&ctx->qiov, p, len);\n\n\t\tp += len;\n\n\t\toptind++;\n\n\t}\n\n\n\n\tgettimeofday(&ctx->t1, NULL);\n\n\tacb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov,\n\n\t\t\t      ctx->qiov.size >> 9, aio_write_done, ctx);\n\n\tif (!acb)\n\n\t\treturn -EIO;\n\n\n\n\treturn 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 9, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 10, "prediction": "0", "true_label": "1", "raw_text": " (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags,\n\n                             &local_err);\n\n        if (ret) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n            VmdkExtent *extent;\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, sectors, &extent);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            ret = vmdk_open_sparse(bs, extent_file, bs->open_flags);\n\n            if (ret) {\n\n                bdrv_unref(extent_file);\n\n                return ret;\n\n            }\n\n        } else {\n\n            fprintf(stderr,\n\n                \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type);\n\n            return -ENOTSUP;\n\n        }\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p && *p != '\\n') {\n\n            p++;\n\n        }\n\n        p++;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 11, "prediction": "0", "true_label": "1", "raw_text": "coefs;\n\n    int blk, bnd, i;\n\n    AC3Block *block, *block0;\n\n\n\n    s->num_rematrixing_bands = 4;\n\n\n\n    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)\n\n        return;\n\n\n\n    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);\n\n\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        block = &s->blocks[blk];\n\n        block->new_rematrixing_strategy = !blk;\n\n        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {\n\n            /* calculate calculate sum of squared coeffs for one band in one block */\n\n            int start = ff_ac3_rematrix_band_tab[bnd];\n\n            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);\n\n            CoefSumType sum[4] = {0,};\n\n            for (i = start; i < end; i++) {\n\n                CoefType lt = block->mdct_coef[0][i];\n\n                CoefType rt = block->mdct_coef[1][i];\n\n                CoefType md = lt + rt;\n\n                CoefType sd = lt - rt;\n\n                sum[0] += lt * lt;\n\n                sum[1] += rt * rt;\n\n                sum[2] += md * md;\n\n                sum[3] += sd * sd;\n\n            }\n\n\n\n            /* compare sums to determine if rematrixing will be used for this band */\n\n            if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1]))\n\n                block->rematrixing_flags[bnd] = 1;\n\n            else\n\n                block->rematrixing_flags[bnd] = 0;\n\n\n\n            /* determine if new rematrixing flags will be sent */\n\n            if (blk &&\n\n                block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) {\n\n                block->new_rematrixing_strategy = 1;\n\n            }\n\n        }\n\n        block0 = block;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 12, "prediction": "0", "true_label": "1", "raw_text": "Question: void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 13, "prediction": "0", "true_label": "0", "raw_text": "Question: void cpu_x86_init_mmu(CPUX86State *env)\n\n{\n\n    a20_enabled = 1;\n\n    a20_mask = 0xffffffff;\n\n\n\n    last_pg_state = -1;\n\n    cpu_x86_update_cr0(env);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 14, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 15, "prediction": "0", "true_label": "0", "raw_text": "Question: static void net_vhost_link_down(VhostUserState *s, bool link_down)\n\n{\n\n    s->nc.link_down = link_down;\n\n\n\n    if (s->nc.peer) {\n\n        s->nc.peer->link_down = link_down;\n\n    }\n\n\n\n    if (s->nc.info->link_status_changed) {\n\n        s->nc.info->link_status_changed(&s->nc);\n\n    }\n\n\n\n    if (s->nc.peer && s->nc.peer->info->link_status_changed) {\n\n        s->nc.peer->info->link_status_changed(s->nc.peer);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 16, "prediction": "0", "true_label": "0", "raw_text": " RV34_MB_B_BACKWARD);\n\n        break;\n\n    case RV34_MB_P_16x8:\n\n    case RV34_MB_P_8x16:\n\n        rv34_pred_mv(r, block_type, 0, 0);\n\n        rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1);\n\n        if(block_type == RV34_MB_P_16x8){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0,            2, 1, 0);\n\n            rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0);\n\n        }\n\n        if(block_type == RV34_MB_P_8x16){\n\n            rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0);\n\n            rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0);\n\n        }\n\n        break;\n\n    case RV34_MB_B_BIDIR:\n\n        rv34_pred_mv_b  (r, block_type, 0);\n\n        rv34_pred_mv_b  (r, block_type, 1);\n\n        rv34_mc_2mv     (r, block_type);\n\n        break;\n\n    case RV34_MB_P_8x8:\n\n        for(i=0;i< 4;i++){\n\n            rv34_pred_mv(r, block_type, i, i);\n\n            rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0);\n\n        }\n\n        break;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 17, "prediction": "-1", "true_label": "1", "raw_text": " {\n\n        buf_size = DEFAULT_MIRROR_BUF_SIZE;\n\n    }\n\n\n\n    /* We can't support this case as long as the block layer can't handle\n\n     * multiple BlockBackends per BlockDriverState. */\n\n    if (replaces) {\n\n        replaced_bs = bdrv_lookup_bs(replaces, replaces, errp);\n\n        if (replaced_bs == NULL) {\n\n            return;\n\n        }\n\n    } else {\n\n        replaced_bs = bs;\n\n    }\n\n    if (replaced_bs->blk && target->blk) {\n\n        error_setg(errp, \"Can't create node with two BlockBackends\");\n\n        return;\n\n    }\n\n\n\n    s = block_job_create(driver, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->replaces = g_strdup(replaces);\n\n    s->on_source_error = on_source_error;\n\n    s->on_target_error = on_target_error;\n\n    s->target = target;\n\n    s->is_none_mode = is_none_mode;\n\n    s->base = base;\n\n    s->granularity = granularity;\n\n    s->buf_size = ROUND_UP(buf_size, granularity);\n\n    s->unmap = unmap;\n\n\n\n    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);\n\n    if (!s->dirty_bitmap) {\n\n        g_free(s->replaces);\n\n        block_job_unref(&s->common);\n\n        return;\n\n    }\n\n\n\n    bdrv_op_block_all(s->target, s->common.blocker);\n\n\n\n    bdrv_set_enable_write_cache(s->target, true);\n\n    if (s->target->blk) {\n\n        blk_set_on_error(s->target->blk, on_target_error, on_target_error);\n\n        blk_iostatus_enable(s->target->blk);\n\n    }\n\n    s->common.co = qemu_coroutine_create(mirror_run);\n\n    trace_mirror_start(bs, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 18, "prediction": "0", "true_label": "0", "raw_text": "Question: START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 19, "prediction": "0", "true_label": "1", "raw_text": "Question: static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 20, "prediction": "0", "true_label": "1", "raw_text": "RADL:\n\n    case HEVC_NAL_BLA_N_LP:\n\n    case HEVC_NAL_IDR_W_RADL:\n\n    case HEVC_NAL_IDR_N_LP:\n\n    case HEVC_NAL_CRA_NUT:\n\n        {\n\n            H265RawSlice *slice;\n\n            int pos, len;\n\n\n\n            slice = av_mallocz(sizeof(*slice));\n\n            if (!slice)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header);\n\n            if (err < 0) {\n\n                av_free(slice);\n\n                return err;\n\n            }\n\n\n\n            pos = bitstream_tell(&bc);\n\n            len = unit->data_size;\n\n            if (!unit->data[len - 1]) {\n\n                int z;\n\n                for (z = 0; z < len && !unit->data[len - z - 1]; z++);\n\n                av_log(ctx->log_ctx, AV_LOG_DEBUG, \"Deleted %d trailing zeroes \"\n\n                       \"from slice data.\\n\", z);\n\n                len -= z;\n\n            }\n\n\n\n            slice->data_size = len - pos / 8;\n\n            slice->data = av_malloc(slice->data_size);\n\n            if (!slice->data) {\n\n                av_free(slice);\n\n                return AVERROR(ENOMEM);\n\n            }\n\n            memcpy(slice->data,\n\n                   unit->data + pos / 8, slice->data_size);\n\n            slice->data_bit_start = pos % 8;\n\n\n\n            unit->content = slice;\n\n        }\n\n        break;\n\n\n\n    case HEVC_NAL_AUD:\n\n        {\n\n            H265RawAUD *aud;\n\n\n\n            aud = av_mallocz(sizeof(*aud));\n\n            if (!aud)\n\n                return AVERROR(ENOMEM);\n\n            err = cbs_h265_read_aud(ctx, &bc, aud);\n\n            if (err < 0) {\n\n                av_free(aud);\n\n                return err;\n\n            }\n\n\n\n            unit->content = aud;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 21, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qpa_audio_fini (void *opaque)\n\n{\n\n    (void) opaque;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 22, "prediction": "0", "true_label": "1", "raw_text": "Question: static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 23, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 24, "prediction": "0", "true_label": "1", "raw_text": "Question: static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 25, "prediction": "0", "true_label": "1", "raw_text": "Question: static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,\n\n                                    uint64_t value, unsigned size,\n\n                                    MemTxAttrs attrs)\n\n{\n\n    int ret = 0;\n\n    MSIMessage from = {0}, to = {0};\n\n\n\n    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;\n\n    from.data = (uint32_t) value;\n\n\n\n    ret = vtd_interrupt_remap_msi(opaque, &from, &to);\n\n    if (ret) {\n\n        /* TODO: report error */\n\n        VTD_DPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64\n\n                    \" data 0x%\"PRIx32, from.address, from.data);\n\n        /* Drop this interrupt */\n\n        return MEMTX_ERROR;\n\n    }\n\n\n\n    VTD_DPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32\n\n                \" for device sid 0x%04x\",\n\n                to.address, to.data, sid);\n\n\n\n    if (dma_memory_write(&address_space_memory, to.address,\n\n                         &to.data, size)) {\n\n        VTD_DPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64\n\n                    \" value 0x%\"PRIx32, to.address, to.data);\n\n    }\n\n\n\n    return MEMTX_OK;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 26, "prediction": "0", "true_label": "1", "raw_text": "Question: void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 27, "prediction": "0", "true_label": "0", "raw_text": " NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 28, "prediction": "0", "true_label": "1", "raw_text": "Question: static size_t header_ext_add(char *buf, uint32_t magic, const void *s,\n\n    size_t len, size_t buflen)\n\n{\n\n    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;\n\n    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);\n\n\n\n    if (buflen < ext_len) {\n\n        return -ENOSPC;\n\n    }\n\n\n\n    *ext_backing_fmt = (QCowExtension) {\n\n        .magic  = cpu_to_be32(magic),\n\n        .len    = cpu_to_be32(len),\n\n    };\n\n    memcpy(buf + sizeof(QCowExtension), s, len);\n\n\n\n    return ext_len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 29, "prediction": "1", "true_label": "1", "raw_text": "Question: static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 30, "prediction": "0", "true_label": "0", "raw_text": "Question: static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 31, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 32, "prediction": "0", "true_label": "1", "raw_text": " fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 33, "prediction": "0", "true_label": "1", "raw_text": "Question: void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 34, "prediction": "0", "true_label": "1", "raw_text": "Question: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 35, "prediction": "0", "true_label": "1", "raw_text": "Question: static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 36, "prediction": "0", "true_label": "1", "raw_text": "Question: void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)\n\n{\n\n    s->codec = slave;\n\n    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];\n\n    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 37, "prediction": "0", "true_label": "0", "raw_text": "Question: int floatx80_eq(floatx80 a, floatx80 b, float_status *status)\n\n{\n\n\n\n    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )\n\n         || (    ( extractFloatx80Exp( b ) == 0x7FFF )\n\n              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )\n\n       ) {\n\n        float_raise(float_flag_invalid, status);\n\n        return 0;\n\n    }\n\n    return\n\n           ( a.low == b.low )\n\n        && (    ( a.high == b.high )\n\n             || (    ( a.low == 0 )\n\n                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )\n\n           );\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 38, "prediction": "1", "true_label": "0", "raw_text": "Question: void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 39, "prediction": "1", "true_label": "0", "raw_text": "Question: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 40, "prediction": "0", "true_label": "1", "raw_text": "Question: static int crypto_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    const char *nested_url;\n\n    int ret;\n\n    CryptoContext *c = h->priv_data;\n\n\n\n    if (!av_strstart(uri, \"crypto+\", &nested_url) &&\n\n        !av_strstart(uri, \"crypto:\", &nested_url)) {\n\n        av_log(h, AV_LOG_ERROR, \"Unsupported url %s\\n\", uri);\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n\n\n    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {\n\n        av_log(h, AV_LOG_ERROR, \"Key or IV not set\\n\");\n\n        ret = AVERROR(EINVAL);\n\n        goto err;\n\n    }\n\n    if (flags & AVIO_FLAG_WRITE) {\n\n        av_log(h, AV_LOG_ERROR, \"Only decryption is supported currently\\n\");\n\n        ret = AVERROR(ENOSYS);\n\n        goto err;\n\n    }\n\n    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {\n\n        av_log(h, AV_LOG_ERROR, \"Unable to open input\\n\");\n\n        goto err;\n\n    }\n\n    c->aes = av_mallocz(av_aes_size);\n\n    if (!c->aes) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto err;\n\n    }\n\n\n\n    av_aes_init(c->aes, c->key, 128, 1);\n\n\n\n    h->is_streamed = 1;\n\n\n\n    return 0;\n\nerr:\n\n    av_free(c->key);\n\n    av_free(c->iv);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 41, "prediction": "0", "true_label": "1", "raw_text": "Question: int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 42, "prediction": "0", "true_label": "1", "raw_text": "Question: static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 43, "prediction": "0", "true_label": "0", "raw_text": "SIZE, \"Sun4u\", RAM_size, boot_devices,\n\n                           KERNEL_LOAD_ADDR, kernel_size,\n\n                           kernel_cmdline,\n\n                           INITRD_LOAD_ADDR, initrd_size,\n\n                           /* XXX: need an option to load a NVRAM image */\n\n                           0,\n\n                           graphic_width, graphic_height, graphic_depth,\n\n                           (uint8_t *)&nd_table[0].macaddr);\n\n\n\n    fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]);\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 44, "prediction": "0", "true_label": "0", "raw_text": "Question: static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 45, "prediction": "0", "true_label": "1", "raw_text": ",\n\n                   \"Input resolution larger than actual frame.\\n\");\n\n            return -1;\n\n        }\n\n\n\n        /* Get length and offset(if required) */\n\n        if (length == 0) {\n\n            if (code == 1) {\n\n                length = bytestream_get_byte(&buf);\n\n                offset = bytestream_get_le16(&buf);\n\n            } else {\n\n                length = bytestream_get_le16(&buf);\n\n                if (code == 2 && length == 0)\n\n                    break;\n\n            }\n\n        } else {\n\n            if (code == 1)\n\n                offset = bytestream_get_byte(&buf);\n\n        }\n\n\n\n        /* Do boundary check */\n\n        if (dst + (length << lentab[code]) > frame_end)\n\n            break;\n\n\n\n        switch (code) {\n\n\n\n        case 0:                //Normal Chain\n\n            if (length >= buf_end - buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Frame larger than buffer.\\n\");\n\n                return -1;\n\n            }\n\n            bytestream_get_buffer(&buf, dst, length);\n\n            dst += length;\n\n            break;\n\n\n\n        case 1:                //Back Chain\n\n            dst_offset = dst - offset;\n\n            length *= 4;        //Convert dwords to bytes.\n\n            if (dst_offset < bfi->dst)\n\n                break;\n\n            while (length--)\n\n                *dst++ = *dst_offset++;\n\n            break;\n\n\n\n        case 2:                //Skip Chain\n\n            dst += length;\n\n            break;\n\n\n\n        case 3:                //Fill Chain\n\n            colour1 = bytestream_get_byte(&buf);\n\n            colour2 = bytestream_get_byte(&buf);\n\n            while (length--) {\n\n                *dst++ = colour1;\n\n                *dst++ = colour2;\n\n            }\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    src = bfi->dst;\n\n    dst = bfi->frame.data[0];\n\n    while (height--) {\n\n        memcpy(dst, src, avctx->width);\n\n        src += avctx->width;\n\n        dst += bfi->frame.linesize[0];\n\n    }\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = bfi->frame;\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 46, "prediction": "0", "true_label": "1", "raw_text": "BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 47, "prediction": "0", "true_label": "0", "raw_text": "Question: void thread_pool_submit(ThreadPoolFunc *func, void *arg)\n\n{\n\n    thread_pool_submit_aio(func, arg, NULL, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 48, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pl061_register_devices(void)\n\n{\n\n    sysbus_register_dev(\"pl061\", sizeof(pl061_state),\n\n                        pl061_init_arm);\n\n    sysbus_register_dev(\"pl061_luminary\", sizeof(pl061_state),\n\n                        pl061_init_luminary);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 49, "prediction": "0", "true_label": "1", "raw_text": " delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 50, "prediction": "0", "true_label": "0", "raw_text": "Question: static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)\n\n{\n\n    int i;\n\n    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;\n\n    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;\n\n\n\n    copy_scsw_to_guest(&dest->scsw, &src->scsw);\n\n\n\n    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {\n\n        dest->esw[i] = cpu_to_be32(src->esw[i]);\n\n    }\n\n    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {\n\n        dest->ecw[i] = cpu_to_be32(src->ecw[i]);\n\n    }\n\n    /* extended measurements enabled? */\n\n    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||\n\n        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||\n\n        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {\n\n        return;\n\n    }\n\n    /* extended measurements pending? */\n\n    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {\n\n        return;\n\n    }\n\n    if ((stctl & SCSW_STCTL_PRIMARY) ||\n\n        (stctl == SCSW_STCTL_SECONDARY) ||\n\n        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {\n\n        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {\n\n            dest->emw[i] = cpu_to_be32(src->emw[i]);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 51, "prediction": "0", "true_label": "0", "raw_text": "base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 52, "prediction": "0", "true_label": "1", "raw_text": " PREFIX_REPZ)\n\n            goto illegal_op;\n\n        if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT))\n\n            goto illegal_op;\n\n\n\n        modrm = x86_ldub_code(env, s);\n\n        reg = ((modrm >> 3) & 7) | rex_r;\n\n\n\n        if (s->prefix & PREFIX_DATA) {\n\n            ot = MO_16;\n\n        } else {\n\n            ot = mo_64_32(dflag);\n\n        }\n\n\n\n        gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0);\n\n        gen_extu(ot, cpu_T0);\n\n        tcg_gen_mov_tl(cpu_cc_src, cpu_T0);\n\n        tcg_gen_ctpop_tl(cpu_T0, cpu_T0);\n\n        gen_op_mov_reg_v(ot, reg, cpu_T0);\n\n\n\n        set_cc_op(s, CC_OP_POPCNT);\n\n        break;\n\n    case 0x10e ... 0x10f:\n\n        /* 3DNow! instructions, ignore prefixes */\n\n        s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA);\n\n    case 0x110 ... 0x117:\n\n    case 0x128 ... 0x12f:\n\n    case 0x138 ... 0x13a:\n\n    case 0x150 ... 0x179:\n\n    case 0x17c ... 0x17f:\n\n    case 0x1c2:\n\n    case 0x1c4 ... 0x1c6:\n\n    case 0x1d0 ... 0x1fe:\n\n        gen_sse(env, s, b, pc_start, rex_r);\n\n        break;\n\n    default:\n\n        goto unknown_op;\n\n    }\n\n    return s->pc;\n\n illegal_op:\n\n    gen_illegal_opcode(s);\n\n    return s->pc;\n\n unknown_op:\n\n    gen_unknown_opcode(env, s);\n\n    return s->pc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 53, "prediction": "0", "true_label": "1", "raw_text": "csi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 54, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 55, "prediction": "1", "true_label": "1", "raw_text": "Question: CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 56, "prediction": "0", "true_label": "1", "raw_text": "_blocks[b];\n\n\n\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n\n\n\n        bd[0].raw_other    = bd[1].raw_samples;\n\n        bd[1].raw_other    = bd[0].raw_samples;\n\n\n\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n\n            // damaged block, write zero for the rest of the frame\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n\n            return -1;\n\n        }\n\n\n\n        // reconstruct joint-stereo blocks\n\n        if (bd[0].js_blocks) {\n\n            if (bd[1].js_blocks)\n\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n\n\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n\n        } else if (bd[1].js_blocks) {\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n\n        }\n\n\n\n        offset  += div_blocks[b];\n\n        bd[0].ra_block = 0;\n\n        bd[1].ra_block = 0;\n\n    }\n\n\n\n    // store carryover raw samples,\n\n    // the others channel raw samples are stored by the calling function.\n\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 57, "prediction": "0", "true_label": "0", "raw_text": "1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 58, "prediction": "0", "true_label": "1", "raw_text": "Question: static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)\n\n{\n\n    int compno;\n\n    int x, y;\n\n    int *image_line;\n\n    int frame_index;\n\n    const int numcomps  = image->numcomps;\n\n    uint16_t *frame_ptr = (uint16_t *)frame->data[0];\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        if (image->comps[compno].w > frame->linesize[0] / numcomps) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error: frame's linesize is too small for the image\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        for (y = 0; y < avctx->height; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            frame_index = y * (frame->linesize[0] / 2) + compno;\n\n            for (x = 0; x < avctx->width; ++x) {\n\n                image_line[x] = frame_ptr[frame_index] >> 4;\n\n                frame_index += numcomps;\n\n            }\n\n            for (; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - 1];\n\n            }\n\n        }\n\n        for (; y < image->comps[compno].h; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            for (x = 0; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - image->comps[compno].w];\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 59, "prediction": "0", "true_label": "0", "raw_text": ");\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 60, "prediction": "0", "true_label": "1", "raw_text": " 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 61, "prediction": "0", "true_label": "1", "raw_text": "Question: void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 62, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void codeblock(DiracContext *s, SubBand *b,\n\n                             GetBitContext *gb, DiracArith *c,\n\n                             int left, int right, int top, int bottom,\n\n                             int blockcnt_one, int is_arith)\n\n{\n\n    int x, y, zero_block;\n\n    int qoffset, qfactor;\n\n    IDWTELEM *buf;\n\n\n\n    /* check for any coded coefficients in this codeblock */\n\n    if (!blockcnt_one) {\n\n        if (is_arith)\n\n            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);\n\n        else\n\n            zero_block = get_bits1(gb);\n\n\n\n        if (zero_block)\n\n            return;\n\n    }\n\n\n\n    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {\n\n        if (is_arith)\n\n            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);\n\n        else\n\n            b->quant += dirac_get_se_golomb(gb);\n\n    }\n\n\n\n    b->quant = FFMIN(b->quant, MAX_QUANT);\n\n\n\n    qfactor = qscale_tab[b->quant];\n\n    /* TODO: context pointer? */\n\n    if (!s->num_refs)\n\n        qoffset = qoffset_intra_tab[b->quant];\n\n    else\n\n        qoffset = qoffset_inter_tab[b->quant];\n\n\n\n    buf = b->ibuf + top * b->stride;\n\n    for (y = top; y < bottom; y++) {\n\n        for (x = left; x < right; x++) {\n\n            /* [DIRAC_STD] 13.4.4 Subband coefficients. coeff_unpack() */\n\n            if (is_arith)\n\n                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);\n\n            else\n\n                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);\n\n        }\n\n        buf += b->stride;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 63, "prediction": "0", "true_label": "1", "raw_text": "64_lps_state, 64);\n\n    c->lps_state[2] = 1;\n\n    c->lps_state[3] = 0;\n\n    \n\n    *p = *pict;\n\n    p->pict_type= FF_I_TYPE;\n\n    \n\n    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){\n\n        put_cabac_bypass(c, 1);\n\n        p->key_frame= 1;\n\n        write_header(f);\n\n        clear_state(f);\n\n    }else{\n\n        put_cabac_bypass(c, 0);\n\n        p->key_frame= 0;\n\n    }\n\n\n\n    if(!f->ac){\n\n        used_count += put_cabac_terminate(c, 1);\n\n//printf(\"pos=%d\\n\", used_count);\n\n        init_put_bits(&f->pb, buf + used_count, buf_size - used_count);\n\n    }\n\n    \n\n    if(f->colorspace==0){\n\n        const int chroma_width = -((-width )>>f->chroma_h_shift);\n\n        const int chroma_height= -((-height)>>f->chroma_v_shift);\n\n\n\n        encode_plane(f, p->data[0], width, height, p->linesize[0], 0);\n\n\n\n        encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1);\n\n        encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1);\n\n    }else{\n\n        encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4);\n\n    }\n\n    emms_c();\n\n    \n\n    f->picture_number++;\n\n\n\n    if(f->ac){\n\n        return put_cabac_terminate(c, 1);\n\n    }else{\n\n        flush_put_bits(&f->pb); //nicer padding FIXME\n\n        return used_count + (put_bits_count(&f->pb)+7)/8;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 64, "prediction": "0", "true_label": "1", "raw_text": "Question: void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 65, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 66, "prediction": "0", "true_label": "1", "raw_text": "_FORMAT,\n\n                             bs->backing_format, strlen(bs->backing_format),\n\n                             buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* Feature table */\n\n    Qcow2Feature features[] = {\n\n        /* no feature defined yet */\n\n    };\n\n\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE,\n\n                         features, sizeof(features), buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Keep unknown header extensions */\n\n    QLIST_FOREACH(uext, &s->unknown_header_ext, next) {\n\n        ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        buf += ret;\n\n        buflen -= ret;\n\n    }\n\n\n\n    /* End of header extensions */\n\n    ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    buf += ret;\n\n    buflen -= ret;\n\n\n\n    /* Backing file name */\n\n    if (*bs->backing_file) {\n\n        size_t backing_file_len = strlen(bs->backing_file);\n\n\n\n        if (buflen < backing_file_len) {\n\n            ret = -ENOSPC;\n\n            goto fail;\n\n        }\n\n\n\n        strncpy(buf, bs->backing_file, buflen);\n\n\n\n        header->backing_file_offset = cpu_to_be64(buf - ((char*) header));\n\n        header->backing_file_size   = cpu_to_be32(backing_file_len);\n\n    }\n\n\n\n    /* Write the new header */\n\n    ret = bdrv_pwrite(bs->file, 0, header, s->cluster_size);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(header);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 67, "prediction": "1", "true_label": "1", "raw_text": "Question: void tcp_start_incoming_migration(const char *host_port, Error **errp)\n\n{\n\n    int s;\n\n\n\n    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);\n\n    if (s < 0) {\n\n        return;\n\n    }\n\n\n\n    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,\n\n                         (void *)(intptr_t)s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 68, "prediction": "0", "true_label": "1", "raw_text": "0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 69, "prediction": "1", "true_label": "1", "raw_text": "ctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 70, "prediction": "0", "true_label": "1", "raw_text": "Question: static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 71, "prediction": "0", "true_label": "1", "raw_text": "Question: static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,\n\n                        int nb_sectors, QEMUIOVector *qiov)\n\n{\n\n    SheepdogAIOCB *acb;\n\n    int ret;\n\n\n\n    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {\n\n        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        bs->total_sectors = sector_num + nb_sectors;\n\n    }\n\n\n\n    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);\n\n    acb->aio_done_func = sd_write_done;\n\n    acb->aiocb_type = AIOCB_WRITE_UDATA;\n\n\n\n    ret = sd_co_rw_vector(acb);\n\n    if (ret <= 0) {\n\n        qemu_aio_release(acb);\n\n        return ret;\n\n    }\n\n\n\n    qemu_coroutine_yield();\n\n\n\n    return acb->ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 72, "prediction": "0", "true_label": "0", "raw_text": "Question: static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 73, "prediction": "0", "true_label": "0", "raw_text": "Question: static void device_initfn(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop;\n\n\n\n    if (qdev_hotplug) {\n\n        dev->hotplugged = 1;\n\n        qdev_hot_added = true;\n\n    }\n\n\n\n    dev->instance_id_alias = -1;\n\n    dev->state = DEV_STATE_CREATED;\n\n\n\n    qdev_prop_set_defaults(dev, qdev_get_props(dev));\n\n    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {\n\n        qdev_property_add_legacy(dev, prop, NULL);\n\n        qdev_property_add_static(dev, prop, NULL);\n\n    }\n\n\n\n    object_property_add_str(OBJECT(dev), \"type\", qdev_get_type, NULL, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 74, "prediction": "-1", "true_label": "1", "raw_text": " is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 75, "prediction": "0", "true_label": "1", "raw_text": "Question: static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 76, "prediction": "1", "true_label": "1", "raw_text": "Question: void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 77, "prediction": "0", "true_label": "1", "raw_text": "xffffffff : 0xffff;\n\n\n\n    bs->bl.request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {\n\n            bs->bl.max_pdiscard =\n\n                iscsilun->bl.max_unmap * iscsilun->block_size;\n\n        }\n\n        bs->bl.pdiscard_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pdiscard_alignment = iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 78, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tap_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    TAPState *s = opaque;\n\n    int ret;\n\n    for(;;) {\n\n        ret = write(s->fd, buf, size);\n\n        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 79, "prediction": "0", "true_label": "0", "raw_text": "Question: static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 80, "prediction": "0", "true_label": "0", "raw_text": "clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 81, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vnc_display_listen(VncDisplay *vd,\n\n                              SocketAddress **saddr,\n\n                              size_t nsaddr,\n\n                              SocketAddress **wsaddr,\n\n                              size_t nwsaddr,\n\n                              Error **errp)\n\n{\n\n    size_t i;\n\n\n\n    for (i = 0; i < nsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, saddr[i],\n\n                                    \"vnc-listen\",\n\n                                    &vd->lsock,\n\n                                    &vd->lsock_tag,\n\n                                    &vd->nlsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n    for (i = 0; i < nwsaddr; i++) {\n\n        if (vnc_display_listen_addr(vd, wsaddr[i],\n\n                                    \"vnc-ws-listen\",\n\n                                    &vd->lwebsock,\n\n                                    &vd->lwebsock_tag,\n\n                                    &vd->nlwebsock,\n\n                                    errp) < 0) {\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 82, "prediction": "0", "true_label": "0", "raw_text": "Question: static char *enumerate_cpus(unsigned long *cpus, int max_cpus)\n\n{\n\n    int cpu;\n\n    bool first = true;\n\n    GString *s = g_string_new(NULL);\n\n\n\n    for (cpu = find_first_bit(cpus, max_cpus);\n\n        cpu < max_cpus;\n\n        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {\n\n        g_string_append_printf(s, \"%s%d\", first ? \"\" : \" \", cpu);\n\n        first = false;\n\n    }\n\n    return g_string_free(s, FALSE);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 83, "prediction": "1", "true_label": "1", "raw_text": "Question: MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 84, "prediction": "0", "true_label": "1", "raw_text": "Question: static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 85, "prediction": "0", "true_label": "1", "raw_text": "Question: static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 86, "prediction": "0", "true_label": "1", "raw_text": "Question: static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,\n\n                                  const char *name, Error **errp)\n\n{\n\n    NvmeCtrl *s = NVME(obj);\n\n\n\n    visit_type_int32(v, &s->conf.bootindex, name, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 87, "prediction": "0", "true_label": "1", "raw_text": "block_align;\n\n        } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n\n                   (ast->deint_id == DEINT_ID_VBRS)) {\n\n            int x;\n\n            rm->audio_stream_num = st->index;\n\n            ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n\n            if (ast->sub_packet_cnt) {\n\n                for (x = 0; x < ast->sub_packet_cnt; x++)\n\n                    ast->sub_packet_lengths[x] = avio_rb16(pb);\n\n                rm->audio_pkt_cnt = ast->sub_packet_cnt;\n\n                ast->audiotimestamp = timestamp;\n\n            } else\n\n                return -1;\n\n        } else {\n\n            av_get_packet(pb, pkt, len);\n\n            rm_ac3_swap_bytes(st, pkt);\n\n        }\n\n    } else\n\n        av_get_packet(pb, pkt, len);\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n#if 0\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if(st->codec->codec_id == AV_CODEC_ID_RV20){\n\n            int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1);\n\n            av_log(s, AV_LOG_DEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq);\n\n\n\n            seq |= (timestamp&~0x3FFF);\n\n            if(seq - timestamp >  0x2000) seq -= 0x4000;\n\n            if(seq - timestamp < -0x2000) seq += 0x4000;\n\n        }\n\n    }\n\n#endif\n\n\n\n    pkt->pts = timestamp;\n\n    if (flags & 2)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 88, "prediction": "0", "true_label": "1", "raw_text": "Question: Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 89, "prediction": "1", "true_label": "1", "raw_text": "Question: static void vscsi_process_login(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union viosrp_iu *iu = &req->iu;\n\n    struct srp_login_rsp *rsp = &iu->srp.login_rsp;\n\n    uint64_t tag = iu->srp.rsp.tag;\n\n\n\n    trace_spapr_vscsi__process_login();\n\n\n\n    /* TODO handle case that requested size is wrong and\n\n     * buffer format is wrong\n\n     */\n\n    memset(iu, 0, sizeof(struct srp_login_rsp));\n\n    rsp->opcode = SRP_LOGIN_RSP;\n\n    /* Don't advertise quite as many request as we support to\n\n     * keep room for management stuff etc...\n\n     */\n\n    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);\n\n    rsp->tag = tag;\n\n    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));\n\n    /* direct and indirect */\n\n    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);\n\n\n\n    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 90, "prediction": "0", "true_label": "1", "raw_text": "Question: void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 91, "prediction": "0", "true_label": "1", "raw_text": " if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 92, "prediction": "1", "true_label": "0", "raw_text": "Question: int bdrv_is_removable(BlockDriverState *bs)\n\n{\n\n    return bs->removable;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 93, "prediction": "0", "true_label": "1", "raw_text": "Question: static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 94, "prediction": "1", "true_label": "1", "raw_text": "Question: void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 95, "prediction": "0", "true_label": "1", "raw_text": "Question: void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 96, "prediction": "0", "true_label": "1", "raw_text": "Question: static void kvmclock_pre_save(void *opaque)\n\n{\n\n    KVMClockState *s = opaque;\n\n    struct kvm_clock_data data;\n\n    int ret;\n\n\n\n    if (s->clock_valid) {\n\n        return;\n\n    }\n\n    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"KVM_GET_CLOCK failed: %s\\n\", strerror(ret));\n\n        data.clock = 0;\n\n    }\n\n    s->clock = data.clock;\n\n    /*\n\n     * If the VM is stopped, declare the clock state valid to avoid re-reading\n\n     * it on next vmsave (which would return a different value). Will be reset\n\n     * when the VM is continued.\n\n     */\n\n    s->clock_valid = !runstate_is_running();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 97, "prediction": "0", "true_label": "1", "raw_text": "Question: static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 98, "prediction": "0", "true_label": "1", "raw_text": "Question: static int check_checksum(ByteIOContext *bc){\n\n    unsigned long checksum= get_checksum(bc);\n\n//    return checksum != get_be32(bc);\n\n\n\n    av_log(NULL, AV_LOG_ERROR, \"%08X %08X\\n\", checksum, (int)get_be32(bc));\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 99, "prediction": "0", "true_label": "0", "raw_text": " wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 100, "prediction": "0", "true_label": "1", "raw_text": "Question: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 101, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)\n\n{\n\n    uint32_t val;\n\n    val = gic_dist_readb(opaque, offset);\n\n    val |= gic_dist_readb(opaque, offset + 1) << 8;\n\n    return val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 102, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_qemu_strtoull_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 103, "prediction": "0", "true_label": "0", "raw_text": " s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, \"ssi\");\n\n    }\n\n\n\n    if (usb_enabled) {\n\n        sysbus_create_simple(\"sysbus-ohci\", 0x4c000000,\n\n                             s->pic[PXA2XX_PIC_USBH1]);\n\n    }\n\n\n\n    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);\n\n    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);\n\n\n\n    s->rtc_base = 0x40900000;\n\n    iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn,\n\n                    pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);\n\n    pxa2xx_rtc_init(s);\n\n    register_savevm(NULL, \"pxa2xx_rtc\", 0, 0, pxa2xx_rtc_save,\n\n                    pxa2xx_rtc_load, s);\n\n\n\n    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);\n\n    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);\n\n\n\n    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);\n\n\n\n    /* GPIO1 resets the processor */\n\n    /* The handler can be overridden by board-specific code */\n\n    qdev_connect_gpio_out(s->gpio, 1, s->reset);\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 104, "prediction": "0", "true_label": "0", "raw_text": "Question: int usb_device_delete_addr(int busnr, int addr)\n\n{\n\n    USBBus *bus;\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n\n\n    bus = usb_bus_find(busnr);\n\n    if (!bus)\n\n        return -1;\n\n\n\n    TAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev->addr == addr)\n\n            break;\n\n    }\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    TAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n    dev->info->handle_destroy(dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 105, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qmp_output_type_number(Visitor *v, const char *name, double *obj,\n\n                                   Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qmp_output_add(qov, name, qfloat_from_double(*obj));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 106, "prediction": "0", "true_label": "1", "raw_text": "aio_write_cmd);\n\n    }\n\n\n\n    if (ctx->zflag && optind != argc - 2) {\n\n        printf(\"-z supports only a single length parameter\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag && ctx->Pflag) {\n\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n\n\n        return 0;\n\n    }\n\n\n\n    ctx->offset = cvtnum(argv[optind]);\n\n    if (ctx->offset < 0) {\n\n        print_cvtnum_err(ctx->offset, argv[optind]);\n\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (ctx->offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               ctx->offset);\n\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n        return 0;\n\n    }\n\n\n\n    if (ctx->zflag) {\n\n        int64_t count = cvtnum(argv[optind]);\n\n        if (count < 0) {\n\n            print_cvtnum_err(count, argv[optind]);\n\n\n            return 0;\n\n        }\n\n\n\n        ctx->qiov.size = count;\n\n        blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0,\n\n                             aio_write_done, ctx);\n\n    } else {\n\n        nr_iov = argc - optind;\n\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n\n                                pattern);\n\n        if (ctx->buf == NULL) {\n\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n\n\n            return 0;\n\n        }\n\n\n\n        gettimeofday(&ctx->t1, NULL);\n\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n\n                         BLOCK_ACCT_WRITE);\n\n\n\n        blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov,\n\n                       ctx->qiov.size >> 9, aio_write_done, ctx);\n\n    }\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 107, "prediction": "0", "true_label": "1", "raw_text": " table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 108, "prediction": "0", "true_label": "1", "raw_text": " = get_bits_long(&alac->gb, alac->setinfo_sample_size);\n\n                audiobits = extend_sign32(audiobits, alac->setinfo_sample_size);\n\n\n\n                alac->outputsamples_buffer[chan][i] = audiobits;\n\n            }\n\n        /* wasted_bytes = 0; */\n\n        interlacing_shift = 0;\n\n        interlacing_leftweight = 0;\n\n    }\n\n    if (get_bits(&alac->gb, 3) != 7)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : Wrong End Of Frame\\n\");\n\n\n\n    switch(alac->setinfo_sample_size) {\n\n    case 16:\n\n        if (channels == 2) {\n\n            reconstruct_stereo_16(alac->outputsamples_buffer,\n\n                                  (int16_t*)outbuffer,\n\n                                  alac->numchannels,\n\n                                  outputsamples,\n\n                                  interlacing_shift,\n\n                                  interlacing_leftweight);\n\n        } else {\n\n            int i;\n\n            for (i = 0; i < outputsamples; i++) {\n\n                int16_t sample = alac->outputsamples_buffer[0][i];\n\n                ((int16_t*)outbuffer)[i * alac->numchannels] = sample;\n\n            }\n\n        }\n\n        break;\n\n    case 20:\n\n    case 24:\n\n        // It is not clear if there exist any encoder that creates 24 bit ALAC\n\n        // files. iTunes convert 24 bit raw files to 16 bit before encoding.\n\n    case 32:\n\n        av_log(avctx, AV_LOG_ERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfo_sample_size);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8)\n\n        av_log(avctx, AV_LOG_ERROR, \"Error : %d bits left\\n\", input_buffer_size * 8 - get_bits_count(&alac->gb));\n\n\n\n    return input_buffer_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 109, "prediction": "0", "true_label": "0", "raw_text": "Question: static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 110, "prediction": "0", "true_label": "0", "raw_text": "NORST:\n\n        // set limit without resetting counter\n\n        s->limit = val & TIMER_MAX_COUNT32;\n\n        if (!s->limit)\n\n            s->limit = TIMER_MAX_COUNT32;\n\n        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);\n\n        break;\n\n    case TIMER_STATUS:\n\n        if (slavio_timer_is_user(s)) {\n\n            // start/stop user counter\n\n            if ((val & 1) && !s->running) {\n\n                DPRINTF(\"processor %d user timer started\\n\", s->slave_index);\n\n                ptimer_run(s->timer, 0);\n\n                s->running = 1;\n\n            } else if (!(val & 1) && s->running) {\n\n                DPRINTF(\"processor %d user timer stopped\\n\", s->slave_index);\n\n                ptimer_stop(s->timer);\n\n                s->running = 0;\n\n            }\n\n        }\n\n        break;\n\n    case TIMER_MODE:\n\n        if (s->master == NULL) {\n\n            unsigned int i;\n\n\n\n            for (i = 0; i < s->num_slaves; i++) {\n\n                if (val & (1 << i)) {\n\n                    qemu_irq_lower(s->slave[i]->irq);\n\n                    s->slave[i]->limit = -1ULL;\n\n                }\n\n                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {\n\n                    ptimer_stop(s->slave[i]->timer);\n\n                    ptimer_set_limit(s->slave[i]->timer,\n\n                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);\n\n                    DPRINTF(\"processor %d timer changed\\n\",\n\n                            s->slave[i]->slave_index);\n\n                    ptimer_run(s->slave[i]->timer, 0);\n\n                }\n\n            }\n\n            s->slave_mode = val & ((1 << s->num_slaves) - 1);\n\n        } else\n\n            DPRINTF(\"not system timer\\n\");\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid write address \" TARGET_FMT_plx \"\\n\", addr);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 111, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 112, "prediction": "0", "true_label": "0", "raw_text": "Question: static void temp_allocate_frame(TCGContext *s, int temp)\n\n{\n\n    TCGTemp *ts;\n\n    ts = &s->temps[temp];\n\n    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);\n\n    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)\n\n        tcg_abort();\n\n    ts->mem_offset = s->current_frame_offset;\n\n    ts->mem_reg = s->frame_reg;\n\n    ts->mem_allocated = 1;\n\n    s->current_frame_offset += sizeof(tcg_target_long);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 113, "prediction": "1", "true_label": "0", "raw_text": "Question: void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 114, "prediction": "1", "true_label": "1", "raw_text": "port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF &&\n\n        msi_init(dev, 0, 1, true, false) >= 0) {\n\n        /* TODO check for errors */\n\n        s->msi_in_use = true;\n\n    }\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 115, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int num_effective_busses(XilinxSPIPS *s)\n\n{\n\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 116, "prediction": "0", "true_label": "1", "raw_text": "Question: FFTContext *av_fft_init(int nbits, int inverse)\n\n{\n\n    FFTContext *s = av_malloc(sizeof(*s));\n\n\n\n    if (s && ff_fft_init(s, nbits, inverse))\n\n        av_freep(&s);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 117, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 118, "prediction": "1", "true_label": "1", "raw_text": "y[1] == 1 && s->cdx[1] == 1 &&\n            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {\n            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n                s->cdef[0] = 0;\n                s->cdef[1] = 1;\n                s->cdef[2] = 2;\n                s->cdef[3] = 3;\n                i = 0;\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d\\n\"\n               \"cdx[0]: %d, cdy[0]: %d\\n\"\n               \"cdx[1]: %d, cdy[1]: %d\\n\"\n               \"cdx[2]: %d, cdy[2]: %d\\n\"\n               \"cdx[3]: %d, cdy[3]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               s->cdx[0],\n               s->cdy[0],\n               ncomponents > 1 ? s->cdx[1] : 0,\n               ncomponents > 1 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0,\n               ncomponents > 3 ? s->cdx[3] : 0,\n               ncomponents > 3 ? s->cdy[3] : 0);\n        return AVERROR_PATCHWELCOME;\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 119, "prediction": "0", "true_label": "1", "raw_text": "Question: static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 120, "prediction": "0", "true_label": "1", "raw_text": "Question: static void sd_1d97_int(int *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;\n\n        else\n\n            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;\n\n        return;\n\n    }\n\n\n\n    extend97_int(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 121, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r=  ((uint32_t*)src)[i]&0xFF;\n\n\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\n\n\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 122, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 123, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    V9fsVirtioState *v = VIRTIO_9P(dev);\n\n    V9fsState *s = &v->state;\n\n\n\n    virtio_cleanup(vdev);\n\n    v9fs_device_unrealize_common(s, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 124, "prediction": "0", "true_label": "1", "raw_text": "Question: static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 125, "prediction": "0", "true_label": "1", "raw_text": "_audio_fifo_write(s->celt_delay, delaybuf, celt_delay);\n\n            if (ret < 0)\n\n                return ret;\n\n        }\n\n    } else\n\n        ff_celt_flush(s->celt);\n\n\n\n    if (s->redundancy_idx) {\n\n        for (i = 0; i < s->output_channels; i++)\n\n            opus_fade(s->out[i], s->out[i],\n\n                      s->redundancy_output[i] + 120 + s->redundancy_idx,\n\n                      ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx);\n\n        s->redundancy_idx = 0;\n\n    }\n\n    if (redundancy) {\n\n        if (!redundancy_pos) {\n\n            ff_celt_flush(s->celt);\n\n            ret = opus_decode_redundancy(s, data + size, redundancy_size);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                opus_fade(s->out[i] + samples - 120 + delayed_samples,\n\n                          s->out[i] + samples - 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          ff_celt_window2, 120 - delayed_samples);\n\n                if (delayed_samples)\n\n                    s->redundancy_idx = 120 - delayed_samples;\n\n            }\n\n        } else {\n\n            for (i = 0; i < s->output_channels; i++) {\n\n                memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float));\n\n                opus_fade(s->out[i] + 120 + delayed_samples,\n\n                          s->redundancy_output[i] + 120,\n\n                          s->out[i] + 120 + delayed_samples,\n\n                          ff_celt_window2, 120);\n\n            }\n\n        }\n\n    }\n\n\n\n    return samples;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 126, "prediction": "1", "true_label": "1", "raw_text": "Question: bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 127, "prediction": "0", "true_label": "1", "raw_text": ";\n\n        }\n\n    }\n\n\n\n    /* number of coded QMF bands */\n\n    pSnd->bandsCoded = get_bits(gb,2);\n\n\n\n    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);\n\n    if (result) return result;\n\n\n\n    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);\n\n    if (pSnd->numComponents == -1) return -1;\n\n\n\n    numSubbands = decodeSpectrum (gb, pSnd->spectrum);\n\n\n\n    /* Merge the decoded spectrum and tonal components. */\n\n    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);\n\n\n\n\n\n    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */\n\n    numBands = (subbandTab[numSubbands] - 1) >> 8;\n\n    if (lastTonal >= 0)\n\n        numBands = FFMAX((lastTonal + 256) >> 8, numBands);\n\n\n\n\n\n    /* Reconstruct time domain samples. */\n\n    for (band=0; band<4; band++) {\n\n        /* Perform the IMDCT step without overlapping. */\n\n        if (band <= numBands) {\n\n            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);\n\n        } else\n\n            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));\n\n\n\n        /* gain compensation and overlapping */\n\n        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),\n\n                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),\n\n                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));\n\n    }\n\n\n\n    /* Swap the gain control buffers for the next frame. */\n\n    pSnd->gcBlkSwitch ^= 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 128, "prediction": "0", "true_label": "1", "raw_text": "Question: static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 129, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)\n\n{\n\n    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);\n\n    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);\n\n    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 130, "prediction": "0", "true_label": "1", "raw_text": " qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ),\n\n                                NULL);\n\n    for (i = 0; i < 32; i++) {\n\n        pic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n    sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]);\n\n    sysbus_create_varargs(\"integrator_pit\", 0x13000000,\n\n                          pic[5], pic[6], pic[7], NULL);\n\n    sysbus_create_simple(\"pl031\", 0x15000000, pic[8]);\n\n    sysbus_create_simple(\"pl011\", 0x16000000, pic[1]);\n\n    sysbus_create_simple(\"pl011\", 0x17000000, pic[2]);\n\n    icp_control_init(0xcb000000);\n\n    sysbus_create_simple(\"pl050_keyboard\", 0x18000000, pic[3]);\n\n    sysbus_create_simple(\"pl050_mouse\", 0x19000000, pic[4]);\n\n\n    sysbus_create_varargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL);\n\n    if (nd_table[0].used)\n\n        smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n\n\n    sysbus_create_simple(\"pl110\", 0xc0000000, pic[22]);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(cpu, &integrator_binfo);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 131, "prediction": "1", "true_label": "1", "raw_text": "Question: static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES.\n"}], [{"ID": 132, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int png_dec_end(AVCodecContext *avctx)\n\n{\n\n    PNGDecContext *s = avctx->priv_data;\n\n\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n\n    av_frame_free(&s->previous_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n\n    av_frame_free(&s->last_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->picture);\n\n    av_frame_free(&s->picture.f);\n\n    av_freep(&s->buffer);\n\n    s->buffer_size = 0;\n\n    av_freep(&s->last_row);\n\n    s->last_row_size = 0;\n\n    av_freep(&s->tmp_row);\n\n    s->tmp_row_size = 0;\n\n    av_freep(&s->extra_data);\n\n    s->extra_data_size = 0;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 133, "prediction": "1", "true_label": "1", "raw_text": "Question: static void fd_chr_update_read_handler(CharDriverState *chr)\n\n{\n\n    FDCharDriver *s = chr->opaque;\n\n\n\n    if (s->fd_in_tag) {\n\n        g_source_remove(s->fd_in_tag);\n\n        s->fd_in_tag = 0;\n\n    }\n\n\n\n    if (s->fd_in) {\n\n        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 134, "prediction": "0", "true_label": "1", "raw_text": " < fmt_ctx->nb_streams; i++) {\n\n        if (stream_specifier) {\n\n            ret = avformat_match_stream_specifier(fmt_ctx,\n\n                                                  fmt_ctx->streams[i],\n\n                                                  stream_specifier);\n\n            CHECK_END;\n\n            else\n\n                selected_streams[i] = ret;\n\n            ret = 0;\n\n        } else {\n\n            selected_streams[i] = 1;\n\n        }\n\n    }\n\n\n\n    if (do_read_frames || do_read_packets) {\n\n        if (do_show_frames && do_show_packets &&\n\n            wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER)\n\n            section_id = SECTION_ID_PACKETS_AND_FRAMES;\n\n        else if (do_show_packets && !do_show_frames)\n\n            section_id = SECTION_ID_PACKETS;\n\n        else // (!do_show_packets && do_show_frames)\n\n            section_id = SECTION_ID_FRAMES;\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_header(wctx, section_id);\n\n        ret = read_packets(wctx, fmt_ctx);\n\n        if (do_show_frames || do_show_packets)\n\n            writer_print_section_footer(wctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_programs) {\n\n        ret = show_programs(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\n    if (do_show_streams) {\n\n        ret = show_streams(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_chapters) {\n\n        ret = show_chapters(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n    if (do_show_format) {\n\n        ret = show_format(wctx, fmt_ctx);\n\n        CHECK_END;\n\n    }\n\n\n\nend:\n\n    close_input_file(&fmt_ctx);\n\n    av_freep(&nb_streams_frames);\n\n    av_freep(&nb_streams_packets);\n\n    av_freep(&selected_streams);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 135, "prediction": "0", "true_label": "1", "raw_text": "Question: static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,\n\n                                          target_phys_addr_t end_addr)\n\n{\n\n    KVMState *s = kvm_state;\n\n    unsigned long size, allocated_size = 0;\n\n    KVMDirtyLog d;\n\n    KVMSlot *mem;\n\n    int ret = 0;\n\n\n\n    d.dirty_bitmap = NULL;\n\n    while (start_addr < end_addr) {\n\n        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);\n\n        if (mem == NULL) {\n\n            break;\n\n        }\n\n\n\n        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;\n\n        if (!d.dirty_bitmap) {\n\n            d.dirty_bitmap = qemu_malloc(size);\n\n        } else if (size > allocated_size) {\n\n            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);\n\n        }\n\n        allocated_size = size;\n\n        memset(d.dirty_bitmap, 0, allocated_size);\n\n\n\n        d.slot = mem->slot;\n\n\n\n        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {\n\n            DPRINTF(\"ioctl failed %d\\n\", errno);\n\n            ret = -1;\n\n            break;\n\n        }\n\n\n\n        kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap,\n\n                                      mem->start_addr, mem->memory_size);\n\n        start_addr = mem->start_addr + mem->memory_size;\n\n    }\n\n    qemu_free(d.dirty_bitmap);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 136, "prediction": "0", "true_label": "1", "raw_text": "->linesize[2];\n\n        p->frame->format  = p->avctx_enc[i]->pix_fmt;\n\n\n\n        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);\n\n        p->frame_dec = p->avctx_enc[i]->coded_frame;\n\n\n\n        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];\n\n\n\n        for (y = 0; y < height; y++)\n\n            for (x = 0; x < width; x++)\n\n                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];\n\n\n\n        if (!src[2] || !dst[2])\n\n            continue;\n\n\n\n        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];\n\n\n\n        for (y = 0; y < height>>p->vsub; y++) {\n\n            for (x = 0; x < width>>p->hsub; x++) {\n\n                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];\n\n                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];\n\n            }\n\n        }\n\n    }\n\n\n\n    for (j = 0; j < 3; j++) {\n\n        int is_chroma = !!j;\n\n        if (!dst[j])\n\n            continue;\n\n        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],\n\n                      width  >> (is_chroma ? p->hsub : 0),\n\n                      height >> (is_chroma ? p->vsub : 0),\n\n                      8-p->log2_count);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 137, "prediction": "0", "true_label": "0", "raw_text": "Question: int main(void)\n\n{\n\n    int nf;\n\n    Suite *s;\n\n    SRunner *sr;\n\n\n\n    s = qfloat_suite();\n\n    sr = srunner_create(s);\n\n\n\n    srunner_run_all(sr, CK_NORMAL);\n\n    nf = srunner_ntests_failed(sr);\n\n    srunner_free(sr);\n\n\n\n    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 138, "prediction": "0", "true_label": "0", "raw_text": "Question: static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    IOMMUTLBEntry entry;\n\n    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;\n\n\n\n    if (index >= tcet->nb_table) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-bounds IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcet->table[index] = tce;\n\n\n\n    entry.target_as = &address_space_memory,\n\n    entry.iova = ioba & page_mask;\n\n    entry.translated_addr = tce & page_mask;\n\n    entry.addr_mask = ~page_mask;\n\n    entry.perm = spapr_tce_iommu_access_flags(tce);\n\n    memory_region_notify_iommu(&tcet->iommu, entry);\n\n\n\n    return H_SUCCESS;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 139, "prediction": "0", "true_label": "0", "raw_text": " 0) {\n\n            /* 16M page */\n\n            /* lowest AVA bit must be 0 for 16M pages */\n\n            if (pteh & 0x80) {\n\n                return H_PARAMETER;\n\n            }\n\n        } else {\n\n            return H_PARAMETER;\n\n        }\n\n    }\n\n\n\n    /* FIXME: bounds check the pa? */\n\n\n\n    /* Check WIMG */\n\n    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {\n\n        return H_PARAMETER;\n\n    }\n\n    pteh &= ~0x60ULL;\n\n\n\n    if ((pte_index * HASH_PTE_SIZE_64) & ~env->htab_mask) {\n\n        return H_PARAMETER;\n\n    }\n\n    if (likely((flags & H_EXACT) == 0)) {\n\n        pte_index &= ~7ULL;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        for (i = 0; ; ++i) {\n\n            if (i == 8) {\n\n                return H_PTEG_FULL;\n\n            }\n\n            if (((ldq_p(hpte) & HPTE_V_VALID) == 0) &&\n\n                lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n                break;\n\n            }\n\n            hpte += HASH_PTE_SIZE_64;\n\n        }\n\n    } else {\n\n        i = 0;\n\n        hpte = env->external_htab + (pte_index * HASH_PTE_SIZE_64);\n\n        if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) {\n\n            return H_PTEG_FULL;\n\n        }\n\n    }\n\n    stq_p(hpte + (HASH_PTE_SIZE_64/2), ptel);\n\n    /* eieio();  FIXME: need some sort of barrier for smp? */\n\n    stq_p(hpte, pteh);\n\n\n\n    assert(!(ldq_p(hpte) & HPTE_V_HVLOCK));\n\n    args[0] = pte_index + i;\n\n    return H_SUCCESS;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 140, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 141, "prediction": "0", "true_label": "1", "raw_text": " \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r), \"m\"(mmx_null)\n\n            :\"memory\");\n\n        /* borrowed 32 to 24 */\n\n        __asm__ volatile(\n\n            \"movq       %%mm0, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"movq       %%mm6, %%mm0    \\n\\t\"\n\n            \"movq       %%mm7, %%mm1    \\n\\t\"\n\n\n\n            \"movq       %%mm4, %%mm6    \\n\\t\"\n\n            \"movq       %%mm5, %%mm7    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm1, %%mm3    \\n\\t\"\n\n\n\n            STORE_BGR24_MMX\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s)\n\n            :\"memory\");\n\n        d += 24;\n\n        s += 8;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 142, "prediction": "0", "true_label": "1", "raw_text": "ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 143, "prediction": "1", "true_label": "0", "raw_text": "Question: static int ftp_file_size(FTPContext *s)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    char *res = NULL;\n\n    const int size_codes[] = {213, 0};\n\n\n\n    snprintf(command, sizeof(command), \"SIZE %s\\r\\n\", s->path);\n\n    if (ftp_send_command(s, command, size_codes, &res)) {\n\n        s->filesize = strtoll(&res[4], NULL, 10);\n\n    } else {\n\n        s->filesize = -1;\n\n        av_free(res);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    av_free(res);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 144, "prediction": "0", "true_label": "1", "raw_text": "2(s, LWZX | TAB(datalo, rbase, TCG_REG_R0));\n\n        } else if (addrlo == datahi) {\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n        } else {\n\n            tcg_out32(s, LWZ | TAI(datahi, addrlo, 0));\n\n            tcg_out32(s, LWZ | TAI(datalo, addrlo, 4));\n\n        }\n\n    } else {\n\n        uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)];\n\n        if (!HAVE_ISA_2_06 && insn == LDBRX) {\n\n            tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4));\n\n            tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo));\n\n            tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0));\n\n            tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0);\n\n        } else if (insn) {\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n        } else {\n\n            insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)];\n\n            tcg_out32(s, insn | TAB(datalo, rbase, addrlo));\n\n            insn = qemu_exts_opc[s_bits];\n\n            tcg_out32(s, insn | RA(datalo) | RS(datalo));\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n    add_qemu_ldst_label(s, true, oi, datalo, datahi, addrlo, addrhi,\n\n                        s->code_ptr, label_ptr);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 145, "prediction": "0", "true_label": "0", "raw_text": "Opcode opcode = get_ue_golomb_31(gb);\n\n\n\n                mmco[i].opcode = opcode;\n\n                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {\n\n                    mmco[i].short_pic_num =\n\n                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &\n\n                            (sl->max_pic_num - 1);\n\n#if 0\n\n                    if (mmco[i].short_pic_num >= h->short_ref_count ||\n\n                        !h->short_ref[mmco[i].short_pic_num]) {\n\n                        av_log(s->avctx, AV_LOG_ERROR,\n\n                               \"illegal short ref in memory management control \"\n\n                               \"operation %d\\n\", mmco);\n\n                        return -1;\n\n                    }\n\n#endif\n\n                }\n\n                if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED ||\n\n                    opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) {\n\n                    unsigned int long_arg = get_ue_golomb_31(gb);\n\n                    if (long_arg >= 32 ||\n\n                        (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG &&\n\n                                             long_arg == 16) &&\n\n                         !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"illegal long ref in memory management control \"\n\n                               \"operation %d\\n\", opcode);\n\n                        return -1;\n\n                    }\n\n                    mmco[i].long_arg = long_arg;\n\n                }\n\n\n\n                if (opcode > (unsigned) MMCO_LONG) {\n\n                    av_log(h->avctx, AV_LOG_ERROR,\n\n                           \"illegal memory management control operation %d\\n\",\n\n                           opcode);\n\n                    return -1;\n\n                }\n\n                if (opcode == MMCO_END)\n\n                    break;\n\n            }\n\n            nb_mmco = i;\n\n        }\n\n    }\n\n\n\n    sl->nb_mmco = nb_mmco;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 146, "prediction": "0", "true_label": "0", "raw_text": "Question:  void cpu_sh4_invalidate_tlb(CPUSH4State *s)\n\n{\n\n    int i;\n\n\n\n    /* UTLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n    /* ITLB */\n\n    for (i = 0; i < UTLB_SIZE; i++) {\n\n        tlb_t * entry = &s->utlb[i];\n\n        entry->v = 0;\n\n    }\n\n\n\n    tlb_flush(s, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 147, "prediction": "0", "true_label": "0", "raw_text": "Question: uint16_t net_checksum_finish(uint32_t sum)\n\n{\n\n    while (sum>>16)\n\n\tsum = (sum & 0xFFFF)+(sum >> 16);\n\n    return ~sum;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 148, "prediction": "0", "true_label": "0", "raw_text": "_DISCARD\t\t0x100\t/* Primary discard timer */\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t/* Secondary discard timer */\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t/* Discard timer status */\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t/* Discard timer SERR# enable */\n\n/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n */\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    /* Below does not do anything as we never set this bit, put here for\n\n     * completeness. */\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 149, "prediction": "0", "true_label": "0", "raw_text": "Question: static TranslationBlock *tb_alloc(target_ulong pc)\n\n{\n\n    TranslationBlock *tb;\n\n    TBContext *ctx;\n\n\n\n    assert_tb_locked();\n\n\n\n    tb = tcg_tb_alloc(&tcg_ctx);\n\n    if (unlikely(tb == NULL)) {\n\n        return NULL;\n\n    }\n\n    ctx = &tcg_ctx.tb_ctx;\n\n    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {\n\n        ctx->tbs_size *= 2;\n\n        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);\n\n    }\n\n    ctx->tbs[ctx->nb_tbs++] = tb;\n\n    tb->pc = pc;\n\n    tb->cflags = 0;\n\n    tb->invalid = false;\n\n    return tb;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 150, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gpollfds_from_select(void)\n\n{\n\n    int fd;\n\n    for (fd = 0; fd <= nfds; fd++) {\n\n        int events = 0;\n\n        if (FD_ISSET(fd, &rfds)) {\n\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &wfds)) {\n\n            events |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &xfds)) {\n\n            events |= G_IO_PRI;\n\n        }\n\n        if (events) {\n\n            GPollFD pfd = {\n\n                .fd = fd,\n\n                .events = events,\n\n            };\n\n            g_array_append_val(gpollfds, pfd);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 151, "prediction": "0", "true_label": "0", "raw_text": "\n                       s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_YA16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE ||\n\n                       s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j += 2)\n\n                        AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff));\n\n                    dst += stride;\n\n                }\n\n            } else {\n\n                for (i = 0; i < s->height; i++) {\n\n                    for (j = soff; j < ssize; j++)\n\n                        dst[j] += dst[j - soff];\n\n                    dst += stride;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) {\n\n            dst = p->data[plane];\n\n            for (i = 0; i < s->height; i++) {\n\n                for (j = 0; j < stride; j++)\n\n                    dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j];\n\n                dst += stride;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->planar && s->bppcount > 2) {\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[2]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[2]);\n\n        FFSWAP(uint8_t*, p->data[0],     p->data[1]);\n\n        FFSWAP(int,      p->linesize[0], p->linesize[1]);\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 152, "prediction": "0", "true_label": "0", "raw_text": "Question: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n\n                                              int *got_picture_ptr,\n\n                                              AVPacket *avpkt)\n\n{\n\n    int ret;\n\n\n\n    *got_picture_ptr = 0;\n\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n\n        return -1;\n\n\n\n    avctx->pkt = avpkt;\n\n    apply_param_change(avctx, avpkt);\n\n\n\n    avcodec_get_frame_defaults(picture);\n\n\n\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n\n                                         avpkt);\n\n        else {\n\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n\n                                       avpkt);\n\n            picture->pkt_dts             = avpkt->dts;\n\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n\n            picture->width               = avctx->width;\n\n            picture->height              = avctx->height;\n\n            picture->format              = avctx->pix_fmt;\n\n        }\n\n\n\n        emms_c(); //needed to avoid an emms_c() call before every return;\n\n\n\n        if (*got_picture_ptr)\n\n            avctx->frame_number++;\n\n    } else\n\n        ret = 0;\n\n\n\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n\n     * make sure it's set correctly */\n\n    picture->extended_data = picture->data;\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 153, "prediction": "1", "true_label": "1", "raw_text": "\n\n        }\n\n        return MFI_STAT_INVALID_STATUS;\n\n    }\n\n    /* Finished, set FW state */\n\n    if ((info->inquiry_data[0] >> 5) == 0) {\n\n        if (megasas_is_jbod(cmd->state)) {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM);\n\n        } else {\n\n            info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE);\n\n        }\n\n    } else {\n\n        info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE);\n\n    }\n\n\n\n    info->ref.v.device_id = cpu_to_le16(pd_id);\n\n    info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD|\n\n                                          MFI_PD_DDF_TYPE_INTF_SAS);\n\n    blk_get_geometry(sdev->conf.blk, &pd_size);\n\n    info->raw_size = cpu_to_le64(pd_size);\n\n    info->non_coerced_size = cpu_to_le64(pd_size);\n\n    info->coerced_size = cpu_to_le64(pd_size);\n\n    info->encl_device_id = 0xFFFF;\n\n    info->slot_number = (sdev->id & 0xFF);\n\n    info->path_info.count = 1;\n\n    info->path_info.sas_addr[0] =\n\n        cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n    info->connected_port_bitmap = 0x1;\n\n    info->device_speed = 1;\n\n    info->link_speed = 1;\n\n    resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);\n\n    g_free(cmd->iov_buf);\n\n    cmd->iov_size = dcmd_size - resid;\n\n    cmd->iov_buf = NULL;\n\n    return MFI_STAT_OK;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 154, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_isel(DisasContext *ctx)\n\n{\n\n    int l1, l2;\n\n    uint32_t bi = rC(ctx->opcode);\n\n    uint32_t mask;\n\n    TCGv_i32 t0;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    mask = 0x08 >> (bi & 0x03);\n\n    t0 = tcg_temp_new_i32();\n\n    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);\n\n    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);\n\n    if (rA(ctx->opcode) == 0)\n\n        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);\n\n    else\n\n        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);\n\n    gen_set_label(l2);\n\n    tcg_temp_free_i32(t0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 155, "prediction": "0", "true_label": "0", "raw_text": "Question: static void stream_process_mem2s(struct Stream *s,\n\n                                 StreamSlave *tx_dev)\n\n{\n\n    uint32_t prev_d;\n\n    unsigned char txbuf[16 * 1024];\n\n    unsigned int txlen;\n\n    uint32_t app[6];\n\n\n\n    if (!stream_running(s) || stream_idle(s)) {\n\n        return;\n\n    }\n\n\n\n    while (1) {\n\n        stream_desc_load(s, s->regs[R_CURDESC]);\n\n\n\n        if (s->desc.status & SDESC_STATUS_COMPLETE) {\n\n            s->regs[R_DMASR] |= DMASR_HALTED;\n\n            break;\n\n        }\n\n\n\n        if (stream_desc_sof(&s->desc)) {\n\n            s->pos = 0;\n\n            memcpy(app, s->desc.app, sizeof app);\n\n        }\n\n\n\n        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;\n\n        if ((txlen + s->pos) > sizeof txbuf) {\n\n            hw_error(\"%s: too small internal txbuf! %d\\n\", __func__,\n\n                     txlen + s->pos);\n\n        }\n\n\n\n        cpu_physical_memory_read(s->desc.buffer_address,\n\n                                 txbuf + s->pos, txlen);\n\n        s->pos += txlen;\n\n\n\n        if (stream_desc_eof(&s->desc)) {\n\n            stream_push(tx_dev, txbuf, s->pos, app);\n\n            s->pos = 0;\n\n            stream_complete(s);\n\n        }\n\n\n\n        /* Update the descriptor.  */\n\n        s->desc.status = txlen | SDESC_STATUS_COMPLETE;\n\n        stream_desc_store(s, s->regs[R_CURDESC]);\n\n\n\n        /* Advance.  */\n\n        prev_d = s->regs[R_CURDESC];\n\n        s->regs[R_CURDESC] = s->desc.nxtdesc;\n\n        if (prev_d == s->regs[R_TAILDESC]) {\n\n            s->regs[R_DMASR] |= DMASR_IDLE;\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 156, "prediction": "1", "true_label": "0", "raw_text": "Question: static int adpcm_decode_init(AVCodecContext * avctx)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n\n\n    if(avctx->channels > 2U){\n\n        return -1;\n\n    }\n\n\n\n    c->channel = 0;\n\n    c->status[0].predictor = c->status[1].predictor = 0;\n\n    c->status[0].step_index = c->status[1].step_index = 0;\n\n    c->status[0].step = c->status[1].step = 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_CT:\n\n        c->status[0].step = c->status[1].step = 511;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 157, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)\n\n{\n\n    read_local_name_rp params;\n\n    params.status = HCI_SUCCESS;\n\n    memset(params.name, 0, sizeof(params.name));\n\n    if (hci->device.lmp_name)\n\n        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));\n\n\n\n    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 158, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool vnc_should_update(VncState *vs)\n\n{\n\n    switch (vs->update) {\n\n    case VNC_STATE_UPDATE_NONE:\n\n        break;\n\n    case VNC_STATE_UPDATE_INCREMENTAL:\n\n        /* Only allow incremental updates if the output buffer\n\n         * is empty, or if audio capture is enabled.\n\n         */\n\n        if (!vs->output.offset || vs->audio_cap) {\n\n            return true;\n\n        }\n\n        break;\n\n    case VNC_STATE_UPDATE_FORCE:\n\n        return true;\n\n    }\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 159, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 160, "prediction": "0", "true_label": "0", "raw_text": "(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n\n\n    /* Wait for the first serial output from the source */\n\n    wait_for_serial(\"src_serial\");\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate',\"\n\n                          \"'arguments': { 'uri': '%s' } }\",\n\n                          uri);\n\n    rsp = qmp(cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    wait_for_migration_pass();\n\n\n\n    rsp = return_or_event(qmp(\"{ 'execute': 'migrate-start-postcopy' }\"));\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n\n\n    if (!got_stop) {\n\n        qmp_eventwait(\"STOP\");\n\n    }\n\n\n\n    global_qtest = to;\n\n    qmp_eventwait(\"RESUME\");\n\n\n\n    wait_for_serial(\"dest_serial\");\n\n    global_qtest = from;\n\n    wait_for_migration_complete();\n\n\n\n    qtest_quit(from);\n\n\n\n    global_qtest = to;\n\n\n\n    qtest_memread(to, start_address, &dest_byte_a, 1);\n\n\n\n    /* Destination still running, wait for a byte to change */\n\n    do {\n\n        qtest_memread(to, start_address, &dest_byte_b, 1);\n\n        usleep(10 * 1000);\n\n    } while (dest_byte_a == dest_byte_b);\n\n\n\n    qmp(\"{ 'execute' : 'stop'}\");\n\n    /* With it stopped, check nothing changes */\n\n    qtest_memread(to, start_address, &dest_byte_c, 1);\n\n    sleep(1);\n\n    qtest_memread(to, start_address, &dest_byte_d, 1);\n\n    g_assert_cmpint(dest_byte_c, ==, dest_byte_d);\n\n\n\n    check_guests_ram();\n\n\n\n    qtest_quit(to);\n\n    g_free(uri);\n\n\n\n    global_qtest = global;\n\n\n\n    cleanup(\"bootsect\");\n\n    cleanup(\"migsocket\");\n\n    cleanup(\"src_serial\");\n\n    cleanup(\"dest_serial\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 161, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,\n\n                                          bool tso_enable)\n\n{\n\n    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;\n\n    uint16_t l3_proto;\n\n\n\n    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,\n\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);\n\n\n\n    if (!tso_enable) {\n\n        goto func_exit;\n\n    }\n\n\n\n    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,\n\n                          pkt->l4proto);\n\n\n\nfunc_exit:\n\n    return rc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 162, "prediction": "1", "true_label": "1", "raw_text": "\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case VERIFY:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case LOAD_UNLOAD:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG:\n\n    case MOVE_MEDIUM:\n\n    case UPDATE_BLOCK:\n\n        req->cmd.xfer = 0;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME:\n\n        req->cmd.xfer = 1;\n\n        break;\n\n    case READ_CAPACITY:\n\n        req->cmd.xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        req->cmd.xfer = 6;\n\n        break;\n\n    case READ_POSITION:\n\n        req->cmd.xfer = 20;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        req->cmd.xfer *= 40;\n\n        break;\n\n    case MEDIUM_SCAN:\n\n        req->cmd.xfer *= 8;\n\n        break;\n\n    case WRITE_10:\n\n    case WRITE_VERIFY:\n\n    case WRITE_6:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case READ_10:\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        req->cmd.xfer *= req->dev->blocksize;\n\n        break;\n\n    case INQUIRY:\n\n        req->cmd.xfer = cmd[4] | (cmd[3] << 8);\n\n        break;\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (req->dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            req->cmd.xfer = cmd[9] | (cmd[8] << 8);\n\n        }\n\n        break;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 163, "prediction": "1", "true_label": "1", "raw_text": "Question: int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)\n\n{\n\n    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));\n\n\n\n    if (!p_new)\n\n        return -1;\n\n\n\n    p_new->data = p_data;\n\n\n\n    if (!queue->p_head)\n\n        queue->p_head = p_new;\n\n    else\n\n        queue->p_tail->next = p_new;\n\n    queue->p_tail = p_new;\n\n\n\n    ++queue->size;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 164, "prediction": "0", "true_label": "1", "raw_text": "Question: int kvmppc_reset_htab(int shift_hint)\n\n{\n\n    uint32_t shift = shift_hint;\n\n\n\n    if (!kvm_enabled()) {\n\n        /* Full emulation, tell caller to allocate htab itself */\n\n        return 0;\n\n    }\n\n    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {\n\n        int ret;\n\n        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);\n\n        if (ret == -ENOTTY) {\n\n            /* At least some versions of PR KVM advertise the\n\n             * capability, but don't implement the ioctl().  Oops.\n\n             * Return 0 so that we allocate the htab in qemu, as is\n\n             * correct for PR. */\n\n            return 0;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n        return shift;\n\n    }\n\n\n\n    /* We have a kernel that predates the htab reset calls.  For PR\n\n     * KVM, we need to allocate the htab ourselves, for an HV KVM of\n\n     * this era, it has allocated a 16MB fixed size hash table already. */\n\n    if (kvmppc_is_pr(kvm_state)) {\n\n        /* PR - tell caller to allocate htab */\n\n        return 0;\n\n    } else {\n\n        /* HV - assume 16MB kernel allocated htab */\n\n        return 24;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 165, "prediction": "0", "true_label": "1", "raw_text": "(buf+8);\n\n    h               = AV_RL16(buf+10);\n\n    bytes_per_pixel = AV_RL16(buf+12) >> 3;\n\n\n\n    if (bytes_per_pixel != 2) {\n\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n\n\n    if (buf_end - buf < offset)\n\n\n    if (offset != 0x2c)\n\n        av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\");\n\n\n\n    buf += offset;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    for (y=0; y<h; y++) {\n\n        if (buf_end - buf < w * bytes_per_pixel)\n\n            break;\n\n#if HAVE_BIGENDIAN\n\n        unsigned int x;\n\n        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)\n\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n\n#else\n\n        memcpy(ptr, buf, w*bytes_per_pixel);\n\n#endif\n\n        ptr += stride;\n\n        buf += w*bytes_per_pixel;\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return offset + w*h*bytes_per_pixel;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 166, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 167, "prediction": "0", "true_label": "1", "raw_text": "SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n\n    /* segment page size remain the same */\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n    pcc->radix_page_info = &POWER9_radix_page_info;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 168, "prediction": "0", "true_label": "1", "raw_text": "ence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    return mxf_parse_structural_metadata(mxf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 169, "prediction": "0", "true_label": "1", "raw_text": ":\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"The requested pixel format '%s' is not supported\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt));\n    }\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = sub_dx[i];\n        cmptparm[i].dy = sub_dy[i];\n        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];\n        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];\n    }\n    img = opj_image_create(numcomps, cmptparm, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    img->x0 = 0;\n    img->y0 = 0;\n    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;\n    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;\n    return img;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 170, "prediction": "0", "true_label": "0", "raw_text": "Question: static int xen_platform_initfn(PCIDevice *dev)\n\n{\n\n    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    pci_conf = d->pci_dev.config;\n\n\n\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n\n\n\n    pci_config_set_prog_interface(pci_conf, 0);\n\n\n\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n\n\n\n    pci_register_bar(&d->pci_dev, 0, 0x100,\n\n            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);\n\n\n\n    /* reserve 16MB mmio address for share memory*/\n\n    pci_register_bar(&d->pci_dev, 1, 0x1000000,\n\n            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);\n\n\n\n    platform_fixed_ioport_init(d);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 171, "prediction": "0", "true_label": "0", "raw_text": "Question: static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 172, "prediction": "0", "true_label": "0", "raw_text": "_IRQ_SET_ACTION_TRIGGER,\n\n            .index = VFIO_PCI_INTX_IRQ_INDEX,\n\n            .start = 0,\n\n            .count = 1,\n\n        },\n\n    };\n\n    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);\n\n    int ret;\n\n\n\n    if (vdev->intx.disabled || !pin) {\n\n        return 0;\n\n    }\n\n\n\n    vfio_disable_interrupts(vdev);\n\n\n\n    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */\n\n    ret = event_notifier_init(&vdev->intx.interrupt, 0);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: event_notifier_init failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);\n\n    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);\n\n\n\n    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {\n\n        error_report(\"vfio: Error: Failed to setup INTx fd: %m\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /*\n\n     * Disable mmaps so we can trap on BAR accesses.  We interpret any\n\n     * access as a response to an interrupt and unmask the physical\n\n     * device.  The device will re-assert if the interrupt is still\n\n     * pending.  We'll likely retrigger on the host multiple times per\n\n     * guest interrupt, but without EOI notification it's better than\n\n     * nothing.  Acceleration paths through KVM will avoid this.\n\n     */\n\n    vfio_mmap_set_enabled(vdev, false);\n\n\n\n    vdev->interrupt = VFIO_INT_INTx;\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 173, "prediction": "0", "true_label": "0", "raw_text": "{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    /* mvc and memmove do not behave the same when areas overlap! */\n\n    } else if ((dest < src) || (src + l < dest)) {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if ((dest + 8 <= src) || (src + 8 <= dest)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version with byte accesses which always work */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 174, "prediction": "0", "true_label": "0", "raw_text": "Question: void helper_store_fpcr (uint64_t val)\n\n{\n\n#ifdef CONFIG_SOFTFLOAT\n\n    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);\n\n#endif\n\n    switch ((val >> 58) & 3) {\n\n    case 0:\n\n        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);\n\n        break;\n\n    case 1:\n\n        set_float_rounding_mode(float_round_down, &FP_STATUS);\n\n        break;\n\n    case 2:\n\n        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);\n\n        break;\n\n    case 3:\n\n        set_float_rounding_mode(float_round_up, &FP_STATUS);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 175, "prediction": "1", "true_label": "0", "raw_text": "Question: void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 176, "prediction": "1", "true_label": "0", "raw_text": "Question: void qemu_system_wakeup_request(WakeupReason reason)\n\n{\n\n    if (!is_suspended) {\n\n        return;\n\n    }\n\n    if (!(wakeup_reason_mask & (1 << reason))) {\n\n        return;\n\n    }\n\n    runstate_set(RUN_STATE_RUNNING);\n\n    monitor_protocol_event(QEVENT_WAKEUP, NULL);\n\n    notifier_list_notify(&wakeup_notifiers, &reason);\n\n    reset_requested = 1;\n\n    qemu_notify_event();\n\n    is_suspended = false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 177, "prediction": "0", "true_label": "1", "raw_text": " (!strcmp(proto, \"rtsps\")) {\n\n        lower_proto  = \"tls\";\n\n        default_port = RTSPS_DEFAULT_PORT;\n\n    }\n\n\n\n    if (port < 0)\n\n        port = default_port;\n\n\n\n    /* Create TCP connection */\n\n    ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port,\n\n                \"?listen&listen_timeout=%d\", rt->initial_timeout * 1000);\n\n\n\n    if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE,\n\n                         &s->interrupt_callback, NULL, rt->protocols)) {\n\n        av_log(s, AV_LOG_ERROR, \"Unable to open RTSP for listening\\n\");\n\n        return ret;\n\n    }\n\n    rt->state       = RTSP_STATE_IDLE;\n\n    rt->rtsp_hd_out = rt->rtsp_hd;\n\n    for (;;) { /* Wait for incoming RTSP messages */\n\n        ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen);\n\n        if (ret < 0)\n\n            return ret;\n\n        ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method,\n\n                                 sizeof(method), &methodcode);\n\n        if (ret) {\n\n            av_log(s, AV_LOG_ERROR, \"RTSP: Unexpected Command\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if (methodcode == ANNOUNCE) {\n\n            ret       = rtsp_read_announce(s);\n\n            rt->state = RTSP_STATE_PAUSED;\n\n        } else if (methodcode == OPTIONS) {\n\n            ret = rtsp_read_options(s);\n\n        } else if (methodcode == RECORD) {\n\n            ret = rtsp_read_record(s);\n\n            if (!ret)\n\n                return 0; // We are ready for streaming\n\n        } else if (methodcode == SETUP)\n\n            ret = rtsp_read_setup(s, host, uri);\n\n        if (ret) {\n\n            ffurl_close(rt->rtsp_hd);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 178, "prediction": "0", "true_label": "1", "raw_text": ",\n\n                            int coef_nb_bits)\n\n{\n\n    int code, level, sign;\n\n    const uint32_t *ilvl = (const uint32_t *) level_table;\n\n    uint32_t *iptr = (uint32_t *) ptr;\n\n    const unsigned int coef_mask = block_len - 1;\n\n    for (; offset < num_coefs; offset++) {\n\n        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);\n\n        if (code > 1) {\n\n            /** normal code */\n\n            offset                  += run_table[code];\n\n            sign                     = get_bits1(gb) - 1;\n\n            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;\n\n        } else if (code == 1) {\n\n            /** EOB */\n\n            break;\n\n        } else {\n\n            /** escape */\n\n            if (!version) {\n\n                level = get_bits(gb, coef_nb_bits);\n\n                /** NOTE: this is rather suboptimal. reading\n\n                 *  block_len_bits would be better */\n\n                offset += get_bits(gb, frame_len_bits);\n\n            } else {\n\n                level = ff_wma_get_large_val(gb);\n\n                /** escape decode */\n\n                if (get_bits1(gb)) {\n\n                    if (get_bits1(gb)) {\n\n                        if (get_bits1(gb)) {\n\n                            av_log(avctx, AV_LOG_ERROR,\n\n                                   \"broken escape sequence\\n\");\n\n                            return -1;\n\n                        } else\n\n                            offset += get_bits(gb, frame_len_bits) + 4;\n\n                    } else\n\n                        offset += get_bits(gb, 2) + 1;\n\n                }\n\n            }\n\n            sign                    = get_bits1(gb) - 1;\n\n            ptr[offset & coef_mask] = (level ^ sign) - sign;\n\n        }\n\n    }\n\n    /** NOTE: EOB can be omitted */\n\n    if (offset > num_coefs) {\n\n        av_log(avctx, AV_LOG_ERROR, \"overflow in spectral RLE, ignoring\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 179, "prediction": "0", "true_label": "0", "raw_text": " < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if (filter->input_count == 1 && !curr_inputs && !index) {\n\n            /* First input can be omitted if it is \"[in]\" */\n\n            const char *tmp = \"[in]\";\n\n            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)\n\n                goto fail;\n\n        }\n\n\n\n        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        if ((ret = parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n\n\n        filters += strspn(filters, WHITESPACES);\n\n        chr = *filters++;\n\n\n\n        if (chr == ';' && curr_inputs) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Could not find a output to link when parsing \\\"%s\\\"\\n\",\n\n                   filters - 1);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        index++;\n\n    } while (chr == ',' || chr == ';');\n\n\n\n    if (chr) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Unable to parse graph description substring: \\\"%s\\\"\\n\",\n\n               filters - 1);\n\n        ret = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    if (open_inputs && !strcmp(open_inputs->name, \"out\") && curr_inputs) {\n\n        /* Last output can be omitted if it is \"[out]\" */\n\n        const char *tmp = \"[out]\";\n\n        if ((ret = parse_outputs(&tmp, &curr_inputs, &open_inputs, &open_outputs,\n\n                                 log_ctx)) < 0)\n\n            goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail:\n\n    avfilter_graph_free(graph);\n\n    free_inout(open_inputs);\n\n    free_inout(open_outputs);\n\n    free_inout(curr_inputs);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 180, "prediction": "0", "true_label": "0", "raw_text": "Question: static int virtio_net_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIONet *n = VIRTIO_NET(qdev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);\n\n    int i;\n\n\n\n    /* This will stop vhost backend if appropriate. */\n\n    virtio_net_set_status(vdev, 0);\n\n\n\n    unregister_savevm(qdev, \"virtio-net\", n);\n\n\n\n    if (n->netclient_name) {\n\n        g_free(n->netclient_name);\n\n        n->netclient_name = NULL;\n\n    }\n\n    if (n->netclient_type) {\n\n        g_free(n->netclient_type);\n\n        n->netclient_type = NULL;\n\n    }\n\n\n\n    g_free(n->mac_table.macs);\n\n    g_free(n->vlans);\n\n\n\n    for (i = 0; i < n->max_queues; i++) {\n\n        VirtIONetQueue *q = &n->vqs[i];\n\n        NetClientState *nc = qemu_get_subqueue(n->nic, i);\n\n\n\n        qemu_purge_queued_packets(nc);\n\n\n\n        if (q->tx_timer) {\n\n            timer_del(q->tx_timer);\n\n            timer_free(q->tx_timer);\n\n        } else {\n\n            qemu_bh_delete(q->tx_bh);\n\n        }\n\n    }\n\n\n\n    g_free(n->vqs);\n\n    qemu_del_nic(n->nic);\n\n    virtio_cleanup(vdev);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 181, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)\n\n{\n\n    if (u) {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_u8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_u16(dest, src); break;\n\n        case 2: tcg_gen_extu_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    } else {\n\n        switch (size) {\n\n        case 0: gen_helper_neon_widen_s8(dest, src); break;\n\n        case 1: gen_helper_neon_widen_s16(dest, src); break;\n\n        case 2: tcg_gen_ext_i32_i64(dest, src); break;\n\n        default: abort();\n\n        }\n\n    }\n\n    dead_tmp(src);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 182, "prediction": "0", "true_label": "0", "raw_text": "Question: static int sd_create_branch(BDRVSheepdogState *s)\n\n{\n\n    int ret, fd;\n\n    uint32_t vid;\n\n    char *buf;\n\n\n\n    dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdi_id);\n\n\n\n    buf = g_malloc(SD_INODE_SIZE);\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    dprintf(\"%\" PRIx32 \" is created.\\n\", vid);\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        error_report(\"failed to connect\");\n\n        ret = fd;\n\n        goto out;\n\n    }\n\n\n\n    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,\n\n                      SD_INODE_SIZE, 0, s->cache_enabled);\n\n\n\n    closesocket(fd);\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n\n\n    memcpy(&s->inode, buf, sizeof(s->inode));\n\n\n\n    s->is_snapshot = false;\n\n    ret = 0;\n\n    dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdi_id);\n\n\n\nout:\n\n    g_free(buf);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 183, "prediction": "0", "true_label": "1", "raw_text": "Question: static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 184, "prediction": "0", "true_label": "1", "raw_text": "2_1_func_type*)sum2_double;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s);\n\n    }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){\n\n        // Only for dithering currently\n\n//         s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double));\n\n        s->native_one    = av_mallocz(sizeof(int));\n\n        if (!s->native_one)\n\n            return AVERROR(ENOMEM);\n\n//         for (i = 0; i < nb_out; i++)\n\n//             for (j = 0; j < nb_in; j++)\n\n//                 ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j];\n\n        *((int*)s->native_one) = 32768;\n\n        s->mix_1_1_f = (mix_1_1_func_type*)copy_s32;\n\n        s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32;\n\n        s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s);\n\n    }else\n\n        av_assert0(0);\n\n    //FIXME quantize for integeres\n\n    for (i = 0; i < SWR_CH_MAX; i++) {\n\n        int ch_in=0;\n\n        for (j = 0; j < SWR_CH_MAX; j++) {\n\n            s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768);\n\n            if(s->matrix[i][j])\n\n                s->matrix_ch[i][++ch_in]= j;\n\n        }\n\n        s->matrix_ch[i][0]= ch_in;\n\n    }\n\n\n\n    if(HAVE_YASM && HAVE_MMX)\n\n        return swri_rematrix_init_x86(s);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 185, "prediction": "0", "true_label": "1", "raw_text": "Question: void s390_machine_reset(void)\n\n{\n\n    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));\n\n\n\n    qemu_devices_reset();\n\n    s390_cmma_reset();\n\n    s390_crypto_reset();\n\n\n\n    /* all cpus are stopped - configure and start the ipl cpu only */\n\n    s390_ipl_prepare_cpu(ipl_cpu);\n\n    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 186, "prediction": "0", "true_label": "1", "raw_text": "Question: static int fic_decode_block(FICContext *ctx, GetBitContext *gb,\n\n                            uint8_t *dst, int stride, int16_t *block)\n\n{\n\n    int i, num_coeff;\n\n\n\n    /* Is it a skip block? */\n\n    if (get_bits1(gb)) {\n\n        /* This is a P-frame. */\n\n        ctx->frame->key_frame = 0;\n\n        ctx->frame->pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        return 0;\n\n    }\n\n\n\n    memset(block, 0, sizeof(*block) * 64);\n\n\n\n    num_coeff = get_bits(gb, 7);\n\n    if (num_coeff > 64)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < num_coeff; i++)\n\n        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *\n\n                                     ctx->qmat[ff_zigzag_direct[i]];\n\n\n\n    fic_idct_put(dst, stride, block);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 187, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < rt->nb_rtsp_streams; i++) {\n\n        RTSPStream *rtsp_st = rt->rtsp_streams[i];\n\n        if (!rtsp_st)\n\n            continue;\n\n        if (rtsp_st->transport_priv) {\n\n            if (s->oformat) {\n\n                AVFormatContext *rtpctx = rtsp_st->transport_priv;\n\n                av_write_trailer(rtpctx);\n\n                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n                    uint8_t *ptr;\n\n                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)\n\n                        ff_rtsp_tcp_write_packet(s, rtsp_st);\n\n                    avio_close_dyn_buf(rtpctx->pb, &ptr);\n\n                    av_free(ptr);\n\n                } else {\n\n                    avio_close(rtpctx->pb);\n\n                }\n\n                avformat_free_context(rtpctx);\n\n            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)\n\n                ff_rdt_parse_close(rtsp_st->transport_priv);\n\n            else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC)\n\n                ff_rtp_parse_close(rtsp_st->transport_priv);\n\n        }\n\n        rtsp_st->transport_priv = NULL;\n\n        if (rtsp_st->rtp_handle)\n\n            ffurl_close(rtsp_st->rtp_handle);\n\n        rtsp_st->rtp_handle = NULL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 188, "prediction": "0", "true_label": "0", "raw_text": "Question: static void do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n\n\n    assert(p->ep->nr == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            usb_device_handle_control(s, p, request, value, index,\n\n                                      s->setup_len, s->data_buf);\n\n            if (p->status == USB_RET_ASYNC) {\n\n                return;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            p->actual_length = 0;\n\n        }\n\n        break;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len) {\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            }\n\n            return;\n\n        }\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n\n\n    default:\n\n        p->status = USB_RET_STALL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 189, "prediction": "0", "true_label": "0", "raw_text": "Question: static int get_video_buffer(AVFrame *frame, int align)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n\n    int ret, i;\n\n\n\n    if (!desc)\n\n        return AVERROR(EINVAL);\n\n\n\n    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if (!frame->linesize[0]) {\n\n        ret = av_image_fill_linesizes(frame->linesize, frame->format,\n\n                                      frame->width);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        for (i = 0; i < 4 && frame->linesize[i]; i++)\n\n            frame->linesize[i] = FFALIGN(frame->linesize[i], align);\n\n    }\n\n\n\n    for (i = 0; i < 4 && frame->linesize[i]; i++) {\n\n        int h = FFALIGN(frame->height, 32);\n\n        if (i == 1 || i == 2)\n\n            h = -((-h) >> desc->log2_chroma_h);\n\n\n\n        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);\n\n        if (!frame->buf[i])\n\n            goto fail;\n\n\n\n        frame->data[i] = frame->buf[i]->data;\n\n    }\n\n    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {\n\n        av_buffer_unref(&frame->buf[1]);\n\n        frame->buf[1] = av_buffer_alloc(1024);\n\n        if (!frame->buf[1])\n\n            goto fail;\n\n        frame->data[1] = frame->buf[1]->data;\n\n    }\n\n\n\n    frame->extended_data = frame->data;\n\n\n\n    return 0;\n\nfail:\n\n    av_frame_unref(frame);\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 190, "prediction": "0", "true_label": "0", "raw_text": "SR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 191, "prediction": "0", "true_label": "0", "raw_text": "Question: host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 192, "prediction": "1", "true_label": "0", "raw_text": "Question: av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n\n{\n\n    int i;\n\n\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n\n    if (f->slice_count <= 0) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < f->slice_count; i++) {\n\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n\n        int sx          = i % f->num_h_slices;\n\n        int sy          = i / f->num_h_slices;\n\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n\n        f->slice_context[i] = fs;\n\n        memcpy(fs, f, sizeof(*fs));\n\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n\n\n        fs->slice_width  = sxe - sxs;\n\n        fs->slice_height = sye - sys;\n\n        fs->slice_x      = sxs;\n\n        fs->slice_y      = sys;\n\n\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n\n                                      sizeof(*fs->sample_buffer));\n\n        if (!fs->sample_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 193, "prediction": "0", "true_label": "0", "raw_text": ")\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        s->frc = value & 0x3f;\n\n        break;\n\n    case 0x04:\t/* VRC */\n\n        if ((value ^ s->vrc) & 1) {\n\n            if (value & 1)\n\n                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)\n\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n\n                                ((omap_clk_getrate(s->clk) >> 3) /\n\n                                 /* Pre-multiplexer divider */\n\n                                 ((s->gcr & 2) ? 1 : 154) /\n\n                                 /* Octave multiplexer */\n\n                                 (2 << (value & 3)) *\n\n                                 /* 101/107 divider */\n\n                                 ((value & (1 << 2)) ? 101 : 107) *\n\n                                 /*  49/55 divider */\n\n                                 ((value & (1 << 3)) ?  49 : 55) *\n\n                                 /*  50/63 divider */\n\n                                 ((value & (1 << 4)) ?  50 : 63) *\n\n                                 /*  80/127 divider */\n\n                                 ((value & (1 << 5)) ?  80 : 127) /\n\n                                 (107 * 55 * 63 * 127)));\n\n            else\n\n                printf(\"%s: silence!\\n\", __FUNCTION__);\n\n        }\n\n        s->vrc = value & 0x7f;\n\n        break;\n\n    case 0x08:\t/* GCR */\n\n        s->gcr = value & 3;\n\n        break;\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 194, "prediction": "0", "true_label": "0", "raw_text": " currentA, A, sign;\n\n\n\n    currentA = p->lastA[0];\n\n\n\n    while (count--) {\n\n        A = *decoded0;\n\n\n\n        p->buf[YDELAYA] = currentA;\n\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n\n\n        currentA = A + (predictionA >> 10);\n\n\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n\n\n        sign = APESIGN(A);\n\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n\n\n        p->buf++;\n\n\n\n        /* Have we filled the history buffer? */\n\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n\n            memmove(p->historybuffer, p->buf,\n\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n\n            p->buf = p->historybuffer;\n\n        }\n\n\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n\n        *(decoded0++) = p->filterA[0];\n\n    }\n\n\n\n    p->lastA[0] = currentA;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 195, "prediction": "0", "true_label": "0", "raw_text": " += scale;\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%c:%2.2f \", type[j], psnr(error/scale));\n\n                }\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"*:%2.2f \", psnr(error_sum/scale_sum));\n\n            }\n\n            vid = 1;\n\n        }\n\n        /* compute min output value */\n\n        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);\n\n        if ((pts < ti1) && (pts > 0))\n\n            ti1 = pts;\n\n    }\n\n    if (ti1 < 0.01)\n\n        ti1 = 0.01;\n\n\n\n    if (verbose || is_last_report) {\n\n        bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n\n\n\n        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n\n            \"size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s\",\n\n            (double)total_size / 1024, ti1, bitrate);\n\n\n\n        if (nb_frames_dup || nb_frames_drop)\n\n          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \" dup=%d drop=%d\",\n\n                  nb_frames_dup, nb_frames_drop);\n\n\n\n        if (verbose >= 0)\n\n            fprintf(stderr, \"%s    \\r\", buf);\n\n\n\n        fflush(stderr);\n\n    }\n\n\n\n    if (is_last_report && verbose >= 0){\n\n        int64_t raw= audio_size + video_size + extra_size;\n\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\\n\",\n\n                video_size/1024.0,\n\n                audio_size/1024.0,\n\n                extra_size/1024.0,\n\n                100.0*(total_size - raw)/raw\n\n        );\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 196, "prediction": "0", "true_label": "1", "raw_text": "dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);\n\n            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);\n\n        }\n\n\n\n        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +\n\n              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;\n\n        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +\n\n              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);\n\n            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);\n\n        }\n\n\n\n        src[-2*step] = p1;\n\n        src[-1*step] = p0;\n\n        src[ 0*step] = q0;\n\n        src[ 1*step] = q1;\n\n\n\n        if(!chroma){\n\n            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +\n\n                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;\n\n            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +\n\n                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 197, "prediction": "-1", "true_label": "1", "raw_text": "p);\n\n    if (!dc) {\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path, errp);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n\n                       driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus || qbus_is_full(bus)) {\n\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n\n                       dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    if (!migration_is_idle()) {\n\n        error_setg(errp, \"device_add not allowed while migrating\");\n\n        return NULL;\n\n    }\n\n\n\n    /* create device */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n\n\n\n\n\n    }\n\n\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n\n\n    /* set properties */\n\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        dev->opts = NULL;\n\n\n    }\n\n    return dev;\n\n\n\nerr_del_dev:\n\n    error_propagate(errp, err);\n\n    object_unparent(OBJECT(dev));\n\n    object_unref(OBJECT(dev));\n\n    return NULL;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 198, "prediction": "0", "true_label": "1", "raw_text": "->gb, 16);\n\n\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n\n\n            if (!v)\n\n                ret = SLICE_END;\n\n        }\n\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n\n            active_bits_size = buf_size2 * 8;\n\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n\n                   8 * buf_size, active_bits_size);\n\n            ret = SLICE_OK;\n\n        }\n\n\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x,\n\n                   s->mb_y);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            ff_h263_update_motion_val(s);\n\n        ff_MPV_decode_mb(s, s->block);\n\n        if (s->loop_filter)\n\n            ff_h263_loop_filter(s);\n\n\n\n        if (++s->mb_x == s->mb_width) {\n\n            s->mb_x = 0;\n\n            s->mb_y++;\n\n            ff_init_block_index(s);\n\n        }\n\n        if (s->mb_x == s->resync_mb_x)\n\n            s->first_slice_line = 0;\n\n        if (ret == SLICE_END)\n\n            break;\n\n    }\n\n\n\n    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,\n\n                    ER_MB_END);\n\n\n\n    return active_bits_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 199, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int cpu_gdb_index(CPUState *cpu)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    return cpu->host_tid;\n\n#else\n\n    return cpu->cpu_index + 1;\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 200, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)\n\n{\n\n    unsigned nz = idx >> 12;\n\n\n\n    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));\n\n\n\n    return dst + 4;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 201, "prediction": "0", "true_label": "1", "raw_text": "Question: void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)\n{\n    BlockJobInfoList *list;\n    Error *err = NULL;\n    list = qmp_query_block_jobs(&err);\n    assert(!err);\n    if (!list) {\n        monitor_printf(mon, \"No active jobs\\n\");\n        return;\n    }\n    while (list) {\n        if (strcmp(list->value->type, \"stream\") == 0) {\n            monitor_printf(mon, \"Streaming device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        } else {\n            monitor_printf(mon, \"Type %s, device %s: Completed %\" PRId64\n                           \" of %\" PRId64 \" bytes, speed limit %\" PRId64\n                           \" bytes/s\\n\",\n                           list->value->type,\n                           list->value->device,\n                           list->value->offset,\n                           list->value->len,\n                           list->value->speed);\n        }\n        list = list->next;\n    }\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 202, "prediction": "0", "true_label": "0", "raw_text": ", s->end_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts < s->end_pts) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_pts - pts);\n\n        }\n\n\n\n        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);\n\n        }\n\n\n\n        if (drop) {\n\n            s->eof = 1;\n\n            goto drop;\n\n        }\n\n    }\n\n\n\n    s->nb_samples += frame->nb_samples;\n\n    start_sample   = FFMAX(0, start_sample);\n\n    end_sample     = FFMIN(frame->nb_samples, end_sample);\n\n    av_assert0(start_sample < end_sample);\n\n\n\n    if (start_sample) {\n\n        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        av_frame_copy_props(out, frame);\n\n        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,\n\n                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                        frame->format);\n\n        if (out->pts != AV_NOPTS_VALUE)\n\n            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },\n\n                                     inlink->time_base);\n\n\n\n        av_frame_free(&frame);\n\n        frame = out;\n\n    } else\n\n        frame->nb_samples = end_sample;\n\n\n\n    s->got_output = 1;\n\n    return ff_filter_frame(ctx->outputs[0], frame);\n\n\n\ndrop:\n\n    s->nb_samples += frame->nb_samples;\n\n    av_frame_free(&frame);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 203, "prediction": "0", "true_label": "0", "raw_text": " nb_oargs; i++) {\n\n        if (IS_DEAD_ARG(i)) {\n\n            temp_dead(s, &s->temps[args[i]]);\n\n        }\n\n    }\n\n    \n\n    /* clobber call registers */\n\n    for (i = 0; i < TCG_TARGET_NB_REGS; i++) {\n\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) {\n\n            tcg_reg_free(s, i, allocated_regs);\n\n        }\n\n    }\n\n\n\n    /* Save globals if they might be written by the helper, sync them if\n\n       they might be read. */\n\n    if (flags & TCG_CALL_NO_READ_GLOBALS) {\n\n        /* Nothing to do */\n\n    } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) {\n\n        sync_globals(s, allocated_regs);\n\n    } else {\n\n        save_globals(s, allocated_regs);\n\n    }\n\n\n\n    tcg_out_call(s, func_addr);\n\n\n\n    /* assign output registers and emit moves if needed */\n\n    for(i = 0; i < nb_oargs; i++) {\n\n        arg = args[i];\n\n        ts = &s->temps[arg];\n\n        reg = tcg_target_call_oarg_regs[i];\n\n        assert(s->reg_to_temp[reg] == NULL);\n\n\n\n        if (ts->fixed_reg) {\n\n            if (ts->reg != reg) {\n\n                tcg_out_mov(s, ts->type, ts->reg, reg);\n\n            }\n\n        } else {\n\n            if (ts->val_type == TEMP_VAL_REG) {\n\n                s->reg_to_temp[ts->reg] = NULL;\n\n            }\n\n            ts->val_type = TEMP_VAL_REG;\n\n            ts->reg = reg;\n\n            ts->mem_coherent = 0;\n\n            s->reg_to_temp[reg] = ts;\n\n            if (NEED_SYNC_ARG(i)) {\n\n                tcg_reg_sync(s, reg, allocated_regs);\n\n            }\n\n            if (IS_DEAD_ARG(i)) {\n\n                temp_dead(s, ts);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 204, "prediction": "0", "true_label": "0", "raw_text": "Question: static void curl_multi_do(void *arg)\n\n{\n\n    BDRVCURLState *s = (BDRVCURLState *)arg;\n\n    int running;\n\n    int r;\n\n\n\n    if (!s->multi) {\n\n        return;\n\n    }\n\n\n\n    do {\n\n        r = curl_multi_socket_all(s->multi, &running);\n\n    } while(r == CURLM_CALL_MULTI_PERFORM);\n\n\n\n    curl_multi_read(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 205, "prediction": "0", "true_label": "0", "raw_text": "option, \"time_base\")  || !strcmp(option, \"pixel_format\") ||\n\n               !strcmp(option, \"video_size\") || !strcmp(option, \"codec_tag\")))\n\n        o = av_opt_find(ctx, option, NULL, 0, 0);\n\n    if (!o) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                            &config->errors, \"Option not found: %s\\n\", opt);\n\n        if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) {\n\n            hinted = 1;\n\n            report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL,\n\n                                \"If '%s' is a codec private option, then prefix it with codec name, \"\n\n                                \"for example '%s:%s %s' or define codec earlier.\\n\",\n\n                                opt, avcodec_get_name(guessed_codec_id) ,opt, arg);\n\n        }\n\n    } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, \"Invalid value for option %s (%s): %s\\n\", opt,\n\n                arg, av_err2str(ret));\n\n    } else if ((e = av_dict_get(*dict, option, NULL, 0))) {\n\n        if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-'))\n\n            return av_dict_set(dict, option, arg, AV_DICT_APPEND);\n\n        report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors,\n\n                \"Redeclaring value of the option %s, previous value: %s\\n\",\n\n                opt, e->value);\n\n    } else if (av_dict_set(dict, option, arg, 0) < 0) {\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 206, "prediction": "0", "true_label": "0", "raw_text": " break;\n\n        case 0x38: /* ldo.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_ld16u(t2, t1, ctx->memidx);\n\n                tcg_gen_mov_i32(REG(a), t2);\n\n\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        case 0x39: /* sto.s */\n\n            {\n\n                int a = (opcode >> 4) & 0xf;\n\n                int b = opcode & 0xf;\n\n\n\n                TCGv t1 = tcg_temp_new_i32();\n\n                TCGv t2 = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2));\n\n                tcg_gen_qemu_st16(REG(b), t1, ctx->memidx);\n\n                tcg_temp_free_i32(t1);\n\n                tcg_temp_free_i32(t2);\n\n\n\n                length = 6;\n\n            }\n\n            break;\n\n        default:\n\n            {\n\n                TCGv temp = tcg_temp_new_i32();\n\n                tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n                tcg_gen_movi_i32(temp, MOXIE_EX_BAD);\n\n                gen_helper_raise_exception(cpu_env, temp);\n\n                tcg_temp_free_i32(temp);\n\n             }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return length;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 207, "prediction": "0", "true_label": "0", "raw_text": "s, int opc, int r, int rm, int x)\n\n{\n\n    int rex;\n\n\n\n    if (opc & P_GS) {\n\n        tcg_out8(s, 0x65);\n\n    }\n\n    if (opc & P_DATA16) {\n\n        /* We should never be asking for both 16 and 64-bit operation.  */\n\n        assert((opc & P_REXW) == 0);\n\n        tcg_out8(s, 0x66);\n\n    }\n\n    if (opc & P_ADDR32) {\n\n        tcg_out8(s, 0x67);\n\n    }\n\n\n\n    rex = 0;\n\n    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */\n\n    rex |= (r & 8) >> 1;                /* REX.R */\n\n    rex |= (x & 8) >> 2;                /* REX.X */\n\n    rex |= (rm & 8) >> 3;               /* REX.B */\n\n\n\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n\n       that are ORed in merely indicate that the REX byte must be present;\n\n       those bits get discarded in output.  */\n\n    rex |= opc & (r >= 4 ? P_REXB_R : 0);\n\n    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);\n\n\n\n    if (rex) {\n\n        tcg_out8(s, (uint8_t)(rex | 0x40));\n\n    }\n\n\n\n    if (opc & (P_EXT | P_EXT38)) {\n\n        tcg_out8(s, 0x0f);\n\n        if (opc & P_EXT38) {\n\n            tcg_out8(s, 0x38);\n\n        }\n\n    }\n\n\n\n    tcg_out8(s, opc);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 208, "prediction": "0", "true_label": "1", "raw_text": " = (uint8_t *)buf;\n\n    strm.avail_out = s->cluster_size;\n\n    strm.next_out = out_buf;\n\n\n\n    ret = deflate(&strm, Z_FINISH);\n\n    if (ret != Z_STREAM_END && ret != Z_OK) {\n\n        deflateEnd(&strm);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n    }\n\n    out_len = strm.next_out - out_buf;\n\n\n\n    deflateEnd(&strm);\n\n\n\n    if (ret != Z_STREAM_END || out_len >= s->cluster_size) {\n\n        /* could not compress: write normal cluster */\n\n        ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n        goto success;\n\n    }\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    cluster_offset =\n\n        qcow2_alloc_compressed_cluster_offset(bs, offset, out_len);\n\n    if (!cluster_offset) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    cluster_offset &= s->cluster_offset_mask;\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    iov = (struct iovec) {\n\n        .iov_base   = out_buf,\n\n        .iov_len    = out_len,\n\n    };\n\n    qemu_iovec_init_external(&hd_qiov, &iov, 1);\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED);\n\n    ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\nsuccess:\n\n    ret = 0;\n\nfail:\n\n    qemu_vfree(buf);\n\n    g_free(out_buf);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 209, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 210, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 211, "prediction": "0", "true_label": "0", "raw_text": " instead)\n\n         */\n\n        tio.c_cc[VMIN] = 1;\n\n        tio.c_cc[VTIME] = 0;\n\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n\n        tcflush(fd, TCIFLUSH);\n\n        tcsetattr(fd, TCSANOW, &tio);\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_UNIX_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n\n\n            fd = unix_listen(path, NULL, strlen(path), &local_err);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    case GA_CHANNEL_VSOCK_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n            SocketAddress *addr;\n\n            char *addr_str;\n\n\n\n            addr_str = g_strdup_printf(\"vsock:%s\", path);\n\n            addr = socket_parse(addr_str, &local_err);\n\n            g_free(addr_str);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n\n\n            fd = socket_listen(addr, &local_err);\n\n            qapi_free_SocketAddress(addr);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    default:\n\n        g_critical(\"error binding/listening to specified socket\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 212, "prediction": "0", "true_label": "0", "raw_text": "Question: static int ram_save_block(QEMUFile *f)\n\n{\n\n    RAMBlock *block = last_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n\n\n    if (!block)\n\n        block = QLIST_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                    DIRTY_MEMORY_MIGRATION)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                      DIRTY_MEMORY_MIGRATION);\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n            }\n\n\n\n            break;\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QLIST_NEXT(block, next);\n\n            if (!block)\n\n                block = QLIST_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_block || offset != last_offset);\n\n\n\n    last_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 213, "prediction": "0", "true_label": "0", "raw_text": "Question: bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,\n\n    size_t len)\n\n{\n\n    hwaddr mapped_len = 0;\n\n    struct iovec *ventry;\n\n    assert(pkt);\n\n    assert(pkt->max_raw_frags > pkt->raw_frags);\n\n\n\n    if (!len) {\n\n        return true;\n\n     }\n\n\n\n    ventry = &pkt->raw[pkt->raw_frags];\n\n    mapped_len = len;\n\n\n\n    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);\n\n    ventry->iov_len = mapped_len;\n\n    pkt->raw_frags += !!ventry->iov_base;\n\n\n\n    if ((ventry->iov_base == NULL) || (len != mapped_len)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 214, "prediction": "0", "true_label": "0", "raw_text": "Question: yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,\n\n                     const uint16_t *buf1, const uint16_t *ubuf0,\n\n                     const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                     const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                     const uint16_t *abuf1, uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target)\n\n{\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n\n\n        output_pixels(i * 4, Y1, U, Y2, V);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 215, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,\n\n                                              int linesize,\n\n                                              int block_w, int block_h,\n\n                                              int src_x, int src_y,\n\n                                              int w, int h,\n\n                                              emu_edge_core_func *core_fn)\n\n{\n\n    int start_y, start_x, end_y, end_x, src_y_add = 0;\n\n\n\n    if (src_y >= h) {\n\n        src_y_add = h - 1 - src_y;\n\n        src_y     = h - 1;\n\n    } else if (src_y <= -block_h) {\n\n        src_y_add = 1 - block_h - src_y;\n\n        src_y     = 1 - block_h;\n\n    }\n\n    if (src_x >= w) {\n\n        src   += w - 1 - src_x;\n\n        src_x  = w - 1;\n\n    } else if (src_x <= -block_w) {\n\n        src   += 1 - block_w - src_x;\n\n        src_x  = 1 - block_w;\n\n    }\n\n\n\n    start_y = FFMAX(0, -src_y);\n\n    start_x = FFMAX(0, -src_x);\n\n    end_y   = FFMIN(block_h, h-src_y);\n\n    end_x   = FFMIN(block_w, w-src_x);\n\n    av_assert2(start_x < end_x && block_w > 0);\n\n    av_assert2(start_y < end_y && block_h > 0);\n\n\n\n    // fill in the to-be-copied part plus all above/below\n\n    src += (src_y_add + start_y) * linesize + start_x;\n\n    buf += start_x;\n\n    core_fn(buf, src, linesize, start_y, end_y,\n\n            block_h, start_x, end_x, block_w);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 216, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 217, "prediction": "0", "true_label": "1", "raw_text": " < s->num_children; i++) {\n\n        if (!acb->qcrs[i].ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    assert(i < s->num_children);\n\n\n\n    /* compare this read with all other successful reads stopping at quorum\n\n     * failure\n\n     */\n\n    for (j = i + 1; j < s->num_children; j++) {\n\n        if (acb->qcrs[j].ret) {\n\n            continue;\n\n        }\n\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n\n        if (!quorum) {\n\n            break;\n\n       }\n\n    }\n\n\n\n    /* Every successful read agrees */\n\n    if (quorum) {\n\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n\n        return;\n\n    }\n\n\n\n    /* compute hashes for each successful read, also store indexes */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (acb->qcrs[i].ret) {\n\n            continue;\n\n        }\n\n        ret = quorum_compute_hash(acb, i, &hash);\n\n        /* if ever the hash computation failed */\n\n        if (ret < 0) {\n\n            acb->vote_ret = ret;\n\n            goto free_exit;\n\n        }\n\n        quorum_count_vote(&acb->votes, &hash, i);\n\n    }\n\n\n\n    /* vote to select the most represented version */\n\n    winner = quorum_get_vote_winner(&acb->votes);\n\n\n\n    /* if the winner count is smaller than threshold the read fails */\n\n    if (winner->vote_count < s->threshold) {\n\n        quorum_report_failure(acb);\n\n        acb->vote_ret = -EIO;\n\n        goto free_exit;\n\n    }\n\n\n\n    /* we have a winner: copy it */\n\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n\n\n\n    /* some versions are bad print them */\n\n    quorum_report_bad_versions(s, acb, &winner->value);\n\n\n\nfree_exit:\n\n    /* free lists */\n\n    quorum_free_vote_list(&acb->votes);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 218, "prediction": "0", "true_label": "1", "raw_text": "raise(gpio_out[GPIO_D][0]);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        DeviceState *enet;\n\n\n\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n\n\n\n        enet = qdev_create(NULL, \"stellaris_enet\");\n\n        qdev_set_nic_properties(enet, &nd_table[0]);\n\n        qdev_init_nofail(enet);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            for (j = 0; j < 8; j++) {\n\n                if (gpio_out[i][j]) {\n\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 219, "prediction": "0", "true_label": "1", "raw_text": "Question: void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 220, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 221, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 222, "prediction": "0", "true_label": "1", "raw_text": "\n\n    /* load up the VQA parameters from the header */\n\n    vqa_header = (unsigned char *)s->avctx->extradata;\n\n    s->vqa_version = vqa_header[0];\n\n    s->width = LE_16(&vqa_header[6]);\n\n    s->height = LE_16(&vqa_header[8]);\n\n\n\n\n\n    s->vector_width = vqa_header[10];\n\n    s->vector_height = vqa_header[11];\n\n    s->partial_count = s->partial_countdown = vqa_header[13];\n\n\n\n    /* the vector dimensions have to meet very stringent requirements */\n\n    if ((s->vector_width != 4) ||\n\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n\n        /* return without further initialization */\n\n\n\n\n\n    /* allocate codebooks */\n\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n\n    s->codebook = av_malloc(s->codebook_size);\n\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n\n\n\n    /* initialize the solid-color vectors */\n\n    if (s->vector_height == 4) {\n\n        codebook_index = 0xFF00 * 16;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 16; j++)\n\n                s->codebook[codebook_index++] = i;\n\n    } else {\n\n        codebook_index = 0xF00 * 8;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 8; j++)\n\n                s->codebook[codebook_index++] = i;\n\n\n    s->next_codebook_buffer_index = 0;\n\n\n\n    /* allocate decode buffer */\n\n    s->decode_buffer_size = (s->width / s->vector_width) *\n\n        (s->height / s->vector_height) * 2;\n\n    s->decode_buffer = av_malloc(s->decode_buffer_size);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 223, "prediction": "0", "true_label": "0", "raw_text": "(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    /* process manually set metadata */\n\n    for (i = 0; i < o->nb_metadata; i++) {\n\n        AVDictionary **m;\n\n        char type, *val;\n\n        const char *stream_spec;\n\n        int index = 0, j, ret = 0;\n\n\n\n        val = strchr(o->metadata[i].u.str, '=');\n\n        if (!val) {\n\n            av_log(NULL, AV_LOG_FATAL, \"No '=' character in metadata string %s.\\n\",\n\n                   o->metadata[i].u.str);\n\n            exit_program(1);\n\n        }\n\n        *val++ = 0;\n\n\n\n        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);\n\n        if (type == 's') {\n\n            for (j = 0; j < oc->nb_streams; j++) {\n\n                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n\n                    av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n                } else if (ret < 0)\n\n                    exit_program(1);\n\n            }\n\n        }\n\n        else {\n\n            switch (type) {\n\n            case 'g':\n\n                m = &oc->metadata;\n\n                break;\n\n            case 'c':\n\n                if (index < 0 || index >= oc->nb_chapters) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Invalid chapter index %d in metadata specifier.\\n\", index);\n\n                    exit_program(1);\n\n                }\n\n                m = &oc->chapters[index]->metadata;\n\n                break;\n\n            default:\n\n                av_log(NULL, AV_LOG_FATAL, \"Invalid metadata specifier %s.\\n\", o->metadata[i].specifier);\n\n                exit_program(1);\n\n            }\n\n            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 224, "prediction": "0", "true_label": "1", "raw_text": " 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 225, "prediction": "1", "true_label": "1", "raw_text": "Question: static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n\n                             int poc, int ref_flag)\n\n{\n\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n\n\n    if (ref == s->ref)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!ref) {\n\n        ref = generate_missing_ref(s, poc);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    list->list[list->nb_refs] = ref->poc;\n\n    list->ref[list->nb_refs]  = ref;\n\n    list->nb_refs++;\n\n\n\n    mark_ref(ref, ref_flag);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 226, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 227, "prediction": "0", "true_label": "1", "raw_text": " Vorbis id header packet corrupt (framing flag not set). \\n\");\n\n        return 2;\n\n    }\n\n\n\n    vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->channel_floors  = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->saved           = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->ret             = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float));\n\n    vc->buf             = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->buf_tmp         = av_malloc( vc->blocksize[1]                       * sizeof(float));\n\n    vc->previous_window=0;\n\n\n\n    ff_mdct_init(&vc->mdct[0], bl0, 1);\n\n    ff_mdct_init(&vc->mdct[1], bl1, 1);\n\n\n\n    AV_DEBUG(\" vorbis version %d \\n audio_channels %d \\n audio_samplerate %d \\n bitrate_max %d \\n bitrate_nom %d \\n bitrate_min %d \\n blk_0 %d blk_1 %d \\n \",\n\n            vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]);\n\n\n\n/*\n\n    BLK=vc->blocksize[0];\n\n    for(i=0;i<BLK/2;++i) {\n\n        vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358)));\n\n    }\n\n*/\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 228, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,\n\n                                         src - (stride * 2) +\n\n                                         sizeof(uint8_t), stride, dst, stride);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 229, "prediction": "0", "true_label": "1", "raw_text": "Question: static int net_vhost_user_init(NetClientState *peer, const char *device,\n\n                               const char *name, CharDriverState *chr,\n\n                               int queues)\n\n{\n\n    NetClientState *nc;\n\n    VhostUserState *s;\n\n    int i;\n\n\n\n    for (i = 0; i < queues; i++) {\n\n        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);\n\n\n\n        snprintf(nc->info_str, sizeof(nc->info_str), \"vhost-user%d to %s\",\n\n                 i, chr->label);\n\n\n\n        nc->queue_index = i;\n\n\n\n        s = DO_UPCAST(VhostUserState, nc, nc);\n\n        s->chr = chr;\n\n    }\n\n\n\n    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 230, "prediction": "0", "true_label": "0", "raw_text": "Question: static int flv_probe(AVProbeData *p)\n\n{\n\n    const uint8_t *d;\n\n\n\n    if (p->buf_size < 6)\n\n        return 0;\n\n    d = p->buf;\n\n    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {\n\n        return AVPROBE_SCORE_MAX;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 231, "prediction": "0", "true_label": "0", "raw_text": "Question: static void scsi_read_data(SCSIDevice *d, uint32_t tag)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n\n    SCSIDiskReq *r;\n\n\n\n    r = scsi_find_request(s, tag);\n\n    if (!r) {\n\n        BADF(\"Bad read tag 0x%x\\n\", tag);\n\n        /* ??? This is the wrong error.  */\n\n        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);\n\n        return;\n\n    }\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    scsi_read_request(r);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 232, "prediction": "0", "true_label": "0", "raw_text": "c':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, \"chapter\")\n\n                meta[j] = &files[j]->chapters[map->index]->metadata;\n\n                break;\n\n            case 'p':\n\n                METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, \"program\")\n\n                meta[j] = &files[j]->programs[map->index]->metadata;\n\n                break;\n\n            }\n\n        }\n\n\n\n        av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE);\n\n    }\n\n\n\n    /* copy global metadata by default */\n\n    if (metadata_global_autocopy && nb_input_files)\n\n        av_dict_copy(&oc->metadata, input_files[0].ctx->metadata,\n\n                     AV_DICT_DONT_OVERWRITE);\n\n    if (metadata_streams_autocopy)\n\n        for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) {\n\n            InputStream *ist = &input_streams[output_streams[i].source_index];\n\n            av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);\n\n        }\n\n\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_width   = 0;\n\n    frame_height  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    chapters_input_file = INT_MAX;\n\n    limit_filesize = UINT64_MAX;\n\n\n\n    av_freep(&meta_data_maps);\n\n    nb_meta_data_maps = 0;\n\n    metadata_global_autocopy   = 1;\n\n    metadata_streams_autocopy  = 1;\n\n    metadata_chapters_autocopy = 1;\n\n    av_freep(&streamid_map);\n\n    nb_streamid_map = 0;\n\n\n\n    av_dict_free(&codec_names);\n\n\n\n    av_freep(&forced_key_frames);\n\n    reset_options(o);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 233, "prediction": "0", "true_label": "0", "raw_text": "Question: static int spawn_thread(void)\n\n{\n\n    pthread_attr_t attr;\n\n    int ret;\n\n\n\n    cur_threads++;\n\n    idle_threads++;\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 234, "prediction": "0", "true_label": "0", "raw_text": "IStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf      = pb->buf_ptr,\n\n                             .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 235, "prediction": "0", "true_label": "0", "raw_text": "Question: bool machine_iommu(MachineState *machine)\n\n{\n\n    return machine->iommu;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 236, "prediction": "0", "true_label": "0", "raw_text": "\n\n        /* mcrr.  Used for block cache operations, so implement as no-op.  */\n\n        return 0;\n\n    }\n\n    if ((insn & (1 << 4)) == 0) {\n\n        /* cdp */\n\n        return 1;\n\n    }\n\n    if (IS_USER(s) && !cp15_user_ok(insn)) {\n\n        return 1;\n\n    }\n\n    if ((insn & 0x0fff0fff) == 0x0e070f90\n\n        || (insn & 0x0fff0fff) == 0x0e070f58) {\n\n        /* Wait for interrupt.  */\n\n        gen_set_pc_im(s->pc);\n\n        s->is_jmp = DISAS_WFI;\n\n        return 0;\n\n    }\n\n    rd = (insn >> 12) & 0xf;\n\n\n\n    if (cp15_tls_load_store(env, s, insn, rd))\n\n        return 0;\n\n\n\n    tmp2 = tcg_const_i32(insn);\n\n    if (insn & ARM_CP_RW_BIT) {\n\n        tmp = new_tmp();\n\n        gen_helper_get_cp15(tmp, cpu_env, tmp2);\n\n        /* If the destination register is r15 then sets condition codes.  */\n\n        if (rd != 15)\n\n            store_reg(s, rd, tmp);\n\n        else\n\n            dead_tmp(tmp);\n\n    } else {\n\n        tmp = load_reg(s, rd);\n\n        gen_helper_set_cp15(cpu_env, tmp2, tmp);\n\n        dead_tmp(tmp);\n\n        /* Normally we would always end the TB here, but Linux\n\n         * arch/arm/mach-pxa/sleep.S expects two instructions following\n\n         * an MMU enable to execute from cache.  Imitate this behaviour.  */\n\n        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||\n\n                (insn & 0x0fff0fff) != 0x0e010f10)\n\n            gen_lookup_tb(s);\n\n    }\n\n    tcg_temp_free_i32(tmp2);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 237, "prediction": "0", "true_label": "0", "raw_text": "Question: static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 238, "prediction": "0", "true_label": "0", "raw_text": "update_endp_table(dev);\n\n    if (ret)\n\n        goto fail;\n\n\n\n    if (ci.slow)\n\n        dev->dev.speed = USB_SPEED_LOW;\n\n    else\n\n        dev->dev.speed = USB_SPEED_HIGH;\n\n    dev->dev.handle_packet = usb_generic_handle_packet;\n\n\n\n    dev->dev.handle_reset = usb_host_handle_reset;\n\n    dev->dev.handle_control = usb_host_handle_control;\n\n    dev->dev.handle_data = usb_host_handle_data;\n\n    dev->dev.handle_destroy = usb_host_handle_destroy;\n\n\n\n    if (product_name[0] == '\\0')\n\n        snprintf(dev->dev.devname, sizeof(dev->dev.devname),\n\n                 \"host:%s\", devname);\n\n    else\n\n        pstrcpy(dev->dev.devname, sizeof(dev->dev.devname),\n\n                product_name);\n\n\n\n#ifdef USE_ASYNCIO\n\n    /* set up the signal handlers */\n\n    sigemptyset(&sigact.sa_mask);\n\n    sigact.sa_sigaction = isoch_done;\n\n    sigact.sa_flags = SA_SIGINFO;\n\n    sigact.sa_restorer = 0;\n\n    ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL);\n\n    if (ret < 0) {\n\n        perror(\"usb_host_device_open: sigaction failed\");\n\n        goto fail;\n\n    }\n\n\n\n    if (pipe(dev->pipe_fds) < 0) {\n\n        perror(\"usb_host_device_open: pipe creation failed\");\n\n        goto fail;\n\n    }\n\n    fcntl(dev->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC);\n\n    fcntl(dev->pipe_fds[1], F_SETFL, O_NONBLOCK);\n\n    qemu_set_fd_handler(dev->pipe_fds[0], urb_completion_pipe_read, NULL, dev);\n\n#endif\n\n    dev->urbs_ready = 0;\n\n    return (USBDevice *)dev;\n\nfail:\n\n    if (dev)\n\n        qemu_free(dev);\n\n    close(fd);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 239, "prediction": "0", "true_label": "0", "raw_text": "Question: uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN square root */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 240, "prediction": "0", "true_label": "0", "raw_text": "Question: int gen_new_label(void)\n\n{\n\n    TCGContext *s = &tcg_ctx;\n\n    int idx;\n\n    TCGLabel *l;\n\n\n\n    if (s->nb_labels >= TCG_MAX_LABELS)\n\n        tcg_abort();\n\n    idx = s->nb_labels++;\n\n    l = &s->labels[idx];\n\n    l->has_value = 0;\n\n    l->u.first_reloc = NULL;\n\n    return idx;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 241, "prediction": "0", "true_label": "0", "raw_text": "Question: void bdrv_round_to_clusters(BlockDriverState *bs,\n\n                            int64_t sector_num, int nb_sectors,\n\n                            int64_t *cluster_sector_num,\n\n                            int *cluster_nb_sectors)\n\n{\n\n    BlockDriverInfo bdi;\n\n\n\n    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {\n\n        *cluster_sector_num = sector_num;\n\n        *cluster_nb_sectors = nb_sectors;\n\n    } else {\n\n        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;\n\n        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);\n\n        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +\n\n                                            nb_sectors, c);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 242, "prediction": "0", "true_label": "1", "raw_text": "Question: void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 243, "prediction": "1", "true_label": "1", "raw_text": "Question: blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 244, "prediction": "0", "true_label": "1", "raw_text": "Question: static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 245, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void tcg_out_ld_ptr(TCGContext *s, int ret,\n\n                                  tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with offset %ld\\n\", __func__, arg);\n\n    if (arg != (arg & 0xfff))\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));\n\n    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |\n\n              INSN_IMM13(arg & 0x3ff));\n\n#else\n\n    tcg_out_ld_raw(s, ret, arg);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 246, "prediction": "0", "true_label": "0", "raw_text": "Question: int xen_config_dev_blk(DriveInfo *disk)\n\n{\n\n    char fe[256], be[256];\n\n    int vdev = 202 * 256 + 16 * disk->unit;\n\n    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;\n\n    const char *devtype = cdrom ? \"cdrom\" : \"disk\";\n\n    const char *mode    = cdrom ? \"r\"     : \"w\";\n\n\n\n    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),\n\n\t     \"xvd%c\", 'a' + disk->unit);\n\n    xen_be_printf(NULL, 1, \"config disk %d [%s]: %s\\n\",\n\n                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);\n\n    xen_config_dev_dirs(\"vbd\", \"qdisk\", vdev, fe, be, sizeof(fe));\n\n\n\n    /* frontend */\n\n    xenstore_write_int(fe, \"virtual-device\",  vdev);\n\n    xenstore_write_str(fe, \"device-type\",     devtype);\n\n\n\n    /* backend */\n\n    xenstore_write_str(be, \"dev\",             disk->bdrv->device_name);\n\n    xenstore_write_str(be, \"type\",            \"file\");\n\n    xenstore_write_str(be, \"params\",          disk->bdrv->filename);\n\n    xenstore_write_str(be, \"mode\",            mode);\n\n\n\n    /* common stuff */\n\n    return xen_config_dev_all(fe, be);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 247, "prediction": "0", "true_label": "0", "raw_text": "_LAST_IO) {\n\n        gen_io_end();\n\n    }\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    }\n\n    if (unlikely(cs->singlestep_enabled)) {\n\n        if (dc->is_jmp == DISAS_NEXT) {\n\n            tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n        }\n\n        gen_exception(dc, EXCP_DEBUG);\n\n    } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 0, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_JUMP:\n\n            break;\n\n        case DISAS_UPDATE:\n\n            /* indicate that the hash table must be used\n\n               to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n            /* nothing more to generate */\n\n            break;\n\n        }\n\n    }\n\n\n\n    gen_tb_end(tb, num_insns);\n\n    *tcg_ctx.gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf;\n\n        k++;\n\n        while (k <= j) {\n\n            tcg_ctx.gen_opc_instr_start[k++] = 0;\n\n        }\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -\n\n            tcg_ctx.gen_opc_buf);\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 248, "prediction": "0", "true_label": "1", "raw_text": " for 16 peers and grow as needed */\n\n        resize_peers(s, 16);\n\n        s->vm_id = -1;\n\n\n\n        pci_register_bar(dev, 2, attr, &s->bar);\n\n\n\n        qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive,\n\n                              ivshmem_check_version, NULL, s);\n\n    } else {\n\n        /* just map the file immediately, we're not using a server */\n\n        int fd;\n\n\n\n        IVSHMEM_DPRINTF(\"using shm_open (shm object = %s)\\n\", s->shmobj);\n\n\n\n        /* try opening with O_EXCL and if it succeeds zero the memory\n\n         * by truncating to 0 */\n\n        if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) > 0) {\n\n           /* truncate file to length PCI device's memory */\n\n            if (ftruncate(fd, s->ivshmem_size) != 0) {\n\n                error_report(\"could not truncate shared file\");\n\n            }\n\n\n\n        } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR,\n\n                        S_IRWXU|S_IRWXG|S_IRWXO)) < 0) {\n\n            error_setg(errp, \"could not open shared file\");\n\n            return;\n\n        }\n\n\n\n        if (check_shm_size(s, fd, errp) == -1) {\n\n            return;\n\n        }\n\n\n\n        create_shared_memory_BAR(s, fd, attr, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return;\n\n        }\n\n    }\n\n\n\n    fifo8_create(&s->incoming_fifo, sizeof(int64_t));\n\n\n\n    if (s->role_val == IVSHMEM_PEER) {\n\n        error_setg(&s->migration_blocker,\n\n                   \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\");\n\n        migrate_add_blocker(s->migration_blocker);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 249, "prediction": "0", "true_label": "1", "raw_text": "\n\n                    r2_name = find_reg_info(r2)->name;\n\n                    fprintf_fn(stream, \"%s\", r2_name);\n\n                    break;\n\n                }\n\n                case 'c': {\n\n                    uint8_t csr;\n\n                    const char *csr_name;\n\n                    csr = (op >> 21) & 0x1f;\n\n                    csr_name = find_csr_info(csr)->name;\n\n                    if (csr_name) {\n\n                        fprintf_fn(stream, \"%s\", csr_name);\n\n                    } else {\n\n                        fprintf_fn(stream, \"0x%x\", csr);\n\n                    }\n\n                    break;\n\n                }\n\n                case 'u': {\n\n                    uint16_t u16;\n\n                    u16 = op & 0xffff;\n\n                    fprintf_fn(stream, \"0x%x\", u16);\n\n                    break;\n\n                }\n\n                case 's': {\n\n                    int16_t s16;\n\n                    s16 = (int16_t)(op & 0xffff);\n\n                    fprintf_fn(stream, \"%d\", s16);\n\n                    break;\n\n                }\n\n                case 'r': {\n\n                    uint32_t rela;\n\n                    rela = memaddr + (((int16_t)(op & 0xffff)) << 2);\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'R': {\n\n                    uint32_t rela;\n\n                    int32_t imm26;\n\n                    imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4;\n\n                    rela = memaddr + imm26;\n\n                    fprintf_fn(stream, \"%x\", rela);\n\n                    break;\n\n                }\n\n                case 'h': {\n\n                    uint8_t u5;\n\n                    u5 = (op & 0x1f);\n\n                    fprintf_fn(stream, \"%d\", u5);\n\n                    break;\n\n                }\n\n                default:\n\n                    break;\n\n                }\n\n            } else {\n\n                fprintf_fn(stream, \"%c\", *args_fmt);\n\n            }\n\n            args_fmt++;\n\n        }\n\n    } else {\n\n        fprintf_fn(stream, \".word 0x%x\", op);\n\n    }\n\n\n\n    return 4;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 250, "prediction": "0", "true_label": "0", "raw_text": "Question: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,\n\n                   uint8_t *properties)\n\n{\n\n    int compno;\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    compno = bytestream_get_byte(&s->buf);\n\n\n\n    c      += compno;\n\n    c->csty = bytestream_get_byte(&s->buf);\n\n    get_cox(s, c);\n\n\n\n    properties[compno] |= HAD_COC;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 251, "prediction": "0", "true_label": "1", "raw_text": "Question: static void curses_setup(void)\n\n{\n\n    int i, colour_default[8] = {\n\n        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,\n\n        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,\n\n    };\n\n\n\n    /* input as raw as possible, let everything be interpreted\n\n     * by the guest system */\n\n    initscr(); noecho(); intrflush(stdscr, FALSE);\n\n    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);\n\n    start_color(); raw(); scrollok(stdscr, FALSE);\n\n\n\n    for (i = 0; i < 64; i ++)\n\n        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 252, "prediction": "0", "true_label": "1", "raw_text": "+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\n\n\t\t\"addl $2, %%eax\t\t\t\\n\\t\"\n\n\t\t\"cmpl %2, %%eax\t\t\t\\n\\t\"\n\n\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\n\n\t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF)\n\n\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\"\n\n\t\t);\n\n#ifdef HAVE_MMX2\n\n\t} //if MMX2 cant be used\n\n#endif\n\n#else\n\n\tint i;\n\n\tunsigned int xpos=0;\n\n\tfor(i=0;i<dstWidth;i++)\n\n\t{\n\n\t\tregister unsigned int xx=xpos>>16;\n\n\t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n\t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n\t\txpos+=xInc;\n\n\t}\n\n#endif\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 253, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 254, "prediction": "0", "true_label": "1", "raw_text": " fu_indicator\n\n        if (len > 1) {\n\n            // these are the same as above, we just redo them here for clarity\n\n            uint8_t fu_indicator      = nal;\n\n            uint8_t fu_header         = *buf;\n\n            uint8_t start_bit         = fu_header >> 7;\n\n            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;\n\n            uint8_t nal_type          = fu_header & 0x1f;\n\n            uint8_t reconstructed_nal;\n\n\n\n            // Reconstruct this packet's true nal; only the data follows.\n\n            /* The original nal forbidden bit and NRI are stored in this\n\n             * packet's nal. */\n\n            reconstructed_nal  = fu_indicator & 0xe0;\n\n            reconstructed_nal |= nal_type;\n\n\n\n            // skip the fu_header\n\n            buf++;\n\n            len--;\n\n\n\n            if (start_bit)\n\n                COUNT_NAL_TYPE(data, nal_type);\n\n            if (start_bit) {\n\n                /* copy in the start sequence, and the reconstructed nal */\n\n                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);\n\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n                pkt->data[sizeof(start_sequence)] = reconstructed_nal;\n\n                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);\n\n            } else {\n\n                av_new_packet(pkt, len);\n\n                memcpy(pkt->data, buf, len);\n\n            }\n\n        } else {\n\n            av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H264 RTP packet\\n\");\n\n            result = AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n\n\n    case 30:                   // undefined\n\n    case 31:                   // undefined\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n\n        result = AVERROR_INVALIDDATA;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 255, "prediction": "0", "true_label": "0", "raw_text": "_from_str(drv->format_name)));\n\n            QINCREF(bs->file->bs->full_open_options);\n\n            qdict_put_obj(opts, \"file\",\n\n                          QOBJECT(bs->file->bs->full_open_options));\n\n\n\n            bs->full_open_options = opts;\n\n        } else {\n\n            QDECREF(opts);\n\n        }\n\n    } else if (!bs->full_open_options && qdict_size(bs->options)) {\n\n        /* There is no underlying file BDS (at least referenced by BDS.file),\n\n         * so the full options QDict should be equal to the options given\n\n         * specifically for this block device when it was opened (plus the\n\n         * driver specification).\n\n         * Because those options don't change, there is no need to update\n\n         * full_open_options when it's already set. */\n\n\n\n        opts = qdict_new();\n\n        append_open_options(opts, bs);\n\n        qdict_put_obj(opts, \"driver\",\n\n                      QOBJECT(qstring_from_str(drv->format_name)));\n\n\n\n        if (bs->exact_filename[0]) {\n\n            /* This may not work for all block protocol drivers (some may\n\n             * require this filename to be parsed), but we have to find some\n\n             * default solution here, so just include it. If some block driver\n\n             * does not support pure options without any filename at all or\n\n             * needs some special format of the options QDict, it needs to\n\n             * implement the driver-specific bdrv_refresh_filename() function.\n\n             */\n\n            qdict_put_obj(opts, \"filename\",\n\n                          QOBJECT(qstring_from_str(bs->exact_filename)));\n\n        }\n\n\n\n        bs->full_open_options = opts;\n\n    }\n\n\n\n    if (bs->exact_filename[0]) {\n\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n\n    } else if (bs->full_open_options) {\n\n        QString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n\n        snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n\n                 qstring_get_str(json));\n\n        QDECREF(json);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 256, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline bool cpu_handle_exception(CPUState *cpu, int *ret)\n\n{\n\n    if (cpu->exception_index >= 0) {\n\n        if (cpu->exception_index >= EXCP_INTERRUPT) {\n\n            /* exit request from the cpu execution loop */\n\n            *ret = cpu->exception_index;\n\n            if (*ret == EXCP_DEBUG) {\n\n                cpu_handle_debug_exception(cpu);\n\n            }\n\n            cpu->exception_index = -1;\n\n            return true;\n\n        } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n            /* if user mode only, we simulate a fake exception\n\n               which will be handled outside the cpu execution\n\n               loop */\n\n#if defined(TARGET_I386)\n\n            CPUClass *cc = CPU_GET_CLASS(cpu);\n\n            cc->do_interrupt(cpu);\n\n#endif\n\n            *ret = cpu->exception_index;\n\n            cpu->exception_index = -1;\n\n            return true;\n\n#else\n\n            if (replay_exception()) {\n\n                CPUClass *cc = CPU_GET_CLASS(cpu);\n\n                qemu_mutex_lock_iothread();\n\n                cc->do_interrupt(cpu);\n\n                qemu_mutex_unlock_iothread();\n\n                cpu->exception_index = -1;\n\n            } else if (!replay_has_interrupt()) {\n\n                /* give a chance to iothread in replay mode */\n\n                *ret = EXCP_INTERRUPT;\n\n                return true;\n\n            }\n\n#endif\n\n        }\n\n#ifndef CONFIG_USER_ONLY\n\n    } else if (replay_has_exception()\n\n               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {\n\n        /* try to cause an exception pending in the log */\n\n        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);\n\n        *ret = -1;\n\n        return true;\n\n#endif\n\n    }\n\n\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 257, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)\n\n{\n\n#if HAVE_INLINE_ASM\n\n    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {\n\n        if (ctx->cid_table->bit_depth == 8)\n\n            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;\n\n    }\n\n#endif /* HAVE_INLINE_ASM */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 258, "prediction": "0", "true_label": "0", "raw_text": "Question: uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 259, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_io_channel_ipv4(bool async)\n\n{\n\n    SocketAddress *listen_addr = g_new0(SocketAddress, 1);\n\n    SocketAddress *connect_addr = g_new0(SocketAddress, 1);\n\n\n\n    listen_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    listen_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    listen_addr->u.inet->host = g_strdup(\"0.0.0.0\");\n\n    listen_addr->u.inet->port = NULL; /* Auto-select */\n\n\n\n    connect_addr->type = SOCKET_ADDRESS_KIND_INET;\n\n    connect_addr->u.inet = g_new0(InetSocketAddress, 1);\n\n    connect_addr->u.inet->host = g_strdup(\"127.0.0.1\");\n\n    connect_addr->u.inet->port = NULL; /* Filled in later */\n\n\n\n    test_io_channel(async, listen_addr, connect_addr);\n\n\n\n    qapi_free_SocketAddress(listen_addr);\n\n    qapi_free_SocketAddress(connect_addr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 260, "prediction": "0", "true_label": "0", "raw_text": "(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_and_i64(t1, t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_SUB_CP2 ? \"sub\" : \"dsub\");\n\n            break;\n\n        }\n\n\n\n    case OPC_PMULUW:\n\n        tcg_gen_ext32u_i64(t0, t0);\n\n        tcg_gen_ext32u_i64(t1, t1);\n\n        tcg_gen_mul_i64(t0, t0, t1);\n\n        opn = \"pmuluw\";\n\n        break;\n\n\n\n    case OPC_SEQU_CP2:\n\n    case OPC_SEQ_CP2:\n\n    case OPC_SLTU_CP2:\n\n    case OPC_SLT_CP2:\n\n    case OPC_SLEU_CP2:\n\n    case OPC_SLE_CP2:\n\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n\n           FD field is the CC field?  */\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n#undef LMI_HELPER\n\n#undef LMI_DIRECT\n\n\n\n    gen_store_fpr64(ctx, t0, rd);\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn,\n\n               fregnames[rd], fregnames[rs], fregnames[rt]);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 261, "prediction": "0", "true_label": "0", "raw_text": "Question: static void v9fs_stat(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsStat v9stat;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n\n    err = offset;\n\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n\n    v9fs_stat_free(&v9stat);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 262, "prediction": "0", "true_label": "1", "raw_text": "Question: uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 263, "prediction": "0", "true_label": "1", "raw_text": "group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 264, "prediction": "0", "true_label": "1", "raw_text": "CodecContext* ctx = avcodec_alloc_context3(NULL);\n\n    if (!ctx)\n\n        error(\"Failed memory allocation\");\n\n\n\n    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs\n\n\n\n    int res = avcodec_open2(ctx, c, NULL);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    FDBCreate(&buffer);\n\n    int got_frame;\n\n    AVFrame *frame = av_frame_alloc();\n\n    if (!frame)\n\n        error(\"Failed memory allocation\");\n\n\n\n    // Read very simple container\n\n    AVPacket avpkt;\n\n    while (data < end && it < maxiteration) {\n\n        // Search for the TAG\n\n        while (data + sizeof(fuzz_tag) < end) {\n\n            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)\n\n                break;\n\n            data++;\n\n        }\n\n        if (data + sizeof(fuzz_tag) > end)\n\n            data = end;\n\n\n\n        FDBPrepare(&buffer, &avpkt, last, data - last);\n\n        data += sizeof(fuzz_tag);\n\n        last = data;\n\n\n\n        // Iterate through all data\n\n        while (avpkt.size > 0 && it++ < maxiteration) {\n\n            av_frame_unref(frame);\n\n            int ret = decode_handler(ctx, frame, &got_frame, &avpkt);\n\n\n\n            if (it > 20)\n\n                ctx->error_concealment = 0;\n\n\n\n            if (ret <= 0 || ret > avpkt.size)\n\n               break;\n\n\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n    }\n\n\n\n    av_init_packet(&avpkt);\n\n    avpkt.data = NULL;\n\n    avpkt.size = 0;\n\n\n\n    do {\n\n        got_frame = 0;\n\n        decode_handler(ctx, frame, &got_frame, &avpkt);\n\n    } while (got_frame == 1 && it++ < maxiteration);\n\n\n\n    av_frame_free(&frame);\n\n    avcodec_free_context(&ctx);\n\n    av_freep(&ctx);\n\n    FDBDesroy(&buffer);\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 265, "prediction": "0", "true_label": "0", "raw_text": "Question: void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 266, "prediction": "0", "true_label": "0", "raw_text": "Question: void disas_a64_insn(CPUARMState *env, DisasContext *s)\n\n{\n\n    uint32_t insn;\n\n\n\n    insn = arm_ldl_code(env, s->pc, s->bswap_code);\n\n    s->insn = insn;\n\n    s->pc += 4;\n\n\n\n    switch ((insn >> 24) & 0x1f) {\n\n    default:\n\n        unallocated_encoding(s);\n\n        break;\n\n    }\n\n\n\n    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {\n\n        /* go through the main loop for single step */\n\n        s->is_jmp = DISAS_JUMP;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 267, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {\n\n            goto std_case;\n\n        } else {\n\n            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);\n\n            tcg_gen_ext8u_tl(t0, t0);\n\n        }\n\n        break;\n\n    default:\n\n    std_case:\n\n        tcg_gen_mov_tl(t0, cpu_regs[reg]);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 268, "prediction": "0", "true_label": "0", "raw_text": "Question: static int hdev_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    int access_flags, create_flags;\n\n    DWORD overlapped;\n\n    char device_name[64];\n\n\n\n    if (strstart(filename, \"/dev/cdrom\", NULL)) {\n\n        if (find_cdrom(device_name, sizeof(device_name)) < 0)\n\n            return -ENOENT;\n\n        filename = device_name;\n\n    } else {\n\n        /* transform drive letters into device name */\n\n        if (((filename[0] >= 'a' && filename[0] <= 'z') ||\n\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n\n            filename[1] == ':' && filename[2] == '\\0') {\n\n            snprintf(device_name, sizeof(device_name), \"\\\\\\\\.\\\\%c:\", filename[0]);\n\n            filename = device_name;\n\n        }\n\n    }\n\n    s->type = find_device_type(bs, filename);\n\n    \n\n    if ((flags & BDRV_O_ACCESS) == O_RDWR) {\n\n        access_flags = GENERIC_READ | GENERIC_WRITE;\n\n    } else {\n\n        access_flags = GENERIC_READ;\n\n    }\n\n    create_flags = OPEN_EXISTING;\n\n\n\n#ifdef QEMU_TOOL\n\n    overlapped = FILE_ATTRIBUTE_NORMAL;\n\n#else\n\n    overlapped = FILE_FLAG_OVERLAPPED;\n\n#endif\n\n    s->hfile = CreateFile(filename, access_flags, \n\n                          FILE_SHARE_READ, NULL,\n\n                          create_flags, overlapped, NULL);\n\n    if (s->hfile == INVALID_HANDLE_VALUE) \n\n        return -1;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 269, "prediction": "1", "true_label": "0", "raw_text": "Question: static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    SigpInfo *si = arg.host_ptr;\n\n\n\n    if (!s390_has_feat(S390_FEAT_VECTOR)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);\n\n        return;\n\n    }\n\n\n\n    /* cpu has to be stopped */\n\n    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {\n\n        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);\n\n        return;\n\n    }\n\n\n\n    /* parameter must be aligned to 1024-byte boundary */\n\n    if (si->param & 0x3ff) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n\n\n    cpu_synchronize_state(cs);\n\n\n\n    if (kvm_s390_store_adtl_status(cpu, si->param)) {\n\n        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);\n\n        return;\n\n    }\n\n    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 270, "prediction": "0", "true_label": "0", "raw_text": "_buf, int n)\n\n{\n\n    target_ulong tmp;\n\n\n\n    tmp = ldtul_p(mem_buf);\n\n\n\n    if (n < 32) {\n\n        env->active_tc.gpr[n] = tmp;\n\n        return sizeof(target_ulong);\n\n    }\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)\n\n            && n >= 38 && n < 73) {\n\n        if (n < 70) {\n\n            if (env->CP0_Status & (1 << CP0St_FR))\n\n              env->active_fpu.fpr[n - 38].d = tmp;\n\n            else\n\n              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;\n\n        }\n\n        switch (n) {\n\n        case 70:\n\n            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;\n\n            /* set rounding mode */\n\n            RESTORE_ROUNDING_MODE;\n\n#ifndef CONFIG_SOFTFLOAT\n\n            /* no floating point exception for native float */\n\n            SET_FP_ENABLE(env->active_fpu.fcr31, 0);\n\n#endif\n\n            break;\n\n        case 71: env->active_fpu.fcr0 = tmp; break;\n\n        }\n\n        return sizeof(target_ulong);\n\n    }\n\n    switch (n) {\n\n    case 32: env->CP0_Status = tmp; break;\n\n    case 33: env->active_tc.LO[0] = tmp; break;\n\n    case 34: env->active_tc.HI[0] = tmp; break;\n\n    case 35: env->CP0_BadVAddr = tmp; break;\n\n    case 36: env->CP0_Cause = tmp; break;\n\n    case 37: env->active_tc.PC = tmp; break;\n\n    case 72: /* fp, ignored */ break;\n\n    default: \n\n\tif (n > 89)\n\n\t    return 0;\n\n\t/* Other registers are readonly.  Ignore writes.  */\n\n\tbreak;\n\n    }\n\n\n\n    return sizeof(target_ulong);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 271, "prediction": "0", "true_label": "0", "raw_text": "Question: QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)\n\n{\n\n    QEMUBH *bh;\n\n    bh = g_malloc0(sizeof(QEMUBH));\n\n    bh->ctx = ctx;\n\n    bh->cb = cb;\n\n    bh->opaque = opaque;\n\n    qemu_mutex_lock(&ctx->bh_lock);\n\n    bh->next = ctx->first_bh;\n\n    /* Make sure that the members are ready before putting bh into list */\n\n    smp_wmb();\n\n    ctx->first_bh = bh;\n\n    qemu_mutex_unlock(&ctx->bh_lock);\n\n    return bh;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 272, "prediction": "0", "true_label": "0", "raw_text": "(rnd) * 0.30;\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 0.5 second of high amplitude white noise */\n\n    for (i = 0; i < sample_rate / 2 && k < nb_samples; i++, k++) {\n\n        v = dbl_rand(rnd);\n\n        for (ch = 0; ch < channels; ch++)\n\n            PUT_SAMPLE\n\n    }\n\n\n\n    /* 1 second of unrelated ramps for each channel */\n\n    for (ch = 0; ch < channels; ch++) {\n\n        taba[ch]  = 0;\n\n        tabf1[ch] = 100 + uint_rand(rnd) % 5000;\n\n        tabf2[ch] = 100 + uint_rand(rnd) % 5000;\n\n    }\n\n    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            v = sin(taba[ch]) * 0.30;\n\n            PUT_SAMPLE\n\n            f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / sample_rate);\n\n            taba[ch] += M_PI * f * 2.0 / sample_rate;\n\n        }\n\n    }\n\n\n\n    /* 2 seconds of 500 Hz with varying volume */\n\n    a    = 0;\n\n    ampa = 0;\n\n    for (i = 0; i < 2 * sample_rate && k < nb_samples; i++, k++) {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            double amp = (1.0 + sin(ampa)) * 0.15;\n\n            if (ch & 1)\n\n                amp = 0.30 - amp;\n\n            v = sin(a) * amp;\n\n            PUT_SAMPLE\n\n            a    += M_PI * 500.0 * 2.0 / sample_rate;\n\n            ampa += M_PI *  2.0 / sample_rate;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 273, "prediction": "-1", "true_label": "1", "raw_text": "Size = sizeof(ci);\n\n\n\n    if (GetCursorInfo(&ci)) {\n\n        HCURSOR icon = CopyCursor(ci.hCursor);\n\n        ICONINFO info;\n\n        POINT pos;\n\n        RECT clip_rect = gdigrab->clip_rect;\n\n        HWND hwnd = gdigrab->hwnd;\n\n        info.hbmMask = NULL;\n\n        info.hbmColor = NULL;\n\n\n\n        if (ci.flags != CURSOR_SHOWING)\n\n            return;\n\n\n\n        if (!icon) {\n\n            /* Use the standard arrow cursor as a fallback.\n\n             * You'll probably only hit this in Wine, which can't fetch\n\n             * the current system cursor. */\n\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n\n        }\n\n\n\n        if (!GetIconInfo(icon, &info)) {\n\n            CURSOR_ERROR(\"Could not get icon info\");\n\n            goto icon_error;\n\n        }\n\n\n\n        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;\n\n        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;\n\n\n\n        if (hwnd) {\n\n            RECT rect;\n\n\n\n            if (GetWindowRect(hwnd, &rect)) {\n\n                pos.x -= rect.left;\n\n                pos.y -= rect.top;\n\n            } else {\n\n                CURSOR_ERROR(\"Couldn't get window rectangle\");\n\n                goto icon_error;\n\n            }\n\n        }\n\n\n\n        av_log(s1, AV_LOG_DEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\",\n\n                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);\n\n\n\n        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&\n\n                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {\n\n            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))\n\n                CURSOR_ERROR(\"Couldn't draw icon\");\n\n        }\n\n\n\nicon_error:\n\n\n\n\n\n        if (icon)\n\n            DestroyCursor(icon);\n\n    } else {\n\n        CURSOR_ERROR(\"Couldn't get cursor info\");\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 274, "prediction": "-1", "true_label": "1", "raw_text": " NULL, NULL, NULL);\n\n    object_property_set_description(obj, \"phandle-start\",\n\n                                    \"The first phandle ID we may generate dynamically\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"dt-compatible\",\n\n                            machine_get_dt_compatible,\n\n                            machine_set_dt_compatible,\n\n                            NULL);\n\n    object_property_set_description(obj, \"dt-compatible\",\n\n                                    \"Overrides the \\\"compatible\\\" property of the dt root node\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"dump-guest-core\",\n\n                             machine_get_dump_guest_core,\n\n                             machine_set_dump_guest_core,\n\n                             NULL);\n\n    object_property_set_description(obj, \"dump-guest-core\",\n\n                                    \"Include guest memory in  a core dump\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"mem-merge\",\n\n                             machine_get_mem_merge,\n\n                             machine_set_mem_merge, NULL);\n\n    object_property_set_description(obj, \"mem-merge\",\n\n                                    \"Enable/disable memory merge support\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"usb\",\n\n                             machine_get_usb,\n\n                             machine_set_usb, NULL);\n\n    object_property_set_description(obj, \"usb\",\n\n                                    \"Set on/off to enable/disable usb\",\n\n                                    NULL);\n\n    object_property_add_str(obj, \"firmware\",\n\n                            machine_get_firmware,\n\n                            machine_set_firmware, NULL);\n\n    object_property_set_description(obj, \"firmware\",\n\n                                    \"Firmware image\",\n\n                                    NULL);\n\n    object_property_add_bool(obj, \"iommu\",\n\n                             machine_get_iommu,\n\n                             machine_set_iommu, NULL);\n\n    object_property_set_description(obj, \"iommu\",\n\n                                    \"Set on/off to enable/disable Intel IOMMU (VT-d)\",\n\n                                    NULL);\n\n\n\n    /* Register notifier when init is done for sysbus sanity checks */\n\n    ms->sysbus_notifier.notify = machine_init_notify;\n\n    qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 275, "prediction": "0", "true_label": "1", "raw_text": "Question: void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->peer);\n\n\n\n    /* remove from list, if necessary */\n\n    if (bs->device_name[0] != '\\0') {\n\n        QTAILQ_REMOVE(&bdrv_states, bs, list);\n\n    }\n\n\n\n    bdrv_close(bs);\n\n    if (bs->file != NULL) {\n\n        bdrv_delete(bs->file);\n\n    }\n\n\n\n    assert(bs != bs_snapshots);\n\n    qemu_free(bs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 276, "prediction": "0", "true_label": "1", "raw_text": "Question: static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 277, "prediction": "0", "true_label": "0", "raw_text": "Question: int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 278, "prediction": "0", "true_label": "1", "raw_text": "\n\n\n\n    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    if (!iscsilun->lbp.lbpu) {\n\n        /* UNMAP is not supported by the target */\n\n        return 0;\n\n    }\n\n\n\n    list.lba = offset / iscsilun->block_size;\n\n    list.num = bytes / iscsilun->block_size;\n\n\n\n    iscsi_co_init_iscsitask(iscsilun, &iTask);\n\n    qemu_mutex_lock(&iscsilun->mutex);\n\nretry:\n\n    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,\n\n                         iscsi_co_generic_cb, &iTask) == NULL) {\n\n        r = -ENOMEM;\n\n        goto out_unlock;\n\n    }\n\n\n\n    while (!iTask.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_mutex_unlock(&iscsilun->mutex);\n\n        qemu_coroutine_yield();\n\n        qemu_mutex_lock(&iscsilun->mutex);\n\n    }\n\n\n\n    if (iTask.task != NULL) {\n\n        scsi_free_scsi_task(iTask.task);\n\n        iTask.task = NULL;\n\n    }\n\n\n\n    if (iTask.do_retry) {\n\n        iTask.complete = 0;\n\n        goto retry;\n\n    }\n\n\n\n    if (iTask.status == SCSI_STATUS_CHECK_CONDITION) {\n\n        /* the target might fail with a check condition if it\n\n           is not happy with the alignment of the UNMAP request\n\n           we silently fail in this case */\n\n        goto out_unlock;\n\n    }\n\n\n\n    if (iTask.status != SCSI_STATUS_GOOD) {\n\n        r = iTask.err_code;\n\n        goto out_unlock;\n\n    }\n\n\n\n    iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS,\n\n                               bytes >> BDRV_SECTOR_BITS);\n\n\n\nout_unlock:\n\n    qemu_mutex_unlock(&iscsilun->mutex);\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 279, "prediction": "0", "true_label": "1", "raw_text": "Question: int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,\n\n                              int mmu_idx)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    hwaddr physical;\n\n    int prot;\n\n    int access_type;\n\n#endif\n\n    int ret = 0;\n\n\n\n#if 0\n\n    log_cpu_state(cs, 0);\n\n#endif\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n              \"%s pc \" TARGET_FMT_lx \" ad %\" VADDR_PRIx \" rw %d mmu_idx %d\\n\",\n\n              __func__, env->active_tc.PC, address, rw, mmu_idx);\n\n\n\n    /* data access */\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* XXX: put correct access by using cpu_restore_state()\n\n       correctly */\n\n    access_type = ACCESS_INT;\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    qemu_log_mask(CPU_LOG_MMU,\n\n             \"%s address=%\" VADDR_PRIx \" ret %d physical \" TARGET_FMT_plx\n\n             \" prot %d\\n\",\n\n             __func__, address, ret, physical, prot);\n\n    if (ret == TLBRET_MATCH) {\n\n        tlb_set_page(cs, address & TARGET_PAGE_MASK,\n\n                     physical & TARGET_PAGE_MASK, prot | PAGE_EXEC,\n\n                     mmu_idx, TARGET_PAGE_SIZE);\n\n        ret = 0;\n\n    } else if (ret < 0)\n\n#endif\n\n    {\n\n        raise_mmu_exception(env, address, rw, ret);\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 280, "prediction": "0", "true_label": "0", "raw_text": "Question: static ModuleTypeList *find_type(module_init_type type)\n\n{\n\n    ModuleTypeList *l;\n\n\n\n    init_types();\n\n\n\n    l = &init_type_list[type];\n\n\n\n    return l;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 281, "prediction": "0", "true_label": "0", "raw_text": "Question: static int qemu_suspend_requested(void)\n\n{\n\n    int r = suspend_requested;\n\n    suspend_requested = 0;\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 282, "prediction": "0", "true_label": "0", "raw_text": " { \"ssse3\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = \"flags\" },\n\n        { \"atom\"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = \"flags\" },\n\n        { \"sse4.1\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = \"flags\" },\n\n        { \"sse4.2\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = \"flags\" },\n\n        { \"avx\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = \"flags\" },\n\n        { \"xop\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = \"flags\" },\n\n        { \"fma4\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = \"flags\" },\n\n        { \"3dnow\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = \"flags\" },\n\n        { \"3dnowext\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = \"flags\" },\n\n        { NULL },\n\n    };\n\n    static const AVClass class = {\n\n        .class_name = \"cpuflags\",\n\n        .item_name  = av_default_item_name,\n\n        .option     = cpuflags_opts,\n\n        .version    = LIBAVUTIL_VERSION_INT,\n\n    };\n\n    int flags = av_get_cpu_flags();\n\n    int ret;\n\n    const AVClass *pclass = &class;\n\n\n\n    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)\n\n        return ret;\n\n\n\n    av_force_cpu_flags(flags);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 283, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 284, "prediction": "0", "true_label": "1", "raw_text": "Question: static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 285, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 286, "prediction": "0", "true_label": "1", "raw_text": "env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Thermal management */\n\n    gen_spr_thrm(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750_THRM4, \"THRM4\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    gen_low_BATs(env);\n\n    /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */\n\n    gen_high_BATs(env);\n\n    init_excp_7x0(env);\n\n    env->dcache_line_size = 32;\n\n    env->icache_line_size = 32;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc6xx_irq_init(env);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 287, "prediction": "0", "true_label": "1", "raw_text": "Question: void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))\n\n{\n\n    stream_printf(stream, \"Trace file \\\"%s\\\" %s.\\n\",\n\n                  trace_file_name, trace_file_enabled ? \"on\" : \"off\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 288, "prediction": "0", "true_label": "0", "raw_text": "\n\n\n\n    if (mkv->mode != MODE_WEBM) {\n\n        ret = mkv_write_attachments(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    ret = mkv_write_tags(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        mkv_write_seekhead(pb, mkv);\n\n\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n\n    if (!mkv->cues) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {\n\n        mkv->cues_pos = avio_tell(pb);\n\n        put_ebml_void(pb, mkv->reserve_cues_space);\n\n    }\n\n\n\n    av_init_packet(&mkv->cur_audio_pkt);\n\n    mkv->cur_audio_pkt.size = 0;\n\n    mkv->cluster_pos = -1;\n\n\n\n    avio_flush(pb);\n\n\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n\n    // after 4k and on a keyframe\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 5000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n\n    } else {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 1000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 32 * 1024;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    mkv_free(mkv);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 289, "prediction": "0", "true_label": "1", "raw_text": "Question: e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 290, "prediction": "0", "true_label": "0", "raw_text": "3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 291, "prediction": "0", "true_label": "1", "raw_text": "Question: static unsigned tget(const uint8_t **p, int type, int le)\n\n{\n\n    switch (type) {\n\n    case TIFF_BYTE:\n\n        return *(*p)++;\n\n    case TIFF_SHORT:\n\n        return tget_short(p, le);\n\n    case TIFF_LONG:\n\n        return tget_long(p, le);\n\n    default:\n\n        return UINT_MAX;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 292, "prediction": "0", "true_label": "1", "raw_text": "Question: static int decode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    int i, quant, level, orientation, quant_idx;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    DiracContext *s = avctx->priv_data;\n\n    DiracSlice *slice = arg;\n\n    GetBitContext *gb = &slice->gb;\n\n\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n\n    quant_idx = get_bits(gb, 8);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++) {\n\n        for (orientation = !!level; orientation < 4; orientation++) {\n\n            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n\n            quants[level][orientation] = quant;\n\n        }\n\n    }\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (i = 0; i < 3; i++) {\n\n        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);\n\n        int64_t bits_left = 8 * length;\n\n        int64_t bits_end = get_bits_count(gb) + bits_left;\n\n\n\n        if (bits_end >= INT_MAX) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,\n\n                               &s->plane[i].band[level][orientation], NULL);\n\n            }\n\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 293, "prediction": "-1", "true_label": "1", "raw_text": "Question: static av_cold int amr_wb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRWBContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 16000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 16000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->last_bitrate    = avctx->bit_rate;\n\n\n\n    avctx->frame_size  = 320;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->state     = E_IF_init();\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 294, "prediction": "0", "true_label": "1", "raw_text": "Question: uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 295, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)\n\n{\n\n    int i;\n\n\n\n    s->dts    =\n\n    s->pts    = AV_NOPTS_VALUE;\n\n    s->pos    = -1;\n\n    s->offset = 0;\n\n    for (i = 0; i < AV_PARSER_PTS_NB; i++) {\n\n        if (s->cur_offset + off >= s->cur_frame_offset[i] &&\n\n            (s->frame_offset < s->cur_frame_offset[i] ||\n\n             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame\n\n            // check disabled since MPEG-TS does not send complete PES packets\n\n            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){\n\n\n\n            s->dts    = s->cur_frame_dts[i];\n\n            s->pts    = s->cur_frame_pts[i];\n\n            s->pos    = s->cur_frame_pos[i];\n\n            s->offset = s->next_frame_offset - s->cur_frame_offset[i];\n\n            if (remove)\n\n                s->cur_frame_offset[i] = INT64_MAX;\n\n            if (s->cur_offset + off < s->cur_frame_end[i])\n\n                break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 296, "prediction": "0", "true_label": "1", "raw_text": " {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 297, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)\n\n{\n\n    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {\n\n        if (sregnames[sr].name) {\n\n            qemu_log(\"SR %s is not configured\\n\", sregnames[sr].name);\n\n        } else {\n\n            qemu_log(\"SR %d is not implemented\\n\", sr);\n\n        }\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    } else if (!(sregnames[sr].access & access)) {\n\n        static const char * const access_text[] = {\n\n            [SR_R] = \"rsr\",\n\n            [SR_W] = \"wsr\",\n\n            [SR_X] = \"xsr\",\n\n        };\n\n        assert(access < ARRAY_SIZE(access_text) && access_text[access]);\n\n        qemu_log(\"SR %s is not available for %s\\n\", sregnames[sr].name,\n\n                access_text[access]);\n\n        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 298, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_lswi(DisasContext *ctx)\n\n{\n\n    TCGv t0;\n\n    TCGv_i32 t1, t2;\n\n    int nb = NB(ctx->opcode);\n\n    int start = rD(ctx->opcode);\n\n    int ra = rA(ctx->opcode);\n\n    int nr;\n\n\n\n    if (nb == 0)\n\n        nb = 32;\n\n    nr = (nb + 3) / 4;\n\n    if (unlikely(lsw_reg_in_range(start, nr, ra))) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n        return;\n\n    }\n\n    gen_set_access_type(ctx, ACCESS_INT);\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    t0 = tcg_temp_new();\n\n    gen_addr_register(ctx, t0);\n\n    t1 = tcg_const_i32(nb);\n\n    t2 = tcg_const_i32(start);\n\n    gen_helper_lsw(cpu_env, t0, t1, t2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free_i32(t1);\n\n    tcg_temp_free_i32(t2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 299, "prediction": "0", "true_label": "0", "raw_text": "(q, &q->gb, &q->units[1],\n\n                                        out_samples[1], 1, JOINT_STEREO);\n\n        if (ret != 0)\n\n            return ret;\n\n\n\n        /* Reconstruct the channel coefficients. */\n\n        reverse_matrixing(out_samples[0], out_samples[1],\n\n                          q->matrix_coeff_index_prev,\n\n                          q->matrix_coeff_index_now);\n\n\n\n        channel_weighting(out_samples[0], out_samples[1], q->weighting_delay);\n\n    } else {\n\n        /* single channels */\n\n        /* Decode the channel sound units. */\n\n        for (i = 0; i < avctx->channels; i++) {\n\n            /* Set the bitstream reader at the start of a channel sound unit. */\n\n            init_get_bits(&q->gb,\n\n                          databuf + i * avctx->block_align / avctx->channels,\n\n                          avctx->block_align * 8 / avctx->channels);\n\n\n\n            ret = decode_channel_sound_unit(q, &q->gb, &q->units[i],\n\n                                            out_samples[i], i, q->coding_mode);\n\n            if (ret != 0)\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    /* Apply the iQMF synthesis filter. */\n\n    for (i = 0; i < avctx->channels; i++) {\n\n        float *p1 = out_samples[i];\n\n        float *p2 = p1 + 256;\n\n        float *p3 = p2 + 256;\n\n        float *p4 = p3 + 256;\n\n        ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf);\n\n        ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf);\n\n        ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 300, "prediction": "0", "true_label": "1", "raw_text": "Question: uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 301, "prediction": "0", "true_label": "1", "raw_text": "Question: static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tstrcpy(term_cmd_buf, term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_printf(\"\\n\");\n\n    term_print_cmdline(term_cmd_buf);\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 302, "prediction": "0", "true_label": "0", "raw_text": "Question: static int decode_cabac_mb_cbp_luma( H264Context *h) {\n\n    int cbp_b, cbp_a, ctx, cbp = 0;\n\n\n\n    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;\n\n    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;\n\n\n\n    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);\n\n    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;\n\n    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;\n\n    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);\n\n    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;\n\n    return cbp;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 303, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    QSVFrame *cur;\n\n    AVPacket pkt;\n\n    int ret = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n\n\n    if (q->reinit_pending) {\n\n        close_decoder(q);\n\n    } else if (q->engine_ready) {\n\n        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode get param error %d\\n\", ret);\n\n        }\n\n\n\n        ret = MFXVideoDECODE_Reset(q->session, &param);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MFX decode reset error %d\\n\", ret);\n\n        }\n\n\n\n        /* Free all frames*/\n\n        cur = q->work_frames;\n\n        while (cur) {\n\n            q->work_frames = cur->next;\n\n            av_frame_free(&cur->frame);\n\n            av_freep(&cur);\n\n            cur = q->work_frames;\n\n        }\n\n    }\n\n\n\n    /* Reset output surfaces */\n\n    av_fifo_reset(q->async_fifo);\n\n\n\n    /* Reset input packets fifo */\n\n    while (av_fifo_size(q->pkt_fifo)) {\n\n        av_fifo_generic_read(q->pkt_fifo, &pkt, sizeof(pkt), NULL);\n\n        av_packet_unref(&pkt);\n\n    }\n\n\n\n    /* Reset input bitstream fifo */\n\n    av_fifo_reset(q->input_fifo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 304, "prediction": "0", "true_label": "1", "raw_text": "Question: target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 305, "prediction": "0", "true_label": "1", "raw_text": "->usbsts & USBSTS_HCH)) {\n\n        DPRINTF(\"xhci: reset while running!\\n\");\n\n    }\n\n\n\n    xhci->usbcmd = 0;\n\n    xhci->usbsts = USBSTS_HCH;\n\n    xhci->dnctrl = 0;\n\n    xhci->crcr_low = 0;\n\n    xhci->crcr_high = 0;\n\n    xhci->dcbaap_low = 0;\n\n    xhci->dcbaap_high = 0;\n\n    xhci->config = 0;\n\n\n\n    for (i = 0; i < xhci->numslots; i++) {\n\n        xhci_disable_slot(xhci, i+1);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numports; i++) {\n\n        xhci_port_update(xhci->ports + i, 0);\n\n    }\n\n\n\n    for (i = 0; i < xhci->numintrs; i++) {\n\n        xhci->intr[i].iman = 0;\n\n        xhci->intr[i].imod = 0;\n\n        xhci->intr[i].erstsz = 0;\n\n        xhci->intr[i].erstba_low = 0;\n\n        xhci->intr[i].erstba_high = 0;\n\n        xhci->intr[i].erdp_low = 0;\n\n        xhci->intr[i].erdp_high = 0;\n\n        xhci->intr[i].msix_used = 0;\n\n\n\n        xhci->intr[i].er_ep_idx = 0;\n\n        xhci->intr[i].er_pcs = 1;\n\n        xhci->intr[i].er_full = 0;\n\n        xhci->intr[i].ev_buffer_put = 0;\n\n        xhci->intr[i].ev_buffer_get = 0;\n\n    }\n\n\n\n    xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n\n    xhci_mfwrap_update(xhci);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 306, "prediction": "0", "true_label": "1", "raw_text": "Question: int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)\n\n{\n\n    int i, ret;\n\n\n\n    ret = -1;\n\n    *def = NULL;\n\n    for (i = 0; ppc_defs[i].name != NULL; i++) {\n\n        if ((pvr & ppc_defs[i].pvr_mask) ==\n\n            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {\n\n            *def = &ppc_defs[i];\n\n            ret = 0;\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 307, "prediction": "0", "true_label": "0", "raw_text": "Question: void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 308, "prediction": "0", "true_label": "0", "raw_text": "Question: static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)\n\n{\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;\n\n    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;\n\n\n\n    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,\n\n     * replace the method name: _EJ0 by ACPI_EJ0_.\n\n     */\n\n    /* Sanity check */\n\n    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"_EJ0\", 4));\n\n\n\n    if (!eject) {\n\n        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, \"EJ0_\", 4);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 309, "prediction": "0", "true_label": "0", "raw_text": "Question: static float ssim_plane(uint8_t *main, int main_stride,\n\n                        uint8_t *ref, int ref_stride,\n\n                        int width, int height, void *temp)\n\n{\n\n    int z = 0;\n\n    int x, y;\n\n    float ssim = 0.0;\n\n    int (*sum0)[4] = temp;\n\n    int (*sum1)[4] = sum0 + (width >> 2) + 3;\n\n\n\n    width >>= 2;\n\n    height >>= 2;\n\n\n\n    for (y = 1; y < height; y++) {\n\n        for (; z <= y; z++) {\n\n            FFSWAP(void*, sum0, sum1);\n\n            for (x = 0; x < width; x+=2)\n\n                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,\n\n                                &ref[4 * (x + z * ref_stride)], ref_stride,\n\n                                &sum0[x]);\n\n        }\n\n\n\n        ssim += ssim_endn(sum0, sum1, width - 1);\n\n    }\n\n\n\n    return ssim / ((height - 1) * (width - 1));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 310, "prediction": "0", "true_label": "1", "raw_text": "Question: static void nvme_instance_init(Object *obj)\n\n{\n\n    object_property_add(obj, \"bootindex\", \"int32\",\n\n                        nvme_get_bootindex,\n\n                        nvme_set_bootindex, NULL, NULL, NULL);\n\n    object_property_set_int(obj, -1, \"bootindex\", NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 311, "prediction": "1", "true_label": "1", "raw_text": "Question: static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 312, "prediction": "0", "true_label": "1", "raw_text": "CG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 313, "prediction": "0", "true_label": "0", "raw_text": " - sub_packet_size;\n\n        }\n\n\n\n        packet_bytes -= sub_packet_size;\n\n\n\n        /* add subpacket to 'all subpackets' list */\n\n        q->sub_packet_list_A[i].packet = packet;\n\n\n\n        /* add subpacket to related list */\n\n        if (packet->type == 8) {\n\n            SAMPLES_NEEDED_2(\"packet type 8\");\n\n            return;\n\n        } else if (packet->type >= 9 && packet->type <= 12) {\n\n            /* packets for MPEG Audio like Synthesis Filter */\n\n            QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet);\n\n        } else if (packet->type == 13) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = get_bits(&gb, 6);\n\n        } else if (packet->type == 14) {\n\n            for (j = 0; j < 6; j++)\n\n                q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2);\n\n        } else if (packet->type == 15) {\n\n            SAMPLES_NEEDED_2(\"packet type 15\")\n\n            return;\n\n        } else if (packet->type >= 16 && packet->type < 48 &&\n\n                   !fft_subpackets[packet->type - 16]) {\n\n            /* packets for FFT */\n\n            QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet);\n\n        }\n\n    } // Packet bytes loop\n\n\n\n    if (q->sub_packet_list_D[0].packet != NULL) {\n\n        process_synthesis_subpackets(q, q->sub_packet_list_D);\n\n        q->do_synth_filter = 1;\n\n    } else if (q->do_synth_filter) {\n\n        process_subpacket_10(q, NULL);\n\n        process_subpacket_11(q, NULL);\n\n        process_subpacket_12(q, NULL);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 314, "prediction": "0", "true_label": "1", "raw_text": "Question: static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,\n\n                          const int16_t *filter, const int16_t *filterPos,\n\n                          int filterSize)\n\n{\n\n    int i;\n\n    for (i=0; i<dstW; i++) {\n\n        int j;\n\n        int srcPos= filterPos[i];\n\n        int val=0;\n\n        for (j=0; j<filterSize; j++) {\n\n            val += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n        }\n\n        //filter += hFilterSize;\n\n        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...\n\n        //dst[i] = val>>7;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 315, "prediction": "0", "true_label": "1", "raw_text": "Question: MigrationState *migrate_get_current(void)\n\n{\n\n    static MigrationState current_migration = {\n\n        .state = MIG_STATE_NONE,\n\n        .bandwidth_limit = MAX_THROTTLE,\n\n        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,\n\n        .mbps = -1,\n\n    };\n\n\n\n    return &current_migration;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 316, "prediction": "0", "true_label": "1", "raw_text": "Question: qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 317, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qcow2_change_backing_file(BlockDriverState *bs,\n\n    const char *backing_file, const char *backing_fmt)\n\n{\n\n    return qcow2_update_ext_header(bs, backing_file, backing_fmt);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 318, "prediction": "0", "true_label": "0", "raw_text": "Question: static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);\n\n    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 319, "prediction": "0", "true_label": "0", "raw_text": " 1);\n\n    // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device\n\n    // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device\n\n    escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1],\n\n              serial_hds[0], ESCC_CLOCK, 1);\n\n\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    main_esp = esp_init(hwdef->esp_base, 2,\n\n                        espdma_memory_read, espdma_memory_write,\n\n                        espdma, *espdma_irq, esp_reset);\n\n\n\n    for (i = 0; i < ESP_MAX_DEVS; i++) {\n\n        drive_index = drive_get_index(IF_SCSI, 0, i);\n\n        if (drive_index == -1)\n\n            continue;\n\n        esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i);\n\n    }\n\n\n\n    kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename,\n\n                                    RAM_size);\n\n\n\n    nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline,\n\n               boot_device, RAM_size, kernel_size, graphic_width,\n\n               graphic_height, graphic_depth, hwdef->nvram_machine_id,\n\n               \"Sun4d\");\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 320, "prediction": "0", "true_label": "0", "raw_text": "id);\n\n        }\n\n    }\n\n\n\n    if (wr_id == wrid_requested) {\n\n        return 0;\n\n    }\n\n\n\n    while (1) {\n\n        /*\n\n         * Coroutine doesn't start until process_incoming_migration()\n\n         * so don't yield unless we know we're running inside of a coroutine.\n\n         */\n\n        if (rdma->migration_started_on_destination) {\n\n            yield_until_fd_readable(rdma->comp_channel->fd);\n\n        }\n\n\n\n        if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) {\n\n            perror(\"ibv_get_cq_event\");\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        num_cq_events++;\n\n\n\n        if (ibv_req_notify_cq(cq, 0)) {\n\n            goto err_block_for_wrid;\n\n        }\n\n\n\n        while (wr_id != wrid_requested) {\n\n            ret = qemu_rdma_poll(rdma, &wr_id_in);\n\n            if (ret < 0) {\n\n                goto err_block_for_wrid;\n\n            }\n\n\n\n            wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;\n\n\n\n            if (wr_id == RDMA_WRID_NONE) {\n\n                break;\n\n            }\n\n            if (wr_id != wrid_requested) {\n\n                DDDPRINTF(\"B Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\",\n\n                    print_wrid(wrid_requested), wrid_requested,\n\n                    print_wrid(wr_id), wr_id);\n\n            }\n\n        }\n\n\n\n        if (wr_id == wrid_requested) {\n\n            goto success_block_for_wrid;\n\n        }\n\n    }\n\n\n\nsuccess_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return 0;\n\n\n\nerr_block_for_wrid:\n\n    if (num_cq_events) {\n\n        ibv_ack_cq_events(cq, num_cq_events);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 321, "prediction": "0", "true_label": "1", "raw_text": "mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t *)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    __asm__ volatile(\"pxor    %%mm7,%%mm7    \\n\\t\":::\"memory\");\n\n    __asm__ volatile(\"pcmpeqd %%mm6,%%mm6    \\n\\t\":::\"memory\");\n\n    mm_end = end - 3;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            PACK_RGB32\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r)\n\n            :\"memory\");\n\n        d += 16;\n\n        s += 4;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n        *d++ = 255;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 322, "prediction": "1", "true_label": "1", "raw_text": "Question: static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 323, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 324, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,\n\n                                     const uint8_t *src_in[4],\n\n                                     int srcW, int xInc, const int16_t *hChrFilter,\n\n                                     const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                     uint8_t *formatConvBuffer, uint32_t *pal)\n\n{\n\n    const uint8_t *src1 = src_in[1], *src2 = src_in[2];\n\n    if (c->chrToYV12) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    } else if (c->readChrPlanar) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst1, dst2, dstWidth);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 325, "prediction": "-1", "true_label": "1", "raw_text": "offset, pnum,\n                                     &local_qiov, 0);\n            if (ret < 0) {\n                goto err;\n            bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n            if (drv->bdrv_co_pwrite_zeroes &&\n                buffer_is_zero(bounce_buffer, pnum)) {\n                /* FIXME: Should we (perhaps conditionally) be setting\n                 * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n                 * that still correctly reads as zero? */\n                ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0);\n            } else {\n                /* This does not change the data on the disk, it is not\n                 * necessary to flush even in cache=writethrough mode.\n                 */\n                ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,\n                                          &local_qiov, 0);\n            if (ret < 0) {\n                /* It might be okay to ignore write errors for guest\n                 * requests.  If this is a deliberate copy-on-read\n                 * then we don't want to ignore the error.  Simply\n                 * report it in all cases.\n                 */\n                goto err;\n            qemu_iovec_from_buf(qiov, progress, bounce_buffer + skip_bytes,\n                                pnum - skip_bytes);\n        } else {\n            /* Read directly into the destination */\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes);\n            ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size,\n                                     &local_qiov, 0);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                goto err;\n        cluster_offset += pnum;\n        cluster_bytes -= pnum;\n        progress += pnum - skip_bytes;\n        skip_bytes = 0;\n    ret = 0;\nerr:\n    qemu_vfree(bounce_buffer);\n    return ret;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 326, "prediction": "0", "true_label": "1", "raw_text": "Question: static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)\n{\n    virtio_scsi_common_unrealize(dev, errp);\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 327, "prediction": "1", "true_label": "1", "raw_text": " *client;\n\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n\n                if (vs == client) {\n\n                    continue;\n\n                }\n\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n\n                    continue;\n\n                }\n\n                vnc_disconnect_start(client);\n\n            }\n\n        }\n\n        if (mode == VNC_SHARE_MODE_SHARED) {\n\n            if (vs->vd->num_exclusive > 0) {\n\n                vnc_disconnect_start(vs);\n\n                return 0;\n\n            }\n\n        }\n\n        break;\n\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n\n        /*\n\n         * Policy: Shared connects only.\n\n         * Implementation: Disallow clients asking for exclusive access.\n\n         *\n\n         * Useful for shared desktop sessions where you don't want\n\n         * someone forgetting to say -shared when running the vnc\n\n         * client disconnect everybody else.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            vnc_disconnect_start(vs);\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n    vnc_set_share_mode(vs, mode);\n\n\n\n    vs->client_width = surface_width(vs->vd->ds);\n\n    vs->client_height = surface_height(vs->vd->ds);\n\n    vnc_write_u16(vs, vs->client_width);\n\n    vnc_write_u16(vs, vs->client_height);\n\n\n\n    pixel_format_message(vs);\n\n\n\n    if (qemu_name)\n\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n\n    else\n\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_flush(vs);\n\n\n\n    vnc_client_cache_auth(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 328, "prediction": "0", "true_label": "0", "raw_text": "vt7, 1, (v4i32) src_vt8);\n\n\n\n    XORI_B4_128_SB(src_vt4, src_vt5, src_vt6, src_vt7);\n\n\n\n    /* filter calc */\n\n    vert_out0 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt0, src_vt1, src_vt2,\n\n                                                  src_vt3, src_vt4, src_vt5);\n\n    vert_out1 = AVC_CALC_DPADD_B_6PIX_2COEFF_R_SH(src_vt2, src_vt3, src_vt4,\n\n                                                  src_vt5, src_vt6, src_vt7);\n\n    SRARI_H2_SH(vert_out0, vert_out1, 5);\n\n    SAT_SH2_SH(vert_out0, vert_out1, 7);\n\n\n\n    res1 = __msa_srari_h((hz_out1 + vert_out1), 1);\n\n    res0 = __msa_srari_h((hz_out0 + vert_out0), 1);\n\n\n\n    SAT_SH2_SH(res0, res1, 7);\n\n    res = PCKEV_XORI128_UB(res0, res1);\n\n\n\n    dst0 = (v16u8) __msa_insve_w((v4i32) dst0, 1, (v4i32) dst1);\n\n    dst1 = (v16u8) __msa_insve_w((v4i32) dst2, 1, (v4i32) dst3);\n\n    dst0 = (v16u8) __msa_insve_d((v2i64) dst0, 1, (v2i64) dst1);\n\n    dst0 = __msa_aver_u_b(res, dst0);\n\n\n\n    ST4x4_UB(dst0, dst0, 0, 1, 2, 3, dst, dst_stride);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 329, "prediction": "0", "true_label": "0", "raw_text": "Question: static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,\n\n                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n                         BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,\n\n                       cb, opaque, QEMU_AIO_READ);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 330, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcx_blit_writel(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 331, "prediction": "0", "true_label": "0", "raw_text": "_v(q0_or_p0_org, (v16u8) q0_or_p0, is_less_than);\n\n\n\n        tmp1 = (v8i16) __msa_ilvr_b((v16i8) q0_or_p0_org, (v16i8) p0_or_q0_org);\n\n\n\n        data_cb_or_cr -= 1;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 0);\n\n        out1 = __msa_copy_u_h(tmp1, 1);\n\n        out2 = __msa_copy_u_h(tmp1, 2);\n\n        out3 = __msa_copy_u_h(tmp1, 3);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n        data_cb_or_cr += img_width;\n\n\n\n        out0 = __msa_copy_u_h(tmp1, 4);\n\n        out1 = __msa_copy_u_h(tmp1, 5);\n\n        out2 = __msa_copy_u_h(tmp1, 6);\n\n        out3 = __msa_copy_u_h(tmp1, 7);\n\n\n\n        STORE_HWORD(data_cb_or_cr, out0);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out1);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out2);\n\n        data_cb_or_cr += img_width;\n\n        STORE_HWORD(data_cb_or_cr, out3);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 332, "prediction": "0", "true_label": "1", "raw_text": ");\n\n            data->endbyte_bits = 0;\n\n            buf++;\n\n            len--;\n\n            avio_w8(data->buf, data->endbyte);\n\n        } else {\n\n            /* ebit/sbit values inconsistent, assuming packet loss */\n\n            GetBitContext gb;\n\n            init_get_bits(&gb, buf, len*8 - ebit);\n\n            skip_bits(&gb, sbit);\n\n            if (data->endbyte_bits) {\n\n                data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits);\n\n                avio_w8(data->buf, data->endbyte);\n\n            }\n\n            while (get_bits_left(&gb) >= 8)\n\n                avio_w8(data->buf, get_bits(&gb, 8));\n\n            data->endbyte_bits = get_bits_left(&gb);\n\n            if (data->endbyte_bits)\n\n                data->endbyte = get_bits(&gb, data->endbyte_bits) <<\n\n                                (8 - data->endbyte_bits);\n\n            ebit = 0;\n\n            len = 0;\n\n        }\n\n    }\n\n    if (ebit) {\n\n        if (len > 0)\n\n            avio_write(data->buf, buf, len - 1);\n\n        data->endbyte_bits = 8 - ebit;\n\n        data->endbyte = buf[len - 1] & (0xff << ebit);\n\n    } else {\n\n        avio_write(data->buf, buf, len);\n\n    }\n\n\n\n    /* RTP marker bit means: last fragment of current frame was received;\n\n       otherwise, an additional fragment is needed for the current frame */\n\n    if (!(flags & RTP_FLAG_MARKER))\n\n        return AVERROR(EAGAIN);\n\n\n\n    /* write the completed last byte from the \"byte merging\" */\n\n    if (data->endbyte_bits)\n\n        avio_w8(data->buf, data->endbyte);\n\n    data->endbyte_bits = 0;\n\n\n\n    /* close frame buffering and create resulting A/V packet */\n\n    res = ff_rtp_finalize_packet(pkt, &data->buf, st->index);\n\n    if (res < 0)\n\n        return res;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 333, "prediction": "0", "true_label": "1", "raw_text": " = ref;\n\n        /* fall through to forward prediction */\n\n    case AV_PICTURE_TYPE_P:\n\n        ref = ff_vdpau_get_surface_id(&s->last_picture.f);\n\n        info->forward_reference  = ref;\n\n    }\n\n\n\n    info->slice_count                = 0;\n\n    info->picture_structure          = s->picture_structure;\n\n    info->picture_coding_type        = s->pict_type;\n\n    info->intra_dc_precision         = s->intra_dc_precision;\n\n    info->frame_pred_frame_dct       = s->frame_pred_frame_dct;\n\n    info->concealment_motion_vectors = s->concealment_motion_vectors;\n\n    info->intra_vlc_format           = s->intra_vlc_format;\n\n    info->alternate_scan             = s->alternate_scan;\n\n    info->q_scale_type               = s->q_scale_type;\n\n    info->top_field_first            = s->top_field_first;\n\n    // Both for MPEG-1 only, zero for MPEG-2:\n\n    info->full_pel_forward_vector    = s->full_pel[0];\n\n    info->full_pel_backward_vector   = s->full_pel[1];\n\n    // For MPEG-1 fill both horizontal & vertical:\n\n    info->f_code[0][0]               = s->mpeg_f_code[0][0];\n\n    info->f_code[0][1]               = s->mpeg_f_code[0][1];\n\n    info->f_code[1][0]               = s->mpeg_f_code[1][0];\n\n    info->f_code[1][1]               = s->mpeg_f_code[1][1];\n\n    for (i = 0; i < 64; ++i) {\n\n        info->intra_quantizer_matrix[i]     = s->intra_matrix[i];\n\n        info->non_intra_quantizer_matrix[i] = s->inter_matrix[i];\n\n    }\n\n\n\n    return ff_vdpau_common_start_frame(pic_ctx, buffer, size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 334, "prediction": "0", "true_label": "1", "raw_text": "(&rvlc_rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        init_vlc_rl(&rl_inter);\n\n        init_vlc_rl(&rl_intra);\n\n        init_vlc_rl(&rvlc_rl_inter);\n\n        init_vlc_rl(&rvlc_rl_intra);\n\n        init_vlc_rl(&rl_intra_aic);\n\n        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_lum[0][1], 2, 1,\n\n                 &DCtab_lum[0][0], 2, 1);\n\n        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_chrom[0][1], 2, 1,\n\n                 &DCtab_chrom[0][0], 2, 1);\n\n        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n\n                 &sprite_trajectory_tab[0][1], 4, 2,\n\n                 &sprite_trajectory_tab[0][0], 4, 2);\n\n        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n\n                 &mb_type_b_tab[0][1], 2, 1,\n\n                 &mb_type_b_tab[0][0], 2, 1);\n\n        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,\n\n                 &h263_mbtype_b_tab[0][1], 2, 1,\n\n                 &h263_mbtype_b_tab[0][0], 2, 1);\n\n        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,\n\n                 &cbpc_b_tab[0][1], 2, 1,\n\n                 &cbpc_b_tab[0][0], 2, 1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 335, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,\n\n                             unsigned size)\n\n{\n\n    icp_pit_state *s = (icp_pit_state *)opaque;\n\n    int n;\n\n\n\n    /* ??? Don't know the PrimeCell ID for this device.  */\n\n    n = offset >> 8;\n\n    if (n > 3) {\n\n        hw_error(\"sp804_read: Bad timer %d\\n\", n);\n\n    }\n\n\n\n    return arm_timer_read(s->timer[n], offset & 0xff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 336, "prediction": "0", "true_label": "1", "raw_text": "gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_intra_matrix[i];\n\n            s->intra_matrix[i] = v;\n\n            s->chroma_intra_matrix[i] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->non_intra_matrix[j] = v;\n\n            s->chroma_non_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->non_intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_non_intra_matrix[i];\n\n            s->non_intra_matrix[i] = v;\n\n            s->chroma_non_intra_matrix[i] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 337, "prediction": "0", "true_label": "1", "raw_text": " {\n            int num = 0;\n            double best_error= 0.01;\n            for (j=0; j<MAX_STD_TIMEBASES; j++) {\n                int k;\n                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))\n                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))\n                for(k=0; k<2; k++){\n                    int n= st->info->duration_count;\n                    double a= st->info->duration_error[k][0][j] / n;\n                    double error= st->info->duration_error[k][1][j]/n - a*a;\n                    if(error < best_error && best_error> 0.000000001){\n                        best_error= error;\n                        num = get_std_framerate(j);\n                    }\n                    if(error < 0.02)\n                        av_log(NULL, AV_LOG_DEBUG, \"rfps: %f %f\\n\", get_std_framerate(j) / 12.0/1001, error);\n                }\n            }\n            // do not increase frame rate by more than 1 % in order to match a standard rate.\n            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))\n                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);\n        }\n        av_freep(&st->info->duration_error);\n        st->info->last_dts = AV_NOPTS_VALUE;\n        st->info->duration_count = 0;\n        st->info->rfps_duration_sum = 0;\n    }\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 338, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_compute_eflags_o(DisasContext *s, TCGv reg)\n\n{\n\n    gen_compute_eflags(s);\n\n    tcg_gen_shri_tl(reg, cpu_cc_src, 11);\n\n    tcg_gen_andi_tl(reg, reg, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 339, "prediction": "0", "true_label": "0", "raw_text": " + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 340, "prediction": "0", "true_label": "0", "raw_text": "->regs[offset] = val | readonly;\n\n\n\n    /* Handle register write side effects */\n\n    switch (offset) {\n\n    case GEM_NWCTRL:\n\n        if (val & GEM_NWCTRL_TXSTART) {\n\n            gem_transmit(s);\n\n        }\n\n        if (!(val & GEM_NWCTRL_TXENA)) {\n\n            /* Reset to start of Q when transmit disabled. */\n\n            s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n        }\n\n        if (!(val & GEM_NWCTRL_RXENA)) {\n\n            /* Reset to start of Q when receive disabled. */\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        }\n\n        break;\n\n\n\n    case GEM_TXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_RXQBASE:\n\n        s->rx_desc_addr = val;\n\n        break;\n\n    case GEM_TXQBASE:\n\n        s->tx_desc_addr = val;\n\n        break;\n\n    case GEM_RXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IER:\n\n        s->regs[GEM_IMR] &= ~val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IDR:\n\n        s->regs[GEM_IMR] |= val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (val & GEM_PHYMNTNC_OP_W) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                gem_phy_write(s, reg_num, val);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    DB_PRINT(\"newval: 0x%08x\\n\", s->regs[offset]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 341, "prediction": "0", "true_label": "1", "raw_text": "->active_tc.gpr[4],\n\n                                 env->active_tc.gpr[5],\n\n                                 env->active_tc.gpr[6],\n\n                                 env->active_tc.gpr[7],\n\n                                 arg5, arg6/*, arg7, arg8*/);\n\n\n\n\n\n\n\n            if ((unsigned int)ret >= (unsigned int)(-1133)) {\n\n                env->active_tc.gpr[7] = 1; /* error flag */\n\n                ret = -ret;\n\n            } else {\n\n                env->active_tc.gpr[7] = 0; /* error flag */\n\n\n            env->active_tc.gpr[2] = ret;\n\n\n        case EXCP_TLBL:\n\n        case EXCP_TLBS:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            /* XXX: check env->error_code */\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->CP0_BadVAddr;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_CpU:\n\n        case EXCP_RI:\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = 0;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n\n\n\n        default:\n\n            //        error:\n\n            fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\",\n\n                    trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            abort();\n\n\n        process_pending_signals(env);\n\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 342, "prediction": "0", "true_label": "1", "raw_text": "Question: static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 343, "prediction": "0", "true_label": "1", "raw_text": "Question: static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 344, "prediction": "0", "true_label": "1", "raw_text": "\", bytestream2_peek_be32(&s->g));\n\n    }\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {\n\n                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]\n\n                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4\n\n                ) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                        \"Block length %\"PRIu16\" or lengthinc %d is too large, left %d\\n\",\n\n                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);\n\n                cblk->length   += cblk->lengthinc[cwsno];\n\n                cblk->lengthinc[cwsno] = 0;\n\n                if (cblk->nb_terminationsinc) {\n\n                    cblk->nb_terminationsinc--;\n\n                    cblk->nb_terminations++;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data_start[cblk->nb_terminations] = cblk->length;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 345, "prediction": "0", "true_label": "1", "raw_text": " if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);\n\n            qemu_input_event_send_key_delay(0);\n\n            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);\n\n            qemu_input_event_send_key_delay(0);\n\n\n\n            if (keycode & ALTGR) {\n\n                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & ALT) {\n\n                qemu_input_event_send_key_number(NULL, ALT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & CNTRL) {\n\n                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n            if (keycode & SHIFT) {\n\n                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);\n\n                qemu_input_event_send_key_delay(0);\n\n            }\n\n        } else {\n\n            keysym = curses2qemu[chr];\n\n            if (keysym == -1)\n\n                keysym = chr;\n\n\n\n            kbd_put_keysym(keysym);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 346, "prediction": "0", "true_label": "1", "raw_text": "Question: static int64_t read_ts(char **line, int *duration)\n\n{\n\n    int64_t start, end;\n\n\n\n    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {\n\n        *line += strcspn(*line, \"\\\"\") + 1;\n\n        *duration = end - start;\n\n        return start;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 347, "prediction": "0", "true_label": "1", "raw_text": "Question: static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 348, "prediction": "0", "true_label": "1", "raw_text": " rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 349, "prediction": "0", "true_label": "1", "raw_text": "pb, \"APRF\"); /* audio */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x2);   /* TrackID */\n\n    ffio_wfourcc(pb, \"mp4a\");\n\n    avio_wb32(pb, 0x20f);\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_rate);\n\n    avio_wb32(pb, audio_par->channels);\n\n\n\n    avio_wb32(pb, 0x34);  /* size */\n\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x1);    /* TrackID */\n\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n\n        ffio_wfourcc(pb, \"avc1\");\n\n        avio_wb16(pb, 0x014D);\n\n        avio_wb16(pb, 0x0015);\n\n    } else {\n\n        ffio_wfourcc(pb, \"mp4v\");\n\n        avio_wb16(pb, 0x0000);\n\n        avio_wb16(pb, 0x0103);\n\n    }\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb16(pb, video_par->width);\n\n    avio_wb16(pb, video_par->height);\n\n    avio_wb32(pb, 0x010001); /* ? */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 350, "prediction": "0", "true_label": "1", "raw_text": "Question: static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)\n\n{\n\n    char *path = NULL, *buf = NULL, *host = NULL;\n\n\n\n    /* Get the PCI VFIO host id */\n\n    host = object_property_get_str(OBJECT(pdev), \"host\", NULL);\n\n    if (!host) {\n\n        goto err_out;\n\n    }\n\n\n\n    /* Construct the path of the file that will give us the DT location */\n\n    path = g_strdup_printf(\"/sys/bus/pci/devices/%s/devspec\", host);\n\n    g_free(host);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    g_free(path);\n\n\n\n    /* Construct and read from host device tree the loc-code */\n\n    path = g_strdup_printf(\"/proc/device-tree%s/ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {\n\n        goto err_out;\n\n    }\n\n    return buf;\n\n\n\nerr_out:\n\n    g_free(path);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 351, "prediction": "0", "true_label": "1", "raw_text": "int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)\n\n{\n\n    //FIXME Optimize (just quickly writen not opti..)\n\n    int i;\n\n    for (i=0; i<dstW; i++)\n\n    {\n\n        int val=1<<18;\n\n        int j;\n\n        for (j=0; j<lumFilterSize; j++)\n\n            val += lumSrc[j][i] * lumFilter[j];\n\n\n\n        dest[i]= av_clip_uint8(val>>19);\n\n    }\n\n\n\n    if (!uDest)\n\n        return;\n\n\n\n    if (dstFormat == PIX_FMT_NV12)\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(u>>19);\n\n            uDest[2*i+1]= av_clip_uint8(v>>19);\n\n        }\n\n    else\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(v>>19);\n\n            uDest[2*i+1]= av_clip_uint8(u>>19);\n\n        }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 352, "prediction": "0", "true_label": "1", "raw_text": "Question: static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)\n\n{\n\n    uint32_t qid;\n\n\n\n    if (addr & ((1 << 2) - 1)) {\n\n        return;\n\n    }\n\n\n\n    if (((addr - 0x1000) >> 2) & 1) {\n\n        uint16_t new_head = val & 0xffff;\n\n        int start_sqs;\n\n        NvmeCQueue *cq;\n\n\n\n        qid = (addr - (0x1000 + (1 << 2))) >> 3;\n\n        if (nvme_check_cqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        cq = n->cq[qid];\n\n        if (new_head >= cq->size) {\n\n            return;\n\n        }\n\n\n\n        start_sqs = nvme_cq_full(cq) ? 1 : 0;\n\n        cq->head = new_head;\n\n        if (start_sqs) {\n\n            NvmeSQueue *sq;\n\n            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {\n\n                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n            }\n\n            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n        }\n\n\n\n        if (cq->tail != cq->head) {\n\n            nvme_isr_notify(n, cq);\n\n        }\n\n    } else {\n\n        uint16_t new_tail = val & 0xffff;\n\n        NvmeSQueue *sq;\n\n\n\n        qid = (addr - 0x1000) >> 3;\n\n        if (nvme_check_sqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        sq = n->sq[qid];\n\n        if (new_tail >= sq->size) {\n\n            return;\n\n        }\n\n\n\n        sq->tail = new_tail;\n\n        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 353, "prediction": "0", "true_label": "0", "raw_text": " < 128; ++i) {\n\n    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));\n\n    s->ModPred[i+1*128] = i ==   7 ?  20 :\n\n                          i == 119 ||\n\n                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));\n\n    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));\n\n    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));\n\n    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));\n\n    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));\n\n    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));\n\n    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));\n\n  }\n\n\n\n  s->corrector_type = av_malloc(24 * 256);\n\n\n\n  for (i=0; i < 24; ++i) {\n\n    for (j=0; j < 256; ++j) {\n\n      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :\n\n                                   j < 248 || (i == 16 && j == 248) ? 0 :\n\n                                   corrector_type_2[j - 248];\n\n    }\n\n  }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 354, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 355, "prediction": "0", "true_label": "1", "raw_text": "Question: static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n\n{\n\n    int ret = 0;\n\n\n\n    assert(len > 0);\n\n    ccid_bulk_in_get(s);\n\n    if (s->current_bulk_in != NULL) {\n\n        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n\n        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n\n        s->current_bulk_in->pos += ret;\n\n        if (s->current_bulk_in->pos == s->current_bulk_in->len) {\n\n            ccid_bulk_in_release(s);\n\n        }\n\n    } else {\n\n        /* return when device has no data - usb 2.0 spec Table 8-4 */\n\n        ret = USB_RET_NAK;\n\n    }\n\n    if (ret > 0) {\n\n        DPRINTF(s, D_MORE_INFO,\n\n                \"%s: %d/%d req/act to guest (BULK_IN)\\n\", __func__, len, ret);\n\n    }\n\n    if (ret != USB_RET_NAK && ret < len) {\n\n        DPRINTF(s, 1,\n\n            \"%s: returning short (EREMOTEIO) %d < %d\\n\", __func__, ret, len);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 356, "prediction": "0", "true_label": "1", "raw_text": "[ich];\n\n    else if (input < pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];\n\n\n\n    /* XXX: spec says:\n\n    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;\n\n    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;\n\n\n\n        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two\n\n        seperate buffers? Here I've assumed that the two are same which makes\n\n        more sense to me.\n\n    */\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;\n\n    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */\n\n\n\n    if (s->cdlms[ich][ilms].recent == 0) {\n\n        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.\n\n                follow kshishkov's suggestion of using a union. */\n\n        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_prevvalues,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_updates,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 357, "prediction": "0", "true_label": "1", "raw_text": "Question: static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n\n                         const char *filt_name, const char *args, AVClass *log_ctx)\n\n{\n\n    AVFilter *filt;\n\n    char inst_name[30];\n\n    char tmp_args[256];\n\n    int ret;\n\n\n\n    snprintf(inst_name, sizeof(inst_name), \"Parsed filter %d %s\", index, filt_name);\n\n\n\n    filt = avfilter_get_by_name(filt_name);\n\n\n\n    if (!filt) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"No such filter: '%s'\\n\", filt_name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ret = avfilter_open(filt_ctx, filt, inst_name);\n\n    if (!*filt_ctx) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error creating filter '%s'\\n\", filt_name);\n\n        return ret;\n\n    }\n\n\n\n    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n\n        avfilter_free(*filt_ctx);\n\n        return ret;\n\n    }\n\n\n\n    if (!strcmp(filt_name, \"scale\") && !strstr(args, \"flags\")) {\n\n        snprintf(tmp_args, sizeof(tmp_args), \"%s:%s\",\n\n                 args, ctx->scale_sws_opts);\n\n        args = tmp_args;\n\n    }\n\n\n\n    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error initializing filter '%s' with args '%s'\\n\", filt_name, args);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 358, "prediction": "0", "true_label": "1", "raw_text": "Question: static void decode_mclms(WmallDecodeCtx *s)\n\n{\n\n    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;\n\n    s->mclms_scaling = get_bits(&s->gb, 4);\n\n    if(get_bits1(&s->gb)) {\n\n\t// mclms_send_coef\n\n\tint i;\n\n\tint send_coef_bits;\n\n\tint cbits = av_log2(s->mclms_scaling + 1);\n\n\tassert(cbits == my_log2(s->mclms_scaling + 1));\n\n\tif(1 << cbits < s->mclms_scaling + 1)\n\n\t    cbits++;\n\n\n\n\tsend_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;\n\n\n\n\tfor(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {\n\n\t    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);\n\n\t}\n\n\n\n\tfor(i = 0; i < s->num_channels; i++) {\n\n\t    int c;\n\n\t    for(c = 0; c < i; c++) {\n\n\t\ts->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);\n\n\t    }\n\n\t}\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 359, "prediction": "0", "true_label": "1", "raw_text": " initrd_size = load_image_targphys(initrd_filename, initrd_base,\n                                              load_limit - initrd_base);\n            if (initrd_size < 0) {\n                fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n                        initrd_filename);\n                exit(1);\n            }\n            fprintf(stderr, \"Ramdisk              : 0x%08lx..%08lx\\n\",\n                    (long)initrd_base, (long)(initrd_base + initrd_size - 1));\n        } else {\n            initrd_base = 0;\n            initrd_size = 0;\n        }\n    }\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME);\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n    if (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n    }\n    g_free(filename);\n    fprintf(stderr, \"Firmware load        : 0x%08x..%08lx\\n\",\n            0, fw_size);\n    fprintf(stderr, \"Firmware runtime     : 0x%08lx..%08lx\\n\",\n            load_limit, (unsigned long)spapr->fdt_addr);\n    spapr->entry_point = 0x100;\n    /* SLOF will startup the secondary CPUs using RTAS */\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n        env->halted = 1;\n    }\n    /* Prepare the device tree */\n    spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size,\n                                            initrd_base, initrd_size,\n                                            kernel_size,\n                                            boot_device, kernel_cmdline,\n                                            pteg_shift + 7);\n    assert(spapr->fdt_skel != NULL);\n    qemu_register_reset(spapr_reset, spapr);\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 360, "prediction": "0", "true_label": "0", "raw_text": "samples));\n\n        if (!s->coded_samples[i])\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));\n\n\n\n    s->window_size = ((2*s->tail_size)+s->frame_size);\n\n    s->window = av_calloc(s->window_size, sizeof(*s->window));\n\n    if (!s->window)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->extradata = av_mallocz(16);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&pb, avctx->extradata, 16*8);\n\n\n\n    put_bits(&pb, 2, version); // version\n\n    if (version == 1)\n\n    {\n\n        put_bits(&pb, 2, s->channels);\n\n        put_bits(&pb, 4, code_samplerate(s->samplerate));\n\n    }\n\n    put_bits(&pb, 1, s->lossless);\n\n    if (!s->lossless)\n\n        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision\n\n    put_bits(&pb, 2, s->decorrelation);\n\n    put_bits(&pb, 2, s->downsampling);\n\n    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024\n\n    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table\n\n\n\n    flush_put_bits(&pb);\n\n    avctx->extradata_size = put_bits_count(&pb)/8;\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\",\n\n        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);\n\n\n\n    avctx->frame_size = s->block_align*s->downsampling;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 361, "prediction": "0", "true_label": "0", "raw_text": "Question: int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n\n{\n\n    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n\n    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n\n\n    if (mode > 6U) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"out of range intra chroma pred mode at %d %d\\n\",\n\n               h->mb_x, h->mb_y);\n\n        return -1;\n\n    }\n\n\n\n    if (!(h->top_samples_available & 0x8000)) {\n\n        mode = top[mode];\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n\n        mode = left[mode];\n\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n\n                   (!(h->left_samples_available & 0x8000)) +\n\n                   2 * (mode == DC_128_PRED8x8);\n\n        }\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return mode;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 362, "prediction": "1", "true_label": "0", "raw_text": "Question: void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 363, "prediction": "0", "true_label": "0", "raw_text": "Question: static void block_job_completed_txn_abort(BlockJob *job)\n\n{\n\n    AioContext *ctx;\n\n    BlockJobTxn *txn = job->txn;\n\n    BlockJob *other_job, *next;\n\n\n\n    if (txn->aborting) {\n\n        /*\n\n         * We are cancelled by another job, which will handle everything.\n\n         */\n\n        return;\n\n    }\n\n    txn->aborting = true;\n\n    /* We are the first failed job. Cancel other jobs. */\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        aio_context_acquire(ctx);\n\n    }\n\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n\n        if (other_job == job || other_job->completed) {\n\n            /* Other jobs are \"effectively\" cancelled by us, set the status for\n\n             * them; this job, however, may or may not be cancelled, depending\n\n             * on the caller, so leave it. */\n\n            if (other_job != job) {\n\n                block_job_cancel_async(other_job);\n\n            }\n\n            continue;\n\n        }\n\n        block_job_cancel_sync(other_job);\n\n        assert(other_job->completed);\n\n    }\n\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n\n        ctx = blk_get_aio_context(other_job->blk);\n\n        block_job_completed_single(other_job);\n\n        aio_context_release(ctx);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 364, "prediction": "0", "true_label": "0", "raw_text": "Question: void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)\n\n{\n\n    memory_region_init_io(mr, &isa_mmio_ops, NULL, \"isa-mmio\", size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 365, "prediction": "0", "true_label": "0", "raw_text": "Question: int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddressLegacy *localAddr,\n\n                                  SocketAddressLegacy *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 366, "prediction": "0", "true_label": "0", "raw_text": "(\"wic r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0xe0:\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n            }\n\n            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n\n                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            }\n\n            break;\n\n        case 0x1e0:\n\n            /* swapb */\n\n            LOG_DIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x1e2:\n\n            /*swaph */\n\n            LOG_DIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);\n\n            break;\n\n        default:\n\n            cpu_abort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\",\n\n                     dc->pc, op, dc->rd, dc->ra, dc->rb);\n\n            break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 367, "prediction": "1", "true_label": "0", "raw_text": "Question: int memory_region_get_fd(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_fd(mr->alias);\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 368, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,\n\n                              TCGReg r1, TCGReg r2, TCGReg rn,\n\n                              tcg_target_long ofs, bool pre, bool w)\n\n{\n\n    insn |= 1u << 31; /* ext */\n\n    insn |= pre << 24;\n\n    insn |= w << 23;\n\n\n\n    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);\n\n    insn |= (ofs & (0x7f << 3)) << (15 - 3);\n\n\n\n    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 369, "prediction": "0", "true_label": "0", "raw_text": "Question: static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,\n\n                                   const char *name, Error **errp)\n\n{\n\n    X86CPU *cpu = X86_CPU(obj);\n\n    const int64_t min = 0;\n\n    const int64_t max = INT_MAX;\n\n    int64_t value;\n\n\n\n    visit_type_int(v, &value, name, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n    if (value < min || value > max) {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, \"\",\n\n                  name ? name : \"null\", value, min, max);\n\n        return;\n\n    }\n\n\n\n    cpu->env.tsc_khz = value / 1000;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 370, "prediction": "0", "true_label": "1", "raw_text": "OPT_BACKING_FILE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    cow_bs = NULL;\n\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    memset(&cow_header, 0, sizeof(cow_header));\n\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n\n    cow_header.version = cpu_to_be32(COW_VERSION);\n\n    if (image_filename) {\n\n        /* Note: if no file, we put a dummy mtime */\n\n        cow_header.mtime = cpu_to_be32(0);\n\n\n\n        if (stat(image_filename, &st) != 0) {\n\n            goto mtime_fail;\n\n        }\n\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n\n    mtime_fail:\n\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n\n                image_filename);\n\n    }\n\n    cow_header.sectorsize = cpu_to_be32(512);\n\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* resize to include at least all the bitmap */\n\n    ret = bdrv_truncate(cow_bs,\n\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(image_filename);\n\n    bdrv_unref(cow_bs);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 371, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int check_format(AVCodecContext *avctx)\n\n{\n\n    AVCodecParserContext *parser;\n\n    uint8_t *pout;\n\n    int psize;\n\n    int index;\n\n    H264Context *h;\n\n    int ret = -1;\n\n\n\n    /* init parser & parse file */\n\n    parser = av_parser_init(avctx->codec->id);\n\n    if (!parser) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to open H.264 parser.\\n\");\n\n        goto final;\n\n    }\n\n    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;\n\n    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);\n\n    if (index < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to parse this file.\\n\");\n\n        goto release_parser;\n\n    }\n\n\n\n    /* check if support */\n\n    h = parser->priv_data;\n\n    switch (h->sps.bit_depth_luma) {\n\n    case 8:\n\n        if (!CHROMA444(h) && !CHROMA422(h)) {\n\n            // only this will H.264 decoder switch to hwaccel\n\n            ret = 0;\n\n            break;\n\n        }\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported file.\\n\");\n\n    }\n\n\n\nrelease_parser:\n\n    av_parser_close(parser);\n\n\n\nfinal:\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 372, "prediction": "0", "true_label": "0", "raw_text": "Question: static unsigned int dec_move_mr(DisasContext *dc)\n\n{\n\n\tint memsize = memsize_zz(dc);\n\n\tint insn_len;\n\n\tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\",\n\n\t\t    memsize_char(memsize),\n\n\t\t    dc->op1, dc->postinc ? \"+]\" : \"]\",\n\n\t\t    dc->op2));\n\n\n\n\tif (memsize == 4) {\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_update_cc_op(dc, CC_OP_MOVE, 4);\n\n\t\tcris_update_cc_x(dc);\n\n\t\tcris_update_result(dc, cpu_R[dc->op2]);\n\n\t}\n\n\telse {\n\n\t\tTCGv t0;\n\n\n\n\t\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tinsn_len = dec_prep_move_m(dc, 0, memsize, t0);\n\n\t\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\t\tcris_alu(dc, CC_OP_MOVE,\n\n\t\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);\n\n\t\ttcg_temp_free(t0);\n\n\t}\n\n\tdo_postinc(dc, memsize);\n\n\treturn insn_len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 373, "prediction": "0", "true_label": "0", "raw_text": " 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 374, "prediction": "0", "true_label": "0", "raw_text": "Question: static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    return virtio_load(vdev, f, version_id);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 375, "prediction": "0", "true_label": "0", "raw_text": "filename_bytes),\n\n                                  s->path, s->img_number)<0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for(i=0; i<3; i++){\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if(i>=1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i]= avio_size(f[i]);\n\n\n\n            if(!s->split_planes)\n\n                break;\n\n            filename[ strlen(filename) - 1 ]= 'U' + i;\n\n        }\n\n\n\n        if(codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        size[0]= 4096;\n\n    }\n\n\n\n    av_new_packet(pkt, size[0] + size[1] + size[2]);\n\n    pkt->stream_index = 0;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n\n    pkt->size= 0;\n\n    for(i=0; i<3; i++){\n\n        if(f[i]){\n\n            ret[i]= avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if(ret[i]>0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        return 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 376, "prediction": "1", "true_label": "1", "raw_text": " : 8;\n            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate\n                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){\n        av_log(s, AV_LOG_ERROR,\n               \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\",\n               smk->treesize + 16);\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = avio_tell(pb);\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 377, "prediction": "0", "true_label": "0", "raw_text": "Question: static int coroutine_fn raw_co_discard(BlockDriverState *bs,\n\n                                       int64_t sector_num, int nb_sectors)\n\n{\n\n    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 378, "prediction": "1", "true_label": "0", "raw_text": "Question: BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 379, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_pci_reset(DeviceState *d)\n\n{\n\n    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);\n\n    virtio_reset(proxy->vdev);\n\n    msix_reset(&proxy->pci_dev);\n\n    proxy->flags = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 380, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,\n\n                            TCGReg dst, TCGReg lhs, TCGArg rhs,\n\n                            bool rhs_is_const)\n\n{\n\n    /* Emit either the reg,imm or reg,reg form of a data-processing insn.\n\n     * rhs must satisfy the \"rIK\" constraint.\n\n     */\n\n    if (rhs_is_const) {\n\n        int rot = encode_imm(rhs);\n\n        if (rot < 0) {\n\n            rhs = ~rhs;\n\n            rot = encode_imm(rhs);\n\n            assert(rot >= 0);\n\n            opc = opinv;\n\n        }\n\n        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));\n\n    } else {\n\n        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO.\n"}], [{"ID": 381, "prediction": "0", "true_label": "0", "raw_text": "Question: static int twl92230_init(i2c_slave *i2c)\n\n{\n\n    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);\n\n\n\n    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);\n\n    /* Three output pins plus one interrupt pin.  */\n\n    qdev_init_gpio_out(&i2c->qdev, s->out, 4);\n\n    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);\n\n    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];\n\n\n\n    menelaus_reset(&s->i2c);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 382, "prediction": "-1", "true_label": "1", "raw_text": "c_parse_nal_units(pkt->data, &pkt->data, &pkt->size);\n\n        if (ret < 0)\n\n            return ret;\n\n        assert(pkt->size);\n\n        size = pkt->size;\n\n    } else if (enc->codec_id == CODEC_ID_DNXHD && !trk->vosLen) {\n\n        /* copy frame to create needed atoms */\n\n        trk->vosLen = size;\n\n        trk->vosData = av_malloc(size);\n\n\n\n        memcpy(trk->vosData, pkt->data, size);\n\n    }\n\n\n\n    if (!(trk->entry % MOV_INDEX_CLUSTER_SIZE)) {\n\n        trk->cluster = av_realloc(trk->cluster, (trk->entry + MOV_INDEX_CLUSTER_SIZE) * sizeof(*trk->cluster));\n\n        if (!trk->cluster)\n\n            return -1;\n\n    }\n\n\n\n    trk->cluster[trk->entry].pos = url_ftell(pb);\n\n    trk->cluster[trk->entry].samplesInChunk = samplesInChunk;\n\n    trk->cluster[trk->entry].size = size;\n\n    trk->cluster[trk->entry].entries = samplesInChunk;\n\n    trk->cluster[trk->entry].dts = pkt->dts;\n\n    trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration;\n\n\n\n    if (pkt->pts == AV_NOPTS_VALUE) {\n\n        av_log(s, AV_LOG_WARNING, \"pts has no value\\n\");\n\n        pkt->pts = pkt->dts;\n\n    }\n\n    if (pkt->dts != pkt->pts)\n\n        trk->hasBframes = 1;\n\n    trk->cluster[trk->entry].cts = pkt->pts - pkt->dts;\n\n    trk->cluster[trk->entry].key_frame = !!(pkt->flags & PKT_FLAG_KEY);\n\n    if(trk->cluster[trk->entry].key_frame)\n\n        trk->hasKeyframes++;\n\n    trk->entry++;\n\n    trk->sampleCount += samplesInChunk;\n\n    mov->mdat_size += size;\n\n\n\n    put_buffer(pb, pkt->data, size);\n\n\n\n    put_flush_packet(pb);\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 383, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,\n\n                         int base, int16_t offset)\n\n{\n\n    const char *opn = \"st_cond\";\n\n    TCGv t0, t1;\n\n\n\n    t0 = tcg_temp_local_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n    /* Don't do NOP if destination is zero: we must perform the actual\n\n       memory access. */\n\n\n\n    t1 = tcg_temp_local_new();\n\n    gen_load_gpr(t1, rt);\n\n    switch (opc) {\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_SCD:\n\n        save_cpu_state(ctx, 0);\n\n        op_st_scd(t1, t0, rt, ctx);\n\n        opn = \"scd\";\n\n        break;\n\n#endif\n\n    case OPC_SC:\n\n        save_cpu_state(ctx, 1);\n\n        op_st_sc(t1, t0, rt, ctx);\n\n        opn = \"sc\";\n\n        break;\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 384, "prediction": "0", "true_label": "1", "raw_text": ",\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 385, "prediction": "0", "true_label": "0", "raw_text": " *fdsp = venc->fdsp;\n\n\n\n    if (!venc->have_saved && !samples)\n\n        return 0;\n\n\n\n    if (venc->have_saved) {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memcpy(venc->samples + channel * window_len * 2,\n\n                   venc->saved + channel * window_len, sizeof(float) * window_len);\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2, 0,\n\n                   sizeof(float) * window_len);\n\n    }\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->samples + channel * window_len * 2 + window_len;\n\n\n\n            fdsp->vector_fmul_reverse(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n    } else {\n\n        for (channel = 0; channel < venc->channels; channel++)\n\n            memset(venc->samples + channel * window_len * 2 + window_len,\n\n                   0, sizeof(float) * window_len);\n\n    }\n\n\n\n    for (channel = 0; channel < venc->channels; channel++)\n\n        venc->mdct[0].mdct_calc(&venc->mdct[0], venc->coeffs + channel * window_len,\n\n                     venc->samples + channel * window_len * 2);\n\n\n\n    if (samples) {\n\n        for (channel = 0; channel < venc->channels; channel++) {\n\n            float *offset = venc->saved + channel * window_len;\n\n\n\n            fdsp->vector_fmul(offset, audio + channel * window_len, win, samples);\n\n            fdsp->vector_fmul_scalar(offset, offset, 1/n, samples);\n\n        }\n\n        venc->have_saved = 1;\n\n    } else {\n\n        venc->have_saved = 0;\n\n    }\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 386, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 387, "prediction": "0", "true_label": "1", "raw_text": "Question: static int32_t parse_gain(const char *gain)\n\n{\n\n    char *fraction;\n\n    int  scale = 10000;\n\n    int32_t mb = 0;\n\n    int sign   = 1;\n\n    int db;\n\n\n\n    if (!gain)\n\n        return INT32_MIN;\n\n\n\n    gain += strspn(gain, \" \\t\");\n\n\n\n    if (*gain == '-')\n\n        sign = -1;\n\n\n\n    db = strtol(gain, &fraction, 0);\n\n    if (*fraction++ == '.') {\n\n        while (av_isdigit(*fraction) && scale) {\n\n            mb += scale * (*fraction - '0');\n\n            scale /= 10;\n\n            fraction++;\n\n        }\n\n    }\n\n\n\n    if (abs(db) > (INT32_MAX - mb) / 100000)\n\n        return INT32_MIN;\n\n\n\n    return db * 100000 + sign * mb;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 388, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void ide_dma_submit_check(IDEState *s,\n\n          BlockDriverCompletionFunc *dma_cb)\n\n{\n\n    if (s->bus->dma->aiocb)\n\n\treturn;\n\n    dma_cb(s, -1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 389, "prediction": "0", "true_label": "1", "raw_text": "Question: static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,\n\n                                 bool query_backing)\n\n{\n\n    BlockStats *s = NULL;\n\n\n\n    s = g_malloc0(sizeof(*s));\n\n    s->stats = g_malloc0(sizeof(*s->stats));\n\n\n\n    if (!bs) {\n\n        return s;\n\n    }\n\n\n\n    if (bdrv_get_node_name(bs)[0]) {\n\n        s->has_node_name = true;\n\n        s->node_name = g_strdup(bdrv_get_node_name(bs));\n\n    }\n\n\n\n    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);\n\n\n\n    if (bs->file) {\n\n        s->has_parent = true;\n\n        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);\n\n    }\n\n\n\n    if (query_backing && bs->backing) {\n\n        s->has_backing = true;\n\n        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);\n\n    }\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 390, "prediction": "0", "true_label": "1", "raw_text": "Question: static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n\n                                    const uint8_t *src, const uint8_t *src_end,\n\n                                    int width, int esc_count)\n\n{\n\n    int i = 0;\n\n    int count;\n\n    uint8_t zero_run = 0;\n\n    const uint8_t *src_start = src;\n\n    uint8_t mask1 = -(esc_count < 2);\n\n    uint8_t mask2 = -(esc_count < 3);\n\n    uint8_t *end = dst + (width - 2);\n\n\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n\n    return AVERROR_PATCHWELCOME;\n\n\n\noutput_zeros:\n\n    if (l->zeros_rem) {\n\n        count = FFMIN(l->zeros_rem, width - i);\n\n        if (end - dst < count) {\n\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        memset(dst, 0, count);\n\n        l->zeros_rem -= count;\n\n        dst += count;\n\n    }\n\n\n\n    while (dst < end) {\n\n        i = 0;\n\n        while (!zero_run && dst + i < end) {\n\n            i++;\n\n            if (i+2 >= src_end - src)\n\n                return AVERROR_INVALIDDATA;\n\n            zero_run =\n\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n\n        }\n\n        if (zero_run) {\n\n            zero_run = 0;\n\n            i += esc_count;\n\n            memcpy(dst, src, i);\n\n            dst += i;\n\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n\n\n            src += i + 1;\n\n            goto output_zeros;\n\n        } else {\n\n            memcpy(dst, src, i);\n\n            src += i;\n\n            dst += i;\n\n        }\n\n    }\n\n    return  src - src_start;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 391, "prediction": "0", "true_label": "1", "raw_text": "\n\n                                  TARGET_PAGE_SIZE, &local_err);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report_err(local_err);\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n\n\n    /* Skip setting bitmap if there is no RAM */\n\n    if (ram_bytes_total()) {\n\n        RAMBlock *block;\n\n\n\n        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;\n\n\n\n            block->bmap = bitmap_new(pages);\n\n            bitmap_set(block->bmap, 0, pages);\n\n            if (migrate_postcopy_ram()) {\n\n                block->unsentmap = bitmap_new(pages);\n\n                bitmap_set(block->unsentmap, 0, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync(*rsp);\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 392, "prediction": "0", "true_label": "0", "raw_text": "Question: static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = beta_table[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]]+1;\n\n        tc[1] = tc0_table[index_a][bS[1]]+1;\n\n        tc[2] = tc0_table[index_a][bS[2]]+1;\n\n        tc[3] = tc0_table[index_a][bS[3]]+1;\n\n        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 393, "prediction": "0", "true_label": "1", "raw_text": " width) {\n\n                ref_y--;\n\n                distance -= width;\n\n            }\n\n            if (distance > 0) {\n\n                ref_x = width - distance;\n\n                ref_y--;\n\n            }\n\n            ref_x = FFMAX(0, ref_x);\n\n            ref_y = FFMAX(0, ref_y);\n\n\n\n            /* copy pixels\n\n             * source and dest regions can overlap and wrap lines, so just\n\n             * copy per-pixel */\n\n            for (i = 0; i < length; i++) {\n\n                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);\n\n                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);\n\n\n\n                AV_COPY32(p, p_ref);\n\n                if (img->color_cache_bits)\n\n                    color_cache_put(img, AV_RB32(p));\n\n                x++;\n\n                ref_x++;\n\n                if (x == width) {\n\n                    x = 0;\n\n                    y++;\n\n                }\n\n                if (ref_x == width) {\n\n                    ref_x = 0;\n\n                    ref_y++;\n\n                }\n\n                if (y == img->frame->height || ref_y == img->frame->height)\n\n                    break;\n\n            }\n\n        } else {\n\n            /* read from color cache */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);\n\n\n\n            if (!img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"color cache not found\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (cache_idx >= 1 << img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"color cache index out-of-bounds\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            AV_WB32(p, img->color_cache[cache_idx]);\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 394, "prediction": "0", "true_label": "1", "raw_text": "0)\n\n            dxy |= 1;\n\n        if ((motion_y & 3) != 0)\n\n            dxy |= 2;\n\n        mx = motion_x >> 2;\n\n        my = motion_y >> 2;\n\n    } else {\n\n        mx = motion_x / 2;\n\n        my = motion_y / 2;\n\n        dxy = ((my & 1) << 1) | (mx & 1);\n\n        mx >>= 1;\n\n        my >>= 1;\n\n    }\n\n\n\n    src_x = s->mb_x * 8 + mx;\n\n    src_y = s->mb_y * 8 + my;\n\n    src_x = av_clip(src_x, -8, s->width >> 1);\n\n    if (src_x == (s->width >> 1))\n\n        dxy &= ~1;\n\n    src_y = av_clip(src_y, -8, s->height >> 1);\n\n    if (src_y == (s->height >> 1))\n\n        dxy &= ~2;\n\n    offset = (src_y * uvlinesize) + src_x;\n\n    ptr = ref_picture[1] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cb, ptr, uvlinesize, h >> 1);\n\n\n\n    ptr = ref_picture[2] + offset;\n\n    if(emu){\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, ptr, s->uvlinesize, 9, 9,\n\n                         src_x, src_y, s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n        ptr= s->edge_emu_buffer;\n\n    }\n\n    pix_op[1][dxy](dest_cr, ptr, uvlinesize, h >> 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 395, "prediction": "0", "true_label": "1", "raw_text": "0];\n\n\n\n                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,\n\n                                              stride, 16);\n\n                    score[2] += vlc[1] * lambda;\n\n                    if (score[2] < score[best] && mx == 0 && my == 0) {\n\n                        best = 2;\n\n                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for (i = 0; i < 6; i++)\n\n                            count[2][i] = 0;\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if (best == 1) {\n\n                    for (i = 0; i < 6; i++) {\n\n                        count[1][i] = put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                } else {\n\n                    motion_ptr[0]                      =\n\n                    motion_ptr[1]                      =\n\n                    motion_ptr[2]                      =\n\n                    motion_ptr[3]                      =\n\n                    motion_ptr[0 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[1 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[2 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for (i = 5; i >= 0; i--)\n\n                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],\n\n                                 count[best][i]);\n\n            if (best == 0)\n\n                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n        }\n\n        s->m.first_slice_line = 0;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 396, "prediction": "0", "true_label": "1", "raw_text": "data;\n\n            }\n\n        }\n\n        if (!buf) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n        if (!is_extradata)\n\n            ctx->packets_sent++;\n\n    } else {\n\n        if (!ctx->packets_sent) {\n\n            // Short-cut the flush logic to avoid upsetting MMAL.\n\n            ctx->eos_sent = 1;\n\n            ctx->eos_received = 1;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    start = data;\n\n\n\n    do {\n\n        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));\n\n        if (!buffer) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n\n\n        buffer->data = data;\n\n        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);\n\n\n\n        if (is_extradata)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;\n\n\n\n        if (data == start)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;\n\n\n\n        data += buffer->length;\n\n        size -= buffer->length;\n\n\n\n        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;\n\n        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;\n\n\n\n        if (!size)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;\n\n\n\n        if (!buffer->length) {\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;\n\n            ctx->eos_sent = 1;\n\n        }\n\n\n\n        if (buf) {\n\n            buffer->ref = av_buffer_ref(buf);\n\n            if (!buffer->ref) {\n\n                av_free(buffer);\n\n                ret = AVERROR(ENOMEM);\n\n                goto done;\n\n            }\n\n        }\n\n\n\n        // Insert at end of the list\n\n        if (!ctx->waiting_buffers)\n\n            ctx->waiting_buffers = buffer;\n\n        if (ctx->waiting_buffers_tail)\n\n            ctx->waiting_buffers_tail->next = buffer;\n\n        ctx->waiting_buffers_tail = buffer;\n\n    } while (size);\n\n\n\ndone:\n\n    av_buffer_unref(&buf);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 397, "prediction": "1", "true_label": "1", "raw_text": "\n\n            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt->dts, max);\n\n            pkt->pts = pkt->dts = max;\n\n\n\n\n\n    /*\n\n     * Audio encoders may split the packets --  #frames in != #packets out.\n\n     * But there is no reordering, so we can limit the number of output packets\n\n     * by simply dropping them here.\n\n     * Counting encoded video frames needs to be done separately because of\n\n     * reordering, see do_video_out()\n\n     */\n\n    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {\n\n        if (ost->frame_number >= ost->max_frames) {\n\n            av_free_packet(pkt);\n\n            return;\n\n\n        ost->frame_number++;\n\n\n\n\n    while (bsfc) {\n\n        AVPacket new_pkt = *pkt;\n\n        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,\n\n                                           &new_pkt.data, &new_pkt.size,\n\n                                           pkt->data, pkt->size,\n\n                                           pkt->flags & AV_PKT_FLAG_KEY);\n\n\n\n\n\n\n\n\n\n\n\n        if (a > 0) {\n\n            av_free_packet(pkt);\n\n            new_pkt.destruct = av_destruct_packet;\n\n        } else if (a < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Failed to open bitstream filter %s for stream %d with codec %s\",\n\n                   bsfc->filter->name, pkt->stream_index,\n\n                   avctx->codec ? avctx->codec->name : \"copy\");\n\n            print_error(\"\", a);\n\n            if (exit_on_error)\n\n                exit_program(1);\n\n\n        *pkt = new_pkt;\n\n\n\n        bsfc = bsfc->next;\n\n\n\n\n    pkt->stream_index = ost->index;\n\n    ret = av_interleaved_write_frame(s, pkt);\n\n    if (ret < 0) {\n\n        print_error(\"av_interleaved_write_frame()\", ret);\n\n        exit_program(1);\n\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 398, "prediction": "1", "true_label": "1", "raw_text": "Question: void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 399, "prediction": "1", "true_label": "1", "raw_text": "Question: av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,\n\n                                     AVCodecContext *avctx,\n\n                                     unsigned high_bit_depth)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_mmx;\n\n\n        c->diff_pixels = ff_diff_pixels_mmx;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_sse2;\n\n\n        c->diff_pixels = ff_diff_pixels_sse2;\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 400, "prediction": "0", "true_label": "1", "raw_text": "Question: static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 401, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,\n\n                              int dump_payload, AVRational time_base)\n\n{\n\n    HEXDUMP_PRINT(\"stream #%d:\\n\", pkt->stream_index);\n\n    HEXDUMP_PRINT(\"  keyframe=%d\\n\", (pkt->flags & AV_PKT_FLAG_KEY) != 0);\n\n    HEXDUMP_PRINT(\"  duration=%0.3f\\n\", pkt->duration * av_q2d(time_base));\n\n    /* DTS is _always_ valid after av_read_frame() */\n\n    HEXDUMP_PRINT(\"  dts=\");\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->dts * av_q2d(time_base));\n\n    /* PTS may not be known if B-frames are present. */\n\n    HEXDUMP_PRINT(\"  pts=\");\n\n    if (pkt->pts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->pts * av_q2d(time_base));\n\n    HEXDUMP_PRINT(\"\\n\");\n\n    HEXDUMP_PRINT(\"  size=%d\\n\", pkt->size);\n\n    if (dump_payload)\n\n        av_hex_dump(f, pkt->data, pkt->size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 402, "prediction": "0", "true_label": "0", "raw_text": "Question: static void handle_mousewheel(SDL_Event *ev)\n\n{\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n    SDL_MouseWheelEvent *wev = &ev->wheel;\n\n    InputButton btn;\n\n\n\n    if (wev->y > 0) {\n\n        btn = INPUT_BUTTON_WHEEL_UP;\n\n    } else if (wev->y < 0) {\n\n        btn = INPUT_BUTTON_WHEEL_DOWN;\n\n    } else {\n\n        return;\n\n    }\n\n\n\n    qemu_input_queue_btn(scon->dcl.con, btn, true);\n\n    qemu_input_event_sync();\n\n    qemu_input_queue_btn(scon->dcl.con, btn, false);\n\n    qemu_input_event_sync();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 403, "prediction": "0", "true_label": "1", "raw_text": "Question: static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 404, "prediction": "0", "true_label": "1", "raw_text": "Question: int av_packet_split_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX || p - pkt->data < size)\n\n                return 0;\n\n            if (p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n\n\n        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));\n\n        if (!pkt->side_data)\n\n            return AVERROR(ENOMEM);\n\n\n\n        p= pkt->data + pkt->size - 8 - 5;\n\n        for (i=0; ; i++){\n\n            size= AV_RB32(p);\n\n            av_assert0(size<=INT_MAX && p - pkt->data >= size);\n\n            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            pkt->side_data[i].size = size;\n\n            pkt->side_data[i].type = p[4]&127;\n\n            if (!pkt->side_data[i].data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->side_data[i].data, p-size, size);\n\n            pkt->size -= size + 5;\n\n            if(p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n        pkt->size -= 8;\n\n        pkt->side_data_elems = i+1;\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 405, "prediction": "0", "true_label": "1", "raw_text": "Question: static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 406, "prediction": "0", "true_label": "1", "raw_text": "bdloc + 0x1C, bd->bi_bootflags);\n\n    stl_phys(bdloc + 0x20, bd->bi_ipaddr);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);\n\n    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);\n\n    stl_phys(bdloc + 0x2C, bd->bi_intfreq);\n\n    stl_phys(bdloc + 0x30, bd->bi_busfreq);\n\n    stl_phys(bdloc + 0x34, bd->bi_baudrate);\n\n    for (i = 0; i < 4; i++)\n\n        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);\n\n    for (i = 0; i < 32; i++)\n\n        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);\n\n    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);\n\n    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);\n\n    n = 0x6A;\n\n    if (flags & 0x00000001) {\n\n        for (i = 0; i < 6; i++)\n\n            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);\n\n    }\n\n    stl_phys(bdloc + n, bd->bi_opbfreq);\n\n    n += 4;\n\n    for (i = 0; i < 2; i++) {\n\n        stl_phys(bdloc + n, bd->bi_iic_fast[i]);\n\n        n += 4;\n\n    }\n\n\n\n    return bdloc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 407, "prediction": "0", "true_label": "0", "raw_text": "Question: bool virtio_ipl_disk_is_valid(void)\n\n{\n\n    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 408, "prediction": "1", "true_label": "0", "raw_text": "Question: static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    int ret = 0;\n\n\n\n    if (bdrv_set_key(bs, password) != 0) {\n\n        monitor_printf(mon, \"invalid password\\n\");\n\n        ret = -EPERM;\n\n    }\n\n    if (mon->password_completion_cb)\n\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 409, "prediction": "0", "true_label": "0", "raw_text": "SID_AudioInputDeviceCategory };\n\n    const char *devtypename = (devtype == VideoDevice) ? \"video\" : \"audio\";\n\n\n\n    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],\n\n                                             (IEnumMoniker **) &classenum, 0);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate %s devices.\\n\",\n\n               devtypename);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {\n\n        IPropertyBag *bag = NULL;\n\n        char *buf = NULL;\n\n        VARIANT var;\n\n\n\n        r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        var.vt = VT_BSTR;\n\n        r = IPropertyBag_Read(bag, L\"FriendlyName\", &var, NULL);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        buf = dup_wchar_to_utf8(var.bstrVal);\n\n\n\n        if (pfilter) {\n\n            if (strcmp(device_name, buf))\n\n                goto fail1;\n\n\n\n            if (!skip--)\n\n                IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);\n\n        } else {\n\n            av_log(avctx, AV_LOG_INFO, \" \\\"%s\\\"\\n\", buf);\n\n        }\n\n\n\nfail1:\n\n        if (buf)\n\n            av_free(buf);\n\n        if (bag)\n\n            IPropertyBag_Release(bag);\n\n        IMoniker_Release(m);\n\n    }\n\n\n\n    IEnumMoniker_Release(classenum);\n\n\n\n    if (pfilter) {\n\n        if (!device_filter) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not find %s device.\\n\",\n\n                   devtypename);\n\n            return AVERROR(EIO);\n\n        }\n\n        *pfilter = device_filter;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 410, "prediction": "0", "true_label": "0", "raw_text": ", and users using the new API should not be forced to\n\n    // even know about this field.\n\n    avctx->refcounted_frames = 1;\n\n\n\n    // Some codecs (at least wma lossless) will crash when feeding drain packets\n\n    // after EOF was signaled.\n\n    if (avctx->internal->draining_done)\n\n        return AVERROR_EOF;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))\n\n            ret = pkt->size;\n\n    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n    } else {\n\n        ret = AVERROR(EINVAL);\n\n    }\n\n\n\n    if (ret == AVERROR(EAGAIN))\n\n        ret = pkt->size;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->internal->draining && !got_frame)\n\n        avctx->internal->draining_done = 1;\n\n\n\n    if (ret >= pkt->size) {\n\n        av_packet_unref(avctx->internal->buffer_pkt);\n\n    } else {\n\n        int consumed = ret;\n\n\n\n        if (pkt != avctx->internal->buffer_pkt) {\n\n            av_packet_unref(avctx->internal->buffer_pkt);\n\n            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        avctx->internal->buffer_pkt->data += consumed;\n\n        avctx->internal->buffer_pkt->size -= consumed;\n\n        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;\n\n        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    if (got_frame)\n\n        av_assert0(avctx->internal->buffer_frame->buf[0]);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 411, "prediction": "0", "true_label": "0", "raw_text": "Question: void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n\n\n    vlan = qemu_find_vlan(vlan_id);\n\n\n\n   for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n\n        if (!strcmp(vc->name, device))\n\n            break;\n\n\n\n    if (!vc) {\n\n        monitor_printf(mon, \"can't find device %s\\n\", device);\n\n        return;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 412, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vfio_bar_write(void *opaque, hwaddr addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    VFIOBAR *bar = opaque;\n\n    union {\n\n        uint8_t byte;\n\n        uint16_t word;\n\n        uint32_t dword;\n\n        uint64_t qword;\n\n    } buf;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf.byte = data;\n\n        break;\n\n    case 2:\n\n        buf.word = cpu_to_le16(data);\n\n        break;\n\n    case 4:\n\n        buf.dword = cpu_to_le32(data);\n\n        break;\n\n    default:\n\n        hw_error(\"vfio: unsupported write size, %d bytes\\n\", size);\n\n        break;\n\n    }\n\n\n\n    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {\n\n        error_report(\"%s(,0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d) failed: %m\",\n\n                     __func__, addr, data, size);\n\n    }\n\n\n\n    DPRINTF(\"%s(BAR%d+0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d)\\n\",\n\n            __func__, bar->nr, addr, data, size);\n\n\n\n    /*\n\n     * A read or write to a BAR always signals an INTx EOI.  This will\n\n     * do nothing if not pending (including not in INTx mode).  We assume\n\n     * that a BAR access is in response to an interrupt and that BAR\n\n     * accesses will service the interrupt.  Unfortunately, we don't know\n\n     * which access will service the interrupt, so we're potentially\n\n     * getting quite a few host interrupts per guest interrupt.\n\n     */\n\n    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 413, "prediction": "0", "true_label": "0", "raw_text": " */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, ELF_MACHINE, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 414, "prediction": "0", "true_label": "0", "raw_text": "Question: static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    if (ap == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_ESCAPE);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"%p\")) {\n\n        return va_arg(*ap, QObject *);\n\n    } else if (!strcmp(val, \"%i\")) {\n\n        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%ld\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (!strcmp(val, \"%lld\") ||\n\n               !strcmp(val, \"%I64d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (!strcmp(val, \"%s\")) {\n\n        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (!strcmp(val, \"%f\")) {\n\n        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    }\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 415, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline uint64_t ldq_phys_internal(hwaddr addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 416, "prediction": "0", "true_label": "0", "raw_text": "Question: void main_loop_wait(int nonblocking)\n\n{\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n    int timeout;\n\n\n\n    if (nonblocking)\n\n        timeout = 0;\n\n    else {\n\n        timeout = qemu_calculate_timeout();\n\n        qemu_bh_update_timeout(&timeout);\n\n    }\n\n\n\n    os_host_main_loop_wait(&timeout);\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    qemu_run_all_timers();\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 417, "prediction": "0", "true_label": "1", "raw_text": "Question: void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 418, "prediction": "0", "true_label": "1", "raw_text": " syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n\n    state = new_set;\n\n    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n\n        if (*p == ' ')\n\n            continue;\n\n        else if (state == new_set && !strncmp(p, \"id=\", 3)) {\n\n            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));\n\n            if (mem == NULL)\n\n                return AVERROR(ENOMEM);\n\n            w->as = mem;\n\n            ++w->nb_as;\n\n            w->as[w->nb_as - 1].nb_streams = 0;\n\n            w->as[w->nb_as - 1].streams = NULL;\n\n            p += 3; // consume \"id=\"\n\n            q = w->as[w->nb_as - 1].id;\n\n            while (*p != ',') *q++ = *p++;\n\n            *q = 0;\n\n            p++;\n\n            state = parsed_id;\n\n        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {\n\n            p += 8; // consume \"streams=\"\n\n            state = parsing_streams;\n\n        } else if (state == parsing_streams) {\n\n            struct AdaptationSet *as = &w->as[w->nb_as - 1];\n\n            q = p;\n\n            while (*q != '\\0' && *q != ',' && *q != ' ') q++;\n\n            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n\n            if (as->streams == NULL)\n\n                return AVERROR(ENOMEM);\n\n            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n\n            if (as->streams[as->nb_streams - 1] < 0) return -1;\n\n            if (*q == '\\0') break;\n\n            if (*q == ' ') state = new_set;\n\n            p = ++q;\n\n        } else {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 419, "prediction": "-1", "true_label": "1", "raw_text": "Question: static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 420, "prediction": "0", "true_label": "0", "raw_text": "->coder->search_for_ms)\n\n                s->coder->search_for_ms(s, cpe, s->lambda);\n\n            adjust_frame_information(s, cpe, chans);\n\n            if (chans == 2) {\n\n                put_bits(&s->pb, 1, cpe->common_window);\n\n                if (cpe->common_window) {\n\n                    put_ics_info(s, &cpe->ch[0].ics);\n\n                    encode_ms_info(&s->pb, cpe);\n\n                }\n\n            }\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);\n\n            }\n\n            start_ch += chans;\n\n        }\n\n\n\n        frame_bits = put_bits_count(&s->pb);\n\n        if (frame_bits <= 6144 * avctx->channels - 3) {\n\n            s->psy.bitres.bits = frame_bits / avctx->channels;\n\n            break;\n\n        }\n\n\n\n        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;\n\n\n\n    } while (1);\n\n\n\n    put_bits(&s->pb, 3, TYPE_END);\n\n    flush_put_bits(&s->pb);\n\n    avctx->frame_bits = put_bits_count(&s->pb);\n\n\n\n    // rate control stuff\n\n    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {\n\n        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;\n\n        s->lambda *= ratio;\n\n        s->lambda = FFMIN(s->lambda, 65536.f);\n\n    }\n\n\n\n    if (!data)\n\n        s->last_frame = 1;\n\n    memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n           1024 * avctx->channels * sizeof(s->samples[0]));\n\n    return put_bits_count(&s->pb)>>3;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 421, "prediction": "0", "true_label": "0", "raw_text": "];\n\n    U = pic->data[1];\n\n    V = pic->data[2];\n\n\n\n    cur_y  = 0;\n\n    next_y = ref_slice_height;\n\n    for (slice = 0; slice < nslices; slice++) {\n\n        slice_size   = bytestream2_get_le32(&gb);\n\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n\n        if (slice_size > src_size - off) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n\n                   slice_size, src_size - off);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (slice_size <= 16) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\", slice_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n\n                   AV_RL32(src + off), slice_size - 16);\n\n        }\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n\n                             pic->linesize[0], pic->linesize[1],\n\n                             pic->linesize[2]);\n\n\n\n        Y += pic->linesize[0] *  slice_height;\n\n        U += pic->linesize[1] * (slice_height >> 1);\n\n        V += pic->linesize[2] * (slice_height >> 1);\n\n        off += slice_size;\n\n        cur_y   = next_y;\n\n        next_y += ref_slice_height;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 422, "prediction": "0", "true_label": "0", "raw_text": " outside the time borders table: %d\\n\",\n\n               bs_pointer);\n\n        return -1;\n\n    }\n\n\n\n    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;\n\n\n\n    ch_data->t_q[0]                     = ch_data->t_env[0];\n\n    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];\n\n    if (ch_data->bs_num_noise > 1) {\n\n        unsigned int idx;\n\n        if (ch_data->bs_frame_class == FIXFIX) {\n\n            idx = ch_data->bs_num_env >> 1;\n\n        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR\n\n            idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);\n\n        } else { // VARFIX\n\n            if (!bs_pointer)\n\n                idx = 1;\n\n            else if (bs_pointer == 1)\n\n                idx = ch_data->bs_num_env - 1;\n\n            else // bs_pointer > 1\n\n                idx = bs_pointer - 1;\n\n        }\n\n        ch_data->t_q[1] = ch_data->t_env[idx];\n\n    }\n\n\n\n    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev\n\n    ch_data->e_a[1] = -1;\n\n    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0\n\n        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;\n\n    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1\n\n        ch_data->e_a[1] = bs_pointer - 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 423, "prediction": "0", "true_label": "0", "raw_text": "HCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);\n\n        return TD_RESULT_STOP_FRAME;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_IOERROR:\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n            trace_usb_uhci_packet_complete_error(async->queue->token,\n\n                                                 async->td);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return TD_RESULT_NEXT_QH;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 424, "prediction": "0", "true_label": "0", "raw_text": "_dump_state(FILE *f)\n\n{\n\n    int eflags;\n\n    char cc_op_name[32];\n\n    eflags = cc_table[CC_OP].compute_all();\n\n    eflags |= (DF & DF_MASK);\n\n    if ((unsigned)env->cc_op < CC_OP_NB)\n\n        strcpy(cc_op_name, cc_op_str[env->cc_op]);\n\n    else\n\n        snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n    fprintf(f, \n\n            \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\"\n\n            \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\"\n\n            \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\"\n\n            \"EIP=%08x\\n\",\n\n            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], \n\n            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], \n\n            env->cc_src, env->cc_dst, cc_op_name,\n\n            eflags & DF_MASK ? 'D' : '-',\n\n            eflags & CC_O ? 'O' : '-',\n\n            eflags & CC_S ? 'S' : '-',\n\n            eflags & CC_Z ? 'Z' : '-',\n\n            eflags & CC_A ? 'A' : '-',\n\n            eflags & CC_P ? 'P' : '-',\n\n            eflags & CC_C ? 'C' : '-',\n\n            env->eip);\n\n#if 1\n\n    fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", \n\n            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 425, "prediction": "0", "true_label": "0", "raw_text": " | AV_RB24(spal);\n\n        spal += 3;\n\n    }\n\n    for(; i < 256; i++)\n\n        s->image_palette[i] = (0xffu << 24);\n\n    /* handle transparency */\n\n    if (s->transparent_color_index >= 0)\n\n        s->image_palette[s->transparent_color_index] = 0;\n\n\n\n    /* now get the image data */\n\n    code_size = bytestream_get_byte(&s->bytestream);\n\n    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,\n\n                       s->bytestream_end - s->bytestream, FF_LZW_GIF);\n\n\n\n    /* read all the image */\n\n    linesize = s->picture.linesize[0];\n\n    ptr1 = s->picture.data[0] + top * linesize + left;\n\n    ptr = ptr1;\n\n    pass = 0;\n\n    y1 = 0;\n\n    for (y = 0; y < height; y++) {\n\n        ff_lzw_decode(s->lzw, ptr, width);\n\n        if (is_interleaved) {\n\n            switch(pass) {\n\n            default:\n\n            case 0:\n\n            case 1:\n\n                y1 += 8;\n\n                ptr += linesize * 8;\n\n                if (y1 >= height) {\n\n                    y1 = pass ? 2 : 4;\n\n                    ptr = ptr1 + linesize * y1;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 2:\n\n                y1 += 4;\n\n                ptr += linesize * 4;\n\n                if (y1 >= height) {\n\n                    y1 = 1;\n\n                    ptr = ptr1 + linesize;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 3:\n\n                y1 += 2;\n\n                ptr += linesize * 2;\n\n                break;\n\n            }\n\n        } else {\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    /* read the garbage data until end marker is found */\n\n    ff_lzw_decode_tail(s->lzw);\n\n    s->bytestream = ff_lzw_cur_ptr(s->lzw);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 426, "prediction": "0", "true_label": "0", "raw_text": "Question: static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                             int buf_size, void *data)\n\n{\n\n    AlacEncodeContext *s = avctx->priv_data;\n\n    PutBitContext *pb = &s->pbctx;\n\n    int i, out_bytes, verbatim_flag = 0;\n\n\n\n    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"input frame size exceeded\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (buf_size < 2 * s->max_coded_frame_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"buffer size is too small\\n\");\n\n        return -1;\n\n    }\n\n\n\nverbatim:\n\n    init_put_bits(pb, frame, buf_size);\n\n\n\n    if (s->compression_level == 0 || verbatim_flag) {\n\n        // Verbatim mode\n\n        const int16_t *samples = data;\n\n        write_frame_header(s, 1);\n\n        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {\n\n            put_sbits(pb, 16, *samples++);\n\n        }\n\n    } else {\n\n        init_sample_buffers(s, data);\n\n        write_frame_header(s, 0);\n\n        write_compressed_frame(s);\n\n    }\n\n\n\n    put_bits(pb, 3, 7);\n\n    flush_put_bits(pb);\n\n    out_bytes = put_bits_count(pb) >> 3;\n\n\n\n    if (out_bytes > s->max_coded_frame_size) {\n\n        /* frame too large. use verbatim mode */\n\n        if (verbatim_flag || s->compression_level == 0) {\n\n            /* still too large. must be an error. */\n\n            av_log(avctx, AV_LOG_ERROR, \"error encoding frame\\n\");\n\n            return -1;\n\n        }\n\n        verbatim_flag = 1;\n\n        goto verbatim;\n\n    }\n\n\n\n    return out_bytes;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 427, "prediction": "0", "true_label": "1", "raw_text": "Question: static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 428, "prediction": "0", "true_label": "1", "raw_text": " %d\",\n\n                 le32_to_cpu(header.version));\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                bs->device_name, \"vmdk\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)\n\n                        * le64_to_cpu(header.granularity);\n\n    if (l1_entry_sectors == 0) {\n\n        return -EINVAL;\n\n    }\n\n    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)\n\n                / l1_entry_sectors;\n\n    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {\n\n        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;\n\n    }\n\n    extent = vmdk_add_extent(bs, file, false,\n\n                          le64_to_cpu(header.capacity),\n\n                          le64_to_cpu(header.gd_offset) << 9,\n\n                          l1_backup_offset,\n\n                          l1_size,\n\n                          le32_to_cpu(header.num_gtes_per_gte),\n\n                          le64_to_cpu(header.granularity));\n\n    extent->compressed =\n\n        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;\n\n    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;\n\n    extent->version = le32_to_cpu(header.version);\n\n    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;\n\n    ret = vmdk_init_tables(bs, extent);\n\n    if (ret) {\n\n        /* free extent allocated by vmdk_add_extent */\n\n        vmdk_free_last_extent(bs);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 429, "prediction": "0", "true_label": "1", "raw_text": "Question: static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 430, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 431, "prediction": "0", "true_label": "0", "raw_text": "{\n\n    OutputFile    *of = output_files[ost->file_index];\n\n    AVFrame *filtered_frame = NULL;\n\n    int frame_size, ret;\n\n\n\n    if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n\n        return AVERROR(ENOMEM);\n\n    } else\n\n        avcodec_get_frame_defaults(ost->filtered_frame);\n\n    filtered_frame = ost->filtered_frame;\n\n\n\n    if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&\n\n        !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))\n\n        ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame,\n\n                                         ost->st->codec->frame_size);\n\n    else\n\n        ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame);\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (filtered_frame->pts != AV_NOPTS_VALUE) {\n\n        filtered_frame->pts = av_rescale_q(filtered_frame->pts,\n\n                                           ost->filter->filter->inputs[0]->time_base,\n\n                                           ost->st->codec->time_base) -\n\n                              av_rescale_q(of->start_time,\n\n                                           AV_TIME_BASE_Q,\n\n                                           ost->st->codec->time_base);\n\n    }\n\n\n\n    switch (ost->filter->filter->inputs[0]->type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (!ost->frame_aspect_ratio)\n\n            ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;\n\n\n\n        do_video_out(of->ctx, ost, filtered_frame, &frame_size);\n\n        if (vstats_filename && frame_size)\n\n            do_video_stats(ost, frame_size);\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        do_audio_out(of->ctx, ost, filtered_frame);\n\n        break;\n\n    default:\n\n        // TODO support subtitle filters\n\n        av_assert0(0);\n\n    }\n\n\n\n    av_frame_unref(filtered_frame);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 432, "prediction": "0", "true_label": "0", "raw_text": "Question: void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 433, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 434, "prediction": "0", "true_label": "0", "raw_text": "Question: void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 435, "prediction": "0", "true_label": "1", "raw_text": "mm3, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"psrlq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $3, %%mm3    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %2, %%mm3    \\n\\t\"\n\n            \"psrlq         $6, %%mm1    \\n\\t\"\n\n            \"psrlq         $6, %%mm4    \\n\\t\"\n\n            \"pand       %%mm6, %%mm1    \\n\\t\"\n\n            \"pand       %%mm6, %%mm4    \\n\\t\"\n\n            \"psrlq         $9, %%mm2    \\n\\t\"\n\n            \"psrlq         $9, %%mm5    \\n\\t\"\n\n            \"pand       %%mm7, %%mm2    \\n\\t\"\n\n            \"pand       %%mm7, %%mm5    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n            \"psllq        $16, %%mm3    \\n\\t\"\n\n            \"por        %%mm3, %%mm0    \\n\\t\"\n\n            MOVNTQ\"     %%mm0, %0       \\n\\t\"\n\n            :\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\n\n        d += 4;\n\n        s += 12;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        const int b = *s++;\n\n        const int g = *s++;\n\n        const int r = *s++;\n\n        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 436, "prediction": "0", "true_label": "1", "raw_text": " - s->last_x);\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);\n\n        qemu_input_event_sync();\n\n    }\n\n    s->last_x = x;\n\n    s->last_y = y;\n\n\n\n    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {\n\n        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);\n\n        int x = (int)motion->x_root;\n\n        int y = (int)motion->y_root;\n\n\n\n        /* In relative mode check to see if client pointer hit\n\n         * one of the screen edges, and if so move it back by\n\n         * 200 pixels. This is important because the pointer\n\n         * in the server doesn't correspond 1-for-1, and so\n\n         * may still be only half way across the screen. Without\n\n         * this warp, the server pointer would thus appear to hit\n\n         * an invisible wall */\n\n        if (x == 0) {\n\n            x += 200;\n\n        }\n\n        if (y == 0) {\n\n            y += 200;\n\n        }\n\n        if (x == (gdk_screen_get_width(screen) - 1)) {\n\n            x -= 200;\n\n        }\n\n        if (y == (gdk_screen_get_height(screen) - 1)) {\n\n            y -= 200;\n\n        }\n\n\n\n        if (x != (int)motion->x_root || y != (int)motion->y_root) {\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);\n\n            gdk_device_warp(dev, screen, x, y);\n\n#else\n\n            GdkDisplay *display = gtk_widget_get_display(widget);\n\n            gdk_display_warp_pointer(display, screen, x, y);\n\n#endif\n\n            s->last_x = -1;\n\n            s->last_y = -1;\n\n            return FALSE;\n\n        }\n\n    }\n\n    return TRUE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 437, "prediction": "0", "true_label": "0", "raw_text": "QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        decoder_query_caps = func;\n\n\n\n    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,\n\n                                &max_mb, &max_width, &max_height);\n\n#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE\n\n    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {\n\n        profile = VDP_DECODER_PROFILE_H264_MAIN;\n\n        status = decoder_query_caps(vdctx->device, profile, &supported,\n\n                                    &max_level, &max_mb,\n\n                                    &max_width, &max_height);\n\n    }\n\n#endif\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n\n\n    if (supported != VDP_TRUE || max_level < level ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        create = func;\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        vdctx->render = func;\n\n\n\n    status = create(vdctx->device, profile, width, height, avctx->refs,\n\n                    &vdctx->decoder);\n\n    if (status == VDP_STATUS_OK) {\n\n        vdctx->width  = avctx->coded_width;\n\n        vdctx->height = avctx->coded_height;\n\n    }\n\n\n\n    return vdpau_error(status);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 438, "prediction": "0", "true_label": "1", "raw_text": "Question: static int estimate_qp(MpegEncContext *s, int dry_run){\n\n    if (s->next_lambda){\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = s->next_lambda;\n\n        if(!dry_run) s->next_lambda= 0;\n\n    } else if (!s->fixed_qscale) {\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);\n\n        if (s->current_picture.f.quality < 0)\n\n            return -1;\n\n    }\n\n\n\n    if(s->adaptive_quant){\n\n        switch(s->codec_id){\n\n        case AV_CODEC_ID_MPEG4:\n\n            if (CONFIG_MPEG4_ENCODER)\n\n                ff_clean_mpeg4_qscales(s);\n\n            break;\n\n        case AV_CODEC_ID_H263:\n\n        case AV_CODEC_ID_H263P:\n\n        case AV_CODEC_ID_FLV1:\n\n            if (CONFIG_H263_ENCODER)\n\n                ff_clean_h263_qscales(s);\n\n            break;\n\n        default:\n\n            ff_init_qscale_tab(s);\n\n        }\n\n\n\n        s->lambda= s->lambda_table[0];\n\n        //FIXME broken\n\n    }else\n\n        s->lambda = s->current_picture.f.quality;\n\n    update_qscale(s);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 439, "prediction": "0", "true_label": "0", "raw_text": "Question: static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 440, "prediction": "0", "true_label": "0", "raw_text": "kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {\n\n        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    argsz = sizeof(*irq_set) + sizeof(*pfd);\n\n\n\n    irq_set = g_malloc0(argsz);\n\n    irq_set->argsz = argsz;\n\n    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;\n\n    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;\n\n    irq_set->start = 0;\n\n    irq_set->count = 1;\n\n    pfd = (int32_t *)&irq_set->data;\n\n\n\n    *pfd = irqfd.resamplefd;\n\n\n\n    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);\n\n    g_free(irq_set);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");\n\n        goto fail_vfio;\n\n    }\n\n\n\n    /* Let'em rip */\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n\n\n    vdev->intx.kvm_accel = true;\n\n\n\n    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);\n\n\n\n    return;\n\n\n\nfail_vfio:\n\n    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;\n\n    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);\n\nfail_irqfd:\n\n    event_notifier_cleanup(&vdev->intx.unmask);\n\nfail:\n\n    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 441, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_evfsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 442, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerGState *s = (IMXTimerGState *)opaque;\n\n\n\n    DPRINTF(\"g-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\" cr = %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* prescaler */\n\n        DPRINTF(\" pr = %x\\n\", s->pr);\n\n        return s->pr;\n\n\n\n    case 2: /* Status Register */\n\n        DPRINTF(\" sr = %x\\n\", s->sr);\n\n        return s->sr;\n\n\n\n    case 3: /* Interrupt Register */\n\n        DPRINTF(\" ir = %x\\n\", s->ir);\n\n        return s->ir;\n\n\n\n    case 4: /* Output Compare Register 1 */\n\n        DPRINTF(\" ocr1 = %x\\n\", s->ocr1);\n\n        return s->ocr1;\n\n\n\n\n\n    case 9: /* cnt */\n\n        imx_timerg_update_counts(s);\n\n        DPRINTF(\" cnt = %x\\n\", s->cnt);\n\n        return s->cnt;\n\n    }\n\n\n\n    IPRINTF(\"imx_timerg_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 443, "prediction": "1", "true_label": "0", "raw_text": " *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    s->config_file = g_strdup(qemu_opt_get(opts, \"config\"));\n\n    ret = read_config(s, s->config_file, options, errp);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the image file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    bs->supported_write_flags = BDRV_REQ_FUA &\n\n        bs->file->bs->supported_write_flags;\n\n    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &\n\n        bs->file->bs->supported_zero_flags;\n\n    ret = -EINVAL;\n\n\n\n    /* Set request alignment */\n\n    s->align = qemu_opt_get_size(opts, \"align\", 0);\n\n    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {\n\n        error_setg(errp, \"Cannot meet constraints with align %\" PRIu64,\n\n                   s->align);\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (ret < 0) {\n\n        g_free(s->config_file);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 444, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_qemu_strtoull_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 18446744073709551295LLU);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 445, "prediction": "0", "true_label": "0", "raw_text": "IMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];\n\n    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;\n\n    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;\n\n    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:\n\n        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;\n\n    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:\n\n        w = (offset - FIMD_PAL_MEM_START) >> 10;\n\n        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:\n\n        /* Palette aliases for win 0,1 */\n\n        w = (offset - FIMD_PALMEM_AL_START) >> 10;\n\n        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    }\n\n\n\n    DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n    return 0xBAADBAAD;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 446, "prediction": "0", "true_label": "0", "raw_text": "Question: float64 HELPER(ucf64_absd)(float64 a)\n\n{\n\n    return float64_abs(a);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 447, "prediction": "0", "true_label": "0", "raw_text": "Question: static CharDriverState *qemu_chr_open_null(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ChardevCommon *common = backend->u.null;\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 448, "prediction": "0", "true_label": "0", "raw_text": "Question: static int packet_enqueue(CompareState *s, int mode)\n\n{\n\n    ConnectionKey key;\n\n    Packet *pkt = NULL;\n\n    Connection *conn;\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        pkt = packet_new(s->pri_rs.buf,\n\n                         s->pri_rs.packet_len,\n\n                         s->pri_rs.vnet_hdr_len);\n\n    } else {\n\n        pkt = packet_new(s->sec_rs.buf,\n\n                         s->sec_rs.packet_len,\n\n                         s->sec_rs.vnet_hdr_len);\n\n    }\n\n\n\n    if (parse_packet_early(pkt)) {\n\n        packet_destroy(pkt, NULL);\n\n        pkt = NULL;\n\n        return -1;\n\n    }\n\n    fill_connection_key(pkt, &key);\n\n\n\n    conn = connection_get(s->connection_track_table,\n\n                          &key,\n\n                          &s->conn_list);\n\n\n\n    if (!conn->processing) {\n\n        g_queue_push_tail(&s->conn_list, conn);\n\n        conn->processing = true;\n\n    }\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        if (!colo_insert_packet(&conn->primary_list, pkt)) {\n\n            error_report(\"colo compare primary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    } else {\n\n        if (!colo_insert_packet(&conn->secondary_list, pkt)) {\n\n            error_report(\"colo compare secondary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 449, "prediction": "1", "true_label": "0", "raw_text": "Question: enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)\n\n{\n\n    int i;\n\n    for(i=0; i<4 && tags[i]; i++){\n\n        enum CodecID id= codec_get_id(tags[i], tag);\n\n        if(id!=CODEC_ID_NONE) return id;\n\n    }\n\n    return CODEC_ID_NONE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 450, "prediction": "0", "true_label": "0", "raw_text": "62, 7);  /* single word dma0-2 supported */\n\n    put_le16(p + 63, 7);  /* mdma0-2 supported */\n\n#else\n\n    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */\n\n    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */\n\n#endif\n\n    put_le16(p + 64, 3); /* pio3-4 supported */\n\n    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */\n\n    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */\n\n    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */\n\n    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */\n\n\n\n    put_le16(p + 71, 30); /* in ns */\n\n    put_le16(p + 72, 30); /* in ns */\n\n\n\n    if (s->ncq_queues) {\n\n        put_le16(p + 75, s->ncq_queues - 1);\n\n        /* NCQ supported */\n\n        put_le16(p + 76, (1 << 8));\n\n    }\n\n\n\n    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */\n\n#endif\n\n    memcpy(s->identify_data, p, sizeof(s->identify_data));\n\n    s->identify_set = 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 451, "prediction": "0", "true_label": "0", "raw_text": "Question: static int kvm_put_xsave(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XSAVE\n\n    int i, r;\n\n    struct kvm_xsave* xsave;\n\n    uint16_t cwd, swd, twd, fop;\n\n\n\n    if (!kvm_has_xsave())\n\n        return kvm_put_fpu(env);\n\n\n\n    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    memset(xsave, 0, sizeof(struct kvm_xsave));\n\n    cwd = swd = twd = fop = 0;\n\n    swd = env->fpus & ~(7 << 11);\n\n    swd |= (env->fpstt & 7) << 11;\n\n    cwd = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n        twd |= (!env->fptags[i]) << i;\n\n    xsave->region[0] = (uint32_t)(swd << 16) + cwd;\n\n    xsave->region[1] = (uint32_t)(fop << 16) + twd;\n\n    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n\n            sizeof env->fpregs);\n\n    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n\n            sizeof env->xmm_regs);\n\n    xsave->region[XSAVE_MXCSR] = env->mxcsr;\n\n    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;\n\n    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n\n            sizeof env->ymmh_regs);\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);\n\n    qemu_free(xsave);\n\n    return r;\n\n#else\n\n    return kvm_put_fpu(env);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 452, "prediction": "0", "true_label": "1", "raw_text": "\telse\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\n\n#define SIMPLE_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 453, "prediction": "0", "true_label": "1", "raw_text": "Question: build_tpm2(GArray *table_data, BIOSLinker *linker)\n\n{\n\n    Acpi20TPM2 *tpm2_ptr;\n\n\n\n    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);\n\n\n\n    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);\n\n    tpm2_ptr->control_area_address = cpu_to_le64(0);\n\n    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tpm2_ptr, \"TPM2\", sizeof(*tpm2_ptr), 4, NULL, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 454, "prediction": "0", "true_label": "1", "raw_text": " i;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* wait for more frames before output */\n\n        if (!flush && s->seq_output == s->seq_decode && s->sps &&\n\n            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics)\n\n            return 0;\n\n\n\n        if (nb_output) {\n\n            HEVCFrame *frame = &s->DPB[min_idx];\n\n            AVFrame *dst = out;\n\n            AVFrame *src = frame->frame;\n\n            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);\n\n            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);\n\n\n\n            ret = av_frame_ref(out, src);\n\n            if (frame->flags & HEVC_FRAME_FLAG_BUMPING)\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);\n\n            else\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < 3; i++) {\n\n                int hshift = (i > 0) ? desc->log2_chroma_w : 0;\n\n                int vshift = (i > 0) ? desc->log2_chroma_h : 0;\n\n                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +\n\n                          (frame->window.top_offset   >> vshift) * dst->linesize[i];\n\n                dst->data[i] += off;\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"Output frame with POC %d.\\n\", frame->poc);\n\n            return 1;\n\n        }\n\n\n\n        if (s->seq_output != s->seq_decode)\n\n            s->seq_output = (s->seq_output + 1) & 0xff;\n\n        else\n\n            break;\n\n    } while (1);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 455, "prediction": "0", "true_label": "0", "raw_text": " (header1 & SAME_HEADER_MASK)) {\n\n                        /* header found: update pointers */\n\n                        len = (p + 4) - s->inbuf_ptr;\n\n                        buf_ptr += len;\n\n                        buf_size -= len;\n\n                        s->inbuf_ptr = p;\n\n                        /* compute frame size */\n\n                        s->free_format_next_header = header;\n\n                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;\n\n                        padding = (header1 >> 9) & 1;\n\n                        if (s->layer == 1)\n\n                            s->free_format_frame_size -= padding * 4;\n\n                        else\n\n                            s->free_format_frame_size -= padding;\n\n                        dprintf(\"free frame size=%d padding=%d\\n\", \n\n                                s->free_format_frame_size, padding);\n\n                        decode_header(s, header1);\n\n                        goto next_data;\n\n                    }\n\n                    p++;\n\n                }\n\n                /* not found: simply increase pointers */\n\n                buf_ptr += len;\n\n                s->inbuf_ptr += len;\n\n                buf_size -= len;\n\n            }\n\n\t} else \n\n#endif\n\n        if (len < s->frame_size) {\n\n            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)\n\n                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;\n\n\t    len = s->frame_size - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    memcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t    buf_ptr += len;\n\n\t    s->inbuf_ptr += len;\n\n\t    buf_size -= len;\n\n\t}\n\n        //    next_data:\n\n        if (s->frame_size > 0 && \n\n            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n\n            *poutbuf = s->inbuf;\n\n            *poutbuf_size = s->inbuf_ptr - s->inbuf;\n\n\t    s->inbuf_ptr = s->inbuf;\n\n\t    s->frame_size = 0;\n\n\t    break;\n\n\t}\n\n    }\n\n    return buf_ptr - buf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 456, "prediction": "0", "true_label": "0", "raw_text": "_attach_env(int *attached, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n    JNIEnv *env = NULL;\n\n\n\n    *attached = 0;\n\n\n\n    pthread_mutex_lock(&lock);\n\n    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {\n\n\n\n        av_log(log_ctx, AV_LOG_INFO, \"Retrieving current Java virtual machine using Android JniInvocation wrapper\\n\");\n\n        if (check_jni_invocation(log_ctx) == 0) {\n\n            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libdvm.so\", log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libart.so\", log_ctx)) != NULL) {\n\n                av_log(log_ctx, AV_LOG_INFO, \"Found Java virtual machine using Android JniInvocation wrapper\\n\");\n\n            }\n\n        }\n\n    }\n\n    pthread_mutex_unlock(&lock);\n\n\n\n    if (!java_vm) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not retrieve a Java virtual machine\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);\n\n    switch(ret) {\n\n    case JNI_EDETACHED:\n\n        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Failed to attach the JNI environment to the current thread\\n\");\n\n            env = NULL;\n\n        } else {\n\n            *attached = 1;\n\n        }\n\n        break;\n\n    case JNI_OK:\n\n        break;\n\n    case JNI_EVERSION:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"The specified JNI version is not supported\\n\");\n\n        break;\n\n    default:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Failed to get the JNI environment attached to this thread\");\n\n        break;\n\n    }\n\n\n\n    return env;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 457, "prediction": "0", "true_label": "1", "raw_text": " (m->data_qiov) {\n\n        qemu_iovec_reset(&qiov);\n\n        if (start->nb_bytes) {\n\n            qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        }\n\n        qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes);\n\n        if (end->nb_bytes) {\n\n            qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        }\n\n        /* NOTE: we have a write_aio blkdebug event here followed by\n\n         * a cow_write one in do_perform_cow_write(), but there's only\n\n         * one single I/O operation */\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n    } else {\n\n        /* If there's no guest data then write both COW regions separately */\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov);\n\n    }\n\n\n\nfail:\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    /*\n\n     * Before we update the L2 table to actually point to the new cluster, we\n\n     * need to be sure that the refcounts have been increased and COW was\n\n     * handled.\n\n     */\n\n    if (ret == 0) {\n\n        qcow2_cache_depends_on_flush(s->l2_table_cache);\n\n    }\n\n\n\n    qemu_vfree(start_buffer);\n\n    qemu_iovec_destroy(&qiov);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 458, "prediction": "0", "true_label": "0", "raw_text": "Question: void sws_rgb2rgb_init(int flags)\n\n{\n\n#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX\n\n    if (flags & SWS_CPU_CAPS_SSE2)\n\n        rgb2rgb_init_SSE2();\n\n    else if (flags & SWS_CPU_CAPS_MMX2)\n\n        rgb2rgb_init_MMX2();\n\n    else if (flags & SWS_CPU_CAPS_3DNOW)\n\n        rgb2rgb_init_3DNOW();\n\n    else if (flags & SWS_CPU_CAPS_MMX)\n\n        rgb2rgb_init_MMX();\n\n    else\n\n#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */\n\n        rgb2rgb_init_C();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 459, "prediction": "0", "true_label": "0", "raw_text": "Question: static double tget_double(GetByteContext *gb, int le)\n\n{\n\n    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};\n\n    return i.f64;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 460, "prediction": "0", "true_label": "1", "raw_text": "_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); /* TOFIX */\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc970_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 461, "prediction": "1", "true_label": "1", "raw_text": "Question: static int64_t get_bit_rate(AVCodecContext *ctx)\n\n{\n\n    int64_t bit_rate;\n\n    int bits_per_sample;\n\n\n\n    switch (ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n    case AVMEDIA_TYPE_DATA:\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n    case AVMEDIA_TYPE_ATTACHMENT:\n\n        bit_rate = ctx->bit_rate;\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n\n        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;\n\n        break;\n\n    default:\n\n        bit_rate = 0;\n\n        break;\n\n    }\n\n    return bit_rate;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 462, "prediction": "0", "true_label": "0", "raw_text": " 0);\n\n            }\n\n            avio_write(dyn_cp, par->extradata, par->extradata_size);\n\n        } else {\n\n            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))\n\n                av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,\n\n                                                  par->codec_id);\n\n            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n                av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n                ret = AVERROR(EINVAL);\n\n            }\n\n\n\n            ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0);\n\n        }\n\n    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        unsigned int tag;\n\n        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);\n\n        if (!tag) {\n\n            av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",\n\n                   avcodec_get_name(par->codec_id));\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n        if (!par->codec_tag)\n\n            par->codec_tag = tag;\n\n\n\n        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);\n\n    }\n\n\n\n    codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv);\n\n    if (codecpriv_size)\n\n        put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,\n\n                        codecpriv_size);\n\n    av_free(codecpriv);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 463, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n\n    int i, dc = (block[0] + 15) >> 5;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += line_size;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 464, "prediction": "1", "true_label": "1", "raw_text": "Question: void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 465, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int mirror(int v, int m){\n\n    if     (v<0) return -v;\n\n    else if(v>m) return 2*m-v;\n\n    else         return v;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 466, "prediction": "0", "true_label": "1", "raw_text": "Question: void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)\n\n{\n\n    if (!s->started) {\n\n        return;\n\n    }\n\n    s->started = false;\n\n    trace_virtio_blk_data_plane_stop(s);\n\n\n\n    /* Stop thread or cancel pending thread creation BH */\n\n    if (s->start_bh) {\n\n        qemu_bh_delete(s->start_bh);\n\n        s->start_bh = NULL;\n\n    } else {\n\n        event_poll_notify(&s->event_poll);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    ioq_cleanup(&s->ioqueue);\n\n\n\n    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);\n\n\n\n    event_poll_cleanup(&s->event_poll);\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);\n\n\n\n    vring_teardown(&s->vring);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 467, "prediction": "0", "true_label": "1", "raw_text": "rotation == 270) {\n\n        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);\n\n\n    } else {\n\n        write_matrix(pb,  1,  0,  0,  1, 0, 0);\n\n    }\n\n    /* Track width and height, for visual only */\n\n    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {\n\n        int64_t track_width_1616;\n\n        if (track->mode == MODE_MOV) {\n\n            track_width_1616 = track->par->width * 0x10000ULL;\n\n        } else {\n\n            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,\n\n                                                  track->par->width * 0x10000LL,\n\n                                                  st->sample_aspect_ratio.den);\n\n            if (!track_width_1616 ||\n\n                track->height != track->par->height ||\n\n                track_width_1616 > UINT32_MAX)\n\n                track_width_1616 = track->par->width * 0x10000ULL;\n\n        }\n\n        if (track_width_1616 > UINT32_MAX) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track width is too large\\n\");\n\n            track_width_1616 = 0;\n\n        }\n\n        avio_wb32(pb, track_width_1616);\n\n        if (track->height > 0xFFFF) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track height is too large\\n\");\n\n            avio_wb32(pb, 0);\n\n        } else\n\n            avio_wb32(pb, track->height * 0x10000U);\n\n    } else {\n\n        avio_wb32(pb, 0);\n\n        avio_wb32(pb, 0);\n\n    }\n\n    return 0x5c;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 468, "prediction": "-1", "true_label": "1", "raw_text": "Question: static int vobsub_read_seek(AVFormatContext *s, int stream_index,\n\n                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)\n\n{\n\n    MpegDemuxContext *vobsub = s->priv_data;\n\n\n\n    /* Rescale requested timestamps based on the first stream (timebase is the\n\n     * same for all subtitles stream within a .idx/.sub). Rescaling is done just\n\n     * like in avformat_seek_file(). */\n\n    if (stream_index == -1 && s->nb_streams != 1) {\n\n        int i, ret = 0;\n\n        AVRational time_base = s->streams[0]->time_base;\n\n        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);\n\n        min_ts = av_rescale_rnd(min_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);\n\n        max_ts = av_rescale_rnd(max_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);\n\n        for (i = 0; i < s->nb_streams; i++) {\n\n            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,\n\n                                            min_ts, ts, max_ts, flags);\n\n            if (r < 0)\n\n                ret = r;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n\n\n    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,\n\n                                   min_ts, ts, max_ts, flags);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 469, "prediction": "0", "true_label": "0", "raw_text": "rate + 255) >> 8);\n\n            goto error;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH,\n\n                                       avctx->cutoff)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the encoder bandwidth to %d: %s\\n\",\n\n                   avctx->cutoff, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to initialize the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to get encoder info: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n#if FF_API_OLD_ENCODE_AUDIO\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto error;\n\n    }\n\n#endif\n\n    avctx->frame_size = info.frameLength;\n\n    avctx->delay      = info.encoderDelay;\n\n    ff_af_queue_init(avctx, &s->afq);\n\n\n\n    if (avctx->flags & CODEC_FLAG_GLOBAL_HEADER) {\n\n        avctx->extradata_size = info.confSize;\n\n        avctx->extradata      = av_mallocz(avctx->extradata_size +\n\n                                           FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto error;\n\n        }\n\n\n\n        memcpy(avctx->extradata, info.confBuf, info.confSize);\n\n    }\n\n    return 0;\n\nerror:\n\n    aac_encode_close(avctx);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 470, "prediction": "0", "true_label": "1", "raw_text": "_neigh_offs].x);\n\n        off = err / adx;\n\n        if (dy < 0) {\n\n            predicted = floor1_Y_final[low_neigh_offs] - off;\n\n        } else {\n\n            predicted = floor1_Y_final[low_neigh_offs] + off;\n\n        } // render_point end\n\n\n\n        val = floor1_Y[i];\n\n        highroom = range-predicted;\n\n        lowroom  = predicted;\n\n        if (highroom < lowroom) {\n\n            room = highroom * 2;\n\n        } else {\n\n            room = lowroom * 2;   // SPEC mispelling\n\n        }\n\n        if (val) {\n\n            floor1_flag[low_neigh_offs]  = 1;\n\n            floor1_flag[high_neigh_offs] = 1;\n\n            floor1_flag[i]               = 1;\n\n            if (val >= room) {\n\n                if (highroom > lowroom) {\n\n                    floor1_Y_final[i] = val - lowroom + predicted;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted - val + highroom - 1;\n\n                }\n\n            } else {\n\n                if (val & 1) {\n\n                    floor1_Y_final[i] = predicted - (val + 1) / 2;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted + val / 2;\n\n                }\n\n            }\n\n        } else {\n\n            floor1_flag[i]    = 0;\n\n            floor1_Y_final[i] = predicted;\n\n        }\n\n\n\n        av_dlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\",\n\n                vf->list[i].x, floor1_Y_final[i], val);\n\n    }\n\n\n\n// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?\n\n\n\n    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);\n\n\n\n    av_dlog(NULL, \" Floor decoded\\n\");\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 471, "prediction": "-1", "true_label": "1", "raw_text": ");\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 472, "prediction": "0", "true_label": "0", "raw_text": "0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 473, "prediction": "0", "true_label": "0", "raw_text": "Question: uint32_t wm8750_adc_dat(void *opaque)\n\n{\n\n    WM8750State *s = (WM8750State *) opaque;\n\n    uint32_t *data;\n\n\n\n    if (s->idx_in >= sizeof(s->data_in))\n\n        wm8750_in_load(s);\n\n\n\n    data = (uint32_t *) &s->data_in[s->idx_in];\n\n    s->req_in -= 4;\n\n    s->idx_in += 4;\n\n    return *data;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 474, "prediction": "0", "true_label": "0", "raw_text": "Question: static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 475, "prediction": "0", "true_label": "0", "raw_text": "Question: static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    struct video_data *s = s1->priv_data;\n\n    AVFrame *frame = s1->streams[0]->codec->coded_frame;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    int res;\n\n\n\n    av_init_packet(pkt);\n\n    if ((res = mmap_read_frame(s1, pkt)) < 0) {\n\n        return res;\n\n    }\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (frame && s->interlaced) {\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first = s->top_field_first;\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    return pkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 476, "prediction": "0", "true_label": "1", "raw_text": "Question: static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 477, "prediction": "0", "true_label": "0", "raw_text": "Question: static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)\n\n{\n\n    uint32_t v, spf;\n\n    MPADecodeHeader c;\n\n    int vbrtag_size = 0;\n\n    MP3DecContext *mp3 = s->priv_data;\n\n\n\n    ffio_init_checksum(s->pb, ff_crcA001_update, 0);\n\n\n\n    v = avio_rb32(s->pb);\n\n    if(ff_mpa_check_header(v) < 0)\n\n      return -1;\n\n\n\n    if (avpriv_mpegaudio_decode_header(&c, v) == 0)\n\n        vbrtag_size = c.frame_size;\n\n    if(c.layer != 3)\n\n        return -1;\n\n\n\n    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */\n\n\n\n    mp3->frames = 0;\n\n    mp3->size   = 0;\n\n\n\n    mp3_parse_info_tag(s, st, &c, spf);\n\n    mp3_parse_vbri_tag(s, st, base);\n\n\n\n    if (!mp3->frames && !mp3->size)\n\n        return -1;\n\n\n\n    /* Skip the vbr tag frame */\n\n    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);\n\n\n\n    if (mp3->frames)\n\n        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},\n\n                                    st->time_base);\n\n    if (mp3->size && mp3->frames && !mp3->is_cbr)\n\n        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 478, "prediction": "0", "true_label": "0", "raw_text": "Question: void memory_region_iommu_replay_all(MemoryRegion *mr)\n\n{\n\n    IOMMUNotifier *notifier;\n\n\n\n    IOMMU_NOTIFIER_FOREACH(notifier, mr) {\n\n        memory_region_iommu_replay(mr, notifier, false);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 479, "prediction": "0", "true_label": "0", "raw_text": "Question: static int usb_uhci_piix3_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);\n\n    return usb_uhci_common_initfn(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 480, "prediction": "0", "true_label": "0", "raw_text": " - 1 > extradata_copied) {\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 2);\n\n                            extradata_copied += 2;\n\n                            q += 2;\n\n                        } else {\n\n                            /* The Teletext descriptor:\n\n                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)\n\n                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.\n\n                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */\n\n                            *q++ = 0x08;\n\n                            *q++ = 0x00;\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                 }\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {\n\n                *q++ = 0x05; /*MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'd';\n\n                *q++ = 'r';\n\n                *q++ = 'a';\n\n                *q++ = 'c';\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor */\n\n                *q++ = 4;\n\n                *q++ = 'K';\n\n                *q++ = 'L';\n\n                *q++ = 'V';\n\n                *q++ = 'A';\n\n            }\n\n            break;\n\n        }\n\n\n\n        val = 0xf000 | (q - desc_length_ptr - 2);\n\n        desc_length_ptr[0] = val >> 8;\n\n        desc_length_ptr[1] = val;\n\n    }\n\n    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,\n\n                          data, q - data);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 481, "prediction": "0", "true_label": "0", "raw_text": "Question: static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 482, "prediction": "0", "true_label": "0", "raw_text": "\n\n            /* Always trap */\n\n            generate_exception(ctx, EXCP_TRAP);\n\n            break;\n\n        case OPC_TLT:   /* rs < rs           */\n\n        case OPC_TLTI:  /* r0 < 0            */\n\n        case OPC_TLTU:  /* rs < rs unsigned  */\n\n        case OPC_TLTIU: /* r0 < 0  unsigned  */\n\n        case OPC_TNE:   /* rs != rs          */\n\n        case OPC_TNEI:  /* r0 != 0           */\n\n            /* Never trap: treat as NOP. */\n\n            break;\n\n        }\n\n    } else {\n\n        int l1 = gen_new_label();\n\n\n\n        switch (opc) {\n\n        case OPC_TEQ:\n\n        case OPC_TEQI:\n\n            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);\n\n            break;\n\n        case OPC_TGE:\n\n        case OPC_TGEI:\n\n            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);\n\n            break;\n\n        case OPC_TGEU:\n\n        case OPC_TGEIU:\n\n            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);\n\n            break;\n\n        case OPC_TLT:\n\n        case OPC_TLTI:\n\n            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);\n\n            break;\n\n        case OPC_TLTU:\n\n        case OPC_TLTIU:\n\n            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);\n\n            break;\n\n        case OPC_TNE:\n\n        case OPC_TNEI:\n\n            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);\n\n            break;\n\n        }\n\n        generate_exception(ctx, EXCP_TRAP);\n\n        gen_set_label(l1);\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 483, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,\n\n                                 unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    uint32_t ret;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return 0;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        return s->dir[bank];\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPSR\\n\");\n\n        return 0;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPCR\\n\");\n\n        return 0;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising[bank];\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling[bank];\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2];\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2 + 1];\n\n\n\n    case GPLR:\t\t/* GPIO Pin-Level registers */\n\n        ret = (s->olevel[bank] & s->dir[bank]) |\n\n                (s->ilevel[bank] & ~s->dir[bank]);\n\n        qemu_irq_raise(s->read_notify);\n\n        return ret;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        return s->status[bank];\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 484, "prediction": "1", "true_label": "1", "raw_text": "Question: static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)\n{\n    int y;\n    unsigned char P[2];\n    /* 4-color block encoding: each 4x4 block is a different color */\n    for (y = 0; y < 8; y++) {\n        if (!(y & 3)) {\n            P[0] = bytestream2_get_byte(&s->stream_ptr);\n            P[1] = bytestream2_get_byte(&s->stream_ptr);\n        memset(s->pixel_ptr,     P[0], 4);\n        memset(s->pixel_ptr + 4, P[1], 4);\n        s->pixel_ptr += s->stride;\n    /* report success */\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 485, "prediction": "0", "true_label": "0", "raw_text": "Question: static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    MigrationState *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n\n\n    s->xfer_limit = new_rate;\n\n\n\nout:\n\n    return s->xfer_limit;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 486, "prediction": "0", "true_label": "0", "raw_text": " + 1];\n\n            mc2_l = matrix_coeffs[s2 * 2    ];\n\n            mc2_r = matrix_coeffs[s2 * 2 + 1];\n\n\n\n            /* Interpolation is done over the first eight samples. */\n\n            for (; nsample < 8; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +\n\n                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);\n\n                su1[band + nsample] = c2;\n\n                su2[band + nsample] = c1 * 2.0 - c2;\n\n            }\n\n        }\n\n\n\n        /* Apply the matrix without interpolation. */\n\n        switch (s2) {\n\n        case 0:     /* M/S decoding */\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] =  c2       * 2.0;\n\n                su2[band + nsample] = (c1 - c2) * 2.0;\n\n            }\n\n            break;\n\n        case 1:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = (c1 + c2) *  2.0;\n\n                su2[band + nsample] =  c2       * -2.0;\n\n            }\n\n            break;\n\n        case 2:\n\n        case 3:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = c1 + c2;\n\n                su2[band + nsample] = c1 - c2;\n\n            }\n\n            break;\n\n        default:\n\n            assert(0);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 487, "prediction": "1", "true_label": "0", "raw_text": "Question: static void scsi_disk_reset(DeviceState *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n\n    uint64_t nb_sectors;\n\n\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    if (nb_sectors) {\n\n        nb_sectors--;\n\n    }\n\n    s->qdev.max_lba = nb_sectors;\n\n    /* reset tray statuses */\n\n    s->tray_locked = 0;\n\n    s->tray_open = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 488, "prediction": "0", "true_label": "1", "raw_text": " unsigned char pes_header_data[256];\n\n\n\n            pes_signal             = avio_rb24(pb);\n\n            avio_r8(pb);\n\n            pes_packet_length      = avio_rb16(pb);\n\n            pes_flags              = avio_rb16(pb);\n\n            pes_header_data_length = avio_r8(pb);\n\n\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n\n                                          \"trying to recover\\n\");\n\n                avio_skip(pb, length - 9);\n\n                if (!read_packet)\n\n                    return AVERROR(EIO);\n\n                goto recover;\n\n            }\n\n\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n\n            if (ret != pes_header_data_length)\n\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n\n            length -= 9 + pes_header_data_length;\n\n\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n\n\n            pvactx->continue_pes = pes_packet_length;\n\n\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20)\n\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n\n        }\n\n\n\n        pvactx->continue_pes -= length;\n\n\n\n        if (pvactx->continue_pes < 0) {\n\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n\n            pvactx->continue_pes = 0;\n\n        }\n\n    }\n\n\n\n    if (pva_pts != AV_NOPTS_VALUE)\n\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n\n\n    *pts   = pva_pts;\n\n    *len   = length;\n\n    *strid = streamid;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 489, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0;\n\n\n\n    dc0=0;\n\n    for(i=0;i<8; i++)\n\n        dc0+= src[i-stride];\n\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]=\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 490, "prediction": "0", "true_label": "0", "raw_text": "Question: static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,\n\n                              uint16_t index, uint16_t num)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n\n\n    if (index >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (addr && (align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    virtio_queue_set_addr(vdev, index, addr);\n\n    if (!addr) {\n\n        virtio_queue_set_vector(vdev, index, 0);\n\n    } else {\n\n        /* Fail if we don't have a big enough queue. */\n\n        /* TODO: Add interface to handle vring.num changing */\n\n        if (virtio_queue_get_num(vdev, index) > num) {\n\n            return -EINVAL;\n\n        }\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 491, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    rtl8139_do_receive(opaque, buf, size, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 492, "prediction": "0", "true_label": "0", "raw_text": "Question: static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||\n\n        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n        (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        return lchown(rpath(fs_ctx, path, buffer),\n\n                      credp->fc_uid, credp->fc_gid);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        return local_set_mapped_file_attr(fs_ctx, path, credp);\n\n    }\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 493, "prediction": "0", "true_label": "0", "raw_text": "0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(acl, \"rules\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n\n    rules = qobject_to_qlist(child);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 494, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 495, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 496, "prediction": "0", "true_label": "1", "raw_text": "], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,\n\n                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,\n\n                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,\n\n                     ff_vc1_cbpcy_p_bits[i], 1, 1,\n\n                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,\n\n                     ff_vc1_mv_diff_bits[i], 1, 1,\n\n                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<8; i++)\n\n            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],\n\n                     &vc1_ac_tables[i][0][1], 8, 4,\n\n                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,\n\n                 &ff_msmp4_mb_i_table[0][1], 4, 2,\n\n                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);\n\n    }\n\n\n\n    /* Other defaults */\n\n    v->pq = -1;\n\n    v->mvrange = 0; /* 7.1.1.18, p80 */\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 497, "prediction": "-1", "true_label": "1", "raw_text": "_id)   st->codec->codec_id= s->video_codec_id;\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;\n            break;\n        if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE ||\n                     !st->probe_packets))\n            return ret;\n        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);\n        s->raw_packet_buffer_remaining_size -= pkt->size;\n        if(st->codec->codec_id == CODEC_ID_PROBE){\n            AVProbeData *pd = &st->probe_data;\n            av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);\n            --st->probe_packets;\n            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n            memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n            pd->buf_size += pkt->size;\n            memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n            if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){\n                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes\n                set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);\n                if(st->codec->codec_id != CODEC_ID_PROBE){\n                    pd->buf_size=0;\n                    av_freep(&pd->buf);\n                    av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 498, "prediction": "0", "true_label": "1", "raw_text": "Question: static int nbd_can_accept(void)\n\n{\n\n    return nb_fds < shared;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 499, "prediction": "0", "true_label": "1", "raw_text": " &netdev->rx_ring_ref) == -1) {\n\n        return 1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"event-channel\",\n\n                             &netdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"request-rx-copy\", &rx_copy) == -1) {\n\n        rx_copy = 0;\n\n    }\n\n    if (rx_copy == 0) {\n\n        xen_be_printf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->tx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->rx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    if (!netdev->txs || !netdev->rxs) {\n\n        return -1;\n\n    }\n\n    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);\n\n    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);\n\n\n\n    xen_be_bind_evtchn(&netdev->xendev);\n\n\n\n    xen_be_printf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  netdev->tx_ring_ref, netdev->rx_ring_ref,\n\n                  netdev->xendev.remote_port, netdev->xendev.local_port);\n\n\n\n    net_tx_packets(netdev);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 500, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 501, "prediction": "-1", "true_label": "1", "raw_text": " tonal components */\n\n    if (components == 0)\n\n        return 0;\n\n\n\n    coding_mode_selector = get_bits(gb,2);\n\n    if (coding_mode_selector == 2)\n\n\n\n\n    coding_mode = coding_mode_selector & 1;\n\n\n\n    for (i = 0; i < components; i++) {\n\n        for (cnt = 0; cnt <= numBands; cnt++)\n\n            band_flags[cnt] = get_bits1(gb);\n\n\n\n        coded_values_per_component = get_bits(gb,3);\n\n\n\n        quant_step_index = get_bits(gb,3);\n\n        if (quant_step_index <= 1)\n\n\n\n\n        if (coding_mode_selector == 3)\n\n            coding_mode = get_bits1(gb);\n\n\n\n        for (j = 0; j < (numBands + 1) * 4; j++) {\n\n            if (band_flags[j >> 2] == 0)\n\n                continue;\n\n\n\n            coded_components = get_bits(gb,3);\n\n\n\n            for (k=0; k<coded_components; k++) {\n\n                sfIndx = get_bits(gb,6);\n\n\n\n                pComponent[component_count].pos = j * 64 + (get_bits(gb,6));\n\n                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;\n\n                coded_values = coded_values_per_component + 1;\n\n                coded_values = FFMIN(max_coded_values,coded_values);\n\n\n\n                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];\n\n\n\n                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);\n\n\n\n                pComponent[component_count].numCoefs = coded_values;\n\n\n\n                /* inverse quant */\n\n                pCoef = pComponent[component_count].coef;\n\n                for (cnt = 0; cnt < coded_values; cnt++)\n\n                    pCoef[cnt] = mantissa[cnt] * scalefactor;\n\n\n\n                component_count++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return component_count;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 502, "prediction": "0", "true_label": "1", "raw_text": "Question: static void do_send_key(const char *string)\n\n{\n\n    char keybuf[16], *q;\n\n    uint8_t keycodes[16];\n\n    const char *p;\n\n    int nb_keycodes, keycode, i;\n\n\n\n    nb_keycodes = 0;\n\n    p = string;\n\n    while (*p != '\\0') {\n\n        q = keybuf;\n\n        while (*p != '\\0' && *p != '-') {\n\n            if ((q - keybuf) < sizeof(keybuf) - 1) {\n\n                *q++ = *p;\n\n            }\n\n            p++;\n\n        }\n\n        *q = '\\0';\n\n        keycode = get_keycode(keybuf);\n\n        if (keycode < 0) {\n\n            term_printf(\"unknown key: '%s'\\n\", keybuf);\n\n            return;\n\n        }\n\n        keycodes[nb_keycodes++] = keycode;\n\n        if (*p == '\\0')\n\n            break;\n\n        p++;\n\n    }\n\n    /* key down events */\n\n    for(i = 0; i < nb_keycodes; i++) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode & 0x7f);\n\n    }\n\n    /* key up events */\n\n    for(i = nb_keycodes - 1; i >= 0; i--) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 503, "prediction": "0", "true_label": "0", "raw_text": "Question: void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    double d;\n\n    char *ptr;\n\n    FdMigrationState *s;\n\n    const char *value = qdict_get_str(qdict, \"value\");\n\n\n\n    d = strtod(value, &ptr);\n\n    switch (*ptr) {\n\n    case 'G': case 'g':\n\n        d *= 1024;\n\n    case 'M': case 'm':\n\n        d *= 1024;\n\n    case 'K': case 'k':\n\n        d *= 1024;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    max_throttle = (uint32_t)d;\n\n    s = migrate_to_fms(current_migration);\n\n\n\n    if (s) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n    \n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 504, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_efdneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 505, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 506, "prediction": "0", "true_label": "0", "raw_text": "Question: static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtQueue *vq;\n\n\n\n    vq = vser->c_ivq;\n\n    if (!virtio_queue_ready(vq)) {\n\n        return 0;\n\n    }\n\n    if (!virtqueue_pop(vq, &elem)) {\n\n        return 0;\n\n    }\n\n\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n\n\n    virtqueue_push(vq, &elem, len);\n\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n\n    return len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 507, "prediction": "0", "true_label": "0", "raw_text": "io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 508, "prediction": "0", "true_label": "0", "raw_text": "Question: uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint8_t ret;\n\n\n\n    OMAP_8B_REG(addr);\n\n    cpu_physical_memory_read(addr, (void *) &ret, 1);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 509, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 510, "prediction": "0", "true_label": "1", "raw_text": "_OK)\n\n            return -1;\n\n        zstream.next_in = data;\n\n        zstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            zstream.avail_out = pkt_size - zstream.total_out;\n\n            zstream.next_out = pkt_data + zstream.total_out;\n\n            result = inflate(&zstream, Z_NO_FLUSH);\n\n        } while (result==Z_OK && pkt_size<10000000);\n\n        pkt_size = zstream.total_out;\n\n        inflateEnd(&zstream);\n\n        if (result != Z_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n#if CONFIG_BZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n\n        bz_stream bzstream = {0};\n\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n\n            return -1;\n\n        bzstream.next_in = data;\n\n        bzstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n\n            result = BZ2_bzDecompress(&bzstream);\n\n        } while (result==BZ_OK && pkt_size<10000000);\n\n        pkt_size = bzstream.total_out_lo32;\n\n        BZ2_bzDecompressEnd(&bzstream);\n\n        if (result != BZ_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    *buf = pkt_data;\n\n    *buf_size = pkt_size;\n\n    return 0;\n\n failed:\n\n    av_free(pkt_data);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 511, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < nb_coefs; i++) {\n\n        int e;\n\n        int v = abs(coef[i]);\n\n        if (v == 0)\n\n            e = 24;\n\n        else {\n\n            e = 23 - av_log2(v);\n\n            if (e >= 24) {\n\n                e = 24;\n\n                coef[i] = 0;\n\n            }\n\n            av_assert2(e >= 0);\n\n        }\n\n        exp[i] = e;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 512, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vhost_log_stop(MemoryListener *listener,\n\n                           MemoryRegionSection *section)\n\n{\n\n    /* FIXME: implement */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 513, "prediction": "0", "true_label": "0", "raw_text": "_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 514, "prediction": "0", "true_label": "0", "raw_text": "CG_TYPE_TL, TCG_REG_T1,\n\n                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n\n\n    /* Mask the tlb index.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);\n\n    \n\n    /* Mask page, part 2.  */\n\n    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);\n\n\n\n    /* Shift the tlb index into place.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);\n\n\n\n    /* Relative to the current ENV.  */\n\n    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);\n\n\n\n    /* Find a base address that can load both tlb comparator and addend.  */\n\n    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);\n\n    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {\n\n        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);\n\n        tlb_ofs &= 0x3ff;\n\n    }\n\n\n\n    /* Load the tlb comparator and the addend.  */\n\n    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);\n\n    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));\n\n\n\n    /* subcc arg0, arg2, %g0 */\n\n    tcg_out_cmp(s, r0, r2, 0);\n\n\n\n    /* If the guest address must be zero-extended, do so now.  */\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);\n\n        return r0;\n\n    }\n\n    return addr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 515, "prediction": "0", "true_label": "0", "raw_text": "Question: static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,\n\n                        void *s, void *sp)\n\n{\n\n    DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd);\n\n    switch (action) {\n\n        case CURL_POLL_IN:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);\n\n            break;\n\n        case CURL_POLL_OUT:\n\n            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_INOUT:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_REMOVE:\n\n            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);\n\n            break;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 516, "prediction": "0", "true_label": "1", "raw_text": "24_MMX;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX;\n\n\t}\n\n    }\n\n#endif\n\n#ifdef HAVE_MLIB\n\n    {\n\n\tSwsFunc t= yuv2rgb_init_mlib(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n#ifdef HAVE_ALTIVEC\n\n    if (c->flags & SWS_CPU_CAPS_ALTIVEC)\n\n    {\n\n\tSwsFunc t = yuv2rgb_init_altivec(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n\n\n    av_log(c, AV_LOG_WARNING, \"No accelerated colorspace conversion found\\n\");\n\n\n\n    switch(c->dstFormat){\n\n    case PIX_FMT_BGR32:\n\n    case PIX_FMT_RGB32: return yuv2rgb_c_32;\n\n    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;\n\n    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;\n\n    case PIX_FMT_RGB565:\n\n    case PIX_FMT_BGR565:\n\n    case PIX_FMT_RGB555:\n\n    case PIX_FMT_BGR555: return yuv2rgb_c_16;\n\n    case PIX_FMT_RGB8:\n\n    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;\n\n    case PIX_FMT_RGB4:\n\n    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;\n\n    case PIX_FMT_RGB4_BYTE:\n\n    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;\n\n    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;\n\n    default:\n\n    \tassert(0);\n\n    }\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 517, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 518, "prediction": "1", "true_label": "1", "raw_text": "Question: uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)\n\n{\n\n    uint32_t scratch = 0;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n\n\n    for (; buf < buf_end - 3; buf += 4)\n\n        scratch ^= *((const uint32_t*)buf);\n\n\n\n    scratch = xor_32_to_8(scratch);\n\n\n\n    for (; buf < buf_end; buf++)\n\n\n\n\n    return scratch;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 519, "prediction": "1", "true_label": "0", "raw_text": "Question: void ff_er_frame_start(ERContext *s)\n\n{\n\n    if (!s->avctx->err_recognition)\n\n        return;\n\n\n\n    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n\n           s->mb_stride * s->mb_height * sizeof(uint8_t));\n\n    s->error_count    = 3 * s->mb_num;\n\n    s->error_occurred = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 520, "prediction": "0", "true_label": "0", "raw_text": "[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n        }\n\n    }\n\n\n\n    s->context_initialized = 1;\n\n    s->thread_context[0]= s;\n\n\n\n    if (s->width && s->height) {\n\n    if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) {\n\n        threads = s->avctx->thread_count;\n\n\n\n        for(i=1; i<threads; i++){\n\n            s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n\n            memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n\n        }\n\n\n\n        for(i=0; i<threads; i++){\n\n            if(init_duplicate_context(s->thread_context[i], s) < 0)\n\n                goto fail;\n\n            s->thread_context[i]->start_mb_y= (s->mb_height*(i  ) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n            s->thread_context[i]->end_mb_y  = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n        }\n\n    } else {\n\n        if(init_duplicate_context(s, s) < 0) goto fail;\n\n        s->start_mb_y = 0;\n\n        s->end_mb_y   = s->mb_height;\n\n    }\n\n    }\n\n\n\n    return 0;\n\n fail:\n\n    MPV_common_end(s);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 521, "prediction": "0", "true_label": "0", "raw_text": "\n\n        int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;\n\n        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\n\n        void *buftmp;\n\n\n\n        if (probe_size < offset) {\n\n            continue;\n\n        }\n\n\n\n        /* read probe data */\n\n        buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n\n        if(!buftmp){\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        buf=buftmp;\n\n        if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n\n            /* fail if error was not end of file, otherwise, lower score */\n\n            if (ret != AVERROR_EOF) {\n\n                av_free(buf);\n\n                return ret;\n\n            }\n\n            score = 0;\n\n            ret = 0;            /* error was end of file, nothing read */\n\n        }\n\n        pd.buf_size += ret;\n\n        pd.buf = &buf[offset];\n\n\n\n        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n\n\n\n        /* guess file format */\n\n        *fmt = av_probe_input_format2(&pd, 1, &score);\n\n        if(*fmt){\n\n            if(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration\n\n                av_log(logctx, AV_LOG_WARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score);\n\n            }else\n\n                av_log(logctx, AV_LOG_DEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probe_size, score);\n\n        }\n\n    }\n\n\n\n    if (!*fmt) {\n\n        av_free(buf);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* rewind. reuse probe buffer to avoid seeking */\n\n    ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 522, "prediction": "0", "true_label": "1", "raw_text": "conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 523, "prediction": "0", "true_label": "0", "raw_text": " can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 524, "prediction": "0", "true_label": "0", "raw_text": "target_phys_addr_t addr, target_phys_addr_t addrg,\n\n                         const uint32_t *intbit_to_level,\n\n                         qemu_irq **irq, qemu_irq **cpu_irq,\n\n                         unsigned int cputimer)\n\n\n\n{\n\n    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;\n\n    SLAVIO_INTCTLState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->intbit_to_level = intbit_to_level;\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n\tslavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);\n\n\tcpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,\n\n                                     slavio_intctl_io_memory);\n\n    }\n\n\n\n    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);\n\n    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);\n\n\n\n    register_savevm(\"slavio_intctl\", addr, 1, slavio_intctl_save, slavio_intctl_load, s);\n\n    qemu_register_reset(slavio_intctl_reset, s);\n\n    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);\n\n\n\n    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);\n\n    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];\n\n    slavio_intctl_reset(s);\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 525, "prediction": "0", "true_label": "1", "raw_text": "Question: void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 526, "prediction": "0", "true_label": "0", "raw_text": "Question: static void start_children(FFStream *feed)\n\n{\n\n    if (no_launch)\n\n        return;\n\n\n\n    for (; feed; feed = feed->next) {\n\n        if (feed->child_argv && !feed->pid) {\n\n            feed->pid_start = time(0);\n\n\n\n            feed->pid = fork();\n\n\n\n            if (feed->pid < 0) {\n\n                http_log(\"Unable to create children\\n\");\n\n                exit(1);\n\n            }\n\n            if (!feed->pid) {\n\n                /* In child */\n\n                char pathname[1024];\n\n                char *slash;\n\n                int i;\n\n\n\n                av_strlcpy(pathname, my_program_name, sizeof(pathname));\n\n\n\n                slash = strrchr(pathname, '/');\n\n                if (!slash)\n\n                    slash = pathname;\n\n                else\n\n                    slash++;\n\n                strcpy(slash, \"ffmpeg\");\n\n\n\n                http_log(\"Launch command line: \");\n\n                http_log(\"%s \", pathname);\n\n                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n\n                    http_log(\"%s \", feed->child_argv[i]);\n\n                http_log(\"\\n\");\n\n\n\n                for (i = 3; i < 256; i++)\n\n                    close(i);\n\n\n\n                if (!ffserver_debug) {\n\n                    i = open(\"/dev/null\", O_RDWR);\n\n                    if (i != -1) {\n\n                        dup2(i, 0);\n\n                        dup2(i, 1);\n\n                        dup2(i, 2);\n\n                        close(i);\n\n                    }\n\n                }\n\n\n\n                /* This is needed to make relative pathnames work */\n\n                chdir(my_program_dir);\n\n\n\n                signal(SIGPIPE, SIG_DFL);\n\n\n\n                execvp(pathname, feed->child_argv);\n\n\n\n                _exit(1);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 527, "prediction": "0", "true_label": "1", "raw_text": "Question: static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    int i, j;\n\n\n\n    if (!mov->fragment_index_complete)\n\n        return 0;\n\n\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n\n        if (mov->fragment_index_data[i]->track_id == st->id) {\n\n            MOVFragmentIndex *index = index = mov->fragment_index_data[i];\n\n            for (j = index->item_count - 1; j >= 0; j--) {\n\n                if (index->items[j].time <= timestamp) {\n\n                    if (index->items[j].headers_read)\n\n                        return 0;\n\n\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 528, "prediction": "0", "true_label": "1", "raw_text": "Question: static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)\n\n{\n\n    switch(tag) {\n\n    case 0x4801:\n\n        track->track_id = get_be32(pb);\n\n        break;\n\n    case 0x4804:\n\n        get_buffer(pb, track->track_number, 4);\n\n        break;\n\n    case 0x4B01:\n\n        track->edit_rate.den = get_be32(pb);\n\n        track->edit_rate.num = get_be32(pb);\n\n        break;\n\n    case 0x4803:\n\n        get_buffer(pb, track->sequence_ref, 16);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 529, "prediction": "0", "true_label": "1", "raw_text": ", \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {\n\n        AVIOContext pb;\n\n        RTSPState *rt = s->priv_data;\n\n        AVDictionary *opts = NULL;\n\n        int len = strlen(p) * 6 / 8;\n\n        char *buf = av_mallocz(len);\n\n        AVInputFormat *iformat;\n\n\n\n        if (!buf)\n\n            return AVERROR(ENOMEM);\n\n        av_base64_decode(buf, p, len);\n\n\n\n        if (rtp_asf_fix_header(buf, len) < 0)\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");\n\n        init_packetizer(&pb, buf, len);\n\n        if (rt->asf_ctx) {\n\n            avformat_close_input(&rt->asf_ctx);\n\n        }\n\n\n\n        if (!(iformat = av_find_input_format(\"asf\")))\n\n            return AVERROR_DEMUXER_NOT_FOUND;\n\n\n\n        rt->asf_ctx = avformat_alloc_context();\n\n        if (!rt->asf_ctx) {\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        rt->asf_ctx->pb      = &pb;\n\n        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);\n\n\n\n        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {\n\n            av_dict_free(&opts);\n\n            return ret;\n\n        }\n\n\n\n        ret = avformat_open_input(&rt->asf_ctx, \"\", iformat, &opts);\n\n        av_dict_free(&opts);\n\n        if (ret < 0) {\n\n            av_free(buf);\n\n            return ret;\n\n        }\n\n        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n\n        rt->asf_pb_pos = avio_tell(&pb);\n\n        av_free(buf);\n\n        rt->asf_ctx->pb = NULL;\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 530, "prediction": "0", "true_label": "1", "raw_text": "pc_refl[i] = ff_lpc_refl_cb[i][idx];\n\n    }\n\n    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);\n\n    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);\n\n    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);\n\n    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,\n\n                            energy <= ractx->old_energy,\n\n                            ff_t_sqrt(energy * ractx->old_energy) >> 12);\n\n    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);\n\n    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);\n\n    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]);\n\n    put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32));\n\n    for (i = 0; i < NBLOCKS; i++)\n\n        ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,\n\n                              block_coefs[i], refl_rms[i], &pb);\n\n    flush_put_bits(&pb);\n\n    ractx->old_energy = energy;\n\n    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];\n\n    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);\n\n    for (i = 0; i < NBLOCKS * BLOCKSIZE; i++)\n\n        ractx->curr_block[i] = *((int16_t *)data + i) >> 2;\n\n    return FRAMESIZE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 531, "prediction": "0", "true_label": "0", "raw_text": "Question: static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 532, "prediction": "0", "true_label": "0", "raw_text": ";i++) {\n\n\t\ts->types[i] = read_uint32(s->fd, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_chunk = qemu_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    return 0;\n\nfail:\n\n    close(s->fd);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 533, "prediction": "0", "true_label": "1", "raw_text": "Question: bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 534, "prediction": "0", "true_label": "1", "raw_text": "Question: static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 535, "prediction": "0", "true_label": "1", "raw_text": "Question: static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 536, "prediction": "1", "true_label": "1", "raw_text": " frame list size -- value %d\\n\",\n                    val & USBCMD_FLS);\n            val &= ~USBCMD_FLS;\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n            if (s->pstate == EST_INACTIVE) {\n                SET_LAST_RUN_CLOCK(s);\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n            ehci_update_halt(s);\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n        break;\n    case USBSTS:\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n        val = s->usbsts;\n        ehci_update_irq(s);\n        break;\n    case USBINTR:\n        val &= USBINTR_MASK;\n        break;\n    case FRINDEX:\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n        break;\n    case CONFIGFLAG:\n        val &= 0x1;\n        if (val) {\n            for(i = 0; i < NB_PORTS; i++)\n                handle_port_owner_write(s, i, 0);\n        break;\n    case PERIODICLISTBASE:\n        if (ehci_periodic_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    case ASYNCLISTADDR:\n        if (ehci_async_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    *mmio = val;\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 537, "prediction": "0", "true_label": "0", "raw_text": " < 0)\n\n        return ret;\n\n\n\n    /* Avid Nitris hardware decoder requires a minimum amount of padding\n\n     * in the coding unit payload */\n\n    if (ctx->nitris_compat)\n\n        ctx->min_padding = 1600;\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx)) < 0)\n\n        return ret;\n\n    if ((ret = dnxhd_init_rc(ctx)) < 0)\n\n        return ret;\n\n\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,\n\n                      ctx->m.mb_num * sizeof(uint16_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,\n\n                      ctx->m.mb_num * sizeof(uint8_t), fail);\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (avctx->thread_count > MAX_THREADS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->thread[0] = ctx;\n\n    for (i = 1; i < avctx->thread_count; i++) {\n\n        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));\n\n        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));\n\n    }\n\n\n\n    return 0;\n\nfail:  // for FF_ALLOCZ_OR_GOTO\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 538, "prediction": "0", "true_label": "0", "raw_text": "get_bits_count(&s->gb) > buf_size * 8)\n\n//      return -1;\n\n        if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err;\n\n        if(!v->field_mode)\n\n            ff_er_frame_end(s);\n\n    }\n\n\n\n    ff_MPV_frame_end(s);\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\nimage:\n\n        avctx->width  = avctx->coded_width  = v->output_width;\n\n        avctx->height = avctx->coded_height = v->output_height;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            goto end;\n\n#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER\n\n        if (vc1_decode_sprites(v, &s->gb))\n\n            goto err;\n\n#endif\n\n        *pict      = v->sprite_output_frame;\n\n        *data_size = sizeof(AVFrame);\n\n    } else {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            *pict = s->current_picture_ptr->f;\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            *pict = s->last_picture_ptr->f;\n\n        }\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *data_size = sizeof(AVFrame);\n\n            ff_print_debug_info(s, pict);\n\n        }\n\n    }\n\n\n\nend:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return buf_size;\n\n\n\nerr:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 539, "prediction": "1", "true_label": "0", "raw_text": "Question: void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)\n\n{\n\n    bs->detect_zeroes = blk->root_state.detect_zeroes;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 540, "prediction": "0", "true_label": "0", "raw_text": " NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);\n\n    if (firstObj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    /* count the certs */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        cert_count++;\n\n    }\n\n\n\n    if (cert_count == 0) {\n\n        PK11_DestroyGenericObjects(firstObj);\n\n        return NULL;\n\n    }\n\n\n\n    /* allocate the arrays */\n\n    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);\n\n\n\n    /* fill in the arrays */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        SECItem derCert;\n\n        CERTCertificate *cert;\n\n        SECStatus rv;\n\n\n\n        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,\n\n                                   CKA_VALUE, &derCert);\n\n        if (rv != SECSuccess) {\n\n            continue;\n\n        }\n\n        /* create floating temp cert. This gives us a cert structure even if\n\n         * the token isn't logged in */\n\n        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,\n\n                                       NULL, PR_FALSE, PR_TRUE);\n\n        SECITEM_FreeItem(&derCert, PR_FALSE);\n\n        if (cert == NULL) {\n\n            continue;\n\n        }\n\n\n\n        certs[cert_count] = cert->derCert.data;\n\n        cert_len[cert_count] = cert->derCert.len;\n\n        keys[cert_count] = vcard_emul_make_key(slot, cert);\n\n        cert_count++;\n\n        CERT_DestroyCertificate(cert); /* key obj still has a reference */\n\n    }\n\n\n\n    /* now create the card */\n\n    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);\n\n    g_free(certs);\n\n    g_free(cert_len);\n\n    g_free(keys);\n\n\n\n    return card;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 541, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 542, "prediction": "0", "true_label": "1", "raw_text": "Question: static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)\n\n{\n\n    OfDpaFlow *flow;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;\n\n\n\n    flow = g_new0(OfDpaFlow, 1);\n\n    if (!flow) {\n\n        return NULL;\n\n    }\n\n\n\n    flow->cookie = cookie;\n\n    flow->mask.tbl_id = 0xffffffff;\n\n\n\n    flow->stats.install_time = flow->stats.refresh_time = now;\n\n\n\n    return flow;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 543, "prediction": "0", "true_label": "0", "raw_text": "RTPContext));\n\n    if (!s)\n\n        return AVERROR(ENOMEM);\n\n    h->priv_data = s;\n\n\n\n    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,\n\n              path, sizeof(path), uri);\n\n    /* extract parameters */\n\n    ttl = -1;\n\n    local_port = -1;\n\n    p = strchr(uri, '?');\n\n    if (p) {\n\n        if (find_info_tag(buf, sizeof(buf), \"ttl\", p)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (find_info_tag(buf, sizeof(buf), \"localport\", p)) {\n\n            local_port = strtol(buf, NULL, 10);\n\n        }\n\n    }\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port, local_port, ttl);\n\n    if (url_open(&s->rtp_hd, buf, flags) < 0)\n\n        goto fail;\n\n    local_port = udp_get_local_port(s->rtp_hd);\n\n    /* XXX: need to open another connection if the port is not even */\n\n\n\n    /* well, should suppress localport in path */\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port + 1, local_port + 1, ttl);\n\n    if (url_open(&s->rtcp_hd, buf, flags) < 0)\n\n        goto fail;\n\n\n\n    /* just to ease handle access. XXX: need to suppress direct handle\n\n       access */\n\n    s->rtp_fd = udp_get_file_handle(s->rtp_hd);\n\n    s->rtcp_fd = udp_get_file_handle(s->rtcp_hd);\n\n\n\n    h->max_packet_size = url_get_max_packet_size(s->rtp_hd);\n\n    h->is_streamed = 1;\n\n    return 0;\n\n\n\n fail:\n\n    if (s->rtp_hd)\n\n        url_close(s->rtp_hd);\n\n    if (s->rtcp_hd)\n\n        url_close(s->rtcp_hd);\n\n    av_free(s);\n\n    return AVERROR(EIO);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 544, "prediction": "0", "true_label": "1", "raw_text": "\\t\"\n\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n\n              \"memory\"\n\n        );\n\n\n\n        cost += di0 * di0 + di1 * di1\n\n                + di2 * di2 + di3 * di3;\n\n    }\n\n\n\n    if (bits)\n\n        *bits = curbits;\n\n    return cost * lambda + curbits;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 545, "prediction": "0", "true_label": "1", "raw_text": "Question: QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 546, "prediction": "0", "true_label": "1", "raw_text": " FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n\n    /* media descriptor: hard disk=0xf8, floppy=0xf0 */\n\n    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);\n\n    s->fat.pointer[0] = bootsector->media_type;\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track = cpu_to_le16(secs);\n\n    bootsector->number_of_heads = cpu_to_le16(heads);\n\n    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n\n\n\n    /* LATER TODO: if FAT32, this is wrong */\n\n    /* drive_number: fda=0, hda=0x80 */\n\n    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label, s->volume_label,\n\n           sizeof(bootsector->u.fat16.volume_label));\n\n    memcpy(bootsector->u.fat16.fat_type,\n\n           s->fat_type == 12 ? \"FAT12   \" : \"FAT16   \", 8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 547, "prediction": "0", "true_label": "0", "raw_text": "Question: void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    s->freq = PXA25X_FREQ;\n\n    s->tm4 = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 548, "prediction": "0", "true_label": "0", "raw_text": "021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     */\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 549, "prediction": "0", "true_label": "0", "raw_text": " ir, mem_index);\n\n    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);\n\n    tcg_out32 (s, B | 8);\n\n    tcg_out32 (s, (tcg_target_long) raddr);\n\n    switch (opc) {\n\n    case 0|4:\n\n        tcg_out32 (s, EXTSB | RA (data_reg) | RS (3));\n\n        break;\n\n    case 1|4:\n\n        tcg_out32 (s, EXTSH | RA (data_reg) | RS (3));\n\n        break;\n\n    case 0:\n\n    case 1:\n\n    case 2:\n\n        if (data_reg != 3)\n\n            tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3);\n\n        break;\n\n    case 3:\n\n        if (data_reg == 3) {\n\n            if (data_reg2 == 4) {\n\n                tcg_out_mov (s, TCG_TYPE_I32, 0, 4);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 4, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 0);\n\n            }\n\n            else {\n\n                tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 4);\n\n            }\n\n        }\n\n        else {\n\n            if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4);\n\n            if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n        }\n\n        break;\n\n    }\n\n    /* Jump to the code corresponding to next IR of qemu_st */\n\n    tcg_out_b (s, 0, (tcg_target_long) raddr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 550, "prediction": "-1", "true_label": "0", "raw_text": " opt, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD, opt,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, length, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt,\n\n                                      errp, \"%s\", msg);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 551, "prediction": "0", "true_label": "0", "raw_text": "Question: static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    /* stream commands */\n\n    case ERASE_12:\n\n    case ERASE_16:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case WRITE_6:\n\n        cmd->len = 6;\n\n        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case READ_16:\n\n    case READ_REVERSE_16:\n\n    case VERIFY_16:\n\n    case WRITE_16:\n\n        cmd->len = 16;\n\n        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case REWIND:\n\n    case LOAD_UNLOAD:\n\n        cmd->len = 6;\n\n        cmd->xfer = 0;\n\n        break;\n\n    case SPACE_16:\n\n        cmd->xfer = buf[13] | (buf[12] << 8);\n\n        break;\n\n    case READ_POSITION:\n\n        cmd->xfer = buf[8] | (buf[7] << 8);\n\n        break;\n\n    case FORMAT_UNIT:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    /* generic commands */\n\n    default:\n\n        return scsi_req_length(cmd, dev, buf);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 552, "prediction": "0", "true_label": "0", "raw_text": "_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\t\t\t\t/* invert Z.  */\n\n\t\t\t\ttcg_gen_xori_tl(z, z, 2);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_xori_tl(n, n, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_or_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_P:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_A:\n\n\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tBUG();\n\n\t\t\tbreak;\n\n\t};\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 553, "prediction": "0", "true_label": "0", "raw_text": "S | CC_Z | CC_A | CC_P | CC_C |\n\n                              DF_MASK));\n\n    env->eip = 0x00008000;\n\n    cpu_x86_update_cr0(env,\n\n                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |\n\n                                      CR0_PG_MASK));\n\n    cpu_x86_update_cr4(env, 0);\n\n    env->dr[7] = 0x00000400;\n\n\n\n    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,\n\n                           0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 554, "prediction": "0", "true_label": "1", "raw_text": "Question: PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,\n\n                        const char *default_devaddr)\n\n{\n\n    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;\n\n    PCIDevice *pci_dev;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);\n\n    pci_dev = pci_create(pci_nic_names[i], devaddr);\n\n    dev = &pci_dev->qdev;\n\n    if (nd->id)\n\n        dev->id = qemu_strdup(nd->id);\n\n    dev->nd = nd;\n\n    qdev_init(dev);\n\n    nd->private = dev;\n\n    return pci_dev;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 555, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n#if HAVE_7REGS && HAVE_TEN_OPERANDS\n\n    c->mlp_filter_channel = mlp_filter_channel_x86;\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 556, "prediction": "1", "true_label": "1", "raw_text": "_init(AVCodecContext *avctx)\n{\n    RoqContext *enc = avctx->priv_data;\n    av_lfg_init(&enc->randctx, 1);\n    enc->framesSinceKeyframe = 0;\n    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");\n        return AVERROR(EINVAL);\n    if (avctx->width > 65535 || avctx->height > 65535) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);\n        return AVERROR(EINVAL);\n    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))\n        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");\n    enc->width = avctx->width;\n    enc->height = avctx->height;\n    enc->framesSinceKeyframe = 0;\n    enc->first_frame = 1;\n    enc->last_frame    = av_frame_alloc();\n    enc->current_frame = av_frame_alloc();\n    if (!enc->last_frame || !enc->current_frame) {\n    enc->tmpData      = av_malloc(sizeof(RoqTempdata));\n    enc->this_motion4 =\n        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->last_motion4 =\n        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->this_motion8 =\n        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));\n    enc->last_motion8 =\n        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 557, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_h264_flush_change(H264Context *h)\n\n{\n\n    int i, j;\n\n\n\n    h->next_outputed_poc = INT_MIN;\n\n    h->prev_interlaced_frame = 1;\n\n    idr(h);\n\n\n\n    h->poc.prev_frame_num = -1;\n\n    if (h->cur_pic_ptr) {\n\n        h->cur_pic_ptr->reference = 0;\n\n        for (j=i=0; h->delayed_pic[i]; i++)\n\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n\n                h->delayed_pic[j++] = h->delayed_pic[i];\n\n        h->delayed_pic[j] = NULL;\n\n    }\n\n    ff_h264_unref_picture(h, &h->last_pic_for_ec);\n\n\n\n    h->first_field = 0;\n\n    ff_h264_sei_uninit(&h->sei);\n\n    h->recovery_frame = -1;\n\n    h->frame_recovered = 0;\n\n    h->current_slice = 0;\n\n    h->mmco_reset = 1;\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        h->slice_ctx[i].list_count = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 558, "prediction": "0", "true_label": "0", "raw_text": "Question: static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)\n\n{\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    void *dst;\n\n    if (o_out)\n\n        *o_out= o;\n\n    if (!o || o->offset<=0)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n\n\n    if (o->max*den < num*intnum || o->min*den > num*intnum) {\n\n        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);\n\n        return AVERROR(ERANGE);\n\n    }\n\n\n\n    dst= ((uint8_t*)obj) + o->offset;\n\n\n\n    switch (o->type) {\n\n    case FF_OPT_TYPE_FLAGS:\n\n    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_RATIONAL:\n\n        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};\n\n        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 559, "prediction": "0", "true_label": "1", "raw_text": "\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64 |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                         &qxl->vram_bar);\n\n    }\n\n\n\n    /* print pci bar details */\n\n    dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\",\n\n           qxl->id == 0 ? \"pri\" : \"sec\",\n\n           qxl->vga.vram_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\",\n\n           qxl->vram32_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/64: %d MB %s\\n\",\n\n           qxl->vram_size / (1024*1024),\n\n           qxl->vram32_size < qxl->vram_size ? \"[region 4]\" : \"[unmapped]\");\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {\n\n        error_setg(errp, \"qxl interface %d.%d not supported by spice-server\",\n\n                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);\n\n        return;\n\n    }\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);\n\n    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 560, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 561, "prediction": "0", "true_label": "1", "raw_text": "Question: static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)\n\n{\n\n    switch(mode){\n\n    case 0: //no shift\n\n        return src[0];\n\n    case 1: // 1/4 shift\n\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n\n    case 2: // 1/2 shift\n\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n\n    case 3: // 3/4 shift\n\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n\n    }\n\n    return 0; //should not occur\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 562, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval = -1;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        goto out;\n\n    }\n\n    idx = (addr >> 6) & 0x3;\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        retval = opp->tifr;\n\n        goto out;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        retval = opp->timers[idx].ticc;\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        retval = opp->timers[idx].tibc;\n\n        break;\n\n    case 0x20: /* TIPV (TIPV) */\n\n        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    case 0x30: /* TIDE (TIDR) */\n\n        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    }\n\n\n\nout:\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 563, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_exception_insn(DisasContext *s, int offset, int excp)\n\n{\n\n    gen_a64_set_pc_im(s->pc - offset);\n\n    gen_exception(excp);\n\n    s->is_jmp = DISAS_JUMP;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 564, "prediction": "1", "true_label": "0", "raw_text": "Question: static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    const char *arg_name;\n\n    const QObject *arg_obj;\n\n    bool has_exec_key = false;\n\n    QDict *dict = NULL;\n\n\n\n    if (qobject_type(request) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,\n\n                   \"request is not a dictionary\");\n\n        return NULL;\n\n    }\n\n\n\n    dict = qobject_to_qdict(request);\n\n\n\n    for (ent = qdict_first(dict); ent;\n\n         ent = qdict_next(dict, ent)) {\n\n        arg_name = qdict_entry_key(ent);\n\n        arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                           \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = true;\n\n        } else if (strcmp(arg_name, \"arguments\")) {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return dict;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes\n"}], [{"ID": 565, "prediction": "1", "true_label": "0", "raw_text": ", e, a, 4 + i);\n\n    }\n\n    R0(a, b, c, d, e, 15);\n\n    R1(e, a, b, c, d, 16);\n\n    R1(d, e, a, b, c, 17);\n\n    R1(c, d, e, a, b, 18);\n\n    R1(b, c, d, e, a, 19);\n\n    for (i = 20; i < 40; i += 5) {\n\n        R2(a, b, c, d, e, 0 + i);\n\n        R2(e, a, b, c, d, 1 + i);\n\n        R2(d, e, a, b, c, 2 + i);\n\n        R2(c, d, e, a, b, 3 + i);\n\n        R2(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 60; i += 5) {\n\n        R3(a, b, c, d, e, 0 + i);\n\n        R3(e, a, b, c, d, 1 + i);\n\n        R3(d, e, a, b, c, 2 + i);\n\n        R3(c, d, e, a, b, 3 + i);\n\n        R3(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 80; i += 5) {\n\n        R4(a, b, c, d, e, 0 + i);\n\n        R4(e, a, b, c, d, 1 + i);\n\n        R4(d, e, a, b, c, 2 + i);\n\n        R4(c, d, e, a, b, 3 + i);\n\n        R4(b, c, d, e, a, 4 + i);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 566, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 567, "prediction": "0", "true_label": "1", "raw_text": "Question: static void acpi_build_update(void *build_opaque, uint32_t offset)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = 1;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    assert(acpi_data_len(tables.table_data) == build_state->table_size);\n\n    memcpy(build_state->table_ram, tables.table_data->data,\n\n           build_state->table_size);\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 568, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int amr_nb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 8000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    avctx->frame_size  = 160;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->enc_state = Encoder_Interface_init(s->enc_dtx);\n\n    if (!s->enc_state) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Encoder_Interface_init error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->enc_bitrate = avctx->bit_rate;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 569, "prediction": "0", "true_label": "1", "raw_text": "Question: void help(void)\n\n{\n\n    printf(\"dct-test [-i] [<test-number>]\\n\"\n\n           \"test-number 0 -> test with random matrixes\\n\"\n\n           \"            1 -> test with random sparse matrixes\\n\"\n\n           \"            2 -> do 3. test from mpeg4 std\\n\"\n\n           \"-i          test IDCT implementations\\n\"\n\n           \"-4          test IDCT248 implementations\\n\");\n\n    exit(1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 570, "prediction": "0", "true_label": "1", "raw_text": "Question: PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 571, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_num(ByteIOContext *pb, int *len)\n\n{\n\n    int n, n1;\n\n\n\n    n = get_be16(pb);\n\n    (*len)-=2;\n\n//    n &= 0x7FFF;\n\n    if (n >= 0x4000) {\n\n        return n - 0x4000;\n\n    } else {\n\n        n1 = get_be16(pb);\n\n        (*len)-=2;\n\n        return (n << 16) | n1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 572, "prediction": "0", "true_label": "0", "raw_text": "BANKS,\n\n                                    ram_memories,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, do_init);\n\n\n\n    /* PCI */\n\n    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    return env;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 573, "prediction": "0", "true_label": "0", "raw_text": "Question: static int piix4_initfn(PCIDevice *dev)\n\n{\n\n    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    isa_bus_new(&d->dev.qdev);\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n\n\n    piix4_dev = &d->dev;\n\n    qemu_register_reset(piix4_reset, d);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 574, "prediction": "0", "true_label": "1", "raw_text": "Question: static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel *) _dst;\n\n    dctcoef *src = (dctcoef *) _src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        dst[0] += src[0];\n\n        dst[1] += src[1];\n\n        dst[2] += src[2];\n\n        dst[3] += src[3];\n\n        dst[4] += src[4];\n\n        dst[5] += src[5];\n\n        dst[6] += src[6];\n\n        dst[7] += src[7];\n\n\n\n        dst += stride;\n\n        src += 8;\n\n    }\n\n\n\n    memset(_src, 0, sizeof(dctcoef) * 64);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 575, "prediction": "0", "true_label": "1", "raw_text": "Question: static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)\n\n{\n\n    int i;\n\n    int ret = av_frame_ref(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!h->sps.crop)\n\n        return 0;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n\n        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +\n\n            (h->sps.crop_top  >> vshift) * dst->linesize[i];\n\n        dst->data[i] += off;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 576, "prediction": "0", "true_label": "1", "raw_text": "Question: void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)\n\n{\n\n    double units = 1.0;\n\n\n\n    /* if cfg.op_size is defined and smaller than size we compute unit count */\n\n    if (ts->cfg.op_size && size > ts->cfg.op_size) {\n\n        units = (double) size / ts->cfg.op_size;\n\n    }\n\n\n\n    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;\n\n    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;\n\n\n\n    if (is_write) {\n\n        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;\n\n    } else {\n\n        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 577, "prediction": "0", "true_label": "1", "raw_text": "Question: void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 578, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 579, "prediction": "0", "true_label": "1", "raw_text": " send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 580, "prediction": "-1", "true_label": "1", "raw_text": "68; i++)\n\n                if (palette_buffer[i] > 63) {\n\n                    palette_scale = 0;\n\n                    break;\n\n\n\n\n            for (i = 0; i < 256; i++) {\n\n                r = palette_buffer[i * 3    ] << palette_scale;\n\n                g = palette_buffer[i * 3 + 1] << palette_scale;\n\n                b = palette_buffer[i * 3 + 2] << palette_scale;\n\n                palette[i] = (r << 16) | (g << 8) | (b);\n\n\n\n\n\n        chunk_size = avio_rl32(pb);\n\n\n\n\n\n        /* skip the number of decoded bytes (always equal to width * height) */\n\n        avio_skip(pb, 4);\n\n        chunk_size -= 4;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        if (command == 1) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (ret < 0)\n\n                return ret;\n\n            memcpy(pal, palette, AVPALETTE_SIZE);\n\n            pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n        pkt->stream_index = idcin->video_stream_index;\n\n        pkt->duration     = 1;\n\n    } else {\n\n        /* send out the audio chunk */\n\n        if (idcin->current_audio_chunk)\n\n            chunk_size = idcin->audio_chunk_size2;\n\n        else\n\n            chunk_size = idcin->audio_chunk_size1;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        pkt->stream_index = idcin->audio_stream_index;\n\n        pkt->duration     = chunk_size / idcin->block_align;\n\n\n\n        idcin->current_audio_chunk ^= 1;\n\n\n\n\n    if (idcin->audio_present)\n\n        idcin->next_chunk_is_video ^= 1;\n\n\n\n    return ret;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 581, "prediction": "0", "true_label": "1", "raw_text": " const uint16_t *buf0,\n\n                                        const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                        const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                        const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                        const uint16_t *abuf1, uint8_t *dest,\n\n                                        int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    x86_reg uv_off = c->uv_off << 1;\n\n\n\n    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2RGB(%%REGBP, %5, %6)\n\n        \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n        /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n        \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n        \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n        \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n        WRITERGB15(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither), \"m\"(uv_off)\n\n    );\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 582, "prediction": "0", "true_label": "0", "raw_text": "Question: static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n\n\n    if (!virtqueue_pop(s->vq, &req->elem)) {\n\n        virtio_blk_free_request(req);\n\n        return NULL;\n\n    }\n\n\n\n    return req;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 583, "prediction": "0", "true_label": "0", "raw_text": ":\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 584, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_system_reset(void)\n\n{\n\n    QEMUResetEntry *re, *nre;\n\n\n\n    /* reset all devices */\n\n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n\n        re->func(re->opaque);\n\n    }\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 585, "prediction": "0", "true_label": "0", "raw_text": "Question: static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (bdrv) {\n\n        bdrv_get_geometry(bdrv, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->bdrv = bdrv;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;\n\n    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);\n\n    memset(sd->function_group, 0, sizeof(int) * 6);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 586, "prediction": "0", "true_label": "0", "raw_text": "Question: static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 587, "prediction": "0", "true_label": "0", "raw_text": "i64:\n\n        c = ARITH_UDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_ext32s_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);\n\n        break;\n\n    case INDEX_op_ext32u_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);\n\n        break;\n\n    case INDEX_op_trunc_shr_i32:\n\n        if (args[2] == 0) {\n\n            tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i64:\n\n        tcg_out_setcond_i64(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i64:\n\n        tcg_out_movcond_i64(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    gen_arith:\n\n        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);\n\n        break;\n\n\n\n    gen_arith1:\n\n\ttcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);\n\n\tbreak;\n\n\n\n    default:\n\n        fprintf(stderr, \"unknown opcode 0x%x\\n\", opc);\n\n        tcg_abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 588, "prediction": "0", "true_label": "0", "raw_text": ";\n\n\n\n            if (buf_size < 2) {\n\n                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n\n\n            /* the uncompressed starting value is contained in the first byte */\n\n            dst = esc->samples;\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *(dst++) = buf[0]+128;\n\n                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table);\n\n                buf += buf_size / avctx->channels;\n\n                dst += n / avctx->channels - 1;\n\n            }\n\n        } else {\n\n            raw_decode(esc->samples, avpkt->data, esc->samples_size);\n\n        }\n\n    }\n\n\n\n    /* get output buffer */\n\n    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));\n\n    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx)  / avctx->channels;\n\n    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = esc->frame;\n\n\n\n    out_data_size = esc->frame.nb_samples;\n\n    for (ch = 0; ch<avctx->channels; ch++) {\n\n        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;\n\n        memcpy(esc->frame.data[ch], src, out_data_size);\n\n    }\n\n    out_data_size *= avctx->channels;\n\n    esc->samples_idx += out_data_size;\n\n\n\n    return esc->table ?\n\n        (avctx->frame_number == 0)*2 + out_data_size / 2 :\n\n        out_data_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 589, "prediction": "0", "true_label": "0", "raw_text": "_map[i]) {\n\n            /*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             */\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            /*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             */\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n        }\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                /*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 */\n\n                virtio_serial_throttle_port(port, false);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 590, "prediction": "0", "true_label": "0", "raw_text": "Question: static CharDriverState *qemu_chr_open_spice_port(const char *id,\n\n                                                 ChardevBackend *backend,\n\n                                                 ChardevReturn *ret,\n\n                                                 Error **errp)\n\n{\n\n    const char *name = backend->spiceport->fqdn;\n\n    CharDriverState *chr;\n\n    SpiceCharDriver *s;\n\n\n\n    if (name == NULL) {\n\n        fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = chr_open(\"port\", spice_port_set_fe_open);\n\n    s = chr->opaque;\n\n    s->sin.portname = g_strdup(name);\n\n\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 591, "prediction": "0", "true_label": "0", "raw_text": "Question: void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(cpu, breakpoint->pc);\n\n\n\n    g_free(breakpoint);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 592, "prediction": "0", "true_label": "1", "raw_text": "Question: static int flv_write_trailer(AVFormatContext *s)\n\n{\n\n    int64_t file_size;\n\n\n\n    AVIOContext *pb = s->pb;\n\n    FLVContext *flv = s->priv_data;\n\n    int i;\n\n\n\n    /* Add EOS tag */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        FLVStreamContext *sc = s->streams[i]->priv_data;\n\n        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            enc->codec_id == AV_CODEC_ID_H264)\n\n            put_avc_eos_tag(pb, sc->last_ts);\n\n    }\n\n\n\n    file_size = avio_tell(pb);\n\n\n\n    /* update information */\n\n    avio_seek(pb, flv->duration_offset, SEEK_SET);\n\n    put_amf_double(pb, flv->duration / (double)1000);\n\n    avio_seek(pb, flv->filesize_offset, SEEK_SET);\n\n    put_amf_double(pb, file_size);\n\n\n\n    avio_seek(pb, file_size, SEEK_SET);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 593, "prediction": "0", "true_label": "1", "raw_text": "Question: static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 594, "prediction": "0", "true_label": "1", "raw_text": "pb) != MKTAG('d','c','o','m'))\n\n        return AVERROR_INVALIDDATA;\n\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_rb32(pb); /* cmvd atom */\n\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n\n        return AVERROR_INVALIDDATA;\n\n    moov_len = avio_rb32(pb); /* uncompressed size */\n\n    cmov_len = atom.size - 6 * 4;\n\n\n\n    cmov_data = av_malloc(cmov_len);\n\n    if (!cmov_data)\n\n        return AVERROR(ENOMEM);\n\n    moov_data = av_malloc(moov_len);\n\n    if (!moov_data) {\n\n        av_free(cmov_data);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    avio_read(pb, cmov_data, cmov_len);\n\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n\n        goto free_and_return;\n\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n\n        goto free_and_return;\n\n    atom.type = MKTAG('m','o','o','v');\n\n    atom.size = moov_len;\n\n    ret = mov_read_default(c, &ctx, atom);\n\nfree_and_return:\n\n    av_free(moov_data);\n\n    av_free(cmov_data);\n\n    return ret;\n\n#else\n\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n\n    return AVERROR(ENOSYS);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 595, "prediction": "0", "true_label": "1", "raw_text": ";\n\n            }\n\n        }\n\n    } else {\n\n        /* We are in a standard case\n\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n\n        /* search into AVRtpPayloadTypes[] */\n\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n\n    }\n\n\n\n    c = avcodec_find_decoder(codec->codec_id);\n\n    if (c && c->name)\n\n        c_name = c->name;\n\n    else\n\n        c_name = (char *) NULL;\n\n\n\n    if (c_name) {\n\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n        i = atoi(buf);\n\n        switch (codec->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n\n            if (i > 0) {\n\n                codec->sample_rate = i;\n\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n                i = atoi(buf);\n\n                if (i > 0)\n\n                    codec->channels = i;\n\n                // TODO: there is a bug here; if it is a mono stream, and\n\n                // less than 22000Hz, faad upconverts to stereo and twice\n\n                // the frequency.  No problem, but the sample rate is being\n\n                // set here by the sdp line. Patch on its way. (rdm)\n\n            }\n\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n\n                   codec->sample_rate);\n\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n\n                   codec->channels);\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 596, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_mpv_frame_end(MpegEncContext *s)\n\n{\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n    } else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    emms_c();\n\n\n\n    if (s->current_picture.reference)\n\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 597, "prediction": "0", "true_label": "1", "raw_text": "Question: static int read_ffserver_streams(AVFormatContext *s, const char *filename)\n\n{\n\n    int i, err;\n\n    AVFormatContext *ic;\n\n    int nopts = 0;\n\n\n\n    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);\n\n    if (err < 0)\n\n        return err;\n\n    /* copy stream format */\n\n    s->nb_streams = ic->nb_streams;\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st;\n\n        AVCodec *codec;\n\n\n\n        // FIXME: a more elegant solution is needed\n\n        st = av_mallocz(sizeof(AVStream));\n\n        memcpy(st, ic->streams[i], sizeof(AVStream));\n\n        st->codec = avcodec_alloc_context();\n\n        if (!st->codec) {\n\n            print_error(filename, AVERROR(ENOMEM));\n\n            ffmpeg_exit(1);\n\n        }\n\n        avcodec_copy_context(st->codec, ic->streams[i]->codec);\n\n        s->streams[i] = st;\n\n\n\n        codec = avcodec_find_encoder(st->codec->codec_id);\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_sample_fmt(st, codec);\n\n        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (video_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_pixel_fmt(st, codec);\n\n        }\n\n\n\n        if(!st->codec->thread_count)\n\n            st->codec->thread_count = 1;\n\n        if(st->codec->thread_count>1)\n\n            avcodec_thread_init(st->codec, st->codec->thread_count);\n\n\n\n        if(st->codec->flags & CODEC_FLAG_BITEXACT)\n\n            nopts = 1;\n\n    }\n\n\n\n    if (!nopts)\n\n        s->timestamp = av_gettime();\n\n\n\n    av_close_input_file(ic);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 598, "prediction": "0", "true_label": "1", "raw_text": "Question: static void uninit(AVFilterContext *ctx)\n\n{\n\n    ZScaleContext *s = ctx->priv;\n\n\n\n    zimg_filter_graph_free(s->graph);\n\n\n    av_freep(&s->tmp);\n\n    s->tmp_size = 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 599, "prediction": "0", "true_label": "0", "raw_text": " off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_POSTINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_W_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    case OPC2_32_BO_ST_W_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_W_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 600, "prediction": "0", "true_label": "0", "raw_text": "_registers(CPUState *cs)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int err, ret = 0;\n\n    unsigned int i;\n\n\n\n    /* Only get FPU state if we're emulating a CPU with an FPU */\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        /* FPU Control Registers */\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,\n\n                                    &env->active_fpu.fcr0);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_IR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        }\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,\n\n                                    &env->active_fpu.fcr31);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_CSR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        } else {\n\n            restore_fp_status(env);\n\n        }\n\n\n\n        /* Floating point registers */\n\n        for (i = 0; i < 32; ++i) {\n\n            if (env->CP0_Status & (1 << CP0St_FR)) {\n\n                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),\n\n                                              &env->active_fpu.fpr[i].d);\n\n            } else {\n\n                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),\n\n                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);\n\n            }\n\n            if (err < 0) {\n\n                DPRINTF(\"%s: Failed to get FPR%u (%d)\\n\", __func__, i, err);\n\n                ret = err;\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 601, "prediction": "0", "true_label": "0", "raw_text": " OPC_DMOD_G_2E:\n\n    case OPC_DMOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"dmod.g\";\n\n        break;\n\n    case OPC_DMODU_G_2E:\n\n    case OPC_DMODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"dmodu.g\";\n\n        break;\n\n#endif\n\n    }\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 602, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n\n{\n\n    struct vfio_region_info reg_info = {\n\n        .argsz = sizeof(reg_info),\n\n        .index = VFIO_PCI_ROM_REGION_INDEX\n\n    };\n\n    uint64_t size;\n\n    off_t off = 0;\n\n    size_t bytes;\n\n\n\n    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {\n\n        error_report(\"vfio: Error getting ROM info: %m\");\n\n        return;\n\n    }\n\n\n\n    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,\n\n                            (unsigned long)reg_info.offset,\n\n                            (unsigned long)reg_info.flags);\n\n\n\n    vdev->rom_size = size = reg_info.size;\n\n    vdev->rom_offset = reg_info.offset;\n\n\n\n    if (!vdev->rom_size) {\n\n        vdev->rom_read_failed = true;\n\n        error_report(\"vfio-pci: Cannot read device rom at \"\n\n                    \"%s\", vdev->vbasedev.name);\n\n        error_printf(\"Device option ROM contents are probably invalid \"\n\n                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"\n\n                    \"or load from file with romfile=\\n\");\n\n        return;\n\n    }\n\n\n\n    vdev->rom = g_malloc(size);\n\n    memset(vdev->rom, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,\n\n                      size, vdev->rom_offset + off);\n\n        if (bytes == 0) {\n\n            break;\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 603, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 604, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 605, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_qemu_strtoul_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321ul);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 606, "prediction": "1", "true_label": "0", "raw_text": "\n\n\t    VNC_DEBUG(\"The certificate uses an insecure algorithm\\n\");\n\n\n\n\treturn -1;\n\n    } else {\n\n\tVNC_DEBUG(\"Certificate is valid!\\n\");\n\n    }\n\n\n\n    /* Only support x509 for now */\n\n    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)\n\n\treturn -1;\n\n\n\n    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))\n\n\treturn -1;\n\n\n\n    for (i = 0 ; i < nCerts ; i++) {\n\n\tgnutls_x509_crt_t cert;\n\n\tVNC_DEBUG (\"Checking certificate chain %d\\n\", i);\n\n\tif (gnutls_x509_crt_init (&cert) < 0)\n\n\t    return -1;\n\n\n\n\tif (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_expiration_time (cert) < now) {\n\n\t    VNC_DEBUG(\"The certificate has expired\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tgnutls_x509_crt_deinit (cert);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 607, "prediction": "0", "true_label": "0", "raw_text": "Question: int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    FWCfgState *s = opaque;\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)\n\n        || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 608, "prediction": "0", "true_label": "1", "raw_text": "Question: static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],\n\n                                   int order, int qlevel, int len, int bps)\n\n{\n\n    int i, j;\n\n    int ebps = 1 << (bps-1);\n\n    unsigned sigma = 0;\n\n\n\n    for (i = order; i < len; i++)\n\n        sigma |= decoded[i] + ebps;\n\n\n\n    if (sigma < 2*ebps)\n\n        return;\n\n\n\n    for (i = len - 1; i >= order; i--) {\n\n        int64_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (int64_t)decoded[i-order+j];\n\n        decoded[i] -= p >> qlevel;\n\n    }\n\n    for (i = order; i < len; i++, decoded++) {\n\n        int32_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (uint32_t)decoded[j];\n\n        decoded[j] += p >> qlevel;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 609, "prediction": "0", "true_label": "0", "raw_text": "10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        /* check if packet is in play range specified by user, then queue, otherwise discard */\n\n        pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n\n                (pkt->pts - ic->streams[pkt->stream_index]->start_time) *\n\n                av_q2d(ic->streams[pkt->stream_index]->time_base) -\n\n                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n\n                <= ((double)duration / 1000000);\n\n        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        avformat_close_input(&is->ic);\n\n    }\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    SDL_DestroyMutex(wait_mutex);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 610, "prediction": "0", "true_label": "0", "raw_text": " }\n\n\n\n    if (render->filled_mv_blocks_num) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface contains %i unprocessed blocks.\\n\",\n\n               render->filled_mv_blocks_num);\n\n        return -1;\n\n    }\n\n    if (render->allocated_mv_blocks   < 1 ||\n\n        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||\n\n        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||\n\n        render->next_free_data_block_num >\n\n                        render->allocated_data_blocks -\n\n                        mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    render->picture_structure = s->picture_structure;\n\n    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;\n\n    render->p_future_surface  = NULL;\n\n    render->p_past_surface    = NULL;\n\n\n\n    switch(s->pict_type) {\n\n        case  FF_I_TYPE:\n\n            return 0; // no prediction from other frames\n\n        case  FF_B_TYPE:\n\n            next = (struct xvmc_pix_fmt*)s->next_picture.data[2];\n\n            if (!next)\n\n                return -1;\n\n            if (next->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_future_surface = next->p_surface;\n\n            // no return here, going to set forward prediction\n\n        case  FF_P_TYPE:\n\n            last = (struct xvmc_pix_fmt*)s->last_picture.data[2];\n\n            if (!last)\n\n                last = render; // predict second field from the first\n\n            if (last->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_past_surface = last->p_surface;\n\n            return 0;\n\n    }\n\n\n\nreturn -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 611, "prediction": "0", "true_label": "1", "raw_text": "Question: static int calculate_bitrate(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    int i, j;\n\n    int64_t lensum = 0;\n\n    int64_t maxpos = 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n\n\n        if (!st->nb_index_entries)\n\n            continue;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);\n\n        lensum += len;\n\n    }\n\n    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file\n\n        return 0;\n\n    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch\n\n        return 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n        int64_t duration;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n\n\n        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)\n\n            continue;\n\n        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;\n\n        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);\n\n    }\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 612, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 613, "prediction": "0", "true_label": "1", "raw_text": "Question: static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 614, "prediction": "0", "true_label": "1", "raw_text": "Question: static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n\n                                                 Error **errp)\n\n{\n\n    struct addrinfo ai, *res;\n\n    int rc;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return NULL;\n\n    }\n\n\n\n    if (saddr->host == NULL || saddr->port == NULL) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return NULL;\n\n    }\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, saddr->port, gai_strerror(rc));\n\n        return NULL;\n\n    }\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 615, "prediction": "0", "true_label": "1", "raw_text": "PC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (pcibus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            /* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. */\n\n            pci_nic_init_nofail(&nd_table[i], pcibus, \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n\n                              NULL, NULL);\n\n        if (success < 0) {\n\n            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,\n\n                               0, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (success < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n\n                                          ram_size - RAMDISK_ADDR);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\",\n\n                    initrd_filename, RAMDISK_ADDR);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n\n                                    initrd_size, kernel_cmdline) < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 616, "prediction": "0", "true_label": "0", "raw_text": "Question: void HELPER(stpq)(CPUS390XState *env, uint64_t addr,\n\n                  uint64_t low, uint64_t high)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    if (parallel_cpus) {\n\n#ifndef CONFIG_ATOMIC128\n\n        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);\n\n#else\n\n        int mem_idx = cpu_mmu_index(env, false);\n\n        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);\n\n\n\n        Int128 v = int128_make128(low, high);\n\n        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);\n\n#endif\n\n    } else {\n\n        check_alignment(env, addr, 16, ra);\n\n\n\n        cpu_stq_data_ra(env, addr + 0, high, ra);\n\n        cpu_stq_data_ra(env, addr + 8, low, ra);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 617, "prediction": "0", "true_label": "1", "raw_text": ")\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= src1[4*i + 1];\n\n\t\tdstV[i]= src1[4*i + 3];\n\n\t}\n\n#endif\n\n        assert(src1 == src2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 618, "prediction": "0", "true_label": "0", "raw_text": "Question: static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){\n\n    int i,j,xy,yz;\n\n    int res;\n\n    for(i=0; i<8; i++){\n\n        for(j=1; j<7; j++){\n\n            xy = j * stride + i;\n\n            yz = j * 8 + i;\n\n            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];\n\n            res +=2;\n\n            res >>=2;\n\n            dest[xy] = (uint8_t)res;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 619, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"mov                  %0, %%\"REG_a\"         \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq  (%1, %%\"REG_a\",2), %%mm0             \\n\\t\"\n\n        \"movq 8(%1, %%\"REG_a\",2), %%mm1             \\n\\t\"\n\n        \"psrlw                $8, %%mm0             \\n\\t\"\n\n        \"psrlw                $8, %%mm1             \\n\\t\"\n\n        \"packuswb          %%mm1, %%mm0             \\n\\t\"\n\n        \"movq              %%mm0, (%2, %%\"REG_a\")   \\n\\t\"\n\n        \"add                  $8, %%\"REG_a\"         \\n\\t\"\n\n        \" js                  1b                    \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src+width*2), \"r\" (dst+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++)\n\n        dst[i]= src[2*i+1];\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 620, "prediction": "0", "true_label": "1", "raw_text": "Question: static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 621, "prediction": "0", "true_label": "1", "raw_text": "filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 622, "prediction": "0", "true_label": "1", "raw_text": "Question: static int ccid_initfn(USBDevice *dev)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n\n\n    s->bus = ccid_bus_new(&dev->qdev);\n\n    s->card = NULL;\n\n    s->cardinfo = NULL;\n\n    s->migration_state = MIGRATION_NONE;\n\n    s->migration_target_ip = 0;\n\n    s->migration_target_port = 0;\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->notify_slot_change = false;\n\n    s->powered = true;\n\n    s->pending_answers_num = 0;\n\n    s->last_answer_error = 0;\n\n    s->bulk_in_pending_start = 0;\n\n    s->bulk_in_pending_end = 0;\n\n    s->current_bulk_in = NULL;\n\n    ccid_reset_error_status(s);\n\n    s->bulk_out_pos = 0;\n\n    ccid_reset_parameters(s);\n\n    ccid_reset(s);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 623, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ppc4xx_pob_reset (void *opaque)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    /* No error */\n\n    pob->bear = 0x00000000;\n\n    pob->besr[0] = 0x0000000;\n\n    pob->besr[1] = 0x0000000;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 624, "prediction": "1", "true_label": "1", "raw_text": "8, alog8, inv_sbox);\n\n        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n\n                     log8, alog8, sbox);\n\n    }\n\n\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n\n        return -1;\n\n\n\n    a->rounds = rounds;\n\n\n\n    memcpy(tk, key, KC * 4);\n\n\n\n    for (t = 0; t < (rounds + 1) * 16;) {\n\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n\n        t += KC * 4;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n\n        tk[0][0] ^= rcon[rconpointer++];\n\n\n\n        for (j = 1; j < KC; j++) {\n\n            if (KC != 8 || j != KC >> 1)\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= tk[j - 1][i];\n\n            else\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n\n        }\n\n    }\n\n\n\n    if (decrypt) {\n\n        for (i = 1; i < rounds; i++) {\n\n            av_aes_block tmp[3];\n\n            tmp[2] = a->round_key[i];\n\n            subshift(&tmp[1], 0, sbox);\n\n            mix(tmp, dec_multbl, 1, 3);\n\n            a->round_key[i] = tmp[0];\n\n        }\n\n    } else {\n\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 625, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 626, "prediction": "1", "true_label": "0", "raw_text": "vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset, false);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    if (nb_numa_nodes > 1) {\n\n        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu));\n\n    }\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 627, "prediction": "0", "true_label": "0", "raw_text": "\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 628, "prediction": "0", "true_label": "0", "raw_text": "0]; i<3 && !f; i++){\n\n        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);\n\n        f= fopen(filename, \"r\");\n\n        if(!f){\n\n            char *codec_name= *opt == 'v' ? video_codec_name :\n\n                              *opt == 'a' ? audio_codec_name :\n\n                                            subtitle_codec_name;\n\n            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i],  i ? \"\" : \".\", codec_name, arg);\n\n            f= fopen(filename, \"r\");\n\n        }\n\n    }\n\n    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||\n\n              is_dos_path(arg))){\n\n        snprintf(filename, sizeof(filename), arg);\n\n        f= fopen(filename, \"r\");\n\n    }\n\n\n\n    if(!f){\n\n        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);\n\n        av_exit(1);\n\n    }\n\n\n\n    while(!feof(f)){\n\n        int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1;\n\n        if(line[0] == '#' && !e)\n\n            continue;\n\n        e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;\n\n        if(e){\n\n            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);\n\n            av_exit(1);\n\n        }\n\n        if(!strcmp(tmp, \"acodec\")){\n\n            opt_audio_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"vcodec\")){\n\n            opt_video_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"scodec\")){\n\n            opt_subtitle_codec(tmp2);\n\n        }else if(opt_default(tmp, tmp2) < 0){\n\n            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);\n\n            av_exit(1);\n\n        }\n\n    }\n\n\n\n    fclose(f);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 629, "prediction": "0", "true_label": "1", "raw_text": "Question: static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf  = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n    uint64_t size    = avio_rl64(pb);\n\n    uint16_t nb_desc = avio_rl16(pb);\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_desc; i++) {\n\n        uint16_t name_len, type, val_len;\n\n        uint8_t *name = NULL;\n\n\n\n        name_len = avio_rl16(pb);\n\n        if (!name_len)\n\n            return AVERROR_INVALIDDATA;\n\n        name = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         name_len);\n\n        type    = avio_rl16(pb);\n\n        val_len = avio_rl16(pb);\n\n\n\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 630, "prediction": "0", "true_label": "1", "raw_text": " sector_offset, data_tmp, leading_length);\n\n            bytes_written = leading_length;\n\n            sector_write = merged_sector;\n\n        } else if (i == sectors - 1 && trailing_length) {\n\n            /* partial sector at the end of the buffer */\n\n            ret = bdrv_pread(bs->file,\n\n                            file_offset,\n\n                            merged_sector + trailing_length,\n\n                            VHDX_LOG_SECTOR_SIZE - trailing_length);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector, data_tmp, trailing_length);\n\n            bytes_written = trailing_length;\n\n            sector_write = merged_sector;\n\n        } else {\n\n            bytes_written = VHDX_LOG_SECTOR_SIZE;\n\n            sector_write = data_tmp;\n\n        }\n\n\n\n        /* populate the raw sector data into the proper structures,\n\n         * as well as update the descriptor, and convert to proper\n\n         * endianness */\n\n        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,\n\n                                  s->log.sequence);\n\n\n\n        data_tmp += bytes_written;\n\n        data_sector++;\n\n        new_desc++;\n\n        file_offset += VHDX_LOG_SECTOR_SIZE;\n\n    }\n\n\n\n    /* checksum covers entire entry, from the log header through the\n\n     * last data sector */\n\n    vhdx_update_checksum(buffer, total_length,\n\n                         offsetof(VHDXLogEntryHeader, checksum));\n\n\n\n    /* now write to the log */\n\n    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,\n\n                                 desc_sectors + sectors);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    if (sectors_written != desc_sectors + sectors) {\n\n        /* instead of failing, we could flush the log here */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    s->log.sequence++;\n\n    /* write new tail */\n\n    s->log.tail = s->log.write;\n\n\n\nexit:\n\n    qemu_vfree(buffer);\n\n    qemu_vfree(merged_sector);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 631, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 632, "prediction": "0", "true_label": "1", "raw_text": "c->stream->feed_streams[i] == pkt.stream_index) {\n\n                            pkt.stream_index = i;\n\n                            if (pkt.flags & PKT_FLAG_KEY) {\n\n                                c->got_key_frame |= 1 << i;\n\n                            }\n\n                            /* See if we have all the key frames, then \n\n                             * we start to send. This logic is not quite\n\n                             * right, but it works for the case of a \n\n                             * single video stream with one or more\n\n                             * audio streams (for which every frame is \n\n                             * typically a key frame). \n\n                             */\n\n                            if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) {\n\n                                goto send_it;\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    AVCodecContext *codec;\n\n                send_it:\n\n                    /* Fudge here */\n\n                    codec = &c->fmt_ctx.streams[pkt.stream_index]->codec;\n\n\n\n                    codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0);\n\n\n\n#ifdef PJSG\n\n                    if (codec->codec_type == CODEC_TYPE_AUDIO) {\n\n                        codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000;\n\n                        /* printf(\"Calculated size %d, from sr %d, duration %d\\n\", codec->frame_size, codec->sample_rate, pkt.duration); */\n\n                    }\n\n#endif\n\n\n\n                    if (av_write_packet(&c->fmt_ctx, &pkt, 0))\n\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n\n\n                    codec->frame_number++;\n\n                }\n\n\n\n                av_free_packet(&pkt);\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n    case HTTPSTATE_SEND_DATA_TRAILER:\n\n        /* last packet test ? */\n\n        if (c->last_packet_sent)\n\n            return -1;\n\n        /* prepare header */\n\n        av_write_trailer(&c->fmt_ctx);\n\n        c->last_packet_sent = 1;\n\n        break;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 633, "prediction": "0", "true_label": "1", "raw_text": "Question: static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)\n\n{\n\n    if (!buffer->cmd) {\n\n        AVBufferRef *buf = buffer->user_data;\n\n        av_buffer_unref(&buf);\n\n    }\n\n    mmal_buffer_header_release(buffer);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 634, "prediction": "0", "true_label": "1", "raw_text": "Question: CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 635, "prediction": "0", "true_label": "0", "raw_text": "76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n        AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3,\n\n                    res0, res1, res2, res3);\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 636, "prediction": "0", "true_label": "0", "raw_text": "Question: static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 637, "prediction": "0", "true_label": "0", "raw_text": " 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,\n\n                                           PPC_intack_write, NULL,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL, DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 638, "prediction": "0", "true_label": "0", "raw_text": "chroma_w;\n\n    int vsub = desc->log2_chroma_h;\n\n    int plane, j;\n\n\n\n    for (plane = 0; plane < desc->nb_components; plane++) {\n\n        int cols  = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w;\n\n        int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h;\n\n        uint8_t *dstp = dst_frame->data[plane];\n\n        const uint8_t *srcp = src_frame->data[plane];\n\n\n\n        av_assert0(cols >= 0 || lines >= 0);\n\n\n\n        lines = (lines + (field_type == FIELD_UPPER)) / 2;\n\n        if (field_type == FIELD_LOWER)\n\n            srcp += src_frame->linesize[plane];\n\n        if (field_type == FIELD_LOWER)\n\n            dstp += dst_frame->linesize[plane];\n\n        if (lowpass) {\n\n            int srcp_linesize = src_frame->linesize[plane] * 2;\n\n            int dstp_linesize = dst_frame->linesize[plane] * 2;\n\n            for (j = lines; j > 0; j--) {\n\n                const uint8_t *srcp_above = srcp - src_frame->linesize[plane];\n\n                const uint8_t *srcp_below = srcp + src_frame->linesize[plane];\n\n                if (j == lines)\n\n                    srcp_above = srcp; // there is no line above\n\n                if (j == 1)\n\n                    srcp_below = srcp; // there is no line below\n\n                s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below);\n\n                dstp += dstp_linesize;\n\n                srcp += srcp_linesize;\n\n            }\n\n        } else {\n\n            av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2,\n\n                                srcp, src_frame->linesize[plane] * 2,\n\n                                cols, lines);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 639, "prediction": "0", "true_label": "1", "raw_text": "Question: target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 640, "prediction": "0", "true_label": "1", "raw_text": "Question: void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 641, "prediction": "0", "true_label": "1", "raw_text": "Question: void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 642, "prediction": "0", "true_label": "1", "raw_text": "0q0,\n\n                                                   const int lim_q1,\n\n                                                   const int lim_p1)\n\n{\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    int i, t, u, diff;\n\n\n\n    for (i = 0; i < 4; i++, src += stride) {\n\n        int diff_p1p0 = src[-2*step] - src[-1*step];\n\n        int diff_q1q0 = src[ 1*step] - src[ 0*step];\n\n        int diff_p1p2 = src[-2*step] - src[-3*step];\n\n        int diff_q1q2 = src[ 1*step] - src[ 2*step];\n\n\n\n        t = src[0*step] - src[-1*step];\n\n        if (!t)\n\n            continue;\n\n\n\n        u = (alpha * FFABS(t)) >> 7;\n\n        if (u > 3 - (filter_p1 && filter_q1))\n\n            continue;\n\n\n\n        t <<= 2;\n\n        if (filter_p1 && filter_q1)\n\n            t += src[-2*step] - src[1*step];\n\n\n\n        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n\n        src[-1*step] = cm[src[-1*step] + diff];\n\n        src[ 0*step] = cm[src[ 0*step] - diff];\n\n\n\n        if (filter_p1 && FFABS(diff_p1p2) <= beta) {\n\n            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n\n            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n\n        }\n\n\n\n        if (filter_q1 && FFABS(diff_q1q2) <= beta) {\n\n            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n\n            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 643, "prediction": "0", "true_label": "1", "raw_text": "Question: static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 644, "prediction": "0", "true_label": "1", "raw_text": "Question: static int normalize_bits(int num, int width)\n\n{\n\n    if (!num)\n\n        return 0;\n\n    if (num == -1)\n\n        return width;\n\n    if (num < 0)\n\n        num = ~num;\n\n\n\n    return width - av_log2(num);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 645, "prediction": "0", "true_label": "1", "raw_text": "Question: static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 646, "prediction": "0", "true_label": "1", "raw_text": "Question: static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 647, "prediction": "0", "true_label": "1", "raw_text": "Question: void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n\n    visit_free(v);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 648, "prediction": "0", "true_label": "0", "raw_text": "Question: static int srt_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    AVSubtitle *sub = data;\n\n    AVBPrint buffer;\n\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\n    int size, ret;\n\n    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);\n\n    FFASSDecoderContext *s = avctx->priv_data;\n\n\n\n    if (p && size == 16) {\n\n        x1 = AV_RL32(p     );\n\n        y1 = AV_RL32(p +  4);\n\n        x2 = AV_RL32(p +  8);\n\n        y2 = AV_RL32(p + 12);\n\n    }\n\n\n\n    if (avpkt->size <= 0)\n\n        return avpkt->size;\n\n\n\n    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);\n\n    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);\n\n    av_bprint_finalize(&buffer, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    return avpkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 649, "prediction": "0", "true_label": "1", "raw_text": "csp->comp[td->plane].depth_minus1 + 8) / 8;\n\n    int pix_3 = 3 * df;\n\n    int slice_h = td->h / nb_jobs;\n\n    int slice_start = jobnr * slice_h;\n\n    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;\n\n    int y;\n\n\n\n    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,\n\n     * we need to call the c variant which avoids this for border pixels\n\n     */\n\n    for (y = slice_start; y < slice_end; y++) {\n\n        if ((y ^ td->parity) & 1) {\n\n            uint8_t *prev = &s->prev->data[td->plane][y * refs];\n\n            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];\n\n            uint8_t *next = &s->next->data[td->plane][y * refs];\n\n            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];\n\n            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;\n\n            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,\n\n                           next + pix_3, td->w - 6,\n\n                           y + 1 < td->h ? refs : -refs,\n\n                           y ? -refs : refs,\n\n                           td->parity ^ td->tff, mode);\n\n            s->filter_edges(dst, prev, cur, next, td->w,\n\n                            y + 1 < td->h ? refs : -refs,\n\n                            y ? -refs : refs,\n\n                            td->parity ^ td->tff, mode);\n\n        } else {\n\n            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],\n\n                   &s->cur->data[td->plane][y * refs], td->w * df);\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 650, "prediction": "0", "true_label": "0", "raw_text": "Question: int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 651, "prediction": "0", "true_label": "1", "raw_text": " }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        if (s->frame_size > 0) {\n\n            size[0] = s->frame_size;\n\n        } else {\n\n            size[0] = 4096;\n\n        }\n\n    }\n\n\n\n    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)\n\n        return AVERROR(ENOMEM);\n\n    pkt->stream_index = 0;\n\n    pkt->flags       |= AV_PKT_FLAG_KEY;\n\n    if (s->ts_from_file) {\n\n        struct stat img_stat;\n\n        if (stat(filename, &img_stat))\n\n            return AVERROR(EIO);\n\n        pkt->pts = (int64_t)img_stat.st_mtime;\n\n        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);\n\n    } else if (!s->is_pipe) {\n\n        pkt->pts      = s->pts;\n\n    }\n\n\n\n    pkt->size = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        if (f[i]) {\n\n            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if (ret[i] > 0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        s->pts++;\n\n        return 0;\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 652, "prediction": "0", "true_label": "1", "raw_text": "Question: void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 653, "prediction": "0", "true_label": "1", "raw_text": "\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t5],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t6],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t7],  %[t3]   \\n\\t\"\n\n\n\n            \".set pop                       \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 9 * qc1;\n\n        curidx += qc2 + 40;\n\n\n\n        curidx2 = 9 * qc3;\n\n        curidx2 += qc4 + 40;\n\n\n\n        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);\n\n        v_bits  = p_bits[curidx] + p_bits[curidx2];\n\n        put_bits(pb, v_bits, v_codes);\n\n\n\n        if (out) {\n\n           vec1 = &p_vec[curidx*2 ];\n\n           vec2 = &p_vec[curidx2*2];\n\n           out[i+0] = vec1[0] * IQ;\n\n           out[i+1] = vec1[1] * IQ;\n\n           out[i+2] = vec2[0] * IQ;\n\n           out[i+3] = vec2[1] * IQ;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 654, "prediction": "0", "true_label": "0", "raw_text": " is->audio_hw_buf_size = spec.size;\n\n        is->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;\n\n        is->resample_sample_fmt     = is->sdl_sample_fmt;\n\n        is->resample_channel_layout = avctx->channel_layout;\n\n        is->resample_sample_rate    = avctx->sample_rate;\n\n    }\n\n\n\n    ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;\n\n    switch (avctx->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        is->audio_stream = stream_index;\n\n        is->audio_st = ic->streams[stream_index];\n\n        is->audio_buf_size  = 0;\n\n        is->audio_buf_index = 0;\n\n\n\n        /* init averaging filter */\n\n        is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n\n        is->audio_diff_avg_count = 0;\n\n        /* since we do not have a precise anough audio fifo fullness,\n\n           we correct audio sync only if larger than this threshold */\n\n        is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / avctx->sample_rate;\n\n\n\n        memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));\n\n        packet_queue_init(&is->audioq);\n\n        SDL_PauseAudio(0);\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        is->video_stream = stream_index;\n\n        is->video_st = ic->streams[stream_index];\n\n\n\n        packet_queue_init(&is->videoq);\n\n        is->video_tid = SDL_CreateThread(video_thread, is);\n\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n        is->subtitle_stream = stream_index;\n\n        is->subtitle_st = ic->streams[stream_index];\n\n        packet_queue_init(&is->subtitleq);\n\n\n\n        is->subtitle_tid = SDL_CreateThread(subtitle_thread, is);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    av_dict_free(&opts);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 655, "prediction": "0", "true_label": "1", "raw_text": "Question: static void keyword_literal(void)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QObject *null;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", false));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n    QDECREF(qbool);\n\n\n\n    /* Test that non-zero values other than 1 get collapsed to true */\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", 2));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"null\", NULL);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QNULL);\n\n\n\n    null = qnull();\n\n    g_assert(null == obj);\n\n\n\n    qobject_decref(obj);\n\n    qobject_decref(null);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 656, "prediction": "0", "true_label": "0", "raw_text": "KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = qemu_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 657, "prediction": "0", "true_label": "0", "raw_text": "Question: void DMA_run(void)\n\n{\n\n    /* XXXXX */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 658, "prediction": "0", "true_label": "0", "raw_text": "Question: INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 659, "prediction": "0", "true_label": "0", "raw_text": "Question: uint32_t helper_fcmp_un(uint32_t a, uint32_t b)\n\n{\n\n    CPU_FloatU fa, fb;\n\n    uint32_t r = 0;\n\n\n\n    fa.l = a;\n\n    fb.l = b;\n\n\n\n    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {\n\n        update_fpu_flags(float_flag_invalid);\n\n        r = 1;\n\n    }\n\n\n\n    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {\n\n        r = 1;\n\n    }\n\n\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 660, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vhost_user_start(VhostUserState *s)\n\n{\n\n    VhostNetOptions options;\n\n\n\n    if (vhost_user_running(s)) {\n\n        return 0;\n\n    }\n\n\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    options.net_backend = &s->nc;\n\n    options.opaque = s->chr;\n\n\n\n    s->vhost_net = vhost_net_init(&options);\n\n\n\n    return vhost_user_running(s) ? 0 : -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 661, "prediction": "0", "true_label": "0", "raw_text": "Question: static int alac_set_info(ALACContext *alac)\n\n{\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, alac->avctx->extradata,\n\n                     alac->avctx->extradata_size);\n\n\n\n    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4\n\n\n\n    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);\n\n    if (alac->max_samples_per_frame >= UINT_MAX/4){\n\n        av_log(alac->avctx, AV_LOG_ERROR,\n\n               \"max_samples_per_frame too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    bytestream2_skipu(&gb, 1);  // compatible version\n\n    alac->sample_size          = bytestream2_get_byteu(&gb);\n\n    alac->rice_history_mult    = bytestream2_get_byteu(&gb);\n\n    alac->rice_initial_history = bytestream2_get_byteu(&gb);\n\n    alac->rice_limit           = bytestream2_get_byteu(&gb);\n\n    alac->channels             = bytestream2_get_byteu(&gb);\n\n    bytestream2_get_be16u(&gb); // maxRun\n\n    bytestream2_get_be32u(&gb); // max coded frame size\n\n    bytestream2_get_be32u(&gb); // average bitrate\n\n    bytestream2_get_be32u(&gb); // samplerate\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 662, "prediction": "0", "true_label": "1", "raw_text": " s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 663, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_dealloc_types(void)\n\n{\n\n    UserDefOne *ud1test, *ud1a, *ud1b;\n\n    UserDefOneList *ud1list;\n\n\n\n    ud1test = g_malloc0(sizeof(UserDefOne));\n\n    ud1test->base = g_new0(UserDefZero, 1);\n\n    ud1test->base->integer = 42;\n\n    ud1test->string = g_strdup(\"hi there 42\");\n\n\n\n    qapi_free_UserDefOne(ud1test);\n\n\n\n    ud1a = g_malloc0(sizeof(UserDefOne));\n\n    ud1a->base = g_new0(UserDefZero, 1);\n\n    ud1a->base->integer = 43;\n\n    ud1a->string = g_strdup(\"hi there 43\");\n\n\n\n    ud1b = g_malloc0(sizeof(UserDefOne));\n\n    ud1b->base = g_new0(UserDefZero, 1);\n\n    ud1b->base->integer = 44;\n\n    ud1b->string = g_strdup(\"hi there 44\");\n\n\n\n    ud1list = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->value = ud1a;\n\n    ud1list->next = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->next->value = ud1b;\n\n\n\n    qapi_free_UserDefOneList(ud1list);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 664, "prediction": "0", "true_label": "0", "raw_text": "Question: void net_checksum_calculate(uint8_t *data, int length)\n\n{\n\n    int hlen, plen, proto, csum_offset;\n\n    uint16_t csum;\n\n\n\n    if ((data[14] & 0xf0) != 0x40)\n\n\treturn; /* not IPv4 */\n\n    hlen  = (data[14] & 0x0f) * 4;\n\n    plen  = (data[16] << 8 | data[17]) - hlen;\n\n    proto = data[23];\n\n\n\n    switch (proto) {\n\n    case PROTO_TCP:\n\n\tcsum_offset = 16;\n\n\tbreak;\n\n    case PROTO_UDP:\n\n\tcsum_offset = 6;\n\n\tbreak;\n\n    default:\n\n\treturn;\n\n    }\n\n\n\n    if (plen < csum_offset+2)\n\n\treturn;\n\n\n\n    data[14+hlen+csum_offset]   = 0;\n\n    data[14+hlen+csum_offset+1] = 0;\n\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n\n    data[14+hlen+csum_offset]   = csum >> 8;\n\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 665, "prediction": "0", "true_label": "0", "raw_text": " = g_list_append(plus_features,\n\n                                          g_strdup(featurestr + 1));\n\n            continue;\n\n        } else if (featurestr[0] == '-') {\n\n            minus_features = g_list_append(minus_features,\n\n                                           g_strdup(featurestr + 1));\n\n            continue;\n\n        }\n\n\n\n        eq = strchr(featurestr, '=');\n\n        if (eq) {\n\n            *eq++ = 0;\n\n            val = eq;\n\n        } else {\n\n            val = \"on\";\n\n        }\n\n\n\n        feat2prop(featurestr);\n\n        name = featurestr;\n\n\n\n        if (g_list_find_custom(plus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"+%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n        if (g_list_find_custom(minus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"-%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n\n\n        /* Special case: */\n\n        if (!strcmp(name, \"tsc-freq\")) {\n\n            int64_t tsc_freq;\n\n\n\n            tsc_freq = qemu_strtosz_metric(val, NULL);\n\n            if (tsc_freq < 0) {\n\n                error_setg(errp, \"bad numerical value %s\", val);\n\n                return;\n\n            }\n\n            snprintf(num, sizeof(num), \"%\" PRId64, tsc_freq);\n\n            val = num;\n\n            name = \"tsc-frequency\";\n\n        }\n\n\n\n        prop = g_new0(typeof(*prop), 1);\n\n        prop->driver = typename;\n\n        prop->property = g_strdup(name);\n\n        prop->value = g_strdup(val);\n\n        prop->errp = &error_fatal;\n\n        qdev_prop_register_global(prop);\n\n    }\n\n\n\n    if (ambiguous) {\n\n        error_report(\"warning: Compatibility of ambiguous CPU model \"\n\n                     \"strings won't be kept on future QEMU versions\");\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 666, "prediction": "0", "true_label": "1", "raw_text": "Question: static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n\n                                               VirtQueue *vq,\n\n                                               EventNotifierHandler *handler,\n\n                                               int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        exit(1);\n\n    }\n\n    r->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);\n\n    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);\n\n\n\n    r->parent = s;\n\n\n\n    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n\n        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");\n\n        exit(1);\n\n    }\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 667, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)\n\n{\n\n    NetPacket *packet, *next;\n\n\n\n    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {\n\n        if (packet->sender == from) {\n\n            QTAILQ_REMOVE(&queue->packets, packet, entry);\n\n\n            g_free(packet);\n\n        }\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 668, "prediction": "0", "true_label": "1", "raw_text": "Question: static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n\n                                   size_t datalen)\n\n{\n\n    ssize_t ret = gnutls_read(*session, data, datalen);\n\n    if (ret < 0) {\n\n        if (ret == GNUTLS_E_AGAIN) {\n\n            errno = EAGAIN;\n\n        } else {\n\n            errno = EIO;\n\n        }\n\n        ret = -1;\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 669, "prediction": "0", "true_label": "1", "raw_text": "\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n\n\n    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)\n\n        return 0;\n\n\n\n    if (s->avctx->hwaccel) {\n\n        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n    }\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)\n\n        ff_xvmc_field_end(s);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    /* end of slice reached */\n\n    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {\n\n        /* end of image */\n\n\n\n        ff_er_frame_end(&s->er);\n\n\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else {\n\n            if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n                s->picture_number++;\n\n            /* latency of 1 frame for I- and P-frames */\n\n            /* XXX: use another variable than picture_number */\n\n            if (s->last_picture_ptr != NULL) {\n\n                int ret = av_frame_ref(pict, &s->last_picture_ptr->f);\n\n                if (ret < 0)\n\n                    return ret;\n\n                ff_print_debug_info(s, s->last_picture_ptr);\n\n            }\n\n        }\n\n\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 670, "prediction": "0", "true_label": "1", "raw_text": "\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 671, "prediction": "0", "true_label": "0", "raw_text": "Question: static void stream_close(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int i;\n\n    /* XXX: use a special url_shutdown call to abort parse cleanly */\n\n    is->abort_request = 1;\n\n    SDL_WaitThread(is->read_tid, NULL);\n\n    SDL_WaitThread(is->refresh_tid, NULL);\n\n    packet_queue_destroy(&is->videoq);\n\n    packet_queue_destroy(&is->audioq);\n\n    packet_queue_destroy(&is->subtitleq);\n\n\n\n    /* free all pictures */\n\n    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {\n\n        vp = &is->pictq[i];\n\n#if CONFIG_AVFILTER\n\n        avfilter_unref_bufferp(&vp->picref);\n\n#endif\n\n        if (vp->bmp) {\n\n            SDL_FreeYUVOverlay(vp->bmp);\n\n            vp->bmp = NULL;\n\n        }\n\n    }\n\n    SDL_DestroyMutex(is->pictq_mutex);\n\n    SDL_DestroyCond(is->pictq_cond);\n\n    SDL_DestroyMutex(is->subpq_mutex);\n\n    SDL_DestroyCond(is->subpq_cond);\n\n    SDL_DestroyCond(is->continue_read_thread);\n\n#if !CONFIG_AVFILTER\n\n    sws_freeContext(is->img_convert_ctx);\n\n#endif\n\n    av_free(is);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 672, "prediction": "0", "true_label": "1", "raw_text": "Question: static void init_gain_table(COOKContext *q) {\n\n    int i;\n\n    q->gain_size_factor = q->samples_per_channel/8;\n\n    for (i=0 ; i<23 ; i++) {\n\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n\n                               (1.0/(double)q->gain_size_factor));\n\n    }\n\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 673, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 674, "prediction": "0", "true_label": "0", "raw_text": "Question: static int scsi_device_init(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->init) {\n\n        return sc->init(s);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 675, "prediction": "0", "true_label": "0", "raw_text": "Question: static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n                             int nb_sectors, int dirty)\n\n{\n\n    int64_t start, end;\n\n    unsigned long val, idx, bit;\n\n\n\n    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    for (; start <= end; start++) {\n\n        idx = start / (sizeof(unsigned long) * 8);\n\n        bit = start % (sizeof(unsigned long) * 8);\n\n        val = bs->dirty_bitmap[idx];\n\n        if (dirty) {\n\n            val |= 1 << bit;\n\n        } else {\n\n            val &= ~(1 << bit);\n\n        }\n\n        bs->dirty_bitmap[idx] = val;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 676, "prediction": "0", "true_label": "0", "raw_text": "Question: static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,\n\n    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)\n\n{\n\n    size_t fetched = 0;\n\n    struct iovec *src = pkt->vec;\n\n\n\n    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;\n\n\n\n    while (fetched < pkt->virt_hdr.gso_size) {\n\n\n\n        /* no more place in fragment iov */\n\n        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {\n\n            break;\n\n        }\n\n\n\n        /* no more data in iovec */\n\n        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {\n\n            break;\n\n        }\n\n\n\n\n\n        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;\n\n        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,\n\n            pkt->virt_hdr.gso_size - fetched);\n\n\n\n        *src_offset += dst[*dst_idx].iov_len;\n\n        fetched += dst[*dst_idx].iov_len;\n\n\n\n        if (*src_offset == src[*src_idx].iov_len) {\n\n            *src_offset = 0;\n\n            (*src_idx)++;\n\n        }\n\n\n\n        (*dst_idx)++;\n\n    }\n\n\n\n    return fetched;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 677, "prediction": "0", "true_label": "0", "raw_text": "Question: static void lsi_ram_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t newval;\n\n    uint32_t mask;\n\n    int shift;\n\n\n\n    newval = s->script_ram[addr >> 2];\n\n    shift = (addr & 3) * 8;\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    newval &= ~(mask << shift);\n\n    newval |= val << shift;\n\n    s->script_ram[addr >> 2] = newval;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 678, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n\n{\n\n    int ret, i;\n\n\n\n    frame->width  = s->avctx->width  + 2;\n\n    frame->height = s->avctx->height + 2;\n\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    for (i = 0; frame->data[i]; i++) {\n\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n\n        frame->data[i] += offset;\n\n    }\n\n    frame->width  = s->avctx->width;\n\n    frame->height = s->avctx->height;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 679, "prediction": "0", "true_label": "0", "raw_text": "2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 680, "prediction": "0", "true_label": "0", "raw_text": "pest file in\n\n         * the backing chain (i.e., the very base); however, the traditional\n\n         * behavior of qemu-img commit is using the immediate backing file. */\n\n        base_bs = backing_bs(bs);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, \"Image does not have a backing file\");\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    cbi = (CommonBlockJobCBInfo){\n\n        .errp = &local_err,\n\n        .bs   = bs,\n\n    };\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n    commit_active_start(\"commit\", bs, base_bs, BLOCK_JOB_DEFAULT, 0,\n\n                        BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi,\n\n                        &local_err, false);\n\n    aio_context_release(aio_context);\n\n    if (local_err) {\n\n        goto done;\n\n    }\n\n\n\n    /* When the block job completes, the BlockBackend reference will point to\n\n     * the old backing file. In order to avoid that the top image is already\n\n     * deleted, so we can still empty it afterwards, increment the reference\n\n     * counter here preemptively. */\n\n    if (!drop) {\n\n        bdrv_ref(bs);\n\n    }\n\n\n\n    run_block_job(bs->job, &local_err);\n\n    if (local_err) {\n\n        goto unref_backing;\n\n    }\n\n\n\n    if (!drop && bs->drv->bdrv_make_empty) {\n\n        ret = bs->drv->bdrv_make_empty(bs);\n\n        if (ret) {\n\n            error_setg_errno(&local_err, -ret, \"Could not empty %s\",\n\n                             filename);\n\n            goto unref_backing;\n\n        }\n\n    }\n\n\n\nunref_backing:\n\n    if (!drop) {\n\n        bdrv_unref(bs);\n\n    }\n\n\n\ndone:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        return 1;\n\n    }\n\n\n\n    qprintf(quiet, \"Image committed.\\n\");\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 681, "prediction": "0", "true_label": "0", "raw_text": "[] = {\"DYLD_DEBUG_TRACE=yes\",\n\n    \"DYLD_PREBIND_DEBUG=3\", \"DYLD_UNKNOW_TRACE=yes\",\n\n    \"DYLD_PRINT_INITIALIZERS=yes\",\n\n    \"DYLD_PRINT_SEGMENTS=yes\", \"DYLD_PRINT_REBASINGS=yes\", \"DYLD_PRINT_BINDINGS=yes\", \"DYLD_PRINT_INITIALIZERS=yes\", \"DYLD_PRINT_WARNINGS=yes\" };\n\n\n\n    char ** extra_env = malloc(sizeof(extra_env_static));\n\n    bcopy(extra_env_static, extra_env, sizeof(extra_env_static));\n\n    page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID);\n\n\n\n    for(i = 0; i<9; i++)\n\n    {\n\n        DPRINTF(\"pushing (extra) env %s (0x%x)\\n\", (char*)extra_env[i], (int)extra_env[i]);\n\n        stl(stack, (int) extra_env[i]);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get argc */\n\n    for(argc = 0; argv[argc]; argc++);\n\n\n\n    for(i = argc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing arg %s (0x%x)\\n\", (char*)argv[i], (int)argv[i]);\n\n        stl(stack, (int) argv[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    DPRINTF(\"pushing argc %d \\n\", argc);\n\n    stl(stack, argc);\n\n    stack--;\n\n\n\n    DPRINTF(\"pushing mh 0x%x \\n\", (int)mh);\n\n    stl(stack, (int) mh);\n\n\n\n    /* Stack points on the mh */\n\n    return (unsigned long)stack;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 682, "prediction": "0", "true_label": "0", "raw_text": "locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            rtype = sd_illegal;\n\n            goto send_response;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    if (rtype == sd_illegal) {\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n    }\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\nsend_response:\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    case sd_illegal:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 683, "prediction": "0", "true_label": "0", "raw_text": "\n\n        } else {\n\n            *eax = cpu->phys_bits;\n\n        }\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;\n\n        }\n\n        break;\n\n    case 0x8000000A:\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            *eax = 0x00000001; /* SVM Revision */\n\n            *ebx = 0x00000010; /* nr of ASIDs */\n\n            *ecx = 0;\n\n            *edx = env->features[FEAT_SVM]; /* optional features */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xC0000000:\n\n        *eax = env->cpuid_xlevel2;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xC0000001:\n\n        /* Support for VIA CPU's CPUID instruction */\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_C000_0001_EDX];\n\n        break;\n\n    case 0xC0000002:\n\n    case 0xC0000003:\n\n    case 0xC0000004:\n\n        /* Reserved for the future, and now filled with zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    default:\n\n        /* reserved values: zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 684, "prediction": "0", "true_label": "0", "raw_text": "Question: static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)\n\n{\n\n    char *argstr_flat;\n\n    wchar_t **argv_w;\n\n    int i, buffsize = 0, offset = 0;\n\n\n\n    if (win32_argv_utf8) {\n\n        *argc_ptr = win32_argc;\n\n        *argv_ptr = win32_argv_utf8;\n\n        return;\n\n    }\n\n\n\n    win32_argc = 0;\n\n    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);\n\n    if (win32_argc <= 0 || !argv_w)\n\n        return;\n\n\n\n    /* determine the UTF-8 buffer size (including NULL-termination symbols) */\n\n    for (i = 0; i < win32_argc; i++)\n\n        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                        NULL, 0, NULL, NULL);\n\n\n\n    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);\n\n    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);\n\n    if (win32_argv_utf8 == NULL) {\n\n        LocalFree(argv_w);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < win32_argc; i++) {\n\n        win32_argv_utf8[i] = &argstr_flat[offset];\n\n        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                      &argstr_flat[offset],\n\n                                      buffsize - offset, NULL, NULL);\n\n    }\n\n    win32_argv_utf8[i] = NULL;\n\n    LocalFree(argv_w);\n\n\n\n    *argc_ptr = win32_argc;\n\n    *argv_ptr = win32_argv_utf8;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 685, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 686, "prediction": "1", "true_label": "0", "raw_text": "Question: int MP3lame_encode_frame(AVCodecContext *avctx,\n\n                     unsigned char *frame, int buf_size, void *data)\n\n{\n\n\tMp3AudioContext *s = avctx->priv_data;\n\n\tint num, i;\n\n//av_log(avctx, AV_LOG_DEBUG, \"%X %d %X\\n\", (int)frame, buf_size, (int)data);\n\n//        if(data==NULL)\n\n//            return lame_encode_flush(s->gfp, frame, buf_size);\n\n\n\n\t/* lame 3.91 dies on '1-channel interleaved' data */\n\n\tif (s->stereo) {\n\n\t\tnum = lame_encode_buffer_interleaved(s->gfp, data,\n\n\t\t\tMPA_FRAME_SIZE, frame, buf_size);\n\n\t} else {\n\n\t\tnum = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,\n\n\t\t\tframe, buf_size);\n\n\n\n/*av_log(avctx, AV_LOG_DEBUG, \"in:%d out:%d\\n\", MPA_FRAME_SIZE, num);\n\nfor(i=0; i<num; i++){\n\n    av_log(avctx, AV_LOG_DEBUG, \"%2X \", frame[i]);\n\n}*/\n\n\t}\n\n\n\n\treturn num;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 687, "prediction": "0", "true_label": "1", "raw_text": "Question: int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 688, "prediction": "0", "true_label": "1", "raw_text": "_MIXED_MV)\n\n    {\n\n        status = bitplane_decoding(&v->mv_type_mb_plane, v);\n\n        if (status < 0)\n\n            return -1;\n\n#if TRACE\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n    }\n\n\n\n    //bitplane\n\n    status = bitplane_decoding(&v->direct_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"Skip MB plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    /* FIXME: what is actually chosen for B frames ? */\n\n    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables\n\n    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];\n\n\n\n    if (v->dquant)\n\n    {\n\n        vop_dquant_decoding(v);\n\n    }\n\n\n\n    if (v->vstransform)\n\n    {\n\n        v->ttmbf = get_bits(gb, 1);\n\n        if (v->ttmbf)\n\n        {\n\n            v->ttfrm = get_bits(gb, 2);\n\n            av_log(v->s.avctx, AV_LOG_INFO, \"Transform used: %ix%i\\n\",\n\n                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);\n\n        }\n\n    }\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 689, "prediction": "0", "true_label": "1", "raw_text": "Question: static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        MXFTrack *track = s->streams[i]->priv_data;\n\n        /* SMPTE 379M 7.3 */\n\n        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n\n            return i;\n\n    }\n\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n\n    return s->nb_streams == 1 ? 0 : -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 690, "prediction": "0", "true_label": "1", "raw_text": "1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd);\n\n    } else { // hpel mc - always used for luma\n\n        dxy = (my & 2) | ((mx & 2) >> 1);\n\n        if (!v->rnd)\n\n            s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n        else\n\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n    }\n\n\n\n    if (s->flags & CODEC_FLAG_GRAY) return;\n\n    /* Chroma MC always uses qpel bilinear */\n\n    uvmx = (uvmx & 3) << 1;\n\n    uvmy = (uvmy & 3) << 1;\n\n    if (!v->rnd) {\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    } else {\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 691, "prediction": "0", "true_label": "1", "raw_text": "_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"movq (%2, %%\"REG_a\",4), %%mm2\t\\n\\t\"\n\n\t\t\"movq 8(%2, %%\"REG_a\",4), %%mm3\t\\n\\t\"\n\n\t\tPAVGB(%%mm2, %%mm0)\n\n\t\tPAVGB(%%mm3, %%mm1)\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%4, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" ((long)-width), \"r\" (src1+width*4), \"r\" (src2+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;\n\n\t\tdstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;\n\n\t}\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 692, "prediction": "0", "true_label": "0", "raw_text": "(s, \"MTV files without audio\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    mtv->full_segment_size =\n\n        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +\n\n        mtv->img_segment_size;\n\n    mtv->video_fps         = (mtv->audio_br / 4) / audio_subsegments;\n\n\n\n    // FIXME Add sanity check here\n\n\n\n    // all systems go! init decoders\n\n\n\n    // video - raw rgb565\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id        = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->pix_fmt         = AV_PIX_FMT_RGB565BE;\n\n    st->codec->width           = mtv->img_width;\n\n    st->codec->height          = mtv->img_height;\n\n    st->codec->sample_rate     = mtv->video_fps;\n\n    st->codec->extradata       = av_strdup(\"BottomUp\");\n\n    st->codec->extradata_size  = 9;\n\n\n\n    // audio - mp3\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n\n    st->codec->codec_id        = AV_CODEC_ID_MP3;\n\n    st->codec->bit_rate        = mtv->audio_br;\n\n    st->need_parsing           = AVSTREAM_PARSE_FULL;\n\n\n\n    // Jump over header\n\n\n\n    if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 693, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 694, "prediction": "0", "true_label": "1", "raw_text": "Question: static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)\n\n{\n\n    pkt->data      = NULL;\n\n    pkt->side_data = NULL;\n\n    if (pkt->buf) {\n\n        AVBufferRef *ref = av_buffer_ref(src->buf);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n        pkt->buf  = ref;\n\n        pkt->data = ref->data;\n\n    } else {\n\n        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);\n\n    }\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    pkt->destruct = dummy_destruct_packet;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (pkt->side_data_elems && dup)\n\n        pkt->side_data = src->side_data;\n\n    if (pkt->side_data_elems && !dup) {\n\n        return av_copy_packet_side_data(pkt, src);\n\n    }\n\n    return 0;\n\n\n\nfailed_alloc:\n\n    av_destruct_packet(pkt);\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 695, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);\n\n\n\n    /*\n\n     * The default config_size is sizeof(struct virtio_crypto_config).\n\n     * Can be overriden with virtio_crypto_set_config_size.\n\n     */\n\n    vcrypto->config_size = sizeof(struct virtio_crypto_config);\n\n\n\n    object_property_add_link(obj, \"cryptodev\",\n\n                             TYPE_CRYPTODEV_BACKEND,\n\n                             (Object **)&vcrypto->conf.cryptodev,\n\n                             virtio_crypto_check_cryptodev_is_used,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 696, "prediction": "0", "true_label": "0", "raw_text": " env, target_ulong address, int rw,\n\n\t\t\t     int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong physical;\n\n    int prot, ret, access_type;\n\n\n\n    access_type = ACCESS_INT;\n\n    ret =\n\n\tget_physical_address(env, &physical, &prot, address, rw,\n\n\t\t\t     access_type);\n\n\n\n    if (ret != MMU_OK) {\n\n\tenv->tea = address;\n\n\tswitch (ret) {\n\n\tcase MMU_ITLB_MISS:\n\n\tcase MMU_DTLB_MISS_READ:\n\n\t    env->exception_index = 0x040;\n\n\t    break;\n\n\tcase MMU_DTLB_MULTIPLE:\n\n\tcase MMU_ITLB_MULTIPLE:\n\n\t    env->exception_index = 0x140;\n\n\t    break;\n\n\tcase MMU_ITLB_VIOLATION:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_MISS_WRITE:\n\n\t    env->exception_index = 0x060;\n\n\t    break;\n\n\tcase MMU_DTLB_INITIAL_WRITE:\n\n\t    env->exception_index = 0x080;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_READ:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_WRITE:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_IADDR_ERROR:\n\n\tcase MMU_DADDR_ERROR_READ:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_DADDR_ERROR_WRITE:\n\n\t    env->exception_index = 0x100;\n\n\t    break;\n\n\tdefault:\n\n\t    assert(0);\n\n\t}\n\n\treturn 1;\n\n    }\n\n\n\n    address &= TARGET_PAGE_MASK;\n\n    physical &= TARGET_PAGE_MASK;\n\n\n\n    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 697, "prediction": "0", "true_label": "1", "raw_text": "Question: static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 698, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    uint64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n\n\n\n    mr = ddc->get_memory_region(dimm);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_uint64(v, name, &value, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 699, "prediction": "1", "true_label": "1", "raw_text": "Question: target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 700, "prediction": "1", "true_label": "0", "raw_text": "build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(&r->req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (-1 == scsi_req_parse(&r->req, cmd)) {\n\n        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 0;\n\n    }\n\n    scsi_req_fixup(&r->req);\n\n\n\n    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,\n\n            r->req.cmd.xfer, cmd[0]);\n\n\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", cmd[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (r->req.cmd.xfer == 0) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buflen = 0;\n\n        r->buf = NULL;\n\n        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);\n\n        if (ret < 0) {\n\n            scsi_command_complete(r, ret);\n\n            return 0;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (r->buflen != r->req.cmd.xfer) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buf = qemu_malloc(r->req.cmd.xfer);\n\n        r->buflen = r->req.cmd.xfer;\n\n    }\n\n\n\n    memset(r->buf, 0, r->buflen);\n\n    r->len = r->req.cmd.xfer;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        r->len = 0;\n\n        return -r->req.cmd.xfer;\n\n    } else {\n\n        return r->req.cmd.xfer;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 701, "prediction": "0", "true_label": "0", "raw_text": "Question: void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 702, "prediction": "0", "true_label": "0", "raw_text": "Question: void fork_start(void)\n\n{\n\n    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n    pthread_mutex_lock(&exclusive_lock);\n\n    mmap_fork_start();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 703, "prediction": "0", "true_label": "0", "raw_text": ", endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n            } else {\n\n                /*\n\n                 * fall back to save in plaintext, size_out should be\n\n                 * assigned to s->page_size\n\n                 */\n\n                pd.flags = cpu_convert_to_target32(0, endian);\n\n                size_out = s->page_size;\n\n                pd.size = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf, s->page_size, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /* get and write page desc here */\n\n            pd.page_flags = cpu_convert_to_target64(0, endian);\n\n            pd.offset = cpu_convert_to_target64(offset_data, endian);\n\n            offset_data += size_out;\n\n\n\n            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = write_cache(&page_desc, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_desc.\\n\");\n\n        goto out;\n\n    }\n\n    ret = write_cache(&page_data, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_data.\\n\");\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    free_data_cache(&page_desc);\n\n    free_data_cache(&page_data);\n\n\n\n#ifdef CONFIG_LZO\n\n    g_free(wrkmem);\n\n#endif\n\n\n\n    g_free(buf_out);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 704, "prediction": "0", "true_label": "0", "raw_text": "\n\n        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;\n\n    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;\n\n    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {\n\n        g_assert(env->ext_index >= 0);\n\n        /*\n\n         * FIXME: floating IRQs should be considered by all CPUs and\n\n         *        shuld not get cleared by CPU reset.\n\n         */\n\n        q = &env->ext_queue[env->ext_index];\n\n        lowcore->ext_int_code = cpu_to_be16(q->code);\n\n        lowcore->ext_params = cpu_to_be32(q->param);\n\n        lowcore->ext_params2 = cpu_to_be64(q->param64);\n\n        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);\n\n        env->ext_index--;\n\n        if (env->ext_index == -1) {\n\n            env->pending_int &= ~INTERRUPT_EXT_SERVICE;\n\n        }\n\n    } else {\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    mask = be64_to_cpu(lowcore->external_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->external_new_psw.addr);\n\n    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 705, "prediction": "0", "true_label": "0", "raw_text": "Question: static void verdex_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t verdex_rom = 0x02000000;\n\n    uint32_t verdex_ram = 0x10000000;\n\n\n\n    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: \"pxa270-c0\");\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"verdex.rom\", verdex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, verdex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 99 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 99));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 706, "prediction": "1", "true_label": "1", "raw_text": "cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 707, "prediction": "0", "true_label": "1", "raw_text": "Question: offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)\n\n{\n\n    offset_t offset1;\n\n    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n        return -EINVAL;\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n        offset += offset1;\n\n    }\n\n    offset1 = offset - pos;\n\n    if (!s->must_flush &&\n\n        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {\n\n        /* can do the seek inside the buffer */\n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else {\n\n        if (!s->seek)\n\n            return -EPIPE;\n\n\n\n#ifdef CONFIG_MUXERS\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n            s->must_flush = 1;\n\n        } else\n\n#endif //CONFIG_MUXERS\n\n        {\n\n            s->buf_end = s->buffer;\n\n        }\n\n        s->buf_ptr = s->buffer;\n\n        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)\n\n            return -EPIPE;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 708, "prediction": "0", "true_label": "0", "raw_text": ", cpu_reg_names_size, \"avr%dL\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#else\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n    }\n\n\n\n    cpu_nip = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, nip), \"nip\");\n\n\n\n    cpu_msr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, msr), \"msr\");\n\n\n\n    cpu_ctr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, ctr), \"ctr\");\n\n\n\n    cpu_lr = tcg_global_mem_new(TCG_AREG0,\n\n                                offsetof(CPUState, lr), \"lr\");\n\n\n\n    cpu_xer = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, xer), \"xer\");\n\n\n\n    cpu_reserve = tcg_global_mem_new(TCG_AREG0,\n\n                                     offsetof(CPUState, reserve), \"reserve\");\n\n\n\n    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                       offsetof(CPUState, fpscr), \"fpscr\");\n\n\n\n    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, access_type), \"access_type\");\n\n\n\n    /* register helpers */\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    done_init = 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 709, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_mtfsfi(DisasContext *ctx)\n\n{\n\n    int bf, sh;\n\n    TCGv_i64 t0;\n\n    TCGv_i32 t1;\n\n\n\n    if (unlikely(!ctx->fpu_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_FPU);\n\n        return;\n\n    }\n\n    bf = crbD(ctx->opcode) >> 2;\n\n    sh = 7 - bf;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_reset_fpstatus();\n\n    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));\n\n    t1 = tcg_const_i32(1 << sh);\n\n    gen_helper_store_fpscr(cpu_env, t0, t1);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i32(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0)) {\n\n        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);\n\n        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);\n\n    }\n\n    /* We can raise a differed exception */\n\n    gen_helper_float_check_status(cpu_env);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 710, "prediction": "0", "true_label": "1", "raw_text": "Question: void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n\n{\n\n    int i;\n\n    size_t pagesize = getpagesize();\n\n\n\n    memory = (memory + pagesize - 1) & -pagesize;\n\n    for (i = 0; i < memory / pagesize; i++) {\n\n        memset(area + pagesize * i, 0, 1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 711, "prediction": "0", "true_label": "1", "raw_text": ", frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);\n\n            if (ret) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            av_frame_free(&tmp_frame);\n\n        } else {\n\n            ret = AVERROR_BUG;\n\n            goto error;\n\n        }\n\n\n\n        frame->width = avctx->width;\n\n        frame->height = avctx->height;\n\n        if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n            frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);\n\n        else\n\n            frame->pts = dispinfo.timestamp;\n\n\n\n        /* CUVIDs opaque reordering breaks the internal pkt logic.\n\n         * So set pkt_pts and clear all the other pkt_ fields.\n\n         */\n\n        frame->pkt_pts = frame->pts;\n\n        av_frame_set_pkt_pos(frame, -1);\n\n        av_frame_set_pkt_duration(frame, 0);\n\n        av_frame_set_pkt_size(frame, -1);\n\n\n\n        frame->interlaced_frame = !dispinfo.progressive_frame;\n\n\n\n        if (!dispinfo.progressive_frame)\n\n            frame->top_field_first = dispinfo.top_field_first;\n\n\n\n        *got_frame = 1;\n\n    } else {\n\n        *got_frame = 0;\n\n    }\n\n\n\nerror:\n\n    if (mapped_frame)\n\n        eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));\n\n\n\n    eret = CHECK_CU(cuCtxPopCurrent(&dummy));\n\n\n\n    if (eret < 0)\n\n        return eret;\n\n    else\n\n        return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 712, "prediction": "0", "true_label": "0", "raw_text": "Question: static void hotplug(void)\n\n{\n\n    qtest_start(\"-device virtio-net-pci\");\n\n\n\n    qpci_plug_device_test(\"virtio-net-pci\", \"net1\", PCI_SLOT_HP, NULL);\n\n    qpci_unplug_acpi_device_test(\"net1\", PCI_SLOT_HP);\n\n\n\n    test_end();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 713, "prediction": "0", "true_label": "0", "raw_text": "3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))\n\n        \"paddw          %4, %%xmm4 \\n\"\n\n        \"movdqa     %%xmm4, 0x00(%1) \\n\"\n\n        \"movdqa     %%xmm2, 0x40(%1) \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)\n\n        \"movdqa     %%xmm6, 0x60(%1) \\n\"\n\n        \"movdqa     %%xmm7, 0x70(%1) \\n\"\n\n        \"pxor       %%xmm7, %%xmm7 \\n\"\n\n        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)\n\n        \"lea     (%0,%2,4), %0 \\n\"\n\n        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)\n\n        \"movdqa   0x60(%1), %%xmm0 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm1 \\n\"\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)\n\n        :\"+r\"(dst)\n\n        :\"r\"(block), \"r\"((x86_reg)stride), \"r\"((x86_reg)3L*stride), \"m\"(ff_pw_32)\n\n    );\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 714, "prediction": "0", "true_label": "0", "raw_text": "20, 3); /* buffer type */\n\n    stw(p + 21, 512); /* cache size in sectors */\n\n    stw(p + 22, 4); /* ecc bytes */\n\n    padstr((uint8_t *)(p + 27), \"QEMU HARDDISK\", 40);\n\n#if MAX_MULT_SECTORS > 1    \n\n    stw(p + 47, MAX_MULT_SECTORS);\n\n#endif\n\n    stw(p + 48, 1); /* dword I/O */\n\n    stw(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    stw(p + 51, 0x200); /* PIO transfer cycle */\n\n    stw(p + 52, 0x200); /* DMA transfer cycle */\n\n    stw(p + 54, s->cylinders);\n\n    stw(p + 55, s->heads);\n\n    stw(p + 56, s->sectors);\n\n    oldsize = s->cylinders * s->heads * s->sectors;\n\n    stw(p + 57, oldsize);\n\n    stw(p + 58, oldsize >> 16);\n\n    if (s->mult_sectors)\n\n        stw(p + 59, 0x100 | s->mult_sectors);\n\n    stw(p + 60, s->nb_sectors);\n\n    stw(p + 61, s->nb_sectors >> 16);\n\n    stw(p + 80, (1 << 1) | (1 << 2));\n\n    stw(p + 82, (1 << 14));\n\n    stw(p + 83, (1 << 14));\n\n    stw(p + 84, (1 << 14));\n\n    stw(p + 85, (1 << 14));\n\n    stw(p + 86, 0);\n\n    stw(p + 87, (1 << 14));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 715, "prediction": "0", "true_label": "0", "raw_text": "frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n            if (!s->prev_frame) {\n\n                s->prev_frame = av_frame_alloc();\n\n                if (!s->prev_frame)\n\n                    return AVERROR(ENOMEM);\n\n\n\n                s->prev_frame->format = pict->format;\n\n                s->prev_frame->width = pict->width;\n\n                s->prev_frame->height = pict->height;\n\n                if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n\n                    return ret;\n\n            }\n\n\n\n            // Do disposal, but not blending\n\n            memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n\n                   s->last_frame->linesize[0] * s->last_frame->height);\n\n            if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {\n\n                uint32_t y;\n\n                uint8_t bpp = (s->bits_per_pixel + 7) >> 3;\n\n                for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n\n                    size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n\n                    memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);\n\n                }\n\n            }\n\n        }\n\n\n\n        av_frame_unref(s->last_frame);\n\n        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        s->last_frame_fctl = fctl_chunk;\n\n        s->last_frame_packet_size = s->bytestream - s->bytestream_start;\n\n    } else {\n\n        av_frame_free(&s->last_frame);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 716, "prediction": "1", "true_label": "0", "raw_text": "Question: BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,\n\n                                 QEMUIOVector *qiov, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,\n\n                              cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->rd_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 717, "prediction": "0", "true_label": "0", "raw_text": "Question: static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 718, "prediction": "0", "true_label": "0", "raw_text": " / 2;\n\n            retvals[1] = limit;\n\n            retvals[2] = limit; /* Stack base */\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#endif\n\n\n\n            for (i = 0; i < ARRAY_SIZE(retvals); i++) {\n\n                bool fail;\n\n\n\n                if (is_a64(env)) {\n\n                    fail = put_user_u64(retvals[i], arg0 + i * 8);\n\n                } else {\n\n                    fail = put_user_u32(retvals[i], arg0 + i * 4);\n\n                }\n\n\n\n                if (fail) {\n\n                    /* Couldn't write back to argument block */\n\n                    return -1;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_EXIT:\n\n        if (is_a64(env)) {\n\n            /* The A64 version of this call takes a parameter block,\n\n             * so the application-exit type can return a subcode which\n\n             * is the exit status code from the application.\n\n             */\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n\n\n            if (arg0 == ADP_Stopped_ApplicationExit) {\n\n                ret = arg1;\n\n            } else {\n\n                ret = 1;\n\n            }\n\n        } else {\n\n            /* ARM specifies only Stopped_ApplicationExit as normal\n\n             * exit, everything else is considered an error */\n\n            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;\n\n        }\n\n        gdb_exit(env, ret);\n\n        exit(ret);\n\n    case TARGET_SYS_SYNCCACHE:\n\n        /* Clean the D-cache and invalidate the I-cache for the specified\n\n         * virtual address range. This is a nop for us since we don't\n\n         * implement caches. This is only present on A64.\n\n         */\n\n        if (is_a64(env)) {\n\n            return 0;\n\n        }\n\n        /* fall through -- invalid for A32/T32 */\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(cs, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 719, "prediction": "0", "true_label": "0", "raw_text": "Question: static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,\n\n                                         void *logctx, int size)\n\n{\n\n    uint8_t *user_data;\n\n    int e, build, i;\n\n\n\n    if (size < 16 || size >= INT_MAX - 16)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    user_data = av_malloc(16 + size + 1);\n\n    if (!user_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < size + 16; i++)\n\n        user_data[i] = get_bits(gb, 8);\n\n\n\n    user_data[i] = 0;\n\n    e = sscanf(user_data + 16, \"x264 - core %d\", &build);\n\n    if (e == 1 && build > 0)\n\n        h->x264_build = build;\n\n    if (e == 1 && build == 1 && !strncmp(user_data+16, \"x264 - core 0000\", 16))\n\n        h->x264_build = 67;\n\n\n\n    if (strlen(user_data + 16) > 0)\n\n        av_log(logctx, AV_LOG_DEBUG, \"user data:\\\"%s\\\"\\n\", user_data + 16);\n\n\n\n    av_free(user_data);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 720, "prediction": "0", "true_label": "0", "raw_text": "Question: void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    int i;\n\n\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_samples = dst->filter_samples))\n\n        filter_samples = avfilter_default_filter_samples;\n\n\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n\n        dst->rej_perms & samplesref->perms) {\n\n\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n\n                                                          samplesref->audio->nb_samples);\n\n        link->cur_buf->pts                = samplesref->pts;\n\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n\n\n        /* Copy actual data into new samples buffer */\n\n        for (i = 0; samplesref->data[i]; i++)\n\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n\n\n        avfilter_unref_buffer(samplesref);\n\n    } else\n\n        link->cur_buf = samplesref;\n\n\n\n    filter_samples(link, link->cur_buf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 721, "prediction": "0", "true_label": "0", "raw_text": "Question: static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n\n                                   qemu_irq **irqs)\n\n{\n\n    qemu_irq *mpic;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    int i, j, k;\n\n\n\n    mpic = g_new(qemu_irq, 256);\n\n    dev = qdev_create(NULL, \"openpic\");\n\n    qdev_prop_set_uint32(dev, \"nb_cpus\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"model\", params->mpic_version);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n\n\n    k = 0;\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n\n            sysbus_connect_irq(s, k++, irqs[i][j]);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        mpic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,\n\n                                s->mmio[0].memory);\n\n\n\n    return mpic;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 722, "prediction": "1", "true_label": "0", "raw_text": "Question: CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))\n\n{\n\n    const char *p;\n\n    CharDriverState *chr;\n\n    QemuOpts *opts;\n\n    Error *err = NULL;\n\n\n\n    if (strstart(filename, \"chardev:\", &p)) {\n\n        return qemu_chr_find(p);\n\n    }\n\n\n\n    opts = qemu_chr_parse_compat(label, filename);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    chr = qemu_chr_new_from_opts(opts, init, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n    }\n\n    if (chr && qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        monitor_init(chr, MONITOR_USE_READLINE);\n\n    }\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 723, "prediction": "1", "true_label": "0", "raw_text": "hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, tap) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd || tap->has_fds) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else if (tap->has_helper) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",\n\n                 tap->helper);\n\n    } else {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,\n\n                 downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n\n                     \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (tap->has_vhost ? tap->vhost :\n\n        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n\n        int vhostfd;\n\n\n\n        if (tap->has_vhostfd) {\n\n            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n\n            if (vhostfd == -1) {\n\n                return -1;\n\n            }\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n\n                                      tap->has_vhostforce && tap->vhostforce);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (tap->has_vhostfd || tap->has_vhostfds) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 724, "prediction": "0", "true_label": "0", "raw_text": "Question: int qdev_prop_check_globals(void)\n\n{\n\n    GList *l;\n\n    int ret = 0;\n\n\n\n    for (l = global_props; l; l = l->next) {\n\n        GlobalProperty *prop = l->data;\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 725, "prediction": "0", "true_label": "0", "raw_text": ".endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n\n\n    hw->samples = conf.samples;\n\n    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!esd->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    esd->fd = -1;\n\n    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);\n\n    if (esd->fd < 0) {\n\n        qesd_logerr (errno, \"esd_play_stream failed\\n\");\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    if (close (esd->fd)) {\n\n        qesd_logerr (errno, \"%s: close on esd socket(%d) failed\\n\",\n\n                     AUDIO_FUNC, esd->fd);\n\n    }\n\n    esd->fd = -1;\n\n\n\n fail2:\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n fail1:\n\n    qemu_free (esd->pcm_buf);\n\n    esd->pcm_buf = NULL;\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 726, "prediction": "0", "true_label": "1", "raw_text": "_type(cmd->args_type);\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype = next_arg_type(ptype);\n\n                while (*ptype == '?')\n\n                    ptype = next_arg_type(ptype);\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        if (*ptype == '-' && ptype[1] != '\\0') {\n\n            ptype += 2;\n\n        }\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        case 's':\n\n            /* XXX: more generic ? */\n\n            if (!strcmp(cmd->name, \"info\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n\n                char *sep = strrchr(str, '-');\n\n                if (sep)\n\n                    str = sep + 1;\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(key = key_defs; key->name != NULL; key++) {\n\n                    cmd_completion(str, key->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 727, "prediction": "0", "true_label": "0", "raw_text": "Question: static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 728, "prediction": "0", "true_label": "0", "raw_text": " j + 1] = t >> 4;\n\n                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);\n\n                }\n\n                break;\n\n            case 5:\n\n            case 6:\n\n            case 7:\n\n            case 8:\n\n                cnt = 2 * mpc8_thres[res];\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];\n\n                    c->Q[ch][off + j] = t;\n\n                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);\n\n                }\n\n                break;\n\n            default:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);\n\n                    if(res != 9){\n\n                        c->Q[ch][off + j] <<= res - 9;\n\n                        c->Q[ch][off + j] |= get_bits(gb, res - 9);\n\n                    }\n\n                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);\n\n\n\n    c->cur_frame++;\n\n\n\n    c->last_bits_used = get_bits_count(gb);\n\n    if(c->cur_frame >= c->frames)\n\n        c->cur_frame = 0;\n\n    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;\n\n\n\n    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 729, "prediction": "1", "true_label": "0", "raw_text": "Question: DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 730, "prediction": "0", "true_label": "1", "raw_text": "Question: Visitor *qobject_input_visitor_new_keyval(QObject *obj)\n\n{\n\n    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);\n\n\n\n    v->visitor.type_int64 = qobject_input_type_int64_keyval;\n\n    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;\n\n    v->visitor.type_bool = qobject_input_type_bool_keyval;\n\n    v->visitor.type_str = qobject_input_type_str;\n\n    v->visitor.type_number = qobject_input_type_number_keyval;\n\n    v->visitor.type_any = qobject_input_type_any;\n\n    v->visitor.type_null = qobject_input_type_null;\n\n    v->visitor.type_size = qobject_input_type_size_keyval;\n\n\n\n    return &v->visitor;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 731, "prediction": "0", "true_label": "1", "raw_text": "Question: void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 732, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,\n\n                                  float **plevel_table, uint16_t **pint_table,\n\n                                  const CoefVLCTable *vlc_table)\n\n{\n\n    int n                        = vlc_table->n;\n\n    const uint8_t  *table_bits   = vlc_table->huffbits;\n\n    const uint32_t *table_codes  = vlc_table->huffcodes;\n\n    const uint16_t *levels_table = vlc_table->levels;\n\n    uint16_t *run_table, *level_table, *int_table;\n\n    float *flevel_table;\n\n    int i, l, j, k, level;\n\n\n\n    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);\n\n\n\n    run_table    = av_malloc(n * sizeof(uint16_t));\n\n    level_table  = av_malloc(n * sizeof(uint16_t));\n\n    flevel_table = av_malloc(n * sizeof(*flevel_table));\n\n    int_table    = av_malloc(n * sizeof(uint16_t));\n\n    i            = 2;\n\n    level        = 1;\n\n    k            = 0;\n\n    while (i < n) {\n\n        int_table[k] = i;\n\n        l            = levels_table[k++];\n\n        for (j = 0; j < l; j++) {\n\n            run_table[i]    = j;\n\n            level_table[i]  = level;\n\n            flevel_table[i] = level;\n\n            i++;\n\n        }\n\n        level++;\n\n    }\n\n    *prun_table   = run_table;\n\n    *plevel_table = flevel_table;\n\n    *pint_table   = int_table;\n\n    av_free(level_table);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 733, "prediction": "0", "true_label": "0", "raw_text": ";\n\n                    break;\n\n                default:\n\n                    s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n                    break;\n\n                }\n\n            } else {\n\n                s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n            }\n\n\n\n            if (p->picture_structure == PICT_FRAME) {\n\n                s->picture_structure = AV_PICTURE_STRUCTURE_FRAME;\n\n                if (sps->pic_struct_present_flag) {\n\n                    switch (p->sei.picture_timing.pic_struct) {\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                        s->field_order = AV_FIELD_TT;\n\n                        break;\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                        s->field_order = AV_FIELD_BB;\n\n                        break;\n\n                    default:\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                        break;\n\n                    }\n\n                } else {\n\n                    if (field_poc[0] < field_poc[1])\n\n                        s->field_order = AV_FIELD_TT;\n\n                    else if (field_poc[0] > field_poc[1])\n\n                        s->field_order = AV_FIELD_BB;\n\n                    else\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                }\n\n            } else {\n\n                if (p->picture_structure == PICT_TOP_FIELD)\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;\n\n                else\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;\n\n                s->field_order = AV_FIELD_UNKNOWN;\n\n            }\n\n\n\n            av_freep(&nal.rbsp_buffer);\n\n            return 0; /* no need to evaluate the rest */\n\n        }\n\n        buf += consumed;\n\n    }\n\n    /* didn't find a picture! */\n\n    av_log(avctx, AV_LOG_ERROR, \"missing picture in access unit\\n\");\n\nfail:\n\n    av_freep(&nal.rbsp_buffer);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 734, "prediction": "0", "true_label": "1", "raw_text": "6;\n\n                    for (i = 0; i < 63; i++)\n\n                        left[i] = ((64 - (i + 1)) * left[-1] +\n\n                                   (i + 1)  * left[63] + 32) >> 6;\n\n                    top = filtered_top;\n\n                } else {\n\n                    filtered_left[2 * size - 1] = left[2 * size - 1];\n\n                    filtered_top[2 * size - 1]  = top[2 * size - 1];\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_left[i] = (left[i + 1] + 2 * left[i] +\n\n                                            left[i - 1] + 2) >> 2;\n\n                    filtered_top[-1]  =\n\n                    filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2;\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_top[i] = (top[i + 1] + 2 * top[i] +\n\n                                           top[i - 1] + 2) >> 2;\n\n                    left = filtered_left;\n\n                    top  = filtered_top;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (mode) {\n\n    case INTRA_PLANAR:\n\n        s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                          (uint8_t *)left, stride);\n\n        break;\n\n    case INTRA_DC:\n\n        s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top,\n\n                       (uint8_t *)left, stride, log2_size, c_idx);\n\n        break;\n\n    default:\n\n        s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                           (uint8_t *)left, stride, c_idx,\n\n                                           mode);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 735, "prediction": "0", "true_label": "0", "raw_text": "Question: static void end_last_frame(AVFilterContext *ctx)\n\n{\n\n    TileContext *tile    = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n\n\n    outlink->out_buf = NULL;\n\n    ff_start_frame(outlink, out_buf);\n\n    while (tile->current < tile->nb_frames)\n\n        draw_blank_frame(ctx, out_buf);\n\n    ff_draw_slice(outlink, 0, out_buf->video->h, 1);\n\n    ff_end_frame(outlink);\n\n    tile->current = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 736, "prediction": "1", "true_label": "0", "raw_text": "Question: void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = &first_oformat;\n\n\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n\n\n    *p = format;\n\n    format->next = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 737, "prediction": "0", "true_label": "1", "raw_text": "CRR_CONST4(ctx->opcode);\n\n        temp = tcg_const_i32(const16);\n\n        temp2 = tcg_temp_new(); /* width*/\n\n        temp3 = tcg_temp_new(); /* pos */\n\n\n\n        tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f);\n\n        tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f);\n\n\n\n        gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp3);\n\n\n/* RCRW Format */\n\n    case OPCM_32_RCRW_MASK_INSERT:\n\n        decode_rcrw_insert(env, ctx);\n\n\n/* RCR Format */\n\n    case OPCM_32_RCR_COND_SELECT:\n\n        decode_rcr_cond_select(env, ctx);\n\n\n    case OPCM_32_RCR_MADD:\n\n        decode_rcr_madd(env, ctx);\n\n\n    case OPCM_32_RCR_MSUB:\n\n        decode_rcr_msub(env, ctx);\n\n\n/* RLC Format */\n\n    case OPC1_32_RLC_ADDI:\n\n    case OPC1_32_RLC_ADDIH:\n\n    case OPC1_32_RLC_ADDIH_A:\n\n    case OPC1_32_RLC_MFCR:\n\n    case OPC1_32_RLC_MOV:\n\n    case OPC1_32_RLC_MOV_64:\n\n    case OPC1_32_RLC_MOV_U:\n\n    case OPC1_32_RLC_MOV_H:\n\n    case OPC1_32_RLC_MOVH_A:\n\n    case OPC1_32_RLC_MTCR:\n\n        decode_rlc_opc(env, ctx, op1);\n\n\n\n\n\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 738, "prediction": "1", "true_label": "0", "raw_text": "Question: AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,\n\n                                                            int perms)\n\n{\n\n    AVFilterBufferRef *picref =\n\n        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,\n\n                                                  frame->width, frame->height,\n\n                                                  frame->format);\n\n    if (!picref)\n\n        return NULL;\n\n    avfilter_copy_frame_props(picref, frame);\n\n    return picref;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 739, "prediction": "0", "true_label": "1", "raw_text": "Question: void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 740, "prediction": "0", "true_label": "1", "raw_text": "Question: static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)\n\n{\n\n    AVStream *st;\n\n    OutputStream *ost;\n\n    AVCodecContext *audio_enc;\n\n\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);\n\n    st  = ost->st;\n\n\n\n    audio_enc = st->codec;\n\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n    if (!ost->stream_copy) {\n\n        char *sample_fmt = NULL;\n\n\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n\n        if (sample_fmt &&\n\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n\n            exit_program(1);\n\n        }\n\n\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n    }\n\n\n\n    return ost;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 741, "prediction": "1", "true_label": "1", "raw_text": "_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n        GetBitContext s;\n        for (y = 0; y < h; y++) {\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++)\n                ptr[x] = get_bits(&s, bits_per_pixel);\n            ptr += stride;\n    } else {    /* planar, 4, 8 or 16 colors */\n        int i;\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                int m = 0x80 >> (x & 7), v = 0;\n                for (i = nplanes - 1; i >= 0; i--) {\n                    v <<= 1;\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n                ptr[x] = v;\n            ptr += stride;\n    if (nplanes == 1 && bits_per_pixel == 8) {\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n    } else if (bits_per_pixel < 8) {\n        const uint8_t *palette = bufstart + 16;\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n    *got_frame = 1;\n    ret = buf - bufstart;\nend:\n    av_free(scanline);\n    return ret;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 742, "prediction": "0", "true_label": "1", "raw_text": " dprint(d, 1, \"QXL_SET_MODE %d\\n\", val);\n\n        qxl_set_mode(d, val, 0);\n\n        break;\n\n    case QXL_IO_LOG:\n\n        if (d->guestdebug) {\n\n            fprintf(stderr, \"qxl/guest: %s\", d->ram->log_buf);\n\n        }\n\n        break;\n\n    case QXL_IO_RESET:\n\n        dprint(d, 1, \"QXL_IO_RESET\\n\");\n\n        qxl_hard_reset(d, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_ADD:\n\n        PANIC_ON(val >= NUM_MEMSLOTS);\n\n        PANIC_ON(d->guest_slots[val].active);\n\n        d->guest_slots[val].slot = d->ram->mem_slot;\n\n        qxl_add_memslot(d, val, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_DEL:\n\n        qxl_del_memslot(d, val);\n\n        break;\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_CREATE_PRIMARY\\n\");\n\n        d->guest_primary.surface = d->ram->create_surface;\n\n        qxl_create_guest_primary(d, 0);\n\n        break;\n\n    case QXL_IO_DESTROY_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_DESTROY_PRIMARY\\n\");\n\n        qxl_destroy_primary(d);\n\n        break;\n\n    case QXL_IO_DESTROY_SURFACE_WAIT:\n\n        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);\n\n        break;\n\n    case QXL_IO_DESTROY_ALL_SURFACES:\n\n        d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: ioport=0x%x, abort()\\n\", __FUNCTION__, io_port);\n\n        abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 743, "prediction": "0", "true_label": "0", "raw_text": "chroma_qp(h, 1, sl->qscale);\n\n    // FIXME qscale / qp ... stuff\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); /* sp_for_switch_flag */\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); /* slice_qs_delta */\n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  // 1<->0\n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 744, "prediction": "1", "true_label": "0", "raw_text": "Question: int ffurl_shutdown(URLContext *h, int flags)\n\n{\n\n    if (!h->prot->url_shutdown)\n\n        return AVERROR(EINVAL);\n\n    return h->prot->url_shutdown(h, flags);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 745, "prediction": "0", "true_label": "1", "raw_text": "Question: static void i82378_init(DeviceState *dev, I82378State *s)\n\n{\n\n    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, \"isa.0\"));\n\n    ISADevice *pit;\n\n    qemu_irq *out0_irq;\n\n\n\n    /* This device has:\n\n       2 82C59 (irq)\n\n       1 82C54 (pit)\n\n       2 82C37 (dma)\n\n       NMI\n\n       Utility Bus Support Registers\n\n\n\n       All devices accept byte access only, except timer\n\n     */\n\n\n\n    qdev_init_gpio_out(dev, s->out, 2);\n\n    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);\n\n\n\n    /* Workaround the fact that i8259 is not qdev'ified... */\n\n    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);\n\n\n\n    /* 2 82C59 (irq) */\n\n    s->i8259 = i8259_init(isabus, *out0_irq);\n\n    isa_bus_irqs(isabus, s->i8259);\n\n\n\n    /* 1 82C54 (pit) */\n\n    pit = pit_init(isabus, 0x40, 0, NULL);\n\n\n\n    /* speaker */\n\n    pcspk_init(isabus, pit);\n\n\n\n    /* 2 82C37 (dma) */\n\n    DMA_init(1, &s->out[1]);\n\n    isa_create_simple(isabus, \"i82374\");\n\n\n\n    /* timer */\n\n    isa_create_simple(isabus, \"mc146818rtc\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 746, "prediction": "0", "true_label": "0", "raw_text": "  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = ncpu;\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 747, "prediction": "1", "true_label": "0", "raw_text": "Question: QString *qstring_from_substr(const char *str, int start, int end)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = g_malloc(sizeof(*qstring));\n\n\n\n    qstring->length = end - start + 1;\n\n    qstring->capacity = qstring->length;\n\n\n\n    qstring->string = g_malloc(qstring->capacity + 1);\n\n    memcpy(qstring->string, str + start, qstring->length);\n\n    qstring->string[qstring->length] = 0;\n\n\n\n    QOBJECT_INIT(qstring, &qstring_type);\n\n\n\n    return qstring;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 748, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_source_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL);\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 749, "prediction": "0", "true_label": "0", "raw_text": "Question: static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 750, "prediction": "0", "true_label": "0", "raw_text": " NULL) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            fprintf(stderr, \"VNC requires a display argument vnc=<display>\\n\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr, \"VNC support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"curses\", &opts)) {\n\n#ifdef CONFIG_CURSES\n\n        display = DT_CURSES;\n\n#else\n\n        fprintf(stderr, \"Curses support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"gtk\", &opts)) {\n\n#ifdef CONFIG_GTK\n\n        display = DT_GTK;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",grab_on_hover=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    grab_on_hover = true;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    grab_on_hover = false;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else {\n\n            invalid_gtk_args:\n\n                fprintf(stderr, \"Invalid GTK option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"GTK support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"none\", &opts)) {\n\n        display = DT_NONE;\n\n    } else {\n\n        fprintf(stderr, \"Unknown display type: %s\\n\", p);\n\n        exit(1);\n\n    }\n\n\n\n    return display;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 751, "prediction": "0", "true_label": "0", "raw_text": "Question: static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)\n\n{\n\n    int64_t start, size, last_size;\n\n    start= url_ftell(bc) - prefix_length;\n\n\n\n    if(start != nut->packet_start + nut->written_packet_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"get_packetheader called at weird position\\n\");\n\n        return -1;\n\n    }\n\n    \n\n    if(calculate_checksum)\n\n        init_checksum(bc, update_adler32, 0);\n\n\n\n    size= get_v(bc);\n\n    last_size= get_v(bc);\n\n    if(nut->written_packet_size != last_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"packet size missmatch %d != %lld at %lld\\n\", nut->written_packet_size, last_size, start);\n\n        return -1;\n\n    }\n\n\n\n    nut->last_packet_start = nut->packet_start;\n\n    nut->packet_start = start;\n\n    nut->written_packet_size= size;\n\n\n\n    return size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 752, "prediction": "0", "true_label": "0", "raw_text": "Question: static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *p = PCI_DEVICE(s);\n\n\n\n    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);\n\n    cmd->frame = NULL;\n\n    cmd->pa = 0;\n\n    clear_bit(cmd->index, s->frame_map);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 753, "prediction": "0", "true_label": "0", "raw_text": "Question: int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,\n\n                  int flags, int mode)\n\n{\n\n    int err;\n\n    FsCred cred;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_mode = mode & 07777;\n\n    cred.fc_uid = fidp->uid;\n\n    cred.fc_gid = gid;\n\n    v9fs_co_run_in_worker(\n\n        {\n\n            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);\n\n            err = 0;\n\n            if (fidp->fs.fd == -1) {\n\n                err = -errno;\n\n            }\n\n        });\n\n    if (!err) {\n\n        total_open_fd++;\n\n        if (total_open_fd > open_fd_hw) {\n\n            v9fs_reclaim_fd(s);\n\n        }\n\n    }\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 754, "prediction": "0", "true_label": "0", "raw_text": "Question: static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n\n{\n\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n    static const uint8_t vlan[] = {0x81, 0x00};\n\n    uint8_t *ptr = (uint8_t *)buf;\n\n    int i;\n\n\n\n    if (n->promisc)\n\n        return 1;\n\n\n\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n\n        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n\n            return 0;\n\n    }\n\n\n\n    if ((ptr[0] & 1) && n->allmulti)\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, bcast, sizeof(bcast)))\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, n->mac, ETH_ALEN))\n\n        return 1;\n\n\n\n    for (i = 0; i < n->mac_table.in_use; i++) {\n\n        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 755, "prediction": "0", "true_label": "0", "raw_text": ";\n\n\n\n                    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);\n\n                    opkt.flags= pkt->flags;\n\n\n\n                    //FIXME remove the following 2 lines they shall be replaced by the bitstream filters\n\n                    if(   ost->st->codec->codec_id != CODEC_ID_H264\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO\n\n                       ) {\n\n                        if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY))\n\n                            opkt.destruct= av_destruct_packet;\n\n                    } else {\n\n                        opkt.data = data_buf;\n\n                        opkt.size = data_size;\n\n                    }\n\n\n\n                    write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters);\n\n                    ost->st->codec->frame_number++;\n\n                    ost->frame_number++;\n\n                    av_free_packet(&opkt);\n\n                }\n\n#if CONFIG_AVFILTER\n\n                cont:\n\n                frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n\n                                   ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n                if (ost->picref)\n\n                    avfilter_unref_buffer(ost->picref);\n\n            }\n\n            av_freep(&filtered_frame);\n\n#endif\n\n            }\n\n\n\nfail:\n\n        av_free(buffer_to_free);\n\n        /* XXX: allocate the subtitles in the codec ? */\n\n        if (subtitle_to_free) {\n\n            avsubtitle_free(subtitle_to_free);\n\n            subtitle_to_free = NULL;\n\n        }\n\n        av_freep(&decoded_frame);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n discard_packet:\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 756, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        int l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 757, "prediction": "0", "true_label": "0", "raw_text": "Question: GSource *iohandler_get_g_source(void)\n\n{\n\n    iohandler_init();\n\n    return aio_get_g_source(iohandler_ctx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 758, "prediction": "0", "true_label": "0", "raw_text": " start         -> 1/4\n\n 1  first_SEQEXT        -> 0/2\n\n 2  first field start   -> 3/0\n\n 3  second_SEQEXT       -> 2/0\n\n 4  searching end\n\n*/\n\n\n\n    for(i=0; i<buf_size; i++){\n\n        assert(pc->frame_start_found>=0 && pc->frame_start_found<=4);\n\n        if(pc->frame_start_found&1){\n\n            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)\n\n                pc->frame_start_found--;\n\n            else if(state == EXT_START_CODE+2){\n\n                if((buf[i]&3) == 3) pc->frame_start_found= 0;\n\n                else                pc->frame_start_found= (pc->frame_start_found+1)&3;\n\n            }\n\n            state++;\n\n        }else{\n\n            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;\n\n            if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){\n\n                i++;\n\n                pc->frame_start_found=4;\n\n            }\n\n            if(state == SEQ_END_CODE){\n\n                pc->state=-1;\n\n                return i+1;\n\n            }\n\n            if(pc->frame_start_found==2 && state == SEQ_START_CODE)\n\n                pc->frame_start_found= 0;\n\n            if(pc->frame_start_found<4 && state == EXT_START_CODE)\n\n                pc->frame_start_found++;\n\n            if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){\n\n                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 759, "prediction": "0", "true_label": "0", "raw_text": "slices > avctx->height)\n\n                    continue;\n\n                if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24)\n\n                    continue;\n\n                if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= MAX_SLICES || !avctx->slices)\n\n                    goto slices_ok;\n\n            }\n\n        }\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number %d of slices requested, please specify a \"\n\n               \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",\n\n               avctx->slices);\n\n        return AVERROR(ENOSYS);\n\nslices_ok:\n\n        if ((ret = write_extradata(s)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    if ((ret = ff_ffv1_init_slice_contexts(s)) < 0)\n\n        return ret;\n\n    s->slice_count = s->max_slice_count;\n\n    if ((ret = ff_ffv1_init_slices_state(s)) < 0)\n\n        return ret;\n\n\n\n#define STATS_OUT_SIZE 1024 * 1024 * 6\n\n    if (avctx->flags & AV_CODEC_FLAG_PASS1) {\n\n        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);\n\n        if (!avctx->stats_out)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < s->quant_table_count; i++)\n\n            for (j = 0; j < s->max_slice_count; j++) {\n\n                FFV1Context *sf = s->slice_context[j];\n\n                av_assert0(!sf->rc_stat2[i]);\n\n                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                             sizeof(*sf->rc_stat2[i]));\n\n                if (!sf->rc_stat2[i])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 760, "prediction": "0", "true_label": "0", "raw_text": "->sh.offset[i - 1] = offset;\n\n\n\n    }\n\n    if (s->sh.num_entry_point_offsets != 0) {\n\n        offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt;\n\n        if (length < offset) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"entry_point_offset table is corrupted\\n\");\n\n            res = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset;\n\n        s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset;\n\n\n\n    }\n\n    s->data = data;\n\n\n\n    for (i = 1; i < s->threads_number; i++) {\n\n        s->sList[i]->HEVClc->first_qp_group = 1;\n\n        s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y;\n\n        memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n        s->sList[i]->HEVClc = s->HEVClcList[i];\n\n    }\n\n\n\n    avpriv_atomic_int_set(&s->wpp_err, 0);\n\n    ff_reset_entries(s->avctx);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++) {\n\n        arg[i] = i;\n\n        ret[i] = 0;\n\n    }\n\n\n\n    if (s->ps.pps->entropy_coding_sync_enabled_flag)\n\n        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++)\n\n        res += ret[i];\n\nerror:\n\n    av_free(ret);\n\n    av_free(arg);\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 761, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,\n\n                hwaddr addr, int *miny, int *maxy)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int src_width, dest_width;\n\n    drawfn fn = NULL;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->xres * s->dest_width;\n\n    *miny = 0;\n\n    framebuffer_update_display(surface, s->sysmem,\n\n                               addr, s->xres, s->yres,\n\n                               src_width, dest_width, s->dest_width,\n\n                               s->invalidated,\n\n                               fn, s->dma_ch[0].palette, miny, maxy);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 762, "prediction": "0", "true_label": "0", "raw_text": "Question: build_dmar_q35(GArray *table_data, GArray *linker)\n\n{\n\n    int dmar_start = table_data->len;\n\n\n\n    AcpiTableDmar *dmar;\n\n    AcpiDmarHardwareUnit *drhd;\n\n\n\n    dmar = acpi_data_push(table_data, sizeof(*dmar));\n\n    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;\n\n    dmar->flags = 0;    /* No intr_remap for now */\n\n\n\n    /* DMAR Remapping Hardware Unit Definition structure */\n\n    drhd = acpi_data_push(table_data, sizeof(*drhd));\n\n    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);\n\n    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */\n\n    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;\n\n    drhd->pci_segment = cpu_to_le16(0);\n\n    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);\n\n\n\n    build_header(linker, table_data, (void *)(table_data->data + dmar_start),\n\n                 \"DMAR\", table_data->len - dmar_start, 1, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 763, "prediction": "1", "true_label": "0", "raw_text": "Question: static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)\n\n{\n\n    GtkWidget *machine_menu;\n\n    GtkWidget *separator;\n\n\n\n    machine_menu = gtk_menu_new();\n\n    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);\n\n\n\n    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(\"_Pause\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->reset_item = gtk_menu_item_new_with_mnemonic(_(\"_Reset\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);\n\n\n\n    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(\"Power _Down\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->quit_item = gtk_menu_item_new_with_mnemonic(_(\"_Quit\"));\n\n    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),\n\n                                 \"<QEMU>/Machine/Quit\");\n\n    gtk_accel_map_add_entry(\"<QEMU>/Machine/Quit\",\n\n                            GDK_KEY_q, GDK_CONTROL_MASK);\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);\n\n\n\n    return machine_menu;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes\n"}], [{"ID": 764, "prediction": "0", "true_label": "0", "raw_text": "Question: static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_flashcfg_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_FLASHCFG_CFGR0:\n\n        s->cfgr0 = value;\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 765, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qemu_rdma_get_fd(void *opaque)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n\n\n    return rdma->comp_channel->fd;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 766, "prediction": "0", "true_label": "1", "raw_text": " dump SPE insns */\n\n                            p = strchr(handler->oname, '_');\n\n                            if (p == NULL) {\n\n                                printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                       \"%s\\n\",\n\n                                       opc1, opc2, opc3, opc1,\n\n                                       (opc3 << 5) | opc2,\n\n                                       handler->oname);\n\n                            } else {\n\n                                q = \"speundef\";\n\n                                if ((p - handler->oname) != strlen(q) ||\n\n                                    memcmp(handler->oname, q, strlen(q)) != 0) {\n\n                                    /* First instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%.*s\\n\",\n\n                                           opc1, opc2 << 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1),\n\n                                           (int)(p - handler->oname),\n\n                                           handler->oname);\n\n                                }\n\n                                if (strcmp(p + 1, q) != 0) {\n\n                                    /* Second instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%s\\n\",\n\n                                           opc1, (opc2 << 1) | 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1) | 1,\n\n                                           p + 1);\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 767, "prediction": "0", "true_label": "1", "raw_text": "],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = abuf[0], *abuf1 = abuf[1];\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n        int A1, A2;\n\n        const void *r =  c->table_rV[V],\n\n                   *g = (c->table_gU[U] + c->table_gV[V]),\n\n                   *b =  c->table_bU[U];\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;\n\n        }\n\n\n\n        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                      r, g, b, y, target, hasAlpha);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 768, "prediction": "0", "true_label": "1", "raw_text": "Question: static int minimum_frame_bits(VC2EncContext *s)\n\n{\n\n    int slice_x, slice_y, bits = 0;\n\n    s->size_scaler = 64;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n\n            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);\n\n        }\n\n    }\n\n    return bits;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 769, "prediction": "0", "true_label": "1", "raw_text": "Question: static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 770, "prediction": "0", "true_label": "1", "raw_text": " acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 771, "prediction": "0", "true_label": "0", "raw_text": "discard)\n\n                st->discard= video_discard;\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(subtitle_disable)\n\n                st->discard = AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_ATTACHMENT:\n\n        case AVMEDIA_TYPE_UNKNOWN:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    /* dump the file content */\n\n    if (verbose >= 0)\n\n        av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);\n\n\n\n    top_field_first = -1;\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_pix_fmt = PIX_FMT_NONE;\n\n    frame_height = 0;\n\n    frame_width  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    av_freep(&ts_scale);\n\n    nb_ts_scale = 0;\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n    av_freep(&video_codec_name);\n\n    av_freep(&audio_codec_name);\n\n    av_freep(&subtitle_codec_name);\n\n    uninit_opts();\n\n    init_opts();\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 772, "prediction": "0", "true_label": "0", "raw_text": " *port;\n\n\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            switch(value) {\n\n            case PORT_ENABLE:\n\n                port->wPortStatus &= ~PORT_STAT_ENABLE;\n\n                break;\n\n            case PORT_C_ENABLE:\n\n                port->wPortChange &= ~PORT_STAT_C_ENABLE;\n\n                break;\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus &= ~PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_C_SUSPEND:\n\n                port->wPortChange &= ~PORT_STAT_C_SUSPEND;\n\n                break;\n\n            case PORT_C_CONNECTION:\n\n                port->wPortChange &= ~PORT_STAT_C_CONNECTION;\n\n                break;\n\n            case PORT_C_OVERCURRENT:\n\n                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;\n\n                break;\n\n            case PORT_C_RESET:\n\n                port->wPortChange &= ~PORT_STAT_C_RESET;\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case GetHubDescriptor:\n\n        {\n\n            unsigned int n, limit, var_hub_size = 0;\n\n            memcpy(data, qemu_hub_hub_descriptor,\n\n                   sizeof(qemu_hub_hub_descriptor));\n\n            data[2] = NUM_PORTS;\n\n\n\n            /* fill DeviceRemovable bits */\n\n            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;\n\n            for (n = 7; n < limit; n++) {\n\n                data[n] = 0x00;\n\n                var_hub_size++;\n\n            }\n\n\n\n            /* fill PortPwrCtrlMask bits */\n\n            limit = limit + ((NUM_PORTS + 7) / 8);\n\n            for (;n < limit; n++) {\n\n                data[n] = 0xff;\n\n                var_hub_size++;\n\n            }\n\n\n\n            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;\n\n            data[0] = ret;\n\n            break;\n\n        }\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 773, "prediction": "0", "true_label": "0", "raw_text": "\n\n            mxf_write_partition(s, 1, 2, body_partition_key, 0);\n\n\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        }\n\n\n\n        mxf_write_klv_fill(s);\n\n        mxf_write_system_item(s);\n\n\n\n        if (!mxf->edit_unit_byte_count) {\n\n            mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset;\n\n            mxf->index_entries[mxf->edit_units_count].flags = ie.flags;\n\n            mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref;\n\n            mxf->body_offset += KAG_SIZE; // size of system element\n\n        }\n\n        mxf->edit_units_count++;\n\n    } else if (!mxf->edit_unit_byte_count && st->index == 1) {\n\n        mxf->index_entries[mxf->edit_units_count-1].slice_offset =\n\n            mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset;\n\n    }\n\n\n\n    mxf_write_klv_fill(s);\n\n    avio_write(pb, sc->track_essence_element_key, 16); // write key\n\n    if (s->oformat == &ff_mxf_d10_muxer) {\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            mxf_write_d10_video_packet(s, st, pkt);\n\n        else\n\n            mxf_write_d10_audio_packet(s, st, pkt);\n\n    } else {\n\n        klv_encode_ber4_length(pb, pkt->size); // write length\n\n        avio_write(pb, pkt->data, pkt->size);\n\n        mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size);\n\n    }\n\n\n\n    avio_flush(pb);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 774, "prediction": "0", "true_label": "0", "raw_text": "Question: int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,\n\n                              int access_type, int mmu_idx, int is_softmmu)\n\n{\n\n    uint32_t phys_addr;\n\n    target_ulong page_size;\n\n    int prot;\n\n    int ret, is_user;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,\n\n                        &page_size);\n\n    if (ret == 0) {\n\n        /* Map a single [sub]page.  */\n\n        phys_addr &= ~(uint32_t)0x3ff;\n\n        address &= ~(uint32_t)0x3ff;\n\n        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,\n\n                      page_size);\n\n        return 0;\n\n    }\n\n\n\n    if (access_type == 2) {\n\n        env->cp15.c5_insn = ret;\n\n        env->cp15.c6_insn = address;\n\n        env->exception_index = EXCP_PREFETCH_ABORT;\n\n    } else {\n\n        env->cp15.c5_data = ret;\n\n        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))\n\n            env->cp15.c5_data |= (1 << 11);\n\n        env->cp15.c6_data = address;\n\n        env->exception_index = EXCP_DATA_ABORT;\n\n    }\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 775, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int get_chroma_qp(H264Context *h, int t, int qscale){\n\n    return h->pps.chroma_qp_table[t][qscale];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 776, "prediction": "0", "true_label": "0", "raw_text": ":\n\n                for (i = 0; i < 2; i++)\n\n                    col[i] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                for (i = 0; i < 8; i++) {\n\n                    v = binkb_get_value(c, BINKB_SRC_PATTERN);\n\n                    for (j = 0; j < 8; j++, v >>= 1)\n\n                        dst[i*stride + j] = col[v & 1];\n\n                }\n\n                break;\n\n            case 7:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                break;\n\n            case 8:\n\n                for (i = 0; i < 8; i++)\n\n                    memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8);\n\n                c->bundle[BINKB_SRC_COLORS].cur_ptr += 64;\n\n                break;\n\n            default:\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Unknown block type %d\\n\", blk);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (bitstream_tell(bc) & 0x1F) // next plane data starts at 32-bit boundary\n\n        bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F));\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 777, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 778, "prediction": "0", "true_label": "0", "raw_text": "bol();\n\n            break;\n\n        case 4:\n\n            term_delete_char();\n\n            break;\n\n        case 5:\n\n            term_eol();\n\n            break;\n\n        case 9:\n\n            term_completion();\n\n            break;\n\n        case 10:\n\n        case 13:\n\n            term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n\t    term_hist_add(term_cmd_buf);\n\n            term_printf(\"\\n\");\n\n            term_handle_command(term_cmd_buf);\n\n            term_show_prompt();\n\n            break;\n\n        case 27:\n\n            term_esc_state = IS_ESC;\n\n            break;\n\n        case 127:\n\n        case 8:\n\n            term_backspace();\n\n            break;\n\n\tcase 155:\n\n            term_esc_state = IS_CSI;\n\n\t    break;\n\n        default:\n\n            if (ch >= 32) {\n\n                term_insert_char(ch);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case IS_ESC:\n\n        if (ch == '[') {\n\n            term_esc_state = IS_CSI;\n\n            term_esc_param = 0;\n\n        } else {\n\n            term_esc_state = IS_NORM;\n\n        }\n\n        break;\n\n    case IS_CSI:\n\n        switch(ch) {\n\n\tcase 'A':\n\n\tcase 'F':\n\n\t    term_up_char();\n\n\t    break;\n\n\tcase 'B':\n\n\tcase 'E':\n\n\t    term_down_char();\n\n\t    break;\n\n        case 'D':\n\n            term_backward_char();\n\n            break;\n\n        case 'C':\n\n            term_forward_char();\n\n            break;\n\n        case '0' ... '9':\n\n            term_esc_param = term_esc_param * 10 + (ch - '0');\n\n            goto the_end;\n\n        case '~':\n\n            switch(term_esc_param) {\n\n            case 1:\n\n                term_bol();\n\n                break;\n\n            case 3:\n\n                term_delete_char();\n\n                break;\n\n            case 4:\n\n                term_eol();\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        term_esc_state = IS_NORM;\n\n    the_end:\n\n        break;\n\n    }\n\n    term_update();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 779, "prediction": "0", "true_label": "0", "raw_text": "Question: struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)\n\n{\n\n    struct omap_l4_s *bus = g_malloc0(\n\n                    sizeof(*bus) + ta_num * sizeof(*bus->ta));\n\n\n\n    bus->ta_num = ta_num;\n\n    bus->base = base;\n\n\n\n#ifdef L4_MUX_HACK\n\n    omap_l4_io_entries = 1;\n\n    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));\n\n\n\n    omap_cpu_io_entry =\n\n            cpu_register_io_memory(omap_l4_io_readfn,\n\n                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);\n\n# define L4_PAGES\t(0xb4000 / TARGET_PAGE_SIZE)\n\n    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);\n\n#endif\n\n\n\n    return bus;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 780, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qbus_list_bus(DeviceState *dev, char *dest, int len)\n\n{\n\n    BusState *child;\n\n    const char *sep = \" \";\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\",\n\n                    dev->id ? dev->id : dev->info->name);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name);\n\n        sep = \", \";\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 781, "prediction": "0", "true_label": "1", "raw_text": "->mode = MODE_DIRECTORY;\n\n                s->current_mapping->info.dir.parent_mapping_index =\n\n                    mapping_index;\n\n            } else {\n\n                s->current_mapping->mode = MODE_UNDEFINED;\n\n                s->current_mapping->info.file.offset = 0;\n\n            }\n\n            s->current_mapping->path=buffer;\n\n            s->current_mapping->read_only =\n\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n\n        } else {\n\n            g_free(buffer);\n\n        }\n\n    }\n\n    closedir(dir);\n\n\n\n    /* fill with zeroes up to the end of the cluster */\n\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n\n        direntry_t* direntry=array_get_next(&(s->directory));\n\n        memset(direntry,0,sizeof(direntry_t));\n\n    }\n\n\n\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n\n        /* root directory */\n\n        int cur = s->directory.next;\n\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n\n        s->directory.next = ROOT_ENTRIES;\n\n        memset(array_get(&(s->directory), cur), 0,\n\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n\n    }\n\n\n\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n\n    mapping = array_get(&(s->mapping), mapping_index);\n\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n\n        * 0x20 / s->cluster_size;\n\n    mapping->end = first_cluster;\n\n\n\n    direntry = array_get(&(s->directory), mapping->dir_index);\n\n    set_begin_of_direntry(direntry, mapping->begin);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 782, "prediction": "0", "true_label": "0", "raw_text": "Question: static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n\n{\n\n    const char *p;\n\n    char *q, buf1[20], c;\n\n    int nd, len, addchar_count;\n\n    int found_count = 0;\n\n\n\n    q = buf;\n\n    p = filename;\n\n    for (;;) {\n\n        c = *p;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '%' && *(p+1) == '%')  // %%\n\n            addchar_count = 2;\n\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n\n            nd = 0;\n\n            addchar_count = 1;\n\n            while (av_isdigit(*(p + addchar_count))) {\n\n                nd = nd * 10 + *(p + addchar_count) - '0';\n\n                addchar_count++;\n\n            }\n\n\n\n            if (*(p + addchar_count) == placeholder) {\n\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n\n                if (len < 1)  // returned error or empty buf1\n\n                    goto fail;\n\n                if ((q - buf + len) > buf_size - 1)\n\n                    goto fail;\n\n                memcpy(q, buf1, len);\n\n                q += len;\n\n                p += (addchar_count + 1);\n\n                addchar_count = 0;\n\n                found_count++;\n\n            }\n\n\n\n        } else\n\n            addchar_count = 1;\n\n\n\n        while (addchar_count--)\n\n            if ((q - buf) < buf_size - 1)\n\n                *q++ = *p++;\n\n            else\n\n                goto fail;\n\n    }\n\n    *q = '\\0';\n\n    return found_count;\n\nfail:\n\n    *q = '\\0';\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 783, "prediction": "0", "true_label": "0", "raw_text": "Question: static void cubieboard_init(QEMUMachineInitArgs *args)\n\n{\n\n    CubieBoardState *s = g_new(CubieBoardState, 1);\n\n    Error *err = NULL;\n\n\n\n    s->a10 = AW_A10(object_new(TYPE_AW_A10));\n\n    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"Couldn't realize Allwinner A10: %s\\n\",\n\n                error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,\n\n                                &s->sdram);\n\n\n\n    cubieboard_binfo.ram_size = args->ram_size;\n\n    cubieboard_binfo.kernel_filename = args->kernel_filename;\n\n    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 784, "prediction": "0", "true_label": "0", "raw_text": "Question: void esp_init(target_phys_addr_t espaddr, int it_shift,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_read,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_write,\n\n              void *dma_opaque, qemu_irq irq, qemu_irq *reset,\n\n              qemu_irq *dma_enable)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SysBusESPState *sysbus;\n\n    ESPState *esp;\n\n\n\n    dev = qdev_create(NULL, \"esp\");\n\n    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);\n\n    esp = &sysbus->esp;\n\n    esp->dma_memory_read = dma_memory_read;\n\n    esp->dma_memory_write = dma_memory_write;\n\n    esp->dma_opaque = dma_opaque;\n\n    sysbus->it_shift = it_shift;\n\n    /* XXX for now until rc4030 has been changed to use DMA enable signal */\n\n    esp->dma_enabled = 1;\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, espaddr);\n\n    *reset = qdev_get_gpio_in(dev, 0);\n\n    *dma_enable = qdev_get_gpio_in(dev, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 785, "prediction": "0", "true_label": "0", "raw_text": "Question: static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    float **audio      = (float **) frame->extended_data;\n\n    int len            = frame->nb_samples;\n\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n\n    int ch;\n\n    const float *win   = s->windows[window_index];\n\n    int window_len     = 1 << s->block_len_bits;\n\n    float n            = 2.0 * 32768.0 / window_len;\n\n\n\n    for (ch = 0; ch < avctx->channels; ch++) {\n\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n\n                                    win, len);\n\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 786, "prediction": "0", "true_label": "1", "raw_text": "_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n\n\n        /* The code below is a copy of the code above...\n\n         * This is a manual unroll. */\n\n\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        pixl  = vec_ld(0,  s1);\n\n        pixr  = vec_ld(15, s1);\n\n        bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 787, "prediction": "0", "true_label": "1", "raw_text": "Question: int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->thread_opaque;\n\n    int *progress, err;\n\n\n\n    f->owner = avctx;\n\n\n\n    ff_init_buffer_info(avctx, f);\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {\n\n        f->thread_opaque = NULL;\n\n        return avctx->get_buffer(avctx, f);\n\n    }\n\n\n\n    if (p->state != STATE_SETTING_UP &&\n\n        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&\n\n                avctx->get_buffer != avcodec_default_get_buffer))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() cannot be called after ff_thread_finish_setup()\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pthread_mutex_lock(&p->parent->buffer_mutex);\n\n    f->thread_opaque = progress = allocate_progress(p);\n\n\n\n    if (!progress) {\n\n        pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n        return -1;\n\n    }\n\n\n\n    progress[0] =\n\n    progress[1] = -1;\n\n\n\n    if (avctx->thread_safe_callbacks ||\n\n        avctx->get_buffer == avcodec_default_get_buffer) {\n\n        err = avctx->get_buffer(avctx, f);\n\n    } else {\n\n        p->requested_frame = f;\n\n        p->state = STATE_GET_BUFFER;\n\n        pthread_mutex_lock(&p->progress_mutex);\n\n        pthread_cond_signal(&p->progress_cond);\n\n\n\n        while (p->state != STATE_SETTING_UP)\n\n            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n\n\n        err = p->result;\n\n\n\n        pthread_mutex_unlock(&p->progress_mutex);\n\n\n\n        if (!avctx->codec->update_thread_context)\n\n            ff_thread_finish_setup(avctx);\n\n    }\n\n\n\n    pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 788, "prediction": "1", "true_label": "1", "raw_text": "Question: bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 789, "prediction": "0", "true_label": "0", "raw_text": "Question: static void hds_free(AVFormatContext *s)\n\n{\n\n    HDSContext *c = s->priv_data;\n\n    int i, j;\n\n    if (!c->streams)\n\n        return;\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        OutputStream *os = &c->streams[i];\n\n        if (os->out)\n\n            avio_close(os->out);\n\n        os->out = NULL;\n\n        if (os->ctx && os->ctx_inited)\n\n            av_write_trailer(os->ctx);\n\n        if (os->ctx && os->ctx->pb)\n\n            av_free(os->ctx->pb);\n\n        if (os->ctx)\n\n            avformat_free_context(os->ctx);\n\n        av_free(os->metadata);\n\n        for (j = 0; j < os->nb_extra_packets; j++)\n\n            av_free(os->extra_packets[j]);\n\n        for (j = 0; j < os->nb_fragments; j++)\n\n            av_free(os->fragments[j]);\n\n        av_free(os->fragments);\n\n    }\n\n    av_freep(&c->streams);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 790, "prediction": "0", "true_label": "1", "raw_text": "Question: yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],\n\n            const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n            const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n            int yalpha, int uvalpha, int y)\n\n{\n\n    int hasAlpha = abuf[0] && abuf[1];\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;\n\n        int A;\n\n\n\n        Y = av_clip_uint8(Y);\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;\n\n            A = av_clip_uint8(A);\n\n        }\n\n\n\n        dest[i * 2    ] = Y;\n\n        dest[i * 2 + 1] = hasAlpha ? A : 255;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 791, "prediction": "1", "true_label": "1", "raw_text": "Question: static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 792, "prediction": "1", "true_label": "0", "raw_text": "Question: QBool *qbool_from_bool(bool value)\n\n{\n\n    QBool *qb;\n\n\n\n    qb = g_malloc(sizeof(*qb));\n\n    qb->value = value;\n\n    QOBJECT_INIT(qb, &qbool_type);\n\n\n\n    return qb;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 793, "prediction": "0", "true_label": "0", "raw_text": "Question: static void setup_rt_frame(int usig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));\n\n\tint err = 0;\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\n\n            return 1;\n\n#endif\n\n\t__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\terr |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (target_ulong)frame->pinfo;\n\n            env->regs[2] = (target_ulong)frame->puc;\n\n\t}\n\n\n\n        //\treturn err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 794, "prediction": "0", "true_label": "1", "raw_text": "BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;\n\n    int i;\n\n\n\n    /* Sanity check natural alignments */\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);\n\n    /* Sanity check bounds */\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);\n\n\n\n    if (index >= max_phbs) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_phbs - 1);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;\n\n    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;\n\n    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 795, "prediction": "0", "true_label": "1", "raw_text": "x7F, D);\n\n#endif\n\n    UART1_clk = PLL_out / D;\n\n#ifdef DEBUG_CLOCKS\n\n    printf(\"Setup PPC405EP clocks - sysclk %\" PRIu32 \" VCO %\" PRIu64\n\n           \" PLL out %\" PRIu64 \" Hz\\n\", cpc->sysclk, VCO_out, PLL_out);\n\n    printf(\"CPU %\" PRIu32 \" PLB %\" PRIu32 \" OPB %\" PRIu32 \" EBC %\" PRIu32\n\n           \" MAL %\" PRIu32 \" PCI %\" PRIu32 \" UART0 %\" PRIu32\n\n           \" UART1 %\" PRIu32 \"\\n\",\n\n           CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk,\n\n           UART0_clk, UART1_clk);\n\n#endif\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);\n\n    /* Setup MAL clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);\n\n    /* Setup PCI clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);\n\n    /* Setup UART0 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);\n\n    /* Setup UART1 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 796, "prediction": "0", "true_label": "1", "raw_text": "Question: av_cold void ff_wmv2_common_init(Wmv2Context * w){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 797, "prediction": "-1", "true_label": "1", "raw_text": "Question: void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 798, "prediction": "0", "true_label": "1", "raw_text": ");\n\n\t}\n\n\n\n        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );\n\n\n\n        for(f_code=1; f_code<=MAX_FCODE; f_code++){\n\n            for(mv=-MAX_MV; mv<=MAX_MV; mv++){\n\n                int len;\n\n\n\n                if(mv==0) len= mbMotionVectorTable[0][1];\n\n                else{\n\n                    int val, bit_size, range, code;\n\n\n\n                    bit_size = f_code - 1;\n\n                    range = 1 << bit_size;\n\n\n\n                    val=mv;\n\n                    if (val < 0) \n\n                        val = -val;\n\n                    val--;\n\n                    code = (val >> bit_size) + 1;\n\n                    if(code<17){\n\n                        len= mbMotionVectorTable[code][1] + 1 + bit_size;\n\n                    }else{\n\n                        len= mbMotionVectorTable[16][1] + 2 + bit_size;\n\n                    }\n\n                }\n\n\n\n                mv_penalty[f_code][mv+MAX_MV]= len;\n\n            }\n\n        }\n\n        \n\n\n\n        for(f_code=MAX_FCODE; f_code>0; f_code--){\n\n            for(mv=-(8<<f_code); mv<(8<<f_code); mv++){\n\n                fcode_tab[mv+MAX_MV]= f_code;\n\n            }\n\n        }\n\n    }\n\n    s->me.mv_penalty= mv_penalty;\n\n    s->fcode_tab= fcode_tab;\n\n    if(s->codec_id == CODEC_ID_MPEG1VIDEO){\n\n        s->min_qcoeff=-255;\n\n        s->max_qcoeff= 255;\n\n    }else{\n\n        s->min_qcoeff=-2047;\n\n        s->max_qcoeff= 2047;\n\n    }\n\n    s->intra_ac_vlc_length=\n\n    s->inter_ac_vlc_length=\n\n    s->intra_ac_vlc_last_length=\n\n    s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 799, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int ac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    AC3DecodeContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n\n\n\n    ff_ac3_common_init();\n\n    ac3_tables_init();\n\n    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);\n\n    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);\n\n    ff_kbd_window_init(s->window, 5.0, 256);\n\n    dsputil_init(&s->dsp, avctx);\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    av_lfg_init(&s->dith_state, 0);\n\n\n\n    /* set scale value for float to int16 conversion */\n\n    s->mul_bias = 32767.0f;\n\n\n\n    /* allow downmixing to stereo or mono */\n\n    if (avctx->channels > 0 && avctx->request_channels > 0 &&\n\n            avctx->request_channels < avctx->channels &&\n\n            avctx->request_channels <= 2) {\n\n        avctx->channels = avctx->request_channels;\n\n    }\n\n    s->downmixed = 1;\n\n\n\n    /* allocate context input buffer */\n\n    if (avctx->error_recognition >= FF_ER_CAREFUL) {\n\n        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!s->input_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 800, "prediction": "0", "true_label": "0", "raw_text": "AC-3 metadata\n\n     */\n\n\n\n    /* header */\n\n    frame_bits = 16; /* sync info */\n\n    if (s->eac3) {\n\n        /* bitstream info header */\n\n        frame_bits += 35;\n\n        frame_bits += 1 + 1 + 1;\n\n        /* audio frame header */\n\n        frame_bits += 2;\n\n        frame_bits += 10;\n\n        /* exponent strategy */\n\n        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)\n\n            frame_bits += 2 * s->fbw_channels + s->lfe_on;\n\n        /* converter exponent strategy */\n\n        frame_bits += s->fbw_channels * 5;\n\n        /* snr offsets */\n\n        frame_bits += 10;\n\n        /* block start info */\n\n        frame_bits++;\n\n    } else {\n\n        frame_bits += 49;\n\n        frame_bits += frame_bits_inc[s->channel_mode];\n\n    }\n\n\n\n    /* audio blocks */\n\n    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {\n\n        if (!s->eac3) {\n\n            /* block switch flags */\n\n            frame_bits += s->fbw_channels;\n\n\n\n            /* dither flags */\n\n            frame_bits += s->fbw_channels;\n\n        }\n\n\n\n        /* dynamic range */\n\n        frame_bits++;\n\n\n\n        /* spectral extension */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* exponent strategy */\n\n            frame_bits += 2 * s->fbw_channels;\n\n            if (s->lfe_on)\n\n                frame_bits++;\n\n\n\n            /* bit allocation params */\n\n            frame_bits++;\n\n            if (!blk)\n\n                frame_bits += 2 + 2 + 2 + 2 + 3;\n\n        }\n\n\n\n        /* converter snr offset */\n\n        if (s->eac3)\n\n            frame_bits++;\n\n\n\n        if (!s->eac3) {\n\n            /* delta bit allocation */\n\n            frame_bits++;\n\n\n\n            /* skipped data */\n\n            frame_bits++;\n\n        }\n\n    }\n\n\n\n    /* auxiliary data */\n\n    frame_bits++;\n\n\n\n    /* CRC */\n\n    frame_bits += 1 + 16;\n\n\n\n    s->frame_bits_fixed = frame_bits;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 801, "prediction": "0", "true_label": "0", "raw_text": "Question: static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 802, "prediction": "1", "true_label": "0", "raw_text": "Question: int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,\n\n                         int *frame_size_ptr,\n\n                         uint8_t *buf, int buf_size)\n\n{\n\n    int ret;\n\n\n\n    *frame_size_ptr= 0;\n\n    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){\n\n        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,\n\n                                buf, buf_size);\n\n        avctx->frame_number++;\n\n    }else\n\n        ret= 0;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 803, "prediction": "0", "true_label": "1", "raw_text": "rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n\n                /* Choose the best mv out of 0,0 and the nearest mv */\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n\n\n\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n\n                    mb->mode = VP8_MVMODE_SPLIT;\n\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n\n                } else {\n\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n\n                    mb->bmv[0] = mb->mv;\n\n                }\n\n            } else {\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n\n                mb->bmv[0] = mb->mv;\n\n            }\n\n        } else {\n\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n\n            mb->bmv[0] = mb->mv;\n\n        }\n\n    } else {\n\n        mb->mode = VP8_MVMODE_ZERO;\n\n        AV_ZERO32(&mb->mv);\n\n        mb->bmv[0] = mb->mv;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 804, "prediction": "0", "true_label": "1", "raw_text": "Question: int main()\n\n{\n\n    int rd, rt, dsp;\n\n    int result, resultdsp;\n\n\n\n    rt        = 0x12345678;\n\n    result    = 0xA000C000;\n\n    resultdsp = 1;\n\n\n\n    __asm\n\n        (\"shll.ph %0, %2, 0x0B\\n\\t\"\n\n         \"rddsp %1\\n\\t\"\n\n         : \"=r\"(rd), \"=r\"(dsp)\n\n         : \"r\"(rt)\n\n        );\n\n    dsp = (dsp >> 22) & 0x01;\n\n    assert(dsp == resultdsp);\n\n    assert(rd  == result);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 805, "prediction": "1", "true_label": "0", "raw_text": "Question: int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)\n\n{\n\n    int count, x;\n\n    uint8_t *out;\n\n\n\n    out = outbuf;\n\n\n\n\n\n        for(x = 0; x < w; x += count) {\n\n            /* see if we can encode the next set of pixels with RLE */\n\n            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n\n                if(out + bpp + 1 > outbuf + out_size) return -1;\n\n                *out++ = (count ^ xor) + add;\n\n                memcpy(out, ptr, bpp);\n\n                out += bpp;\n\n            } else {\n\n                /* fall back on uncompressed */\n\n                count = count_pixels(ptr, w-x, bpp, 0);\n\n                *out++ = count - 1;\n\n\n\n                if(out + bpp*count > outbuf + out_size) return -1;\n\n                memcpy(out, ptr, bpp * count);\n\n                out += bpp * count;\n\n        }\n\n\n\n        ptr += count * bpp;\n\n    }\n\n\n\n    return out - outbuf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 806, "prediction": "0", "true_label": "1", "raw_text": "DeviceContext *device_priv = ctx->device_ctx->internal->priv;\n\n    VDPAUFramesContext        *priv = ctx->internal->priv;\n\n\n\n    int i;\n\n\n\n    switch (ctx->sw_format) {\n\n    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;\n\n    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;\n\n    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported data layout: %s\\n\",\n\n               av_get_pix_fmt_name(ctx->sw_format));\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {\n\n        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {\n\n            priv->chroma_idx  = i;\n\n            priv->pix_fmts    = device_priv->pix_fmts[i];\n\n            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];\n\n            break;\n\n        }\n\n    }\n\n    if (!priv->pix_fmts) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported chroma type: %d\\n\", priv->chroma_type);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (!ctx->pool) {\n\n        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,\n\n                                                            vdpau_pool_alloc, NULL);\n\n        if (!ctx->internal->pool_internal)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    priv->get_data = device_priv->get_data;\n\n    priv->put_data = device_priv->put_data;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 807, "prediction": "0", "true_label": "1", "raw_text": "Question: int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 808, "prediction": "0", "true_label": "0", "raw_text": " 256;\n\n        for (; ch < full_channels; ch++)\n\n            s->samples_chanptr[ch] = s->extra_channels[ch - channels] + i * 256;\n\n\n\n        dca_filter_channels(s, i);\n\n\n\n        /* If this was marked as a DTS-ES stream we need to subtract back- */\n\n        /* channel from SL & SR to remove matrixed back-channel signal */\n\n        if ((s->source_pcm_res & 1) && s->xch_present) {\n\n            float *back_chan = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel]];\n\n            float *lt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 2]];\n\n            float *rt_chan   = s->samples_chanptr[s->channel_order_tab[s->xch_base_channel - 1]];\n\n            s->fdsp.vector_fmac_scalar(lt_chan, back_chan, -M_SQRT1_2, 256);\n\n            s->fdsp.vector_fmac_scalar(rt_chan, back_chan, -M_SQRT1_2, 256);\n\n        }\n\n    }\n\n\n\n    /* update lfe history */\n\n    lfe_samples = 2 * s->lfe * (s->sample_blocks / 8);\n\n    for (i = 0; i < 2 * s->lfe * 4; i++)\n\n        s->lfe_data[i] = s->lfe_data[i + lfe_samples];\n\n\n\n    /* AVMatrixEncoding\n\n     *\n\n     * DCA_STEREO_TOTAL (Lt/Rt) is equivalent to Dolby Surround */\n\n    ret = ff_side_data_update_matrix_encoding(frame,\n\n                                              (s->output & ~DCA_LFE) == DCA_STEREO_TOTAL ?\n\n                                              AV_MATRIX_ENCODING_DOLBY : AV_MATRIX_ENCODING_NONE);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_frame_ptr = 1;\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 809, "prediction": "0", "true_label": "0", "raw_text": "Question: static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    const unsigned long *features = cpu->model->features;\n\n    unsigned max_bit = 0;\n\n    S390Feat feat;\n\n\n\n    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);\n\n\n\n    if (test_bit(S390_FEAT_ZARCH, features)) {\n\n        /* z/Architecture is always active if around */\n\n        words[0] = 1ull << (63 - 2);\n\n    }\n\n\n\n    for (feat = find_first_bit(features, S390_FEAT_MAX);\n\n         feat < S390_FEAT_MAX;\n\n         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {\n\n        const S390FeatDef *def = s390_feat_def(feat);\n\n        if (def->type == S390_FEAT_TYPE_STFL) {\n\n            unsigned bit = def->bit;\n\n            if (bit > max_bit) {\n\n                max_bit = bit;\n\n            }\n\n            assert(bit / 64 < MAX_STFL_WORDS);\n\n            words[bit / 64] |= 1ULL << (63 - bit % 64);\n\n        }\n\n    }\n\n\n\n    return max_bit / 64;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 810, "prediction": "1", "true_label": "0", "raw_text": "Question: static int nbd_establish_connection(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    int sock;\n\n    int ret;\n\n    off_t size;\n\n    size_t blocksize;\n\n\n\n    if (s->host_spec[0] == '/') {\n\n        sock = unix_socket_outgoing(s->host_spec);\n\n    } else {\n\n        sock = tcp_socket_outgoing_spec(s->host_spec);\n\n    }\n\n\n\n    /* Failed to establish connection */\n\n    if (sock < 0) {\n\n        logout(\"Failed to establish connection to NBD server\\n\");\n\n        return -errno;\n\n    }\n\n\n\n    /* NBD handshake */\n\n    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,\n\n                                &blocksize);\n\n    if (ret < 0) {\n\n        logout(\"Failed to negotiate with the NBD server\\n\");\n\n        closesocket(sock);\n\n        return -errno;\n\n    }\n\n\n\n    /* Now that we're connected, set the socket to be non-blocking and\n\n     * kick the reply mechanism.  */\n\n    socket_set_nonblock(sock);\n\n    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,\n\n                            nbd_have_request, NULL, s);\n\n\n\n    s->sock = sock;\n\n    s->size = size;\n\n    s->blocksize = blocksize;\n\n\n\n    logout(\"Established connection with NBD server\\n\");\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 811, "prediction": "0", "true_label": "0", "raw_text": "plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 812, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)\n\n{\n\n    int y;\n\n    uint8_t * fcode_tab= s->fcode_tab;\n\n\n\n    // RAL: 8 in MPEG-1, 16 in MPEG-4\n\n    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);\n\n\n\n    /* clip / convert to intra 16x16 type MVs */\n\n    for(y=0; y<s->mb_height; y++){\n\n        int x;\n\n        int xy= (y+1)* (s->mb_width+2)+1;\n\n        int i= y*s->mb_width;\n\n        for(x=0; x<s->mb_width; x++)\n\n            {\n\n            if (s->mb_type[i] & type)    // RAL: \"type\" test added...\n\n                {\n\n                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][0]>0) \n\n                        mv_table[xy][0]=  range-1;\n\n                    else\n\n                        mv_table[xy][0]= -range;\n\n                    }\n\n                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)\n\n                    {\n\n                    if(mv_table[xy][1]>0) \n\n                        mv_table[xy][1]=  range-1;\n\n                    else                  \n\n                        mv_table[xy][1]= -range;\n\n            }\n\n            }\n\n            xy++;\n\n            i++;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 813, "prediction": "0", "true_label": "0", "raw_text": "Question: S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)\n\n{\n\n    S390CPU *cpu;\n\n    Error *err = NULL;\n\n\n\n    cpu = cpu_s390x_create(cpu_model, &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n\n\n    object_property_set_int(OBJECT(cpu), core_id, \"core-id\", &err);\n\n    if (err != NULL) {\n\n        goto out;\n\n    }\n\n    object_property_set_bool(OBJECT(cpu), true, \"realized\", &err);\n\n\n\nout:\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        object_unref(OBJECT(cpu));\n\n        cpu = NULL;\n\n    }\n\n    return cpu;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 814, "prediction": "0", "true_label": "0", "raw_text": "Question: aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 815, "prediction": "0", "true_label": "0", "raw_text": "Question: static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)\n\n{\n\n    int n=0, x, y, i;\n\n\n\n    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));\n\n\n\n    /* Map to the ROQ quadtree order */\n\n    for (y=0; y<enc->height; y+=16)\n\n        for (x=0; x<enc->width; x+=16)\n\n            for(i=0; i<4; i++) {\n\n                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;\n\n                tempData->cel_evals[n++].sourceY = y + (i&2)*4;\n\n            }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 816, "prediction": "0", "true_label": "0", "raw_text": "\n\n                pkt->duration = AV_RB32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n                pkt->duration = ret * 2 / ea->num_channels;\n\n                break;\n\n            case CODEC_ID_PCM_S16LE_PLANAR:\n\n            case CODEC_ID_MP3:\n\n                pkt->duration = num_samples;\n\n                break;\n\n            default:\n\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n\n            }\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        /* ending tag */\n\n        case 0:\n\n        case ISNe_TAG:\n\n        case SCEl_TAG:\n\n        case SEND_TAG:\n\n        case SEEN_TAG:\n\n            ret = AVERROR(EIO);\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case MVIh_TAG:\n\n        case kVGT_TAG:\n\n        case pQGT_TAG:\n\n        case TGQs_TAG:\n\n        case MADk_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MVIf_TAG:\n\n        case fVGT_TAG:\n\n        case MADm_TAG:\n\n        case MADe_TAG:\n\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n\n            chunk_size += 8;\n\n            goto get_video_packet;\n\n\n\n        case mTCD_TAG:\n\n            avio_skip(pb, 8);  // skip ea dct header\n\n            chunk_size -= 8;\n\n            goto get_video_packet;\n\n\n\n        case MV0K_TAG:\n\n        case MPCh_TAG:\n\n        case pIQT_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MV0F_TAG:\n\nget_video_packet:\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->video_stream_index;\n\n            pkt->flags |= key;\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            avio_skip(pb, chunk_size);\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 817, "prediction": "0", "true_label": "1", "raw_text": "Question: static void type_initialize_interface(TypeImpl *ti, const char *parent)\n\n{\n\n    InterfaceClass *new_iface;\n\n    TypeInfo info = { };\n\n    TypeImpl *iface_impl;\n\n\n\n    info.parent = parent;\n\n    info.name = g_strdup_printf(\"%s::%s\", ti->name, info.parent);\n\n    info.abstract = true;\n\n\n\n    iface_impl = type_register(&info);\n\n    type_initialize(iface_impl);\n\n    g_free((char *)info.name);\n\n\n\n    new_iface = (InterfaceClass *)iface_impl->class;\n\n    new_iface->concrete_class = ti->class;\n\n\n\n    ti->class->interfaces = g_slist_append(ti->class->interfaces,\n\n                                           iface_impl->class);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 818, "prediction": "1", "true_label": "0", "raw_text": "Question: static int video_open(VideoState *is){\n\n    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;\n\n    int w,h;\n\n\n\n    if(is_full_screen) flags |= SDL_FULLSCREEN;\n\n    else               flags |= SDL_RESIZABLE;\n\n\n\n    if (is_full_screen && fs_screen_width) {\n\n        w = fs_screen_width;\n\n        h = fs_screen_height;\n\n    } else if(!is_full_screen && screen_width){\n\n        w = screen_width;\n\n        h = screen_height;\n\n    }else if (is->video_st && is->video_st->codec->width){\n\n        w = is->video_st->codec->width;\n\n        h = is->video_st->codec->height;\n\n    } else {\n\n        w = 640;\n\n        h = 480;\n\n    }\n\n#ifndef SYS_DARWIN\n\n    screen = SDL_SetVideoMode(w, h, 0, flags);\n\n#else\n\n    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */\n\n    screen = SDL_SetVideoMode(w, h, 24, flags);\n\n#endif\n\n    if (!screen) {\n\n        fprintf(stderr, \"SDL: could not set video mode - exiting\\n\");\n\n        return -1;\n\n    }\n\n    SDL_WM_SetCaption(\"FFplay\", \"FFplay\");\n\n\n\n    is->width = screen->w;\n\n    is->height = screen->h;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 819, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    struct nand_state_t *s = opaque;\n\n    uint32_t r;\n\n    int rdy;\n\n\n\n    r = nand_getio(s->nand);\n\n    nand_getpins(s->nand, &rdy);\n\n    s->rdy = rdy;\n\n\n\n    DNAND(printf(\"%s addr=%x r=%x\\n\", __func__, addr, r));\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 820, "prediction": "0", "true_label": "0", "raw_text": "Question: void qmp_migrate_set_speed(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s;\n\n\n\n    if (value < 0) {\n\n        value = 0;\n\n    }\n\n\n\n    s = migrate_get_current();\n\n    s->bandwidth_limit = value;\n\n    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 821, "prediction": "0", "true_label": "1", "raw_text": "Question: void block_job_resume_all(void)\n\n{\n\n    BlockJob *job = NULL;\n\n    while ((job = block_job_next(job))) {\n\n        AioContext *aio_context = blk_get_aio_context(job->blk);\n\n\n\n        aio_context_acquire(aio_context);\n\n        block_job_resume(job);\n\n        aio_context_release(aio_context);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 822, "prediction": "0", "true_label": "0", "raw_text": "_SPEC) {\n\n        SpecifierOpt **so = dst;\n\n        char *p = strchr(opt, ':');\n\n\n\n        dstcount = (int *)(so + 1);\n\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n\n        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : \"\");\n\n        dst = &(*so)[*dstcount - 1].u;\n\n    }\n\n\n\n    if (po->flags & OPT_STRING) {\n\n        char *str;\n\n        str = av_strdup(arg);\n\n        av_freep(dst);\n\n        *(char **)dst = str;\n\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n\n    } else if (po->flags & OPT_INT64) {\n\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n\n    } else if (po->flags & OPT_TIME) {\n\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n\n    } else if (po->flags & OPT_FLOAT) {\n\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n\n    } else if (po->flags & OPT_DOUBLE) {\n\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n\n    } else if (po->u.func_arg) {\n\n        int ret = po->u.func_arg(optctx, opt, arg);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR,\n\n                   \"Failed to set value '%s' for option '%s'\\n\", arg, opt);\n\n            return ret;\n\n        }\n\n    }\n\n    if (po->flags & OPT_EXIT)\n\n        exit_program(0);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 823, "prediction": "0", "true_label": "1", "raw_text": "Question: static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 824, "prediction": "0", "true_label": "1", "raw_text": "Question: static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,\n\n                                target_ulong avpn,\n\n                                target_ulong flags,\n\n                                target_ulong *vp, target_ulong *rp)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    uint64_t token;\n\n    target_ulong v, r, rb;\n\n\n\n    if (!valid_pte_index(env, ptex)) {\n\n        return REMOVE_PARM;\n\n    }\n\n\n\n    token = ppc_hash64_start_access(cpu, ptex);\n\n    v = ppc_hash64_load_hpte0(cpu, token, 0);\n\n    r = ppc_hash64_load_hpte1(cpu, token, 0);\n\n    ppc_hash64_stop_access(token);\n\n\n\n    if ((v & HPTE64_V_VALID) == 0 ||\n\n        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||\n\n        ((flags & H_ANDCOND) && (v & avpn) != 0)) {\n\n        return REMOVE_NOT_FOUND;\n\n    }\n\n    *vp = v;\n\n    *rp = r;\n\n    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);\n\n    rb = compute_tlbie_rb(v, r, ptex);\n\n    ppc_tlb_invalidate_one(env, rb);\n\n    return REMOVE_SUCCESS;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 825, "prediction": "0", "true_label": "1", "raw_text": " offset + PCI_ERR_COR_STATUS,\n\n                               PCI_ERR_COR_SUPPORTED);\n\n\n\n    pci_set_long(dev->config + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_MASK_DEFAULT);\n\n    pci_set_long(dev->wmask + offset + PCI_ERR_COR_MASK,\n\n                 PCI_ERR_COR_SUPPORTED);\n\n\n\n    /* capabilities and control. multiple header logging is supported */\n\n    if (dev->exp.aer_log.log_max > 0) {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC |\n\n                     PCI_ERR_CAP_MHRC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE |\n\n                     PCI_ERR_CAP_MHRE);\n\n    } else {\n\n        pci_set_long(dev->config + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENC | PCI_ERR_CAP_ECRC_CHKC);\n\n        pci_set_long(dev->wmask + offset + PCI_ERR_CAP,\n\n                     PCI_ERR_CAP_ECRC_GENE | PCI_ERR_CAP_ECRC_CHKE);\n\n    }\n\n\n\n    switch (pcie_cap_get_type(dev)) {\n\n    case PCI_EXP_TYPE_ROOT_PORT:\n\n        /* this case will be set by pcie_aer_root_init() */\n\n        /* fallthrough */\n\n    case PCI_EXP_TYPE_DOWNSTREAM:\n\n    case PCI_EXP_TYPE_UPSTREAM:\n\n        pci_word_test_and_set_mask(dev->wmask + PCI_BRIDGE_CONTROL,\n\n                                   PCI_BRIDGE_CTL_SERR);\n\n        pci_long_test_and_set_mask(dev->w1cmask + PCI_STATUS,\n\n                                   PCI_SEC_STATUS_RCV_SYSTEM_ERROR);\n\n        break;\n\n    default:\n\n        /* nothing */\n\n        break;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 826, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 827, "prediction": "1", "true_label": "1", "raw_text": "Question: ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n\n{\n\n    ssize_t ret;\n\n#ifdef CONFIG_VNC_TLS\n\n    if (vs->tls.session) {\n\n        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);\n\n    } else {\n\n#endif /* CONFIG_VNC_TLS */\n\n        ret = send(vs->csock, (const void *)data, datalen, 0);\n\n#ifdef CONFIG_VNC_TLS\n\n    }\n\n#endif /* CONFIG_VNC_TLS */\n\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n\n    return vnc_client_io_error(vs, ret, socket_error());\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 828, "prediction": "0", "true_label": "0", "raw_text": " ca - cs;\n\n        }\n\n\n\n        /* compute mdct windows */\n\n        for(i=0;i<36;i++) {\n\n            for(j=0; j<4; j++){\n\n                double d;\n\n\n\n                if(j==2 && i%3 != 1)\n\n                    continue;\n\n\n\n                d= sin(M_PI * (i + 0.5) / 36.0);\n\n                if(j==1){\n\n                    if     (i>=30) d= 0;\n\n                    else if(i>=24) d= sin(M_PI * (i - 18 + 0.5) / 12.0);\n\n                    else if(i>=18) d= 1;\n\n                }else if(j==3){\n\n                    if     (i<  6) d= 0;\n\n                    else if(i< 12) d= sin(M_PI * (i -  6 + 0.5) / 12.0);\n\n                    else if(i< 18) d= 1;\n\n                }\n\n                //merge last stage of imdct into the window coefficients\n\n                d*= 0.5 / cos(M_PI*(2*i + 19)/72);\n\n\n\n                if(j==2)\n\n                    mdct_win[j][i/3] = FIXHR((d / (1<<5)));\n\n                else\n\n                    mdct_win[j][i  ] = FIXHR((d / (1<<5)));\n\n            }\n\n        }\n\n\n\n        /* NOTE: we do frequency inversion adter the MDCT by changing\n\n           the sign of the right window coefs */\n\n        for(j=0;j<4;j++) {\n\n            for(i=0;i<36;i+=2) {\n\n                mdct_win[j + 4][i] = mdct_win[j][i];\n\n                mdct_win[j + 4][i + 1] = -mdct_win[j][i + 1];\n\n            }\n\n        }\n\n\n\n        init = 1;\n\n    }\n\n\n\n    if (avctx->codec_id == CODEC_ID_MP3ADU)\n\n        s->adu_mode = 1;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 829, "prediction": "0", "true_label": "0", "raw_text": "Question: static int libgsm_decode_frame(AVCodecContext *avctx,\n\n                               void *data, int *data_size,\n\n                               AVPacket *avpkt) {\n\n    uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);\n\n\n\n    if (*data_size < out_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Output buffer is too small\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (buf_size < avctx->block_align) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet is too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch(avctx->codec_id) {\n\n    case CODEC_ID_GSM:\n\n        if(gsm_decode(avctx->priv_data,buf,data)) return -1;\n\n        break;\n\n    case CODEC_ID_GSM_MS:\n\n        if(gsm_decode(avctx->priv_data,buf,data) ||\n\n           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;\n\n    }\n\n\n\n    *data_size = out_size;\n\n    return avctx->block_align;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 830, "prediction": "0", "true_label": "1", "raw_text": "Question: static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n\n{\n\n    unsigned access_size_min = mr->ops->impl.min_access_size;\n\n    unsigned access_size_max = mr->ops->impl.max_access_size;\n\n\n\n    /* Regions are assumed to support 1-4 byte accesses unless\n\n       otherwise specified.  */\n\n    if (access_size_min == 0) {\n\n        access_size_min = 1;\n\n    }\n\n    if (access_size_max == 0) {\n\n        access_size_max = 4;\n\n    }\n\n\n\n    /* Bound the maximum access by the alignment of the address.  */\n\n    if (!mr->ops->impl.unaligned) {\n\n        unsigned align_size_max = addr & -addr;\n\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n\n            access_size_max = align_size_max;\n\n        }\n\n    }\n\n\n\n    /* Don't attempt accesses larger than the maximum.  */\n\n    if (l > access_size_max) {\n\n        l = access_size_max;\n\n    }\n\n    /* ??? The users of this function are wrong, not supporting minimums larger\n\n       than the remaining length.  C.f. memory.c:access_with_adjusted_size.  */\n\n    assert(l >= access_size_min);\n\n\n\n    return l;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 831, "prediction": "0", "true_label": "1", "raw_text": " that \"i\" is the current\n\n     * index and \"i - 1\" is the one being copied from, thus the\n\n     * unusual start and end in the for statement.\n\n     */\n\n    for (i = count + 1; i > index; i--) {\n\n        s->files->f[i] = s->files->f[i - 1];\n\n        s->files->f[i].select = cpu_to_be16(FW_CFG_FILE_FIRST + i);\n\n        s->entries[0][FW_CFG_FILE_FIRST + i] =\n\n            s->entries[0][FW_CFG_FILE_FIRST + i - 1];\n\n        s->entry_order[i] = s->entry_order[i - 1];\n\n    }\n\n\n\n    memset(&s->files->f[index], 0, sizeof(FWCfgFile));\n\n    memset(&s->entries[0][FW_CFG_FILE_FIRST + index], 0, sizeof(FWCfgEntry));\n\n\n\n    pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename);\n\n    for (i = 0; i <= count; i++) {\n\n        if (i != index &&\n\n            strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {\n\n            error_report(\"duplicate fw_cfg file name: %s\",\n\n                         s->files->f[index].name);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,\n\n                              select_cb, write_cb,\n\n                              callback_opaque, data, len,\n\n                              read_only);\n\n\n\n    s->files->f[index].size   = cpu_to_be32(len);\n\n    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);\n\n    s->entry_order[index] = order;\n\n    trace_fw_cfg_add_file(s, index, s->files->f[index].name, len);\n\n\n\n    s->files->count = cpu_to_be32(count+1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 832, "prediction": "0", "true_label": "1", "raw_text": "Question: static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 833, "prediction": "0", "true_label": "0", "raw_text": ");\n\n        av_dict_free(&output_files[i]->opts);\n\n        av_freep(&output_files[i]);\n\n    }\n\n    for (i = 0; i < nb_output_streams; i++) {\n\n        AVBitStreamFilterContext *bsfc = output_streams[i]->bitstream_filters;\n\n        while (bsfc) {\n\n            AVBitStreamFilterContext *next = bsfc->next;\n\n            av_bitstream_filter_close(bsfc);\n\n            bsfc = next;\n\n        }\n\n        output_streams[i]->bitstream_filters = NULL;\n\n        avcodec_free_frame(&output_streams[i]->filtered_frame);\n\n\n\n        av_freep(&output_streams[i]->forced_keyframes);\n\n        av_freep(&output_streams[i]->avfilter);\n\n        av_freep(&output_streams[i]->logfile_prefix);\n\n        av_freep(&output_streams[i]);\n\n    }\n\n    for (i = 0; i < nb_input_files; i++) {\n\n        avformat_close_input(&input_files[i]->ctx);\n\n        av_freep(&input_files[i]);\n\n    }\n\n    for (i = 0; i < nb_input_streams; i++) {\n\n        av_frame_free(&input_streams[i]->decoded_frame);\n\n        av_frame_free(&input_streams[i]->filter_frame);\n\n        av_dict_free(&input_streams[i]->opts);\n\n        av_freep(&input_streams[i]->filters);\n\n        av_freep(&input_streams[i]);\n\n    }\n\n\n\n    if (vstats_file)\n\n        fclose(vstats_file);\n\n    av_free(vstats_filename);\n\n\n\n    av_freep(&input_streams);\n\n    av_freep(&input_files);\n\n    av_freep(&output_streams);\n\n    av_freep(&output_files);\n\n\n\n    uninit_opts();\n\n\n\n    avfilter_uninit();\n\n    avformat_network_deinit();\n\n\n\n    if (received_sigterm) {\n\n        av_log(NULL, AV_LOG_INFO, \"Received signal %d: terminating.\\n\",\n\n               (int) received_sigterm);\n\n        exit (255);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 834, "prediction": "0", "true_label": "1", "raw_text": "Question: static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *num_same)\n\n{\n\n    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;\n\n    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;\n\n    uint8_t bitmap[BDRV_SECTOR_SIZE];\n\n    int ret;\n\n    int changed;\n\n\n\n    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    bitnum &= BITS_PER_BITMAP_SECTOR - 1;\n\n    changed = cow_test_bit(bitnum, bitmap);\n\n    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);\n\n    return changed;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 835, "prediction": "0", "true_label": "0", "raw_text": "Question: bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 836, "prediction": "0", "true_label": "0", "raw_text": ";\n\n    QCowSnapshot *sn;\n\n    uint16_t *refcount_table;\n\n\n\n    size = bdrv_getlength(s->hd);\n\n    nb_clusters = size_to_clusters(s, size);\n\n    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));\n\n\n\n    /* header */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  0, s->cluster_size);\n\n\n\n    check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                       s->l1_table_offset, s->l1_size, 1);\n\n\n\n    /* snapshots */\n\n    for(i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        check_refcounts_l1(bs, refcount_table, nb_clusters,\n\n                           sn->l1_table_offset, sn->l1_size, 0);\n\n    }\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->snapshots_offset, s->snapshots_size);\n\n\n\n    /* refcount data */\n\n    inc_refcounts(bs, refcount_table, nb_clusters,\n\n                  s->refcount_table_offset,\n\n                  s->refcount_table_size * sizeof(uint64_t));\n\n    for(i = 0; i < s->refcount_table_size; i++) {\n\n        int64_t offset;\n\n        offset = s->refcount_table[i];\n\n        if (offset != 0) {\n\n            inc_refcounts(bs, refcount_table, nb_clusters,\n\n                          offset, s->cluster_size);\n\n        }\n\n    }\n\n\n\n    /* compare ref counts */\n\n    for(i = 0; i < nb_clusters; i++) {\n\n        refcount1 = get_refcount(bs, i);\n\n        refcount2 = refcount_table[i];\n\n        if (refcount1 != refcount2)\n\n            fprintf(stderr, \"ERROR cluster %d refcount=%d reference=%d\\n\",\n\n                   i, refcount1, refcount2);\n\n    }\n\n\n\n    qemu_free(refcount_table);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 837, "prediction": "0", "true_label": "1", "raw_text": "Question: static int ipoctal_init(IPackDevice *ip)\n\n{\n\n    IPOctalState *s = IPOCTAL(ip);\n\n    unsigned i;\n\n\n\n    for (i = 0; i < N_CHANNELS; i++) {\n\n        SCC2698Channel *ch = &s->ch[i];\n\n        ch->ipoctal = s;\n\n\n\n        /* Redirect IP-Octal channels to host character devices */\n\n        if (ch->devpath) {\n\n            const char chr_name[] = \"ipoctal\";\n\n            char label[ARRAY_SIZE(chr_name) + 2];\n\n            static int index;\n\n\n\n            snprintf(label, sizeof(label), \"%s%d\", chr_name, index);\n\n\n\n            ch->dev = qemu_chr_new(label, ch->devpath, NULL);\n\n\n\n            if (ch->dev) {\n\n                index++;\n\n\n                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,\n\n                                      hostdev_receive, hostdev_event, ch);\n\n                DPRINTF(\"Redirecting channel %u to %s (%s)\\n\",\n\n                        i, ch->devpath, label);\n\n            } else {\n\n                DPRINTF(\"Could not redirect channel %u to %s\\n\",\n\n                        i, ch->devpath);\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 838, "prediction": "0", "true_label": "1", "raw_text": "Question: static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 839, "prediction": "0", "true_label": "0", "raw_text": "PREAMBLE_SIZE)) !=\n\n            WC3_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n        fourcc_tag = AV_RL32(&preamble[0]);\n\n        /* chunk sizes are 16-bit aligned */\n\n        size = (AV_RB32(&preamble[4]) + 1) & (~1);\n\n\n\n    } while (fourcc_tag != BRCH_TAG);\n\n\n\n    /* initialize the decoder streams */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_XAN_WC3;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = wc3->width;\n\n    st->codec->height = wc3->height;\n\n\n\n    /* palette considerations */\n\n    st->codec->palctrl = &wc3->palette_control;\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    wc3->audio_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n    st->codec->codec_id = CODEC_ID_PCM_S16LE;\n\n    st->codec->codec_tag = 1;\n\n    st->codec->channels = WC3_AUDIO_CHANNELS;\n\n    st->codec->bits_per_sample = WC3_AUDIO_BITS;\n\n    st->codec->sample_rate = WC3_SAMPLE_RATE;\n\n    st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n        st->codec->bits_per_sample;\n\n    st->codec->block_align = WC3_AUDIO_BITS * WC3_AUDIO_CHANNELS;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 840, "prediction": "0", "true_label": "0", "raw_text": "Question: static int64_t do_strtosz(const char *nptr, char **end,\n\n                          const char default_suffix, int64_t unit)\n\n{\n\n    int64_t retval;\n\n    char *endptr;\n\n    unsigned char c;\n\n    int mul_required = 0;\n\n    double val, mul, integral, fraction;\n\n\n\n    errno = 0;\n\n    val = strtod(nptr, &endptr);\n\n    if (isnan(val) || endptr == nptr || errno != 0) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    fraction = modf(val, &integral);\n\n    if (fraction != 0) {\n\n        mul_required = 1;\n\n    }\n\n    c = *endptr;\n\n    mul = suffix_mul(c, unit);\n\n    if (mul >= 0) {\n\n        endptr++;\n\n    } else {\n\n        mul = suffix_mul(default_suffix, unit);\n\n        assert(mul >= 0);\n\n    }\n\n    if (mul == 1 && mul_required) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if ((val * mul >= INT64_MAX) || val < 0) {\n\n        retval = -ERANGE;\n\n        goto out;\n\n    }\n\n    retval = val * mul;\n\n\n\nout:\n\n    if (end) {\n\n        *end = endptr;\n\n    } else if (*endptr) {\n\n        retval = -EINVAL;\n\n    }\n\n\n\n    return retval;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 841, "prediction": "0", "true_label": "1", "raw_text": "ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Read L1 table entries from disk */\n\n    if (l1_size2 > 0) {\n\n        l1_table = g_try_malloc(l1_size2);\n\n        if (l1_table == NULL) {\n\n            ret = -ENOMEM;\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: I/O error in check_refcounts_l1\\n\");\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n        for(i = 0;i < l1_size; i++)\n\n            be64_to_cpus(&l1_table[i]);\n\n    }\n\n\n\n    /* Do the actual checks */\n\n    for(i = 0; i < l1_size; i++) {\n\n        l2_offset = l1_table[i];\n\n        if (l2_offset) {\n\n            /* Mark L2 table as used */\n\n            l2_offset &= L1E_OFFSET_MASK;\n\n            ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,\n\n                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            /* L2 tables are cluster aligned */\n\n            if (offset_into_cluster(s, l2_offset)) {\n\n                fprintf(stderr, \"ERROR l2_offset=%\" PRIx64 \": Table is not \"\n\n                    \"cluster aligned; L1 entry corrupted\\n\", l2_offset);\n\n                res->corruptions++;\n\n            }\n\n\n\n            /* Process and check L2 entries */\n\n            ret = check_refcounts_l2(bs, res, refcount_table,\n\n                                     refcount_table_size, l2_offset, flags);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n    g_free(l1_table);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 842, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 843, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int onenand_erase(OneNANDState *s, int sec, int num)\n\n{\n\n    uint8_t *blankbuf, *tmpbuf;\n\n    blankbuf = g_malloc(512);\n\n    if (!blankbuf) {\n\n        return 1;\n\n    }\n\n    tmpbuf = g_malloc(512);\n\n    if (!tmpbuf) {\n\n        g_free(blankbuf);\n\n        return 1;\n\n    }\n\n    memset(blankbuf, 0xff, 512);\n\n    for (; num > 0; num--, sec++) {\n\n        if (s->bdrv_cur) {\n\n            int erasesec = s->secs_cur + (sec >> 5);\n\n            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);\n\n            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {\n\n                goto fail;\n\n            }\n\n        } else {\n\n            if (sec + 1 > s->secs_cur) {\n\n                goto fail;\n\n            }\n\n            memcpy(s->current + (sec << 9), blankbuf, 512);\n\n            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),\n\n                   blankbuf, 1 << 4);\n\n        }\n\n    }\n\n\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 0;\n\n\n\nfail:\n\n    g_free(tmpbuf);\n\n    g_free(blankbuf);\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 844, "prediction": "0", "true_label": "1", "raw_text": "(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        extent_file = NULL;\n\n        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,\n\n                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);\n\n            }\n\n            if (ret) {\n\n                g_free(buf);\n\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 845, "prediction": "0", "true_label": "1", "raw_text": "Question: static int default_lockmgr_cb(void **arg, enum AVLockOp op)\n\n{\n\n    void * volatile * mutex = arg;\n\n    int err;\n\n\n\n    switch (op) {\n\n    case AV_LOCK_CREATE:\n\n        return 0;\n\n    case AV_LOCK_OBTAIN:\n\n        if (!*mutex) {\n\n            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            if ((err = pthread_mutex_init(tmp, NULL))) {\n\n                av_free(tmp);\n\n                return AVERROR(err);\n\n            }\n\n            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {\n\n                pthread_mutex_destroy(tmp);\n\n                av_free(tmp);\n\n            }\n\n        }\n\n\n\n        if ((err = pthread_mutex_lock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_RELEASE:\n\n        if ((err = pthread_mutex_unlock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_DESTROY:\n\n        if (*mutex)\n\n            pthread_mutex_destroy(*mutex);\n\n        av_free(*mutex);\n\n        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 846, "prediction": "0", "true_label": "1", "raw_text": "val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTER;\n\n            }else if(USES_LIST(mb_type, 1)){\n\n                *(uint32_t*)s->b_bidir_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                *(uint32_t*)s->b_bidir_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BIDIR;\n\n            }else{\n\n                *(uint32_t*)s->b_forw_mv_table[mb_xy]= *(uint32_t*)p->motion_val[0][xy];\n\n                s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_FORWARD;\n\n            }\n\n            x= p->motion_val[0][xy][0]; \n\n            y= p->motion_val[0][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chroma_cmpf, flags);\n\n        }else if(USES_LIST(mb_type, 1)){\n\n            *(uint32_t*)s->b_back_mv_table[mb_xy]= *(uint32_t*)p->motion_val[1][xy];\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_BACKWARD;\n\n           \n\n            x= p->motion_val[1][xy][0]; \n\n            y= p->motion_val[1][xy][1];\n\n            d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chroma_cmpf, flags);\n\n        }else\n\n            s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;\n\n    }\n\n    return d;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 847, "prediction": "0", "true_label": "0", "raw_text": "\n#if 0\n\n    printf(\"varc=%4d avg_var=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\\n\",\n\n\t   varc, s->avg_mb_var, sum, vard, mx - xx, my - yy);\n\n#endif\n\n    if(s->flags&CODEC_FLAG_HQ){\n\n        if (vard*2 + 200 > varc)\n\n            mb_type|= MB_TYPE_INTRA;\n\n        if (varc*2 + 200 > vard){\n\n            mb_type|= MB_TYPE_INTER;\n\n            halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n        }else{\n\n            mx = mx*2 - mb_x*32;\n\n            my = my*2 - mb_y*32;\n\n        }\n\n    }else{\n\n        if (vard <= 64 || vard < varc) {\n\n            mb_type|= MB_TYPE_INTER;\n\n            if (s->me_method != ME_ZERO) {\n\n                halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n            } else {\n\n                mx -= 16 * mb_x;\n\n                my -= 16 * mb_y;\n\n            }\n\n#if 0\n\n            if (vard < 10) {\n\n                skip++;\n\n                fprintf(stderr,\"\\nEarly skip: %d vard: %2d varc: %5d dmin: %d\", \n\n                                skip, vard, varc, dmin);\n\n            }\n\n#endif\n\n        }else{\n\n            mb_type|= MB_TYPE_INTRA;\n\n            mx = 0;//mx*2 - 32 * mb_x;\n\n            my = 0;//my*2 - 32 * mb_y;\n\n        }\n\n    }\n\n\n\n    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    set_p_mv_tables(s, mx, my);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 848, "prediction": "1", "true_label": "0", "raw_text": "Question: av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAAPIEncodePicture *pic, *next;\n\n\n\n    for (pic = ctx->pic_start; pic; pic = next) {\n\n        next = pic->next;\n\n        vaapi_encode_free(avctx, pic);\n\n    }\n\n\n\n    if (ctx->va_context != VA_INVALID_ID) {\n\n        vaDestroyContext(ctx->hwctx->display, ctx->va_context);\n\n        ctx->va_context = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->va_config != VA_INVALID_ID) {\n\n        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);\n\n        ctx->va_config = VA_INVALID_ID;\n\n    }\n\n\n\n    if (ctx->codec->close)\n\n        ctx->codec->close(avctx);\n\n\n\n    av_buffer_pool_uninit(&ctx->output_buffer_pool);\n\n\n\n    av_freep(&ctx->codec_sequence_params);\n\n    av_freep(&ctx->codec_picture_params);\n\n\n\n    av_buffer_unref(&ctx->recon_frames_ref);\n\n    av_buffer_unref(&ctx->input_frames_ref);\n\n    av_buffer_unref(&ctx->device_ref);\n\n\n\n    av_freep(&ctx->priv_data);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 849, "prediction": "0", "true_label": "0", "raw_text": "Question: static ssize_t socket_read(int sockfd, void *buff, size_t size)\n\n{\n\n    ssize_t retval, total = 0;\n\n\n\n    while (size) {\n\n        retval = read(sockfd, buff, size);\n\n        if (retval == 0) {\n\n            return -EIO;\n\n        }\n\n        if (retval < 0) {\n\n            if (errno == EINTR) {\n\n                continue;\n\n            }\n\n            return -errno;\n\n        }\n\n        size -= retval;\n\n        buff += retval;\n\n        total += retval;\n\n    }\n\n    return total;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 850, "prediction": "1", "true_label": "0", "raw_text": "Question: AioContext *blk_get_aio_context(BlockBackend *blk)\n\n{\n\n    return bdrv_get_aio_context(blk->bs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 851, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vfio_load_rom(VFIODevice *vdev)\n\n{\n\n    uint64_t size = vdev->rom_size;\n\n    char name[32];\n\n    off_t off = 0, voff = vdev->rom_offset;\n\n    ssize_t bytes;\n\n    void *ptr;\n\n\n\n    /* If loading ROM from file, pci handles it */\n\n    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {\n\n        return 0;\n\n    }\n\n\n\n    DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", __func__, vdev->host.domain,\n\n            vdev->host.bus, vdev->host.slot, vdev->host.function);\n\n\n\n    snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\",\n\n             vdev->host.domain, vdev->host.bus, vdev->host.slot,\n\n             vdev->host.function);\n\n    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);\n\n    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);\n\n    memset(ptr, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->fd, ptr + off, size, voff + off);\n\n        if (bytes == 0) {\n\n            break; /* expect that we could get back less than the ROM BAR */\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            memory_region_destroy(&vdev->pdev.rom);\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);\n\n    vdev->pdev.has_rom = true;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 852, "prediction": "1", "true_label": "0", "raw_text": "Question: UuidInfo *qmp_query_uuid(Error **errp)\n\n{\n\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    char uuid[64];\n\n\n\n    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n\n\n    info->UUID = g_strdup(uuid);\n\n    return info;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 853, "prediction": "0", "true_label": "0", "raw_text": "idx[ch][0]);\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];\n\n                    break;\n\n                case 2:\n\n                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    bands[i].scf_idx[ch][2] = get_scale_idx(&gb, bands[i].scf_idx[ch][1]);\n\n                    break;\n\n                case 3:\n\n                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];\n\n                    break;\n\n                }\n\n                c->oldDSCF[ch][i] = bands[i].scf_idx[ch][2];\n\n            }\n\n        }\n\n    }\n\n    /* get quantizers */\n\n    memset(c->Q, 0, sizeof(c->Q));\n\n    off = 0;\n\n    for(i = 0; i < BANDS; i++, off += SAMPLES_PER_BAND)\n\n        for(ch = 0; ch < 2; ch++)\n\n            idx_to_quant(c, &gb, bands[i].res[ch], c->Q[ch] + off);\n\n\n\n    ff_mpc_dequantize_and_synth(c, mb, c->frame.data[0], 2);\n\n\n\n    bits_used = get_bits_count(&gb);\n\n    bits_avail = buf_size * 8;\n\n    if (!last_frame && ((bits_avail < bits_used) || (bits_used + 32 <= bits_avail))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error decoding frame: used %i of %i bits\\n\", bits_used, bits_avail);\n\n        return -1;\n\n    }\n\n    if(c->frames_to_skip){\n\n        c->frames_to_skip--;\n\n        *got_frame_ptr = 0;\n\n        return avpkt->size;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = c->frame;\n\n\n\n    return avpkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 854, "prediction": "0", "true_label": "1", "raw_text": "Question: static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n\n                      unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    const unsigned char *ps_end;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    ps_end = src + src_len;\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (ps_end - ps < 1)\n\n            return 0;\n\n        *pd++ = *ps++;\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (ps_end - ps < 1)\n\n            break;\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end || ps_end - ps < l)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end || ps_end - ps < 2)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return ps - src;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 855, "prediction": "0", "true_label": "1", "raw_text": "->coded_height = get_bits(gb, 11);\n\n        skip_bits(gb, 5); //frame rate\n\n        v->res_x8 = get_bits1(gb);\n\n        if (get_bits1(gb)) { // something to do with DC VLC selection\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported sprite feature\\n\");\n\n            return -1;\n\n        }\n\n        skip_bits(gb, 3); //slice code\n\n        v->res_rtm_flag = 0;\n\n    } else {\n\n        v->res_rtm_flag = get_bits1(gb); //reserved\n\n    }\n\n    if (!v->res_rtm_flag)\n\n    {\n\n//            av_log(avctx, AV_LOG_ERROR,\n\n//                   \"0 for reserved RES_RTM_FLAG is forbidden\\n\");\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Old WMV3 version detected, some frames may be decoded incorrectly\\n\");\n\n        //return -1;\n\n    }\n\n    //TODO: figure out what they mean (always 0x402F)\n\n    if(!v->res_fasttx) skip_bits(gb, 16);\n\n    av_log(avctx, AV_LOG_DEBUG,\n\n               \"Profile %i:\\nfrmrtq_postproc=%i, bitrtq_postproc=%i\\n\"\n\n               \"LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\\n\"\n\n               \"Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\\n\"\n\n               \"DQuant=%i, Quantizer mode=%i, Max B frames=%i\\n\",\n\n               v->profile, v->frmrtq_postproc, v->bitrtq_postproc,\n\n               v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv,\n\n               v->rangered, v->vstransform, v->overlap, v->s.resync_marker,\n\n               v->dquant, v->quantizer_mode, avctx->max_b_frames\n\n               );\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 856, "prediction": "0", "true_label": "1", "raw_text": "Question: static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 857, "prediction": "0", "true_label": "0", "raw_text": "Question: static void apic_update_irq(APICState *s)\n\n{\n\n    int irrv, ppr;\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE))\n\n        return;\n\n    irrv = get_highest_priority_int(s->irr);\n\n    if (irrv < 0)\n\n        return;\n\n    ppr = apic_get_ppr(s);\n\n    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))\n\n        return;\n\n    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 858, "prediction": "0", "true_label": "0", "raw_text": "(env->segs[R_FS].selector, (unsigned int *)&sc->fs);\n\n    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);\n\n    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);\n\n    __put_user(env->regs[R_EDI], &sc->edi);\n\n    __put_user(env->regs[R_ESI], &sc->esi);\n\n    __put_user(env->regs[R_EBP], &sc->ebp);\n\n    __put_user(env->regs[R_ESP], &sc->esp);\n\n    __put_user(env->regs[R_EBX], &sc->ebx);\n\n    __put_user(env->regs[R_EDX], &sc->edx);\n\n    __put_user(env->regs[R_ECX], &sc->ecx);\n\n    __put_user(env->regs[R_EAX], &sc->eax);\n\n    __put_user(cs->exception_index, &sc->trapno);\n\n    __put_user(env->error_code, &sc->err);\n\n    __put_user(env->eip, &sc->eip);\n\n    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);\n\n    __put_user(env->eflags, &sc->eflags);\n\n    __put_user(env->regs[R_ESP], &sc->esp_at_signal);\n\n    __put_user(env->segs[R_SS].selector, (unsigned int *)&sc->ss);\n\n\n\n        cpu_x86_fsave(env, fpstate_addr, 1);\n\n        fpstate->status = fpstate->sw;\n\n        magic = 0xffff;\n\n    __put_user(magic, &fpstate->magic);\n\n    __put_user(fpstate_addr, &sc->fpstate);\n\n\n\n\t/* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n    __put_user(env->cr[2], &sc->cr2);\n\n\treturn err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 859, "prediction": "0", "true_label": "0", "raw_text": "Question: static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)\n\n{\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n\n\n    /* Free resources */\n\n    qemu_iovec_destroy(&acb->cur_qiov);\n\n    qed_unref_l2_cache_entry(acb->request.l2_table);\n\n\n\n    /* Free the buffer we may have allocated for zero writes */\n\n    if (acb->flags & QED_AIOCB_ZERO) {\n\n        qemu_vfree(acb->qiov->iov[0].iov_base);\n\n        acb->qiov->iov[0].iov_base = NULL;\n\n    }\n\n\n\n    /* Start next allocating write request waiting behind this one.  Note that\n\n     * requests enqueue themselves when they first hit an unallocated cluster\n\n     * but they wait until the entire request is finished before waking up the\n\n     * next request in the queue.  This ensures that we don't cycle through\n\n     * requests multiple times but rather finish one at a time completely.\n\n     */\n\n    if (acb == s->allocating_acb) {\n\n        s->allocating_acb = NULL;\n\n        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {\n\n            qemu_co_enter_next(&s->allocating_write_reqs);\n\n        } else if (s->header.features & QED_F_NEED_CHECK) {\n\n            qed_start_need_check_timer(s);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 860, "prediction": "0", "true_label": "0", "raw_text": "_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 861, "prediction": "0", "true_label": "0", "raw_text": " switch? */\n\n    stl_p(bootinfo + MBI_MMAP_ADDR,   ADDR_E820_MAP);\n\n\n\n    mb_debug(\"multiboot: mh_entry_addr = %#x\\n\", mh_entry_addr);\n\n    mb_debug(\"           mb_buf_phys   = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys);\n\n    mb_debug(\"           mod_start     = \"TARGET_FMT_plx\"\\n\", mbs.mb_buf_phys + mbs.offset_mods);\n\n    mb_debug(\"           mb_mods_count = %d\\n\", mbs.mb_mods_count);\n\n\n\n    /* save bootinfo off the stack */\n\n    mb_bootinfo_data = g_malloc(sizeof(bootinfo));\n\n    memcpy(mb_bootinfo_data, bootinfo, sizeof(bootinfo));\n\n\n\n    /* Pass variables to option rom */\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ENTRY, mh_entry_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, mh_load_addr);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mbs.mb_buf_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_KERNEL_DATA,\n\n                     mbs.mb_buf, mbs.mb_buf_size);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, ADDR_MBI);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, sizeof(bootinfo));\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_INITRD_DATA, mb_bootinfo_data,\n\n                     sizeof(bootinfo));\n\n\n\n    option_rom[nb_option_roms].name = \"multiboot.bin\";\n\n    option_rom[nb_option_roms].bootindex = 0;\n\n    nb_option_roms++;\n\n\n\n    return 1; /* yes, we are multiboot */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 862, "prediction": "0", "true_label": "0", "raw_text": "Question: static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,\n\n                                          int *beta, int *tc, uint8_t *no_p,\n\n                                          uint8_t *no_q)\n\n{\n\n    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),\n\n                                beta, tc, no_p, no_q);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 863, "prediction": "-1", "true_label": "0", "raw_text": "Question: static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,\n\n                           TCGArg b, bool b_const, TCGLabel *l)\n\n{\n\n    intptr_t offset;\n\n    bool need_cmp;\n\n\n\n    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {\n\n        need_cmp = false;\n\n    } else {\n\n        need_cmp = true;\n\n        tcg_out_cmp(s, ext, a, b, b_const);\n\n    }\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);\n\n        offset = tcg_in32(s) >> 5;\n\n    } else {\n\n        offset = l->u.value_ptr - s->code_ptr;\n\n        assert(offset == sextract64(offset, 0, 19));\n\n    }\n\n\n\n    if (need_cmp) {\n\n        tcg_out_insn(s, 3202, B_C, c, offset);\n\n    } else if (c == TCG_COND_EQ) {\n\n        tcg_out_insn(s, 3201, CBZ, ext, a, offset);\n\n    } else {\n\n        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 864, "prediction": "1", "true_label": "0", "raw_text": "_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_INVALID,\n\n                                                     option, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_POLICY,\n\n                                                     option, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_UNSUP,\n\n                                                 option, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32,\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes"}], [{"ID": 865, "prediction": "0", "true_label": "1", "raw_text": " {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        /* HACK: */\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        /* Update FIFO bits.  */\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 866, "prediction": "0", "true_label": "0", "raw_text": "Question: static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)\n\n{\n\n    AMFDataType type;\n\n    AVStream *stream, *astream, *vstream;\n\n    AVIOContext *ioc;\n\n    int i;\n\n    // only needs to hold the string \"onMetaData\".\n\n    // Anything longer is something we don't want.\n\n    char buffer[11];\n\n\n\n    astream = NULL;\n\n    vstream = NULL;\n\n    ioc     = s->pb;\n\n\n\n    // first object needs to be \"onMetaData\" string\n\n    type = avio_r8(ioc);\n\n    if (type != AMF_DATA_TYPE_STRING ||\n\n        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)\n\n        return -1;\n\n\n\n    if (!strcmp(buffer, \"onTextData\"))\n\n        return 1;\n\n\n\n    if (strcmp(buffer, \"onMetaData\"))\n\n        return -1;\n\n\n\n    // find the streams now so that amf_parse_object doesn't need to do\n\n    // the lookup every time it is called.\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        stream = s->streams[i];\n\n        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n            astream = stream;\n\n        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            vstream = stream;\n\n    }\n\n\n\n    // parse the second object (we want a mixed array)\n\n    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)\n\n        return -1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 867, "prediction": "1", "true_label": "0", "raw_text": "\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 868, "prediction": "0", "true_label": "0", "raw_text": "INTERNAL;\n\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n\n     * GPIO array layout is thus:\n\n     *  [0..N-1] SPIs\n\n     *  [N..N+31] PPIs for CPU 0\n\n     *  [N+32..N+63] PPIs for CPU 1\n\n     *   ...\n\n     */\n\n    i += (GIC_INTERNAL * s->num_cpu);\n\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n\n    /* We never use our outbound IRQ lines but provide them so that\n\n     * we maintain the same interface as the non-KVM GIC.\n\n     */\n\n    for (i = 0; i < s->num_cpu; i++) {\n\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n\n    }\n\n    /* Distributor */\n\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n\n                                   \"kvm-gic_dist\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    kvm_arm_register_device(&s->iomem,\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST);\n\n    /* CPU interface for current core. Unlike arm_gic, we don't\n\n     * provide the \"interface for core #N\" memory regions, because\n\n     * cores with a VGIC don't have those.\n\n     */\n\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n\n                                   \"kvm-gic_cpu\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n\n    kvm_arm_register_device(&s->cpuiomem[0],\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 869, "prediction": "0", "true_label": "0", "raw_text": "Question: static int write_fragments(struct Tracks *tracks, int start_index,\n\n                           AVIOContext *in)\n\n{\n\n    char dirname[100], filename[500];\n\n    int i, j;\n\n\n\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n\n        struct Track *track = tracks->tracks[i];\n\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n\n        mkdir(dirname, 0777);\n\n        for (j = 0; j < track->chunks; j++) {\n\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n\n                     dirname, type, track->offsets[j].time);\n\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n\n            write_fragment(filename, in);\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 870, "prediction": "0", "true_label": "0", "raw_text": "Question: char *qemu_find_file(int type, const char *name)\n\n{\n\n    int len;\n\n    const char *subdir;\n\n    char *buf;\n\n\n\n    /* If name contains path separators then try it as a straight path.  */\n\n    if ((strchr(name, '/') || strchr(name, '\\\\'))\n\n        && access(name, R_OK) == 0) {\n\n        return g_strdup(name);\n\n    }\n\n    switch (type) {\n\n    case QEMU_FILE_TYPE_BIOS:\n\n        subdir = \"\";\n\n        break;\n\n    case QEMU_FILE_TYPE_KEYMAP:\n\n        subdir = \"keymaps/\";\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;\n\n    buf = g_malloc0(len);\n\n    snprintf(buf, len, \"%s/%s%s\", data_dir, subdir, name);\n\n    if (access(buf, R_OK)) {\n\n        g_free(buf);\n\n        return NULL;\n\n    }\n\n    return buf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 871, "prediction": "0", "true_label": "0", "raw_text": "Question: void term_flush(void)\n\n{\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 872, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 873, "prediction": "0", "true_label": "0", "raw_text": "Question: static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         uint16_t *refcount_table,\n\n                         int64_t refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 874, "prediction": "1", "true_label": "1", "raw_text": "Question: static int nbd_co_request(BlockDriverState *bs,\n\n                          NBDRequest *request,\n\n                          QEMUIOVector *qiov)\n\n{\n\n    NBDClientSession *client = nbd_get_client_session(bs);\n\n    int ret;\n\n\n\n    if (qiov) {\n\n        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);\n\n        assert(request->len == iov_size(qiov->iov, qiov->niov));\n\n    } else {\n\n        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);\n\n    }\n\n    ret = nbd_co_send_request(bs, request,\n\n                              request->type == NBD_CMD_WRITE ? qiov : NULL);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nbd_co_receive_reply(client, request->handle,\n\n                                request->type == NBD_CMD_READ ? qiov : NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 875, "prediction": "0", "true_label": "1", "raw_text": "Question: static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 876, "prediction": "0", "true_label": "0", "raw_text": "44) {\n\n            if (deblock_topleft) {\n\n                XCHG(top_border_m1 + (24 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                XCHG(top_border_m1 + (40 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n            }\n\n            XCHG(top_border + (16 << pixel_shift), src_cb + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (24 << pixel_shift), src_cb + (9 << pixel_shift), 1);\n\n            XCHG(top_border + (32 << pixel_shift), src_cr + (1 << pixel_shift), xchg);\n\n            XCHG(top_border + (40 << pixel_shift), src_cr + (9 << pixel_shift), 1);\n\n            if (h->mb_x + 1 < h->mb_width) {\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (16 << pixel_shift), src_cb + (17 << pixel_shift), 1);\n\n                XCHG(h->top_borders[top_idx][h->mb_x + 1] + (32 << pixel_shift), src_cr + (17 << pixel_shift), 1);\n\n            }\n\n        } else {\n\n            if (deblock_top) {\n\n                if (deblock_topleft) {\n\n                    XCHG(top_border_m1 + (16 << pixel_shift), src_cb - (7 << pixel_shift), 1);\n\n                    XCHG(top_border_m1 + (24 << pixel_shift), src_cr - (7 << pixel_shift), 1);\n\n                }\n\n                XCHG(top_border + (16 << pixel_shift), src_cb + 1 + pixel_shift, 1);\n\n                XCHG(top_border + (24 << pixel_shift), src_cr + 1 + pixel_shift, 1);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 877, "prediction": "0", "true_label": "1", "raw_text": "Question: static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint8_t *buf, int linesize)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len, height;\n\n    const uint8_t *ptr;\n\n    /* image block */\n\n\n\n    bytestream_put_byte(bytestream, 0x2c);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, avctx->width);\n\n    bytestream_put_le16(bytestream, avctx->height);\n\n    bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    /* no local clut */\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf;\n\n    for (height = avctx->height; height--;) {\n\n        len += ff_lzw_encode(s->lzw, ptr, avctx->width);\n\n        ptr += linesize;\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    bytestream_put_byte(bytestream, 0x3b);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 878, "prediction": "1", "true_label": "1", "raw_text": "Question: static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    int64_t pos = avio_tell(pb);\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"stbl\");\n\n    mov_write_stsd_tag(pb, track);\n\n    mov_write_stts_tag(pb, track);\n\n    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&\n\n        track->has_keyframes && track->has_keyframes < track->entry)\n\n        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);\n\n    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)\n\n        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);\n\n    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n        track->flags & MOV_TRACK_CTTS && track->entry)\n\n        mov_write_ctts_tag(pb, track);\n\n    mov_write_stsc_tag(pb, track);\n\n    mov_write_stsz_tag(pb, track);\n\n    mov_write_stco_tag(pb, track);\n\n    return update_size(pb, pos);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 879, "prediction": "0", "true_label": "1", "raw_text": "bits) - (offset & ((1 << l1_bits) - 1));\n\n\n\n    /* compute the number of available sectors */\n\n\n\n    nb_available = (nb_available >> 9) + index_in_cluster;\n\n\n\n    if (nb_needed > nb_available) {\n\n        nb_needed = nb_available;\n\n    }\n\n\n\n    cluster_offset = 0;\n\n\n\n    /* seek the the l2 offset in the l1 table */\n\n\n\n    l1_index = offset >> l1_bits;\n\n    if (l1_index >= s->l1_size)\n\n        goto out;\n\n\n\n    l2_offset = s->l1_table[l1_index];\n\n\n\n    /* seek the l2 table of the given l2 offset */\n\n\n\n    if (!l2_offset)\n\n        goto out;\n\n\n\n    /* load the l2 table in memory */\n\n\n\n    l2_offset &= ~QCOW_OFLAG_COPIED;\n\n    l2_table = l2_load(bs, l2_offset);\n\n    if (l2_table == NULL)\n\n        return 0;\n\n\n\n    /* find the cluster offset for the given disk offset */\n\n\n\n    l2_index = (offset >> s->cluster_bits) & (s->l2_size - 1);\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n    nb_clusters = size_to_clusters(s, nb_needed << 9);\n\n\n\n    if (!cluster_offset) {\n\n        /* how many empty clusters ? */\n\n        c = count_contiguous_free_clusters(nb_clusters, &l2_table[l2_index]);\n\n    } else {\n\n        /* how many allocated clusters ? */\n\n        c = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, QCOW_OFLAG_COPIED);\n\n    }\n\n\n\n   nb_available = (c * s->cluster_sectors);\n\nout:\n\n    if (nb_available > nb_needed)\n\n        nb_available = nb_needed;\n\n\n\n    *num = nb_available - index_in_cluster;\n\n\n\n    return cluster_offset & ~QCOW_OFLAG_COPIED;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 880, "prediction": "0", "true_label": "1", "raw_text": "6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t     MOVNTQ \" %%mm0, (%1);\" /* store pixel 0-3 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpckhbw %%mm4, %%mm7;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpckhbw %%mm1, %%mm5;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm7;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t     \"por %%mm7, %%mm5;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\t\t     \"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\n\n\t\t     MOVNTQ \" %%mm5, 8 (%1);\" /* store pixel 4-7 */\n\n\n\n\t\t     \"add $16, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n\n\n    return srcSliceH;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 881, "prediction": "0", "true_label": "1", "raw_text": "Question: void memory_region_add_eventfd(MemoryRegion *mr,\n\n                               hwaddr addr,\n\n                               unsigned size,\n\n                               bool match_data,\n\n                               uint64_t data,\n\n                               EventNotifier *e)\n\n{\n\n    MemoryRegionIoeventfd mrfd = {\n\n        .addr.start = int128_make64(addr),\n\n        .addr.size = int128_make64(size),\n\n        .match_data = match_data,\n\n        .data = data,\n\n        .e = e,\n\n    };\n\n    unsigned i;\n\n\n\n    adjust_endianness(mr, &mrfd.data, size);\n\n    memory_region_transaction_begin();\n\n    for (i = 0; i < mr->ioeventfd_nb; ++i) {\n\n        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {\n\n            break;\n\n        }\n\n    }\n\n    ++mr->ioeventfd_nb;\n\n    mr->ioeventfds = g_realloc(mr->ioeventfds,\n\n                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);\n\n    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],\n\n            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));\n\n    mr->ioeventfds[i] = mrfd;\n\n    ioeventfd_update_pending |= mr->enabled;\n\n    memory_region_transaction_commit();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 882, "prediction": "0", "true_label": "0", "raw_text": "_fmts) {\n\n        const enum AVPixelFormat *p = codec->pix_fmts;\n\n        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;\n\n        enum AVPixelFormat best= AV_PIX_FMT_NONE;\n\n        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {\n\n                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,\n\n                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };\n\n            }\n\n        }\n\n        for (; *p != AV_PIX_FMT_NONE; p++) {\n\n            best= avcodec_find_best_pix_fmt_of_2(best, *p, target, has_alpha, NULL);\n\n            if (*p == target)\n\n                break;\n\n        }\n\n        if (*p == AV_PIX_FMT_NONE) {\n\n            if (target != AV_PIX_FMT_NONE)\n\n                av_log(NULL, AV_LOG_WARNING,\n\n                       \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\",\n\n                       av_get_pix_fmt_name(target),\n\n                       codec->name,\n\n                       av_get_pix_fmt_name(best));\n\n            return best;\n\n        }\n\n    }\n\n    return target;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 883, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gic_set_irq(void *opaque, int irq, int level)\n\n{\n\n    /* Meaning of the 'irq' parameter:\n\n     *  [0..N-1] : external interrupts\n\n     *  [N..N+31] : PPI (internal) interrupts for CPU 0\n\n     *  [N+32..N+63] : PPI (internal interrupts for CPU 1\n\n     *  ...\n\n     */\n\n    GICState *s = (GICState *)opaque;\n\n    int cm, target;\n\n    if (irq < (s->num_irq - GIC_INTERNAL)) {\n\n        /* The first external input line is internal interrupt 32.  */\n\n        cm = ALL_CPU_MASK;\n\n        irq += GIC_INTERNAL;\n\n        target = GIC_TARGET(irq);\n\n    } else {\n\n        int cpu;\n\n        irq -= (s->num_irq - GIC_INTERNAL);\n\n        cpu = irq / GIC_INTERNAL;\n\n        irq %= GIC_INTERNAL;\n\n        cm = 1 << cpu;\n\n        target = cm;\n\n    }\n\n\n\n    assert(irq >= GIC_NR_SGIS);\n\n\n\n    if (level == GIC_TEST_LEVEL(irq, cm)) {\n\n        return;\n\n    }\n\n\n\n    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n        gic_set_irq_11mpcore(s, irq, level, cm, target);\n\n    } else {\n\n        gic_set_irq_generic(s, irq, level, cm, target);\n\n    }\n\n\n\n\n    gic_update(s);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 884, "prediction": "0", "true_label": "1", "raw_text": " if (band->qdelta_present) {\n                    if (band->inherit_qdelta) {\n                        if (ref_mb) mb->q_delta = ref_mb->q_delta;\n                    } else if (mb->cbp || (!band->plane && !band->band_num &&\n                                           (ctx->frame_flags & 8))) {\n                        mb->q_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                               IVI_VLC_BITS, 1);\n                        mb->q_delta = IVI_TOSIGNED(mb->q_delta);\n                    }\n                }\n                if (!mb->type) {\n                    mb->mv_x = mb->mv_y = 0; /* there is no motion vector in intra-macroblocks */\n                } else {\n                    if (band->inherit_mv){\n                        /* motion vector inheritance */\n                        if (mv_scale) {\n                            mb->mv_x = ivi_scale_mv(ref_mb->mv_x, mv_scale);\n                            mb->mv_y = ivi_scale_mv(ref_mb->mv_y, mv_scale);\n                        } else {\n                            mb->mv_x = ref_mb->mv_x;\n                            mb->mv_y = ref_mb->mv_y;\n                        }\n                    } else {\n                        /* decode motion vector deltas */\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_y += IVI_TOSIGNED(mv_delta);\n                        mv_delta = get_vlc2(&ctx->gb, ctx->mb_vlc.tab->table,\n                                            IVI_VLC_BITS, 1);\n                        mv_x += IVI_TOSIGNED(mv_delta);\n                        mb->mv_x = mv_x;\n                        mb->mv_y = mv_y;\n                    }\n                }\n            }\n            mb++;\n            if (ref_mb)\n                ref_mb++;\n            mb_offset += band->mb_size;\n        }\n        offs += row_offset;\n    }\n    align_get_bits(&ctx->gb);\n    return 0;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 885, "prediction": "0", "true_label": "1", "raw_text": "Question: VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO.\n"}], [{"ID": 886, "prediction": "0", "true_label": "1", "raw_text": "Question: void coroutine_fn block_job_pause_point(BlockJob *job)\n\n{\n\n    assert(job && block_job_started(job));\n\n\n\n    if (!block_job_should_pause(job)) {\n\n        return;\n\n    }\n\n    if (block_job_is_cancelled(job)) {\n\n        return;\n\n    }\n\n\n\n    if (job->driver->pause) {\n\n        job->driver->pause(job);\n\n    }\n\n\n\n    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {\n\n        job->paused = true;\n\n        job->busy = false;\n\n        qemu_coroutine_yield(); /* wait for block_job_resume() */\n\n        job->busy = true;\n\n        job->paused = false;\n\n    }\n\n\n\n    if (job->driver->resume) {\n\n        job->driver->resume(job);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 887, "prediction": "1", "true_label": "1", "raw_text": "Question: int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 888, "prediction": "0", "true_label": "1", "raw_text": "Question: int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,\n\n                             int max_size)\n\n{\n\n    uint32_t mrk;\n\n    int i, tmp;\n\n    const uint16_t *ssrc = (const uint16_t *) src;\n\n    uint16_t *sdst = (uint16_t *) dst;\n\n    PutBitContext pb;\n\n\n\n    if ((unsigned) src_size > (unsigned) max_size)\n\n        src_size = max_size;\n\n\n\n    mrk = AV_RB32(src);\n\n    switch (mrk) {\n\n    case DCA_SYNCWORD_CORE_BE:\n\n        memcpy(dst, src, src_size);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_LE:\n\n        for (i = 0; i < (src_size + 1) >> 1; i++)\n\n            *sdst++ = av_bswap16(*ssrc++);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_14B_BE:\n\n    case DCA_SYNCWORD_CORE_14B_LE:\n\n        init_put_bits(&pb, dst, max_size);\n\n        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {\n\n            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;\n\n            put_bits(&pb, 14, tmp);\n\n        }\n\n        flush_put_bits(&pb);\n\n        return (put_bits_count(&pb) + 7) >> 3;\n\n    default:\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 889, "prediction": "0", "true_label": "1", "raw_text": "Question: static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 890, "prediction": "0", "true_label": "1", "raw_text": "Question: int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 891, "prediction": "0", "true_label": "0", "raw_text": " irq = (offset - 0x800) + GIC_BASE_IRQ;\n\n            if (irq >= s->num_irq) {\n\n                goto bad_reg;\n\n            }\n\n            if (irq >= 29 && irq <= 31) {\n\n                res = cm;\n\n            } else {\n\n                res = GIC_TARGET(irq);\n\n            }\n\n        }\n\n    } else if (offset < 0xf00) {\n\n        /* Interrupt Configuration.  */\n\n        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;\n\n        if (irq >= s->num_irq)\n\n            goto bad_reg;\n\n        res = 0;\n\n        for (i = 0; i < 4; i++) {\n\n            if (GIC_TEST_MODEL(irq + i))\n\n                res |= (1 << (i * 2));\n\n            if (GIC_TEST_EDGE_TRIGGER(irq + i))\n\n                res |= (2 << (i * 2));\n\n        }\n\n    } else if (offset < 0xf10) {\n\n        goto bad_reg;\n\n    } else if (offset < 0xf30) {\n\n        if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {\n\n            goto bad_reg;\n\n        }\n\n\n\n        if (offset < 0xf20) {\n\n            /* GICD_CPENDSGIRn */\n\n            irq = (offset - 0xf10);\n\n        } else {\n\n            irq = (offset - 0xf20);\n\n            /* GICD_SPENDSGIRn */\n\n        }\n\n\n\n        res = s->sgi_pending[irq][cpu];\n\n    } else if (offset < 0xfe0) {\n\n        goto bad_reg;\n\n    } else /* offset >= 0xfe0 */ {\n\n        if (offset & 3) {\n\n            res = 0;\n\n        } else {\n\n            res = gic_id[(offset - 0xfe0) >> 2];\n\n        }\n\n    }\n\n    return res;\n\nbad_reg:\n\n    qemu_log_mask(LOG_GUEST_ERROR,\n\n                  \"gic_dist_readb: Bad offset %x\\n\", (int)offset);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 892, "prediction": "0", "true_label": "0", "raw_text": "\n\n\n\n        /* Direct-store implies a 32-bit MMU.\n\n         * Check the Segment Register's bus unit ID (BUID).\n\n         */\n\n        sr = env->sr[eaddr >> 28];\n\n        if ((sr & 0x1FF00000) >> 20 == 0x07f) {\n\n            /* Memory-forced I/O controller interface access */\n\n            /* If T=1 and BUID=x'07F', the 601 performs a memory access\n\n             * to SR[28-31] LA[4-31], bypassing all protection mechanisms.\n\n             */\n\n            ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF);\n\n            ctx->prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n            return 0;\n\n        }\n\n\n\n        switch (type) {\n\n        case ACCESS_INT:\n\n            /* Integer load/store : only access allowed */\n\n            break;\n\n        case ACCESS_CODE:\n\n            /* No code fetch is allowed in direct-store areas */\n\n            return -4;\n\n        case ACCESS_FLOAT:\n\n            /* Floating point load/store */\n\n            return -4;\n\n        case ACCESS_RES:\n\n            /* lwarx, ldarx or srwcx. */\n\n            return -4;\n\n        case ACCESS_CACHE:\n\n            /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */\n\n            /* Should make the instruction do no-op.\n\n             * As it already do no-op, it's quite easy :-)\n\n             */\n\n            ctx->raddr = eaddr;\n\n            return 0;\n\n        case ACCESS_EXT:\n\n            /* eciwx or ecowx */\n\n            return -4;\n\n        default:\n\n            qemu_log_mask(CPU_LOG_MMU, \"ERROR: instruction should not need \"\n\n                          \"address translation\\n\");\n\n            return -4;\n\n        }\n\n        if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) {\n\n            ctx->raddr = eaddr;\n\n            ret = 2;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 893, "prediction": "0", "true_label": "0", "raw_text": "Question: static void slirp_socket_save(QEMUFile *f, struct socket *so)\n\n{\n\n    qemu_put_be32(f, so->so_urgc);\n\n    qemu_put_be16(f, so->so_ffamily);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_faddr.s_addr);\n\n        qemu_put_be16(f, so->so_fport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_faddr and so_fport\\n\");\n\n    }\n\n    qemu_put_be16(f, so->so_lfamily);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        qemu_put_be32(f, so->so_laddr.s_addr);\n\n        qemu_put_be16(f, so->so_lport);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to save so_laddr and so_lport\\n\");\n\n    }\n\n    qemu_put_byte(f, so->so_iptos);\n\n    qemu_put_byte(f, so->so_emu);\n\n    qemu_put_byte(f, so->so_type);\n\n    qemu_put_be32(f, so->so_state);\n\n    slirp_sbuf_save(f, &so->so_rcv);\n\n    slirp_sbuf_save(f, &so->so_snd);\n\n    slirp_tcp_save(f, so->so_tcpcb);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 894, "prediction": "0", "true_label": "1", "raw_text": "Question: void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 895, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 896, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstV, dstU, src1, width);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 897, "prediction": "0", "true_label": "0", "raw_text": "int_sts;\n\n    case CSR_INT_EN:\n\n        return s->int_en;\n\n    case CSR_BYTE_TEST:\n\n        return 0x87654321;\n\n    case CSR_FIFO_INT:\n\n        return s->fifo_int;\n\n    case CSR_RX_CFG:\n\n        return s->rx_cfg;\n\n    case CSR_TX_CFG:\n\n        return s->tx_cfg;\n\n    case CSR_HW_CFG:\n\n        return s->hw_cfg;\n\n    case CSR_RX_DP_CTRL:\n\n        return 0;\n\n    case CSR_RX_FIFO_INF:\n\n        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);\n\n    case CSR_TX_FIFO_INF:\n\n        return (s->tx_status_fifo_used << 16)\n\n               | (s->tx_fifo_size - s->txp->fifo_used);\n\n    case CSR_PMT_CTRL:\n\n        return s->pmt_ctrl;\n\n    case CSR_GPIO_CFG:\n\n        return s->gpio_cfg;\n\n    case CSR_GPT_CFG:\n\n        return s->gpt_cfg;\n\n    case CSR_GPT_CNT:\n\n        return ptimer_get_count(s->timer);\n\n    case CSR_WORD_SWAP:\n\n        return s->word_swap;\n\n    case CSR_FREE_RUN:\n\n        return (qemu_get_clock_ns(vm_clock) / 40) - s->free_timer_start;\n\n    case CSR_RX_DROP:\n\n        /* TODO: Implement dropped frames counter.  */\n\n        return 0;\n\n    case CSR_MAC_CSR_CMD:\n\n        return s->mac_cmd;\n\n    case CSR_MAC_CSR_DATA:\n\n        return s->mac_data;\n\n    case CSR_AFC_CFG:\n\n        return s->afc_cfg;\n\n    case CSR_E2P_CMD:\n\n        return s->e2p_cmd;\n\n    case CSR_E2P_DATA:\n\n        return s->e2p_data;\n\n    }\n\n    hw_error(\"lan9118_read: Bad reg 0x%x\\n\", (int)offset);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 898, "prediction": "0", "true_label": "0", "raw_text": "b, nbits - 1);\n\n                escape = ((1 << nbits) - 1) * cnt1;\n\n            } else {\n\n                skip_bits(b, nbits);\n\n                escape = value + ((1 << nbits) - 1) * cnt1 - 1;\n\n            }\n\n        } else {\n\n            escape = get_bits(b, 16);\n\n        }\n\n\n\n        value = -((escape + flag) & 1) | 1;\n\n        dst[j++] = value * ((escape + flag + 1) >> 1);\n\n        i++;\n\n        if (j == width) {\n\n            j = 0;\n\n            dst += stride;\n\n        }\n\n        state = 120 * (escape + flag) + state - (120 * state >> 8);\n\n        flag = 0;\n\n\n\n        if (state * 4 > 0xFF || i >= size)\n\n            continue;\n\n\n\n        nbits = ((state + 8) >> 5) + (state ? ff_clz(state) : 32) - 24;\n\n        escape = av_mod_uintp2(16383, nbits);\n\n        cnt1 = get_unary(b, 0, 8);\n\n        if (cnt1 > 7) {\n\n            rlen = get_bits(b, 16);\n\n        } else {\n\n            value = show_bits(b, nbits);\n\n            if (value > 1) {\n\n                skip_bits(b, nbits);\n\n                rlen = value + escape * cnt1 - 1;\n\n            } else {\n\n                skip_bits(b, nbits - 1);\n\n                rlen = escape * cnt1;\n\n            }\n\n        }\n\n\n\n        if (i + rlen > size)\n\n            return AVERROR_INVALIDDATA;\n\n        i += rlen;\n\n\n\n        for (k = 0; k < rlen; k++) {\n\n            dst[j++] = 0;\n\n            if (j == width) {\n\n                j = 0;\n\n                dst += stride;\n\n            }\n\n        }\n\n\n\n        state = 0;\n\n        flag = rlen < 0xFFFF ? 1 : 0;\n\n    }\n\n\n\n    align_get_bits(b);\n\n    return get_bits_count(b) >> 3;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 899, "prediction": "-1", "true_label": "0", "raw_text": "Question: static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(s, &request);\n\n    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {\n\n        reply.error = errno;\n\n    } else {\n\n        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);\n\n    }\n\n    nbd_coroutine_end(s, &request);\n\n    return -reply.error;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 900, "prediction": "0", "true_label": "0", "raw_text": "Question: static int request_frame(AVFilterLink *link)\n\n{\n\n    AVFilterContext *ctx = link->src;\n\n    IDETContext *idet = ctx->priv;\n\n\n\n    do {\n\n        int ret;\n\n\n\n        if (idet->eof)\n\n            return AVERROR_EOF;\n\n\n\n        ret = ff_request_frame(link->src->inputs[0]);\n\n\n\n        if (ret == AVERROR_EOF && idet->cur) {\n\n            AVFrame *next = av_frame_clone(idet->next);\n\n\n\n            if (!next)\n\n                return AVERROR(ENOMEM);\n\n\n\n            filter_frame(link->src->inputs[0], next);\n\n            idet->eof = 1;\n\n        } else if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (!idet->cur);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 901, "prediction": "0", "true_label": "1", "raw_text": "->channels - 1;\n        }\n        break;\n    case CODEC_ID_SOL_DPCM:\n        in = 0;\n        if (avctx->codec_tag != 3) {\n            if(*data_size/4 < buf_size)\n            while (in < buf_size) {\n                int n1, n2;\n                n1 = (buf[in] >> 4) & 0xF;\n                n2 = buf[in++] & 0xF;\n                s->sample[0] += s->sol_table[n1];\n                 if (s->sample[0] < 0) s->sample[0] = 0;\n                if (s->sample[0] > 255) s->sample[0] = 255;\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n                s->sample[s->channels - 1] += s->sol_table[n2];\n                if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0;\n                if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255;\n                output_samples[out++] = (s->sample[s->channels - 1] - 128) << 8;\n            }\n        } else {\n            while (in < buf_size) {\n                int n;\n                n = buf[in++];\n                if (n & 0x80) s->sample[channel_number] -= s->sol_table[n & 0x7F];\n                else s->sample[channel_number] += s->sol_table[n & 0x7F];\n                s->sample[channel_number] = av_clip_int16(s->sample[channel_number]);\n                output_samples[out++] = s->sample[channel_number];\n                /* toggle channel */\n                channel_number ^= s->channels - 1;\n            }\n        }\n        break;\n    }\n    *data_size = out * sizeof(short);\n    return buf_size;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 902, "prediction": "0", "true_label": "1", "raw_text": "(s, AV_LOG_WARNING, \"Unsupported stream type %08x\\n\", v);\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n        av_dlog(s, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == AV_CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        if (fps > 0) {\n\n            av_reduce(&st->avg_frame_rate.den, &st->avg_frame_rate.num,\n\n                      0x10000, fps, (1 << 30) - 1);\n\n#if FF_API_R_FRAME_RATE\n\n            st->r_frame_rate = st->avg_frame_rate;\n\n#endif\n\n        } else if (s->error_recognition & AV_EF_EXPLODE) {\n\n            av_log(s, AV_LOG_ERROR, \"Invalid framerate\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 903, "prediction": "0", "true_label": "1", "raw_text": "sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n    if (sd->card_status & ILLEGAL_COMMAND)\n\n        rsplen = 0;\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 904, "prediction": "0", "true_label": "0", "raw_text": " = av_clip_int16(predictor[ch]);\n\n            output_samples[out++] = predictor[ch];\n\n\n\n            /* toggle channel */\n\n            ch ^= stereo;\n\n        }\n\n        break;\n\n    case CODEC_ID_SOL_DPCM:\n\n        in = 0;\n\n        if (avctx->codec_tag != 3) {\n\n            if(*data_size/4 < buf_size)\n\n                return -1;\n\n            while (in < buf_size) {\n\n                int n1, n2;\n\n                n1 = (buf[in] >> 4) & 0xF;\n\n                n2 = buf[in++] & 0xF;\n\n                s->sample[0] += s->sol_table[n1];\n\n                if (s->sample[0] < 0)   s->sample[0] = 0;\n\n                if (s->sample[0] > 255) s->sample[0] = 255;\n\n                output_samples[out++] = (s->sample[0] - 128) << 8;\n\n                s->sample[stereo] += s->sol_table[n2];\n\n                if (s->sample[stereo] < 0)   s->sample[stereo] = 0;\n\n                if (s->sample[stereo] > 255) s->sample[stereo] = 255;\n\n                output_samples[out++] = (s->sample[stereo] - 128) << 8;\n\n            }\n\n        } else {\n\n            while (in < buf_size) {\n\n                int n;\n\n                n = buf[in++];\n\n                if (n & 0x80) s->sample[ch] -= s->sol_table[n & 0x7F];\n\n                else s->sample[ch] += s->sol_table[n & 0x7F];\n\n                s->sample[ch] = av_clip_int16(s->sample[ch]);\n\n                output_samples[out++] = s->sample[ch];\n\n                /* toggle channel */\n\n                ch ^= stereo;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    *data_size = out * sizeof(short);\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 905, "prediction": "0", "true_label": "1", "raw_text": "Question: static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 906, "prediction": "0", "true_label": "1", "raw_text": "_DRAW_CALLBACK)\n\n        if(vf->start_slice) vf->start_slice(vf,mpi);\n\n    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){\n\n            mp_msg(MSGT_DECVIDEO,MSGL_V,\"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\\n\",\n\n                  \"NULL\"/*vf->info->name*/,\n\n                  (mpi->type==MP_IMGTYPE_EXPORT)?\"Exporting\":\n\n                  ((mpi->flags&MP_IMGFLAG_DIRECT)?\"Direct Rendering\":\"Allocating\"),\n\n                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?\" (slices)\":\"\",\n\n                  mpi->width,mpi->height,mpi->bpp,\n\n                  (mpi->flags&MP_IMGFLAG_YUV)?\"YUV\":((mpi->flags&MP_IMGFLAG_SWAPPED)?\"BGR\":\"RGB\"),\n\n                  (mpi->flags&MP_IMGFLAG_PLANAR)?\"planar\":\"packed\",\n\n                  mpi->bpp*mpi->width*mpi->height/8);\n\n            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,\"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\\n\",\n\n                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],\n\n                mpi->stride[0], mpi->stride[1], mpi->stride[2],\n\n                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);\n\n            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;\n\n    }\n\n\n\n  mpi->qscale = NULL;\n\n  }\n\n  mpi->usage_count++;\n\n//    printf(\"\\rVF_MPI: %p %p %p %d %d %d    \\n\",\n\n//      mpi->planes[0],mpi->planes[1],mpi->planes[2],\n\n//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);\n\n  return mpi;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 907, "prediction": "1", "true_label": "1", "raw_text": "Question: static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)\n\n{\n\n    Mp4Descr *descr = d->active_descr;\n\n    int predefined;\n\n    if (!descr)\n\n        return -1;\n\n\n\n    predefined = avio_r8(&d->pb);\n\n    if (!predefined) {\n\n        int lengths;\n\n        int flags = avio_r8(&d->pb);\n\n        descr->sl.use_au_start       = !!(flags & 0x80);\n\n        descr->sl.use_au_end         = !!(flags & 0x40);\n\n        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);\n\n        descr->sl.use_padding        = !!(flags & 0x08);\n\n        descr->sl.use_timestamps     = !!(flags & 0x04);\n\n        descr->sl.use_idle           = !!(flags & 0x02);\n\n        descr->sl.timestamp_res      = avio_rb32(&d->pb);\n\n                                       avio_rb32(&d->pb);\n\n        descr->sl.timestamp_len      = avio_r8(&d->pb);\n\n\n\n\n\n\n        descr->sl.ocr_len            = avio_r8(&d->pb);\n\n        descr->sl.au_len             = avio_r8(&d->pb);\n\n        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);\n\n        lengths                      = avio_rb16(&d->pb);\n\n        descr->sl.degr_prior_len     = lengths >> 12;\n\n        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;\n\n        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;\n\n    } else {\n\n        avpriv_report_missing_feature(d->s, \"Predefined SLConfigDescriptor\");\n\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 908, "prediction": "0", "true_label": "1", "raw_text": "Question: target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 909, "prediction": "0", "true_label": "1", "raw_text": "\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) ||\n\n            !ff_guidcmp(g, ff_index_guid) ||\n\n            !ff_guidcmp(g, ff_sync_guid) ||\n\n            !ff_guidcmp(g, ff_stream1_guid) ||\n\n            !ff_guidcmp(g, (const ff_asf_guid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) {\n\n            //ignore known guids\n\n        } else\n\n            av_log(s, AV_LOG_WARNING, \"unsupported chunk:\"FF_PRI_GUID\"\\n\", FF_ARG_GUID(g));\n\n\n\n        avio_skip(pb, WTV_PAD8(len) - consumed);\n\n    }\n\n    return AVERROR_EOF;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 910, "prediction": "0", "true_label": "1", "raw_text": "Question: static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 911, "prediction": "0", "true_label": "1", "raw_text": ", \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 912, "prediction": "0", "true_label": "1", "raw_text": "(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 913, "prediction": "1", "true_label": "1", "raw_text": "\n\n\n\n        st->codec->extradata_size = s[i].codec_specific_len;\n\n        if (st->codec->extradata_size) {\n\n            st->codec->extradata = av_mallocz(st->codec->extradata_size);\n\n\n\n\n\n            memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size);\n\n\n\n\n        avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den);\n\n        st->start_time = 0;\n\n        st->duration = s[i].max_pts;\n\n\n\n        st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag);\n\n\n\n        switch(s[i].type) {\n\n        case NUT_AUDIO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag);\n\n\n\n            st->codec->channels = s[i].channel_count;\n\n            st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom;\n\n            break;\n\n        case NUT_VIDEO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag);\n\n\n\n            st->codec->width = s[i].width;\n\n            st->codec->height = s[i].height;\n\n            st->sample_aspect_ratio.num = s[i].sample_width;\n\n            st->sample_aspect_ratio.den = s[i].sample_height;\n\n            break;\n\n\n        if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n\n\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 914, "prediction": "0", "true_label": "1", "raw_text": "tlb.tlb6) {\n            printf(\"                       %d %s TLB in %d ways\\n\",\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n                   env->nb_ways);\n#endif\n        printf(\"    Exceptions model : %s\\n\"\n               \"    Bus model        : %s\\n\",\n               excp_model, bus_model);\n        printf(\"    MSR features     :\\n\");\n        if (env->flags & POWERPC_FLAG_SPE)\n            printf(\"                        signal processing engine enable\"\n                   \"\\n\");\n        else if (env->flags & POWERPC_FLAG_VRE)\n            printf(\"                        vector processor enable\\n\");\n        if (env->flags & POWERPC_FLAG_TGPR)\n            printf(\"                        temporary GPRs\\n\");\n        else if (env->flags & POWERPC_FLAG_CE)\n            printf(\"                        critical input enable\\n\");\n        if (env->flags & POWERPC_FLAG_SE)\n            printf(\"                        single-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DWE)\n            printf(\"                        debug wait enable\\n\");\n        else if (env->flags & POWERPC_FLAG_UBLE)\n            printf(\"                        user BTB lock enable\\n\");\n        if (env->flags & POWERPC_FLAG_BE)\n            printf(\"                        branch-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DE)\n            printf(\"                        debug interrupt enable\\n\");\n        if (env->flags & POWERPC_FLAG_PX)\n            printf(\"                        inclusive protection\\n\");\n        else if (env->flags & POWERPC_FLAG_PMM)\n            printf(\"                        performance monitor mark\\n\");\n        if (env->flags == POWERPC_FLAG_NONE)\n            printf(\"                        none\\n\");\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n        dump_ppc_insns(env);\n        dump_ppc_sprs(env);\n        fflush(stdout);\n#endif\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 915, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 916, "prediction": "0", "true_label": "1", "raw_text": "\n\n    if (strstart(filename, \"udp:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"udp\");\n\n        if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) {\n\n            host[0] = 0;\n\n            if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) {\n\n                goto fail;\n\n            }\n\n        }\n\n        qemu_opt_set(opts, \"host\", host);\n\n        qemu_opt_set(opts, \"port\", port);\n\n        if (p[pos] == '@') {\n\n            p += pos + 1;\n\n            if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) {\n\n                host[0] = 0;\n\n                if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) {\n\n                    goto fail;\n\n                }\n\n            }\n\n            qemu_opt_set(opts, \"localaddr\", host);\n\n            qemu_opt_set(opts, \"localport\", port);\n\n        }\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"unix:\", &p)) {\n\n        qemu_opt_set(opts, \"backend\", \"socket\");\n\n        if (qemu_opts_do_parse(opts, p, \"path\") != 0)\n\n            goto fail;\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/parport\", NULL) ||\n\n        strstart(filename, \"/dev/ppi\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"parport\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n    if (strstart(filename, \"/dev/\", NULL)) {\n\n        qemu_opt_set(opts, \"backend\", \"tty\");\n\n        qemu_opt_set(opts, \"path\", filename);\n\n        return opts;\n\n    }\n\n\n\nfail:\n\n    qemu_opts_del(opts);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 917, "prediction": "0", "true_label": "1", "raw_text": "\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_STFIWX |\n\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;\n\n    pcc->msr_mask = 0x800000000284FF36ULL;\n\n    pcc->mmu_model = POWERPC_MMU_2_06;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc_hash64_handle_mmu_fault;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER7;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 918, "prediction": "0", "true_label": "0", "raw_text": "\n\n    sequence_desc = bytestream_get_byte(&buf);\n\n\n\n    if (!(sequence_desc & 0x80)) {\n\n        /* Additional RLE data */\n\n        if (buf_size > object->rle_remaining_len)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        memcpy(object->rle + object->rle_data_len, buf, buf_size);\n\n        object->rle_data_len += buf_size;\n\n        object->rle_remaining_len -= buf_size;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (buf_size <= 7)\n\n        return AVERROR_INVALIDDATA;\n\n    buf_size -= 7;\n\n\n\n    /* Decode rle bitmap length, stored size includes width/height data */\n\n    rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n\n\n\n    if (buf_size > rle_bitmap_len) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Buffer dimension %d larger than the expected RLE data %d\\n\",\n\n               buf_size, rle_bitmap_len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Get bitmap dimensions from data */\n\n    width  = bytestream_get_be16(&buf);\n\n    height = bytestream_get_be16(&buf);\n\n\n\n    /* Make sure the bitmap is not too large */\n\n    if (avctx->width < width || avctx->height < height || !width || !height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitmap dimensions (%dx%d) invalid.\\n\", width, height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    object->w = width;\n\n    object->h = height;\n\n\n\n    av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n\n\n\n    if (!object->rle)\n\n        return AVERROR(ENOMEM);\n\n\n\n    memcpy(object->rle, buf, buf_size);\n\n    object->rle_data_len = buf_size;\n\n    object->rle_remaining_len = rle_bitmap_len - buf_size;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 919, "prediction": "0", "true_label": "1", "raw_text": " *rkey, int chunk,\n\n        uint8_t *chunk_start, uint8_t *chunk_end)\n\n{\n\n    if (block->mr) {\n\n        if (lkey) {\n\n            *lkey = block->mr->lkey;\n\n        }\n\n        if (rkey) {\n\n            *rkey = block->mr->rkey;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* allocate memory to store chunk MRs */\n\n    if (!block->pmr) {\n\n        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));\n\n    }\n\n\n\n    /*\n\n     * If 'rkey', then we're the destination, so grant access to the source.\n\n     *\n\n     * If 'lkey', then we're the source VM, so grant access only to ourselves.\n\n     */\n\n    if (!block->pmr[chunk]) {\n\n        uint64_t len = chunk_end - chunk_start;\n\n\n\n        trace_qemu_rdma_register_and_get_keys(len, chunk_start);\n\n\n\n        block->pmr[chunk] = ibv_reg_mr(rdma->pd,\n\n                chunk_start, len,\n\n                (rkey ? (IBV_ACCESS_LOCAL_WRITE |\n\n                        IBV_ACCESS_REMOTE_WRITE) : 0));\n\n\n\n        if (!block->pmr[chunk]) {\n\n            perror(\"Failed to register chunk!\");\n\n            fprintf(stderr, \"Chunk details: block: %d chunk index %d\"\n\n                            \" start %\" PRIuPTR \" end %\" PRIuPTR\n\n                            \" host %\" PRIuPTR\n\n                            \" local %\" PRIuPTR \" registrations: %d\\n\",\n\n                            block->index, chunk, (uintptr_t)chunk_start,\n\n                            (uintptr_t)chunk_end, host_addr,\n\n                            (uintptr_t)block->local_host_addr,\n\n                            rdma->total_registrations);\n\n            return -1;\n\n        }\n\n        rdma->total_registrations++;\n\n    }\n\n\n\n    if (lkey) {\n\n        *lkey = block->pmr[chunk]->lkey;\n\n    }\n\n    if (rkey) {\n\n        *rkey = block->pmr[chunk]->rkey;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 920, "prediction": "0", "true_label": "1", "raw_text": " + TARGET_PAGE_SIZE,\n\n                                                    VGA_DIRTY_FLAG);\n\n        }\n\n        /* explicit invalidation for the hardware cursor */\n\n        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;\n\n        if (update) {\n\n            if (y_start < 0)\n\n                y_start = y;\n\n            if (page0 < page_min)\n\n                page_min = page0;\n\n            if (page1 > page_max)\n\n                page_max = page1;\n\n            if (!(is_buffer_shared(s->ds->surface))) {\n\n                vga_draw_line(s, d, s->vram_ptr + addr, width);\n\n                if (s->cursor_draw_line)\n\n                    s->cursor_draw_line(s, d, y);\n\n            }\n\n        } else {\n\n            if (y_start >= 0) {\n\n                /* flush to display */\n\n                dpy_update(s->ds, 0, y_start,\n\n                           disp_width, y - y_start);\n\n                y_start = -1;\n\n            }\n\n        }\n\n        if (!multi_run) {\n\n            mask = (s->cr[0x17] & 3) ^ 3;\n\n            if ((y1 & mask) == mask)\n\n                addr1 += line_offset;\n\n            y1++;\n\n            multi_run = multi_scan;\n\n        } else {\n\n            multi_run--;\n\n        }\n\n        /* line compare acts on the displayed lines */\n\n        if (y == s->line_compare)\n\n            addr1 = 0;\n\n        d += linesize;\n\n    }\n\n    if (y_start >= 0) {\n\n        /* flush to display */\n\n        dpy_update(s->ds, 0, y_start,\n\n                   disp_width, y - y_start);\n\n    }\n\n    /* reset modified pages */\n\n    if (page_max != -1) {\n\n        cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE,\n\n                                        VGA_DIRTY_FLAG);\n\n    }\n\n    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 921, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 922, "prediction": "1", "true_label": "1", "raw_text": "Question: static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 923, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n\n                                  cavs_vector *col_mv)\n\n{\n\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n\n    int den = h->direct_den[col_mv->ref];\n\n    int m = FF_SIGNBIT(col_mv->x);\n\n\n\n    pmv_fw->dist = h->dist[1];\n\n    pmv_bw->dist = h->dist[0];\n\n    pmv_fw->ref = 1;\n\n    pmv_bw->ref = 0;\n\n    /* scale the co-located motion vector according to its temporal span */\n\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n    m = FF_SIGNBIT(col_mv->y);\n\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 924, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void h264_deblock_q1(register vector unsigned char p0,\n\n                                                   register vector unsigned char p1,\n\n                                                   register vector unsigned char p2,\n\n                                                   register vector unsigned char q0,\n\n                                                   register vector unsigned char tc0) {\n\n\n\n    register vector unsigned char average = vec_avg(p0, q0);\n\n    register vector unsigned char temp;\n\n    register vector unsigned char uncliped;\n\n    register vector unsigned char ones;\n\n    register vector unsigned char max;\n\n    register vector unsigned char min;\n\n\n\n    temp = vec_xor(average, p2);\n\n    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */\n\n    ones = vec_splat_u8(1);\n\n    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */\n\n    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */\n\n    max = vec_adds(p1, tc0);\n\n    min = vec_subs(p1, tc0);\n\n    p1 = vec_max(min, uncliped);\n\n    p1 = vec_min(max, p1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 925, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,\n\n                                target_ulong pc2, TCGv r_cond)\n\n{\n\n    int l1;\n\n\n\n    l1 = gen_new_label();\n\n\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);\n\n\n\n    gen_goto_tb(dc, 0, pc2, pc1);\n\n\n\n    gen_set_label(l1);\n\n    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 926, "prediction": "0", "true_label": "0", "raw_text": " QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 927, "prediction": "0", "true_label": "0", "raw_text": "_nested(tlvs, ROCKER_TLV_TX_FRAG_ATTR_MAX, tlv_frag);\n\n\n\n        if (!tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR] ||\n\n            !tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]) {\n\n            err = -ROCKER_EINVAL;\n\n            goto err_bad_attr;\n\n        }\n\n\n\n        frag_addr = rocker_tlv_get_le64(tlvs[ROCKER_TLV_TX_FRAG_ATTR_ADDR]);\n\n        frag_len = rocker_tlv_get_le16(tlvs[ROCKER_TLV_TX_FRAG_ATTR_LEN]);\n\n\n\n        iov[iovcnt].iov_len = frag_len;\n\n        iov[iovcnt].iov_base = g_malloc(frag_len);\n\n        if (!iov[iovcnt].iov_base) {\n\n            err = -ROCKER_ENOMEM;\n\n            goto err_no_mem;\n\n        }\n\n\n\n        if (pci_dma_read(dev, frag_addr, iov[iovcnt].iov_base,\n\n                     iov[iovcnt].iov_len)) {\n\n            err = -ROCKER_ENXIO;\n\n            goto err_bad_io;\n\n        }\n\n\n\n        if (++iovcnt > ROCKER_TX_FRAGS_MAX) {\n\n            goto err_too_many_frags;\n\n        }\n\n    }\n\n\n\n    if (iovcnt) {\n\n        /* XXX perform Tx offloads */\n\n        /* XXX   silence compiler for now */\n\n        tx_l3_csum_off += tx_tso_mss = tx_tso_hdr_len = 0;\n\n    }\n\n\n\n    err = fp_port_eg(r->fp_port[port], iov, iovcnt);\n\n\n\nerr_too_many_frags:\n\nerr_bad_io:\n\nerr_no_mem:\n\nerr_bad_attr:\n\n    for (i = 0; i < ROCKER_TX_FRAGS_MAX; i++) {\n\n        if (iov[i].iov_base) {\n\n            g_free(iov[i].iov_base);\n\n        }\n\n    }\n\n\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 928, "prediction": "0", "true_label": "0", "raw_text": "Question: AVFilterFormats *avfilter_all_colorspaces(void)\n\n{\n\n    return avfilter_make_format_list(35,\n\n                PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,\n\n                PIX_FMT_YUV411P,  PIX_FMT_YUV410P,\n\n                PIX_FMT_YUYV422,  PIX_FMT_UYVY422,  PIX_FMT_UYYVYY411,\n\n                PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,\n\n                PIX_FMT_YUV440P,  PIX_FMT_YUVJ440P,\n\n                PIX_FMT_RGB32,    PIX_FMT_BGR32,\n\n                PIX_FMT_RGB32_1,  PIX_FMT_BGR32_1,\n\n                PIX_FMT_RGB24,    PIX_FMT_BGR24,\n\n                PIX_FMT_RGB565,   PIX_FMT_BGR565,\n\n                PIX_FMT_RGB555,   PIX_FMT_BGR555,\n\n                PIX_FMT_RGB8,     PIX_FMT_BGR8,\n\n                PIX_FMT_RGB4_BYTE,PIX_FMT_BGR4_BYTE,\n\n                PIX_FMT_GRAY16BE, PIX_FMT_GRAY16LE,\n\n                PIX_FMT_GRAY8,    PIX_FMT_PAL8,\n\n                PIX_FMT_MONOWHITE,PIX_FMT_MONOBLACK\n\n                PIX_FMT_NV12,     PIX_FMT_NV21);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 929, "prediction": "0", "true_label": "0", "raw_text": "Question: MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,\n\n              CharDriverState *chrA, CharDriverState *chrB,\n\n              int clock, int it_shift)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SerialState *d;\n\n\n\n    dev = qdev_create(NULL, \"escc\");\n\n    qdev_prop_set_uint32(dev, \"disabled\", 0);\n\n    qdev_prop_set_uint32(dev, \"frequency\", clock);\n\n    qdev_prop_set_uint32(dev, \"it_shift\", it_shift);\n\n    qdev_prop_set_chr(dev, \"chrB\", chrB);\n\n    qdev_prop_set_chr(dev, \"chrA\", chrA);\n\n    qdev_prop_set_uint32(dev, \"chnBtype\", ser);\n\n    qdev_prop_set_uint32(dev, \"chnAtype\", ser);\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irqB);\n\n    sysbus_connect_irq(s, 1, irqA);\n\n    if (base) {\n\n        sysbus_mmio_map(s, 0, base);\n\n    }\n\n\n\n    d = FROM_SYSBUS(SerialState, s);\n\n    return &d->mmio;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 930, "prediction": "0", "true_label": "1", "raw_text": "Question: static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 931, "prediction": "1", "true_label": "1", "raw_text": "Question: void ff_bink_idct_c(DCTELEM *block)\n\n{\n\n    int i;\n\n    DCTELEM temp[64];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        bink_idct_col(&temp[i], &block[i]);\n\n    for (i = 0; i < 8; i++) {\n\n        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 932, "prediction": "0", "true_label": "1", "raw_text": "Question: PCIBus *pci_pmac_init(qemu_irq *pic)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    UNINState *d;\n\n\n\n    /* Use values found on a real PowerMac */\n\n    /* Uninorth main bus */\n\n    dev = qdev_create(NULL, \"Uni-north main\");\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    d = FROM_SYSBUS(UNINState, s);\n\n    d->host_state.bus = pci_register_bus(&d->busdev.qdev, \"pci\",\n\n                                         pci_unin_set_irq, pci_unin_map_irq,\n\n                                         pic, 11 << 3, 4);\n\n\n\n    pci_create_simple(d->host_state.bus, 11 << 3, \"Uni-north main\");\n\n\n\n    sysbus_mmio_map(s, 0, 0xf2800000);\n\n    sysbus_mmio_map(s, 1, 0xf2c00000);\n\n\n\n    /* DEC 21154 bridge */\n\n#if 0\n\n    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */\n\n    pci_create_simple(d->host_state.bus, 12 << 3, \"DEC 21154\");\n\n#endif\n\n\n\n    /* Uninorth AGP bus */\n\n    pci_create_simple(d->host_state.bus, 13 << 3, \"Uni-north AGP\");\n\n\n\n    /* Uninorth internal bus */\n\n#if 0\n\n    /* XXX: not needed for now */\n\n    pci_create_simple(d->host_state.bus, 14 << 3, \"Uni-north internal\");\n\n#endif\n\n\n\n    return d->host_state.bus;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 933, "prediction": "0", "true_label": "0", "raw_text": "Parser, lexer);\n\n    QDict *dict;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    qdict_put(dict, \"token\", qstring_from_str(input->str));\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 934, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,\n\n                                              target_ulong eaddr, uint32_t pid)\n\n{\n\n#if !defined(FLUSH_ALL_TLBS)\n\n    CPUState *cs = CPU(ppc_env_get_cpu(env));\n\n    ppcemb_tlb_t *tlb;\n\n    hwaddr raddr;\n\n    target_ulong page, end;\n\n    int i;\n\n\n\n    for (i = 0; i < env->nb_tlb; i++) {\n\n        tlb = &env->tlb.tlbe[i];\n\n        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {\n\n            end = tlb->EPN + tlb->size;\n\n            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {\n\n                tlb_flush_page(cs, page);\n\n            }\n\n            tlb->prot &= ~PAGE_VALID;\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    ppc4xx_tlb_invalidate_all(env);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 935, "prediction": "0", "true_label": "0", "raw_text": ".  When done, set this bit writable:\n\n     *\n\n     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,\n\n     *                            PCI_COMMAND_VGA_PALETTE);\n\n     */\n\n\n\n    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);\n\n    dev->config[PCI_HEADER_TYPE] =\n\n        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n    pci_set_word(dev->config + PCI_SEC_STATUS,\n\n                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);\n\n\n\n    /*\n\n     * If we don't specify the name, the bus will be addressed as <id>.0, where\n\n     * id is the device id.\n\n     * Since PCI Bridge devices have a single bus each, we don't need the index:\n\n     * let users address the bus using the device name.\n\n     */\n\n    if (!br->bus_name && dev->qdev.id && *dev->qdev.id) {\n\n\t    br->bus_name = dev->qdev.id;\n\n    }\n\n\n\n    qbus_create_inplace(sec_bus, sizeof(br->sec_bus), typename, DEVICE(dev),\n\n                        br->bus_name);\n\n    sec_bus->parent_dev = dev;\n\n    sec_bus->map_irq = br->map_irq ? br->map_irq : pci_swizzle_map_irq_fn;\n\n    sec_bus->address_space_mem = &br->address_space_mem;\n\n    memory_region_init(&br->address_space_mem, OBJECT(br), \"pci_bridge_pci\", UINT64_MAX);\n\n    sec_bus->address_space_io = &br->address_space_io;\n\n    memory_region_init(&br->address_space_io, OBJECT(br), \"pci_bridge_io\", 65536);\n\n    br->windows = pci_bridge_region_init(br);\n\n    QLIST_INIT(&sec_bus->child);\n\n    QLIST_INSERT_HEAD(&parent->child, sec_bus, sibling);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 936, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,\n\n                              int width, int y)\n\n{\n\n    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,\n\n                           0, y, 0, 0, 0, 0, width, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 937, "prediction": "0", "true_label": "0", "raw_text": "cmsg)\n\n        return -TARGET_EFAULT;\n\n\n\n    while (cmsg && target_cmsg) {\n\n        void *data = CMSG_DATA(cmsg);\n\n        void *target_data = TARGET_CMSG_DATA(target_cmsg);\n\n\n\n        int len = tswapal(target_cmsg->cmsg_len)\n\n                  - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr));\n\n\n\n        space += CMSG_SPACE(len);\n\n        if (space > msgh->msg_controllen) {\n\n            space -= CMSG_SPACE(len);\n\n            gemu_log(\"Host cmsg overflow\\n\");\n\n            break;\n\n        }\n\n\n\n        if (tswap32(target_cmsg->cmsg_level) == TARGET_SOL_SOCKET) {\n\n            cmsg->cmsg_level = SOL_SOCKET;\n\n        } else {\n\n            cmsg->cmsg_level = tswap32(target_cmsg->cmsg_level);\n\n        }\n\n        cmsg->cmsg_type = tswap32(target_cmsg->cmsg_type);\n\n        cmsg->cmsg_len = CMSG_LEN(len);\n\n\n\n        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) {\n\n            gemu_log(\"Unsupported ancillary data: %d/%d\\n\", cmsg->cmsg_level, cmsg->cmsg_type);\n\n            memcpy(data, target_data, len);\n\n        } else {\n\n            int *fd = (int *)data;\n\n            int *target_fd = (int *)target_data;\n\n            int i, numfds = len / sizeof(int);\n\n\n\n            for (i = 0; i < numfds; i++)\n\n                fd[i] = tswap32(target_fd[i]);\n\n        }\n\n\n\n        cmsg = CMSG_NXTHDR(msgh, cmsg);\n\n        target_cmsg = TARGET_CMSG_NXTHDR(target_msgh, target_cmsg);\n\n    }\n\n    unlock_user(target_cmsg, target_cmsg_addr, 0);\n\n the_end:\n\n    msgh->msg_controllen = space;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 938, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool ga_open_pidfile(const char *pidfile)\n\n{\n\n    int pidfd;\n\n    char pidstr[32];\n\n\n\n    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);\n\n    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {\n\n        g_critical(\"Cannot lock pid file, %s\", strerror(errno));\n\n        if (pidfd != -1) {\n\n            close(pidfd);\n\n        }\n\n        return false;\n\n    }\n\n\n\n    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {\n\n        g_critical(\"Failed to truncate pid file\");\n\n        goto fail;\n\n    }\n\n    sprintf(pidstr, \"%d\", getpid());\n\n    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {\n\n        g_critical(\"Failed to write pid file\");\n\n        goto fail;\n\n    }\n\n\n\n    return true;\n\n\n\nfail:\n\n    unlink(pidfile);\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 939, "prediction": "0", "true_label": "1", "raw_text": "\n\n    } else {\n\n        /* compute the blocked signals during the handler execution */\n\n        target_to_host_sigset(&set, &sa->sa_mask);\n\n        /* SA_NODEFER indicates that the current signal should not be\n\n           blocked during the handler */\n\n        if (!(sa->sa_flags & TARGET_SA_NODEFER))\n\n            sigaddset(&set, target_to_host_signal(sig));\n\n\n\n        /* block signals in the handler using Linux */\n\n        do_sigprocmask(SIG_BLOCK, &set, &old_set);\n\n        /* save the previous blocked signal state to restore it at the\n\n           end of the signal execution (see do_sigreturn) */\n\n        host_to_target_sigset_internal(&target_old_set, &old_set);\n\n\n\n        /* if the CPU is in VM86 mode, we restore the 32 bit values */\n\n#if defined(TARGET_I386) && !defined(TARGET_X86_64)\n\n        {\n\n            CPUX86State *env = cpu_env;\n\n            if (env->eflags & VM_MASK)\n\n                save_v86_state(env);\n\n        }\n\n#endif\n\n        /* prepare the stack frame of the virtual CPU */\n\n#if defined(TARGET_ABI_MIPSN32) || defined(TARGET_ABI_MIPSN64) \\\n\n    || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX)\n\n        /* These targets do not have traditional signals.  */\n\n        setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n#else\n\n        if (sa->sa_flags & TARGET_SA_SIGINFO)\n\n            setup_rt_frame(sig, sa, &q->info, &target_old_set, cpu_env);\n\n        else\n\n            setup_frame(sig, sa, &target_old_set, cpu_env);\n\n#endif\n\n        if (sa->sa_flags & TARGET_SA_RESETHAND) {\n\n            sa->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n    }\n\n    if (q != &k->info)\n\n        free_sigqueue(cpu_env, q);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 940, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pcie_pci_bridge_write_config(PCIDevice *d,\n\n        uint32_t address, uint32_t val, int len)\n\n{\n\n    pci_bridge_write_config(d, address, val, len);\n\n    msi_write_config(d, address, val, len);\n\n    shpc_cap_write_config(d, address, val, len);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 941, "prediction": "0", "true_label": "0", "raw_text": "Question: static ram_addr_t find_ram_offset(ram_addr_t size)\n\n{\n\n    RAMBlock *block, *next_block;\n\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n\n\n    assert(size != 0); /* it would hand out same offset multiple times */\n\n\n\n    if (QTAILQ_EMPTY(&ram_list.blocks))\n\n        return 0;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        ram_addr_t end, next = RAM_ADDR_MAX;\n\n\n\n        end = block->offset + block->length;\n\n\n\n        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {\n\n            if (next_block->offset >= end) {\n\n                next = MIN(next, next_block->offset);\n\n            }\n\n        }\n\n        if (next - end >= size && next - end < mingap) {\n\n            offset = end;\n\n            mingap = next - end;\n\n        }\n\n    }\n\n\n\n    if (offset == RAM_ADDR_MAX) {\n\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n\n                (uint64_t)size);\n\n        abort();\n\n    }\n\n\n\n    return offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 942, "prediction": "1", "true_label": "0", "raw_text": "Question: CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 943, "prediction": "-1", "true_label": "0", "raw_text": "xff;\n\n            outbuf[3] = (nb_sectors >> 32) & 0xff;\n\n            outbuf[4] = (nb_sectors >> 24) & 0xff;\n\n            outbuf[5] = (nb_sectors >> 16) & 0xff;\n\n            outbuf[6] = (nb_sectors >> 8) & 0xff;\n\n            outbuf[7] = nb_sectors & 0xff;\n\n            outbuf[8] = 0;\n\n            outbuf[9] = 0;\n\n            outbuf[10] = s->cluster_size * 2;\n\n            outbuf[11] = 0;\n\n            outbuf[12] = 0;\n\n            outbuf[13] = get_physical_block_exp(&s->qdev.conf);\n\n\n\n            /* set TPE bit if the format supports discard */\n\n            if (s->qdev.conf.discard_granularity) {\n\n                outbuf[14] = 0x80;\n\n            }\n\n\n\n            /* Protection, exponent and lowest lba field left blank. */\n\n            buflen = req->cmd.xfer;\n\n            break;\n\n        }\n\n        DPRINTF(\"Unsupported Service Action In\\n\");\n\n        goto illegal_request;\n\n    case REPORT_LUNS:\n\n        if (req->cmd.xfer < 16)\n\n            goto illegal_request;\n\n        memset(outbuf, 0, 16);\n\n        outbuf[3] = 8;\n\n        buflen = 16;\n\n        break;\n\n    case VERIFY_10:\n\n        break;\n\n    default:\n\n        scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));\n\n        return -1;\n\n    }\n\n    return buflen;\n\n\n\nnot_ready:\n\n    if (!bdrv_is_inserted(s->bs)) {\n\n        scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));\n\n    } else {\n\n        scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));\n\n    }\n\n    return -1;\n\n\n\nillegal_request:\n\n    scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 944, "prediction": "0", "true_label": "0", "raw_text": "Question: static void flush_queued_work(CPUState *cpu)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (cpu->queued_work_first == NULL) {\n\n        return;\n\n    }\n\n\n\n    while ((wi = cpu->queued_work_first)) {\n\n        cpu->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n        if (wi->free) {\n\n            g_free(wi);\n\n        }\n\n    }\n\n    cpu->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 945, "prediction": "0", "true_label": "0", "raw_text": "Question: static int validate_guest_space(unsigned long guest_base,\n\n                                unsigned long guest_size)\n\n{\n\n    unsigned long real_start, test_page_addr;\n\n\n\n    /* We need to check that we can force a fault on access to the\n\n     * commpage at 0xffff0fxx\n\n     */\n\n    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);\n\n\n\n    /* If the commpage lies within the already allocated guest space,\n\n     * then there is no way we can allocate it.\n\n     */\n\n    if (test_page_addr >= guest_base\n\n        && test_page_addr <= (guest_base + guest_size)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Note it needs to be writeable to let us initialise it */\n\n    real_start = (unsigned long)\n\n                 mmap((void *)test_page_addr, qemu_host_page_size,\n\n                     PROT_READ | PROT_WRITE,\n\n                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n    /* If we can't map it then try another address */\n\n    if (real_start == -1ul) {\n\n        return 0;\n\n    }\n\n\n\n    if (real_start != test_page_addr) {\n\n        /* OS didn't put the page where we asked - unmap and reject */\n\n        munmap((void *)real_start, qemu_host_page_size);\n\n        return 0;\n\n    }\n\n\n\n    /* Leave the page mapped\n\n     * Populate it (mmap should have left it all 0'd)\n\n     */\n\n\n\n    /* Kernel helper versions */\n\n    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));\n\n\n\n    /* Now it's populated make it RO */\n\n    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {\n\n        perror(\"Protecting guest commpage\");\n\n        exit(-1);\n\n    }\n\n\n\n    return 1; /* All good */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 946, "prediction": "1", "true_label": "1", "raw_text": "Question: long do_sigreturn(CPUCRISState *env)\n\n{\n\n\tstruct target_signal_frame *frame;\n\n\tabi_ulong frame_addr;\n\n\ttarget_sigset_t target_set;\n\n\tsigset_t set;\n\n\tint i;\n\n\n\n\tframe_addr = env->regs[R_SP];\n\n\t/* Make sure the guest isn't playing games.  */\n\n\tif (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))\n\n\t\tgoto badframe;\n\n\n\n\t/* Restore blocked signals */\n\n\tif (__get_user(target_set.sig[0], &frame->sc.oldmask))\n\n\t\tgoto badframe;\n\n\tfor(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n\t\tif (__get_user(target_set.sig[i], &frame->extramask[i - 1]))\n\n\t\t\tgoto badframe;\n\n\t}\n\n\ttarget_to_host_sigset_internal(&set, &target_set);\n\n        do_sigprocmask(SIG_SETMASK, &set, NULL);\n\n\n\n\trestore_sigcontext(&frame->sc, env);\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\treturn env->regs[10];\n\n  badframe:\n\n\tunlock_user_struct(frame, frame_addr, 0);\n\n\tforce_sig(TARGET_SIGSEGV);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 947, "prediction": "0", "true_label": "1", "raw_text": "Question: static void usbredir_interrupt_packet(void *priv, uint32_t id,\n\n    struct usb_redir_interrupt_packet_header *interrupt_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = interrupt_packet->endpoint;\n\n\n\n    DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\",\n\n            interrupt_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n\n        ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n\n            DPRINTF(\"received int packet while not started ep %02X\\n\", ep);\n\n            free(data);\n\n            return;\n\n        }\n\n\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);\n\n    } else {\n\n        int len = interrupt_packet->length;\n\n\n\n        AsyncURB *aurb = async_find(dev, id);\n\n        if (!aurb) {\n\n            return;\n\n        }\n\n\n\n        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {\n\n            ERROR(\"return int packet mismatch, please report this!\\n\");\n\n            len = USB_RET_NAK;\n\n        }\n\n\n\n        if (aurb->packet) {\n\n            aurb->packet->len = usbredir_handle_status(dev,\n\n                                               interrupt_packet->status, len);\n\n            usb_packet_complete(&dev->dev, aurb->packet);\n\n        }\n\n        async_free(dev, aurb);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 948, "prediction": "0", "true_label": "0", "raw_text": "_mv[0][i][0]    , s->f_code);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                        s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                        s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                    }\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[1][i]);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][0] -  s->last_mv[1][i][0]    , s->b_code);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code);\n\n                        s->last_mv[1][i][0]=   s->mv[1][i][0];\n\n                        s->last_mv[1][i][1]= 2*s->mv[1][i][1];\n\n                    }\n\n                    s->b_count++;\n\n                }\n\n            }\n\n            s->mv_bits += get_bits_diff(s);\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n        }\n\n        for(i=0;i<6;i++) {\n\n            if (cbp & (1 << (5 - i))) {\n\n                mpeg1_encode_block(s, block[i], i);\n\n            }\n\n        }\n\n        s->mb_skip_run = 0;\n\n        if(s->mb_intra)\n\n            s->i_tex_bits+= get_bits_diff(s);\n\n        else\n\n            s->p_tex_bits+= get_bits_diff(s);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 949, "prediction": "0", "true_label": "0", "raw_text": " ssid, schid, devno, sch);\n\n                    found = true;\n\n                    break;\n\n                }\n\n            }\n\n            if (found) {\n\n                break;\n\n            }\n\n        }\n\n        if (!found) {\n\n            error_setg(errp, \"Virtual channel subsystem is full!\");\n\n            goto out_err;\n\n        }\n\n        trace_virtio_ccw_new_device(cssid, ssid, schid, devno,\n\n                                    \"auto-configured\");\n\n    }\n\n\n\n    /* Build initial schib. */\n\n    css_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);\n\n\n\n    sch->ccw_cb = virtio_ccw_cb;\n\n\n\n    /* Build senseid data. */\n\n    memset(&sch->id, 0, sizeof(SenseId));\n\n    sch->id.reserved = 0xff;\n\n    sch->id.cu_type = VIRTIO_CCW_CU_TYPE;\n\n\n\n    if (k->realize) {\n\n        k->realize(dev, &err);\n\n    }\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        css_subch_assign(cssid, ssid, schid, devno, NULL);\n\n        goto out_err;\n\n    }\n\n\n\n    /* device_id is only set after vdev has been realized */\n\n    vdev = virtio_ccw_get_vdev(sch);\n\n    sch->id.cu_model = vdev->device_id;\n\n\n\n    /* Only the first 32 feature bits are used. */\n\n    dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                         dev->host_features[0]);\n\n\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);\n\n    virtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);\n\n\n\n    css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\n\n                          parent->hotplugged, 1);\n\n    return;\n\n\n\nout_err:\n\n    dev->sch = NULL;\n\n    g_free(sch);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 950, "prediction": "0", "true_label": "0", "raw_text": "Question: void op_cp1_registers(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 951, "prediction": "0", "true_label": "1", "raw_text": "MOVNTQ\" %%mm1,  8(%2, %%\"REG_a\")\\n\\t\" // B RGB RGB R\n\n\t\t\"movq 16(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // GR BGR BGR\n\n\t\t\"movq 18(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // BGR BGR BG\n\n\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\tMOVNTQ\" %%mm1, 16(%2, %%\"REG_a\")\\n\\t\"\n\n\t\t\"add $24, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t: \"+a\" (mmx_size)\n\n\t\t: \"r\" (src-mmx_size), \"r\"(dst-mmx_size)\n\n\t);\n\n\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n\n\n\tif(mmx_size==23) return; //finihsed, was multiple of 8\n\n\n\n\tsrc+= src_size;\n\n\tdst+= src_size;\n\n\tsrc_size= 23-mmx_size;\n\n\tsrc-= src_size;\n\n\tdst-= src_size;\n\n#endif\n\n\tfor(i=0; i<src_size; i+=3)\n\n\t{\n\n\t\tregister uint8_t x;\n\n\t\tx          = src[i + 2];\n\n\t\tdst[i + 1] = src[i + 1];\n\n\t\tdst[i + 2] = src[i + 0];\n\n\t\tdst[i + 0] = x;\n\n\t}\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 952, "prediction": "-1", "true_label": "1", "raw_text": "Question: static int vda_h264_end_frame(AVCodecContext *avctx)\n{\n    H264Context *h                      = avctx->priv_data;\n    struct vda_context *vda_ctx         = avctx->hwaccel_context;\n    AVFrame *frame                      = &h->cur_pic_ptr->f;\n    struct vda_buffer *context;\n    AVBufferRef *buffer;\n    int status;\n    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)\n    status = vda_sync_decode(vda_ctx);\n    frame->data[3] = (void*)vda_ctx->cv_buffer;\n    if (status)\n        av_log(avctx, AV_LOG_ERROR, \"Failed to decode frame (%d)\\n\", status);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 953, "prediction": "0", "true_label": "1", "raw_text": "4_decode_extradata(h, buf, buf_size);\n\n    }\n\nnot_extra:\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n\n    if (buf_index < 0)\n\n        return -1;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        av_assert0(buf_index <= buf_size);\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n\n            return buf_size;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        field_end(h, 0);\n\n\n\n        /* Wait for second field. */\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n\n            ret = output_frame(h, pict, &h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n            if (CONFIG_MPEGVIDEO) {\n\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n\n                                    &h->low_delay,\n\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n\n            }\n\n        }\n\n    }\n\n\n\n    assert(pict->data[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 954, "prediction": "1", "true_label": "1", "raw_text": "Question: GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)\n\n{\n\n    GIOStatus status = G_IO_STATUS_NORMAL;\n\n    size_t count;\n\n\n\n    while (size) {\n\n        status = ga_channel_write(c, buf, size, &count);\n\n        if (status == G_IO_STATUS_NORMAL) {\n\n            size -= count;\n\n            buf += count;\n\n        } else if (status != G_IO_STATUS_AGAIN) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    return status;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 955, "prediction": "0", "true_label": "1", "raw_text": "Question: static int channelmap_query_formats(AVFilterContext *ctx)\n\n{\n\n    ChannelMapContext *s = ctx->priv;\n\n\n\n    ff_set_common_formats(ctx, ff_planar_sample_fmts());\n\n    ff_set_common_samplerates(ctx, ff_all_samplerates());\n\n    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);\n\n    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 956, "prediction": "0", "true_label": "0", "raw_text": "Question: static void flush_queued_work(CPUState *env)\n\n{\n\n    struct qemu_work_item *wi;\n\n\n\n    if (!env->queued_work_first)\n\n        return;\n\n\n\n    while ((wi = env->queued_work_first)) {\n\n        env->queued_work_first = wi->next;\n\n        wi->func(wi->data);\n\n        wi->done = true;\n\n    }\n\n    env->queued_work_last = NULL;\n\n    qemu_cond_broadcast(&qemu_work_cond);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 957, "prediction": "-1", "true_label": "0", "raw_text": "\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    if (s->cache_flags) {\n\n        hdr.flags |= s->cache_flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, s);\n\n    socket_set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = qemu_co_send(s->fd, &hdr, sizeof(hdr));\n\n    if (ret < 0) {\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -errno;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = qemu_co_sendv(s->fd, iov, niov, aio_req->iov_offset, wlen);\n\n        if (ret < 0) {\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -errno;\n\n        }\n\n    }\n\n\n\n    socket_set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, s);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 958, "prediction": "0", "true_label": "1", "raw_text": " st->codec.height;\n\n\n\n    switch(st->codec.pix_fmt) {\n\n    case PIX_FMT_YUV420P:\n\n        size1 = (width * height * 3) / 2;\n\n        if (size != size1)\n\n            return -EIO;\n\n        \n\n        picture.data[0] = buf;\n\n        picture.data[1] = picture.data[0] + width * height;\n\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n\n        picture.linesize[0] = width;\n\n        picture.linesize[1] = width >> 1; \n\n        picture.linesize[2] = width >> 1;\n\n        break;\n\n    case PIX_FMT_RGB24:\n\n        size1 = (width * height * 3);\n\n        if (size != size1)\n\n            return -EIO;\n\n        picture.data[0] = buf;\n\n        picture.linesize[0] = width * 3;\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (get_frame_filename(filename, sizeof(filename), \n\n                           img->path, img->img_number) < 0)\n\n        return -EIO;\n\n\n\n    if (!img->is_pipe) {\n\n        pb = &pb1;\n\n        if (url_fopen(pb, filename, URL_WRONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        pb = &s->pb;\n\n    }\n\n    switch(img->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_save(&picture, width, height, pb, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_save(&picture, width, height, pb, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_save(&picture, width, height, filename);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_save(&picture, width, height, pb);\n\n        break;\n\n    }\n\n    if (!img->is_pipe) {\n\n        url_fclose(pb);\n\n    }\n\n\n\n    img->img_number++;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 959, "prediction": "0", "true_label": "1", "raw_text": "Question: int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 960, "prediction": "0", "true_label": "1", "raw_text": "uy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);\n\n\tvector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n\tvec_st(v_yuy2_2, (i << 1) + 32, dst);\n\n\tvec_st(v_yuy2_3, (i << 1) + 48, dst);\n\n      }\n\n      if (i < width) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_y1 = vec_ld(i, ysrc);\n\n\tvector unsigned char v_u = vec_ld(j, usrc);\n\n\tvector unsigned char v_v = vec_ld(j, vsrc);\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n      }\n\n      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\n\n\t{\n\n\t  usrc += chromStride;\n\n\t  vsrc += chromStride;\n\n\t}\n\n      ysrc += lumStride;\n\n      dst += dstStride;\n\n    }\n\n\n\n  return srcSliceH;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 961, "prediction": "0", "true_label": "0", "raw_text": "code = TARGET_FPE_INTOVF;\n\n                    break;\n\n                case TARGET_GEN_INTDIV:\n\n                    info.si_code = TARGET_FPE_INTDIV;\n\n                    break;\n\n                case TARGET_GEN_FLTOVF:\n\n                    info.si_code = TARGET_FPE_FLTOVF;\n\n                    break;\n\n                case TARGET_GEN_FLTUND:\n\n                    info.si_code = TARGET_FPE_FLTUND;\n\n                    break;\n\n                case TARGET_GEN_FLTINV:\n\n                    info.si_code = TARGET_FPE_FLTINV;\n\n                    break;\n\n                case TARGET_GEN_FLTINE:\n\n                    info.si_code = TARGET_FPE_FLTRES;\n\n                    break;\n\n                case TARGET_GEN_ROPRAND:\n\n                    info.si_code = 0;\n\n                    break;\n\n                default:\n\n                    info.si_signo = TARGET_SIGTRAP;\n\n                    info.si_code = 0;\n\n                    break;\n\n                }\n\n                info.si_errno = 0;\n\n                info._sifields._sigfault._addr = env->pc;\n\n                queue_signal(env, info.si_signo, &info);\n\n                break;\n\n            default:\n\n                goto do_sigill;\n\n            }\n\n            break;\n\n        case EXCP_DEBUG:\n\n            info.si_signo = gdb_handlesig(cs, TARGET_SIGTRAP);\n\n            if (info.si_signo) {\n\n                env->lock_addr = -1;\n\n                info.si_errno = 0;\n\n                info.si_code = TARGET_TRAP_BRKPT;\n\n                queue_signal(env, info.si_signo, &info);\n\n            }\n\n            break;\n\n        case EXCP_STL_C:\n\n        case EXCP_STQ_C:\n\n            do_store_exclusive(env, env->error_code, trapnr - EXCP_STL_C);\n\n            break;\n\n        case EXCP_INTERRUPT:\n\n            /* Just indicate that signals should be handled asap.  */\n\n            break;\n\n        default:\n\n            printf (\"Unhandled trap: 0x%x\\n\", trapnr);\n\n            cpu_dump_state(cs, stderr, fprintf, 0);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n        process_pending_signals (env);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 962, "prediction": "0", "true_label": "0", "raw_text": "Question: static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)\n\n{\n\n    int i;\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = s390_get_phb();\n\n\n\n    if (!target) {\n\n        return NULL;\n\n    }\n\n\n\n    for (i = 0; i < PCI_SLOT_MAX; i++) {\n\n        pbdev = s->pbdev[i];\n\n        if (!pbdev) {\n\n            continue;\n\n        }\n\n\n\n        if (!strcmp(pbdev->target, target)) {\n\n            return pbdev;\n\n        }\n\n    }\n\n\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 963, "prediction": "0", "true_label": "0", "raw_text": "Question: static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)\n\n{\n\n    uint16_t cmd;\n\n    int i, sz, offset, code;\n\n    unsigned char *dst_end = dst + dst_size;\n\n    const unsigned char *src_end = src + src_size;\n\n\n\n    while (src < src_end && dst < dst_end) {\n\n        code = *src++;\n\n        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {\n\n            if (code & (1 << i)) {\n\n                *dst++ = *src++;\n\n            } else {\n\n                cmd = AV_RL16(src); src += 2;\n\n                offset = cmd >> 4;\n\n                sz = (cmd & 0xF) + 2;\n\n                /* don't use memcpy/memmove here as the decoding routine (ab)uses */\n\n                /* buffer overlappings to repeat bytes in the destination */\n\n                sz = FFMIN(sz, dst_end - dst);\n\n                while (sz--) {\n\n                    *dst = *(dst - offset - 1);\n\n                    ++dst;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 964, "prediction": "1", "true_label": "1", "raw_text": "Question: ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,\n\n                  void *priv_data, RTPDynamicProtocolHandler *handler)\n\n{\n\n    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->ic = ic;\n\n    s->streams = &ic->streams[first_stream_of_set_idx];\n\n    do {\n\n        s->n_streams++;\n\n    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&\n\n             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);\n\n    s->prev_set_id    = -1;\n\n    s->prev_stream_id = -1;\n\n    s->prev_timestamp = -1;\n\n    s->parse_packet = handler->parse_packet;\n\n    s->dynamic_protocol_context = priv_data;\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 965, "prediction": "0", "true_label": "1", "raw_text": " qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = g_malloc0(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buffer(&hd_qiov, cluster_data);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_link_l2(bs, &l2meta);\n\n\n\n        run_dependent_requests(s, &l2meta);\n\n\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 966, "prediction": "0", "true_label": "1", "raw_text": "\n\n        if (r < 0) {\n\n            goto fail_vq;\n\n        }\n\n    }\n\n    hdev->features = features;\n\n\n\n    hdev->memory_listener = (MemoryListener) {\n\n        .begin = vhost_begin,\n\n        .commit = vhost_commit,\n\n        .region_add = vhost_region_add,\n\n        .region_del = vhost_region_del,\n\n        .region_nop = vhost_region_nop,\n\n        .log_start = vhost_log_start,\n\n        .log_stop = vhost_log_stop,\n\n        .log_sync = vhost_log_sync,\n\n        .log_global_start = vhost_log_global_start,\n\n        .log_global_stop = vhost_log_global_stop,\n\n        .eventfd_add = vhost_eventfd_add,\n\n        .eventfd_del = vhost_eventfd_del,\n\n        .priority = 10\n\n    };\n\n    hdev->migration_blocker = NULL;\n\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n\n        error_setg(&hdev->migration_blocker,\n\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n\n        migrate_add_blocker(hdev->migration_blocker);\n\n    }\n\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n\n    hdev->n_mem_sections = 0;\n\n    hdev->mem_sections = NULL;\n\n    hdev->log = NULL;\n\n    hdev->log_size = 0;\n\n    hdev->log_enabled = false;\n\n    hdev->started = false;\n\n    hdev->memory_changed = false;\n\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n\n    hdev->force = force;\n\n    return 0;\n\nfail_vq:\n\n    while (--i >= 0) {\n\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n\n    }\n\nfail:\n\n    r = -errno;\n\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 967, "prediction": "1", "true_label": "1", "raw_text": "Question: int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        int r, g, b;\n\n\n\n        switch (pix_fmt) {\n\n        case AV_PIX_FMT_RGB8:\n\n            r = (i>>5    )*36;\n\n            g = ((i>>2)&7)*36;\n\n            b = (i&3     )*85;\n\n            break;\n\n        case AV_PIX_FMT_BGR8:\n\n            b = (i>>6    )*85;\n\n            g = ((i>>3)&7)*36;\n\n            r = (i&7     )*36;\n\n            break;\n\n        case AV_PIX_FMT_RGB4_BYTE:\n\n            r = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            b = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_BGR4_BYTE:\n\n            b = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            r = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_GRAY8:\n\n            r = b = g = i;\n\n            break;\n\n        default:\n\n            return AVERROR(EINVAL);\n\n        }\n\n        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 968, "prediction": "0", "true_label": "0", "raw_text": "dev_list, Error **errp)\n\n{\n\n    TransactionActionList *dev_entry = dev_list;\n\n    BlkTransactionState *state, *next;\n\n    Error *local_err = NULL;\n\n\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;\n\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n\n\n    /* drain all i/o before any operations */\n\n    bdrv_drain_all();\n\n\n\n    /* We don't do anything in this loop that commits us to the operations */\n\n    while (NULL != dev_entry) {\n\n        TransactionAction *dev_info = NULL;\n\n        const BdrvActionOps *ops;\n\n\n\n        dev_info = dev_entry->value;\n\n        dev_entry = dev_entry->next;\n\n\n\n        assert(dev_info->kind < ARRAY_SIZE(actions));\n\n\n\n        ops = &actions[dev_info->kind];\n\n        assert(ops->instance_size > 0);\n\n\n\n        state = g_malloc0(ops->instance_size);\n\n        state->ops = ops;\n\n        state->action = dev_info;\n\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n\n\n        state->ops->prepare(state, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto delete_and_fail;\n\n        }\n\n    }\n\n\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->commit) {\n\n            state->ops->commit(state);\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    goto exit;\n\n\n\ndelete_and_fail:\n\n    /* failure, and it is all-or-none; roll back all operations */\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->abort) {\n\n            state->ops->abort(state);\n\n        }\n\n    }\n\nexit:\n\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n\n        if (state->ops->clean) {\n\n            state->ops->clean(state);\n\n        }\n\n        g_free(state);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 969, "prediction": "0", "true_label": "0", "raw_text": "Question: static int intel_hda_init(PCIDevice *pci)\n\n{\n\n    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);\n\n    uint8_t *conf = d->pci.config;\n\n\n\n    d->name = d->pci.qdev.info->name;\n\n\n\n    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(conf, 0x2668);\n\n    pci_config_set_revision(conf, 1);\n\n    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);\n\n    pci_config_set_interrupt_pin(conf, 1);\n\n\n\n    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */\n\n    conf[0x40] = 0x01;\n\n\n\n    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,\n\n                                          intel_hda_mmio_write, d,\n\n                                          DEVICE_NATIVE_ENDIAN);\n\n    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);\n\n    if (d->msi) {\n\n        msi_init(&d->pci, 0x50, 1, true, false);\n\n    }\n\n\n\n    hda_codec_bus_init(&d->pci.qdev, &d->codecs,\n\n                       intel_hda_response, intel_hda_xfer);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 970, "prediction": "0", "true_label": "0", "raw_text": "Question: static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (qemu_paio_write(&acb->aiocb) < 0) {\n\n        raw_aio_remove(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 971, "prediction": "0", "true_label": "0", "raw_text": "rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n    \n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n    \n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 972, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)\n\n{\n\n    uint32_t ret;\n\n\n\n    switch (ot) {\n\n    case MO_8:\n\n        ret = cpu_ldub_code(env, s->pc);\n\n        s->pc++;\n\n        break;\n\n    case MO_16:\n\n        ret = cpu_lduw_code(env, s->pc);\n\n        s->pc += 2;\n\n        break;\n\n    case MO_32:\n\n#ifdef TARGET_X86_64\n\n    case MO_64:\n\n#endif\n\n        ret = cpu_ldl_code(env, s->pc);\n\n        s->pc += 4;\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 973, "prediction": "0", "true_label": "0", "raw_text": "Question: static void bdrv_throttle_write_timer_cb(void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    qemu_co_enter_next(&bs->throttled_reqs[1]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 974, "prediction": "0", "true_label": "0", "raw_text": " TARGET_FMT_lx \" %d %d %d \" TARGET_FMT_lx \"\\n\",\n\n                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,\n\n                (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n        LOG_MMU(\"found PTE at addr %08\" HWADDR_PRIx \" prot=%01x ret=%d\\n\",\n\n                ctx->raddr, ctx->prot, ret);\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n            if (env->external_htab) {\n\n                stl_p(env->external_htab + pteg_off + (good * 8) + 4,\n\n                      pte1);\n\n            } else {\n\n                stl_phys_notdirty(env->htab_base + pteg_off +\n\n                                  (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* We have a TLB that saves 4K pages, so let's\n\n     * split a huge page to 4k chunks */\n\n    if (target_page_bits != TARGET_PAGE_BITS) {\n\n        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))\n\n                      & TARGET_PAGE_MASK;\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 975, "prediction": "0", "true_label": "0", "raw_text": "Question: static int kvm_put_xcrs(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XCRS\n\n    struct kvm_xcrs xcrs;\n\n\n\n    if (!kvm_has_xcrs())\n\n        return 0;\n\n\n\n    xcrs.nr_xcrs = 1;\n\n    xcrs.flags = 0;\n\n    xcrs.xcrs[0].xcr = 0;\n\n    xcrs.xcrs[0].value = env->xcr0;\n\n    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);\n\n#else\n\n    return 0;\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 976, "prediction": "0", "true_label": "0", "raw_text": "Question: static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,\n\n                                     TCGv cmp, int32_t disp)\n\n{\n\n    uint64_t dest = ctx->pc + (disp << 2);\n\n    int lab_true = gen_new_label();\n\n\n\n    if (use_goto_tb(ctx, dest)) {\n\n        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);\n\n\n\n        tcg_gen_goto_tb(0);\n\n        tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb);\n\n\n\n        gen_set_label(lab_true);\n\n        tcg_gen_goto_tb(1);\n\n        tcg_gen_movi_i64(cpu_pc, dest);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);\n\n\n\n        return EXIT_GOTO_TB;\n\n    } else {\n\n        TCGv_i64 z = tcg_const_i64(0);\n\n        TCGv_i64 d = tcg_const_i64(dest);\n\n        TCGv_i64 p = tcg_const_i64(ctx->pc);\n\n\n\n        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);\n\n\n\n        tcg_temp_free_i64(z);\n\n        tcg_temp_free_i64(d);\n\n        tcg_temp_free_i64(p);\n\n        return EXIT_PC_UPDATED;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 977, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)\n\n{\n\n    uint32_t val = pci_default_read_config(d, address, len);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n    return val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 978, "prediction": "0", "true_label": "1", "raw_text": "Question: static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,\n\n                                 uint32_t token, uint32_t nargs,\n\n                                 target_ulong args,\n\n                                 uint32_t nret, target_ulong rets)\n\n{\n\n    struct tm tm;\n\n\n\n    if (nret != 8) {\n\n        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n        return;\n\n    }\n\n\n\n    qemu_get_timedate(&tm, spapr->rtc_offset);\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    rtas_st(rets, 1, tm.tm_year + 1900);\n\n    rtas_st(rets, 2, tm.tm_mon + 1);\n\n    rtas_st(rets, 3, tm.tm_mday);\n\n    rtas_st(rets, 4, tm.tm_hour);\n\n    rtas_st(rets, 5, tm.tm_min);\n\n    rtas_st(rets, 6, tm.tm_sec);\n\n    rtas_st(rets, 7, 0); /* we don't do nanoseconds */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 979, "prediction": "1", "true_label": "0", "raw_text": "Question: void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n\n{\n\n    BlockJob *job = find_block_job(device);\n\n\n\n    if (!job) {\n\n        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);\n\n        return;\n\n    }\n\n\n\n    block_job_set_speed(job, speed, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 980, "prediction": "0", "true_label": "0", "raw_text": "Question: static int create_stream(AVFormatContext *s)\n\n{\n\n    XCBGrabContext *c = s->priv_data;\n\n    AVStream *st      = avformat_new_stream(s, NULL);\n\n    xcb_get_geometry_cookie_t gc;\n\n    xcb_get_geometry_reply_t *geo;\n\n    int ret;\n\n\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ret = av_parse_video_size(&c->width, &c->height, c->video_size);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000000);\n\n\n\n    gc  = xcb_get_geometry(c->conn, c->screen->root);\n\n    geo = xcb_get_geometry_reply(c->conn, gc, NULL);\n\n\n\n    c->width      = FFMIN(geo->width, c->width);\n\n    c->height     = FFMIN(geo->height, c->height);\n\n    c->time_base  = (AVRational){ st->avg_frame_rate.den,\n\n                                  st->avg_frame_rate.num };\n\n    c->time_frame = av_gettime();\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width      = c->width;\n\n    st->codec->height     = c->height;\n\n    st->codec->time_base  = c->time_base;\n\n\n\n    ret = pixfmt_from_pixmap_format(s, geo->depth, &st->codec->pix_fmt);\n\n\n\n    free(geo);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 981, "prediction": "0", "true_label": "0", "raw_text": "LOG_ERROR, \"Codebook lookup type not supported. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n\n\n// Initialize VLC table\n\n        if (ff_vorbis_len2vlc(tmp_vlc_bits, tmp_vlc_codes, entries)) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Invalid code lengths while generating vlcs. \\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        codebook_setup->maxdepth = 0;\n\n        for (t = 0; t < entries; ++t)\n\n            if (tmp_vlc_bits[t] >= codebook_setup->maxdepth)\n\n                codebook_setup->maxdepth = tmp_vlc_bits[t];\n\n\n\n        if (codebook_setup->maxdepth > 3 * V_NB_BITS)\n\n            codebook_setup->nb_bits = V_NB_BITS2;\n\n        else\n\n            codebook_setup->nb_bits = V_NB_BITS;\n\n\n\n        codebook_setup->maxdepth = (codebook_setup->maxdepth+codebook_setup->nb_bits - 1) / codebook_setup->nb_bits;\n\n\n\n        if ((ret = init_vlc(&codebook_setup->vlc, codebook_setup->nb_bits,\n\n                            entries, tmp_vlc_bits, sizeof(*tmp_vlc_bits),\n\n                            sizeof(*tmp_vlc_bits), tmp_vlc_codes,\n\n                            sizeof(*tmp_vlc_codes), sizeof(*tmp_vlc_codes),\n\n                            INIT_VLC_LE))) {\n\n            av_log(vc->avctx, AV_LOG_ERROR, \" Error generating vlc tables. \\n\");\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return 0;\n\n\n\n// Error:\n\nerror:\n\n    av_free(tmp_vlc_bits);\n\n    av_free(tmp_vlc_codes);\n\n    av_free(codebook_multiplicands);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 982, "prediction": "0", "true_label": "1", "raw_text": "\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 983, "prediction": "0", "true_label": "0", "raw_text": "Question: static abi_long do_socket(int domain, int type, int protocol)\n\n{\n\n    int target_type = type;\n\n    int ret;\n\n\n\n    ret = target_to_host_sock_type(&type);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (domain == PF_NETLINK)\n\n        return -TARGET_EAFNOSUPPORT;\n\n\n\n    if (domain == AF_PACKET ||\n\n        (domain == AF_INET && type == SOCK_PACKET)) {\n\n        protocol = tswap16(protocol);\n\n    }\n\n\n\n    ret = get_errno(socket(domain, type, protocol));\n\n    if (ret >= 0) {\n\n        ret = sock_flags_fixup(ret, target_type);\n\n        if (type == SOCK_PACKET) {\n\n            /* Manage an obsolete case :\n\n             * if socket type is SOCK_PACKET, bind by name\n\n             */\n\n            fd_trans_register(ret, &target_packet_trans);\n\n        }\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 984, "prediction": "0", "true_label": "0", "raw_text": "Question: int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 985, "prediction": "0", "true_label": "0", "raw_text": "Question: void process_incoming_migration(QEMUFile *f)\n\n{\n\n    if (qemu_loadvm_state(f) < 0) {\n\n        fprintf(stderr, \"load of migration failed\\n\");\n\n        exit(0);\n\n    }\n\n    qemu_announce_self();\n\n    DPRINTF(\"successfully loaded vm state\\n\");\n\n\n\n    incoming_expected = false;\n\n\n\n    if (autostart) {\n\n        vm_start();\n\n    } else {\n\n        runstate_set(RSTATE_PRE_LAUNCH);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 986, "prediction": "0", "true_label": "0", "raw_text": ")\n\n         return RV34_MB_SKIP;\n\n\n\n    if(r->avail_cache[6-1])\n\n        blocks[r->mb_type[mb_pos - 1]]++;\n\n    if(r->avail_cache[6-4]){\n\n        blocks[r->mb_type[mb_pos - s->mb_stride]]++;\n\n        if(r->avail_cache[6-2])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;\n\n        if(r->avail_cache[6-5])\n\n            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;\n\n    }\n\n\n\n    for(i = 0; i < RV34_MB_TYPES; i++){\n\n        if(blocks[i] > count){\n\n            count = blocks[i];\n\n            prev_type = i;\n\n        }\n\n    }\n\n    if(s->pict_type == AV_PICTURE_TYPE_P){\n\n        prev_type = block_num_to_ptype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, ptype_vlc[prev_type].table, PTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for P-frame\\n\");\n\n    }else{\n\n        prev_type = block_num_to_btype_vlc_num[prev_type];\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        if(q < PBTYPE_ESCAPE)\n\n            return q;\n\n        q = get_vlc2(gb, btype_vlc[prev_type].table, BTYPE_VLC_BITS, 1);\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Dquant for B-frame\\n\");\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 987, "prediction": "0", "true_label": "0", "raw_text": " V5*/\n\n                MOVNTQ\"          %%mm0, 32(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 40(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm5, %%mm6   \\n\\t\"\n\n                \"movq    24(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U6 Y V6 Y U6 Y V6*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U7 Y V7 Y U7 Y V7*/\n\n                MOVNTQ\"          %%mm0, 48(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 56(%4, %0, 8)   \\n\\t\"\n\n\n\n                : \"+r\" (x)\n\n                : \"r\"(yp), \"r\" (up), \"r\"(vp), \"r\"(d)\n\n                :\"memory\");\n\n        }\n\n#endif\n\n        for (; x<w; x++) {\n\n            const long x2 = x<<2;\n\n            d[8*x+0] = yp[x2];\n\n            d[8*x+1] = up[x];\n\n            d[8*x+2] = yp[x2+1];\n\n            d[8*x+3] = vp[x];\n\n            d[8*x+4] = yp[x2+2];\n\n            d[8*x+5] = up[x];\n\n            d[8*x+6] = yp[x2+3];\n\n            d[8*x+7] = vp[x];\n\n        }\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 988, "prediction": "0", "true_label": "0", "raw_text": " << 16) + ((*src8++) << 8);\n\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n\n                }\n\n                src = src8;\n\n            }\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n\n            return -1;\n\n        }\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    case CODEC_ID_PCM_LXF:\n\n        dst_int32_t = data;\n\n        n /= avctx->channels;\n\n        //unpack and de-planerize\n\n        for (i = 0; i < n; i++) {\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract low 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n\n            }\n\n\n\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n\n                //extract high 20 bits and expand to 32 bits\n\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n\n            }\n\n        }\n\n        src += n * avctx->channels * 5;\n\n        samples = (uint8_t *) dst_int32_t;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 989, "prediction": "0", "true_label": "0", "raw_text": "ream_get_be16(&buf);\n\n    int h = bytestream_get_be16(&buf);\n\n\n\n    ctx->presentation.pts = pts;\n\n\n\n    av_dlog(avctx, \"Video Dimensions %dx%d\\n\",\n\n            w, h);\n\n    ret = ff_set_dimensions(avctx, w, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Skip 1 bytes of unknown, frame rate? */\n\n    buf++;\n\n\n\n    ctx->presentation.id_number = bytestream_get_be16(&buf);\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     state\n\n     *     palette_update_flag (0x80),\n\n     *     palette_id_to_use,\n\n     */\n\n    buf += 3;\n\n\n\n    ctx->presentation.object_number = bytestream_get_byte(&buf);\n\n    ctx->presentation.composition_flag = 0;\n\n    if (!ctx->presentation.object_number)\n\n        return 0;\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     object_id_ref (2 bytes),\n\n     *     window_id_ref,\n\n     */\n\n    buf += 3;\n\n    ctx->presentation.composition_flag = bytestream_get_byte(&buf);\n\n\n\n    x = bytestream_get_be16(&buf);\n\n    y = bytestream_get_be16(&buf);\n\n\n\n    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/\n\n\n\n    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);\n\n\n\n    if (x > avctx->width || y > avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",\n\n               x, y, avctx->width, avctx->height);\n\n        x = 0; y = 0;\n\n    }\n\n\n\n    /* Fill in dimensions */\n\n    ctx->presentation.x = x;\n\n    ctx->presentation.y = y;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 990, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_coroutine_delete(Coroutine *co_)\n\n{\n\n    CoroutineThreadState *s = coroutine_get_thread_state();\n\n    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);\n\n\n\n    if (s->pool_size < POOL_MAX_SIZE) {\n\n        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);\n\n        co->base.caller = NULL;\n\n        s->pool_size++;\n\n        return;\n\n    }\n\n\n\n    g_free(co->stack);\n\n    g_free(co);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 991, "prediction": "0", "true_label": "0", "raw_text": "Question: int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 992, "prediction": "0", "true_label": "0", "raw_text": "Question: static int tpm_passthrough_unix_tx_bufs(int tpm_fd,\n\n                                        const uint8_t *in, uint32_t in_len,\n\n                                        uint8_t *out, uint32_t out_len)\n\n{\n\n    int ret;\n\n\n\n    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);\n\n    if (ret != in_len) {\n\n        error_report(\"tpm_passthrough: error while transmitting data \"\n\n                     \"to TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n        goto err_exit;\n\n    }\n\n\n\n    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);\n\n    if (ret < 0) {\n\n        error_report(\"tpm_passthrough: error while reading data from \"\n\n                     \"TPM: %s (%i)\\n\",\n\n                     strerror(errno), errno);\n\n    } else if (ret < sizeof(struct tpm_resp_hdr) ||\n\n               tpm_passthrough_get_size_from_buffer(out) != ret) {\n\n        ret = -1;\n\n        error_report(\"tpm_passthrough: received invalid response \"\n\n                     \"packet from TPM\\n\");\n\n    }\n\n\n\nerr_exit:\n\n    if (ret < 0) {\n\n        tpm_write_fatal_error_response(out, out_len);\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 993, "prediction": "0", "true_label": "0", "raw_text": "Question: int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,\n\n                        uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    target_phys_addr_t phys_addr;\n\n    target_ulong page;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        phys_addr = cpu_get_phys_page_debug(env, page);\n\n        /* if no physical page mapped, return an error */\n\n        if (phys_addr == -1)\n\n            return -1;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n\n        if (is_write)\n\n            cpu_physical_memory_write_rom(phys_addr, buf, l);\n\n        else\n\n            cpu_physical_memory_rw(phys_addr, buf, l, is_write);\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 994, "prediction": "0", "true_label": "0", "raw_text": "Question: struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,\n\n                target_phys_addr_t base,\n\n                qemu_irq *irq, qemu_irq dma, omap_clk clk)\n\n{\n\n    struct omap_uwire_s *s = (struct omap_uwire_s *)\n\n            g_malloc0(sizeof(struct omap_uwire_s));\n\n\n\n    s->txirq = irq[0];\n\n    s->rxirq = irq[1];\n\n    s->txdrq = dma;\n\n    omap_uwire_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, \"omap-uwire\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 995, "prediction": "0", "true_label": "0", "raw_text": " static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n\n{\n\n    VncPalette *palette = &color_count_palette;\n\n    uint32_t bg = 0, fg = 0;\n\n    int colors;\n\n    int ret = 0;\n\n#ifdef CONFIG_VNC_JPEG\n\n    bool force_jpeg = false;\n\n    bool allow_jpeg = true;\n\n#endif\n\n\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);\n\n\n\n    vnc_tight_start(vs);\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vnc_tight_stop(vs);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {\n\n        double freq = vnc_update_freq(vs, x, y, w, h);\n\n\n\n        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {\n\n            allow_jpeg = false;\n\n        }\n\n        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {\n\n            force_jpeg = true;\n\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n\n        }\n\n    }\n\n#endif\n\n\n\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);\n\n\n\n#ifdef CONFIG_VNC_JPEG\n\n    if (allow_jpeg && vs->tight.quality != (uint8_t)-1) {\n\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors, palette,\n\n                                 force_jpeg);\n\n    } else {\n\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n    }\n\n#else\n\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors, palette);\n\n#endif\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 996, "prediction": "0", "true_label": "0", "raw_text": " gen_bdirect(ctx, ra, disp21);\n\n        break;\n\n    case 0x35: /* FBNE */\n\n        ret = gen_fbcond(ctx, TCG_COND_NE, ra, disp21);\n\n        break;\n\n    case 0x36: /* FBGE */\n\n        ret = gen_fbcond(ctx, TCG_COND_GE, ra, disp21);\n\n        break;\n\n    case 0x37: /* FBGT */\n\n        ret = gen_fbcond(ctx, TCG_COND_GT, ra, disp21);\n\n        break;\n\n    case 0x38:\n\n        /* BLBC */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 1);\n\n        break;\n\n    case 0x39:\n\n        /* BEQ */\n\n        ret = gen_bcond(ctx, TCG_COND_EQ, ra, disp21, 0);\n\n        break;\n\n    case 0x3A:\n\n        /* BLT */\n\n        ret = gen_bcond(ctx, TCG_COND_LT, ra, disp21, 0);\n\n        break;\n\n    case 0x3B:\n\n        /* BLE */\n\n        ret = gen_bcond(ctx, TCG_COND_LE, ra, disp21, 0);\n\n        break;\n\n    case 0x3C:\n\n        /* BLBS */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 1);\n\n        break;\n\n    case 0x3D:\n\n        /* BNE */\n\n        ret = gen_bcond(ctx, TCG_COND_NE, ra, disp21, 0);\n\n        break;\n\n    case 0x3E:\n\n        /* BGE */\n\n        ret = gen_bcond(ctx, TCG_COND_GE, ra, disp21, 0);\n\n        break;\n\n    case 0x3F:\n\n        /* BGT */\n\n        ret = gen_bcond(ctx, TCG_COND_GT, ra, disp21, 0);\n\n        break;\n\n    invalid_opc:\n\n        ret = gen_invalid(ctx);\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 997, "prediction": "0", "true_label": "0", "raw_text": " \"m\" (src1), \"m\" (dst), \"g\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#else\n\n                :: \"m\" (src1), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc_shr16), \"m\" (xInc_mask),\n\n#endif\n\n                \"r\" (src2)\n\n                : \"%\"REG_a, \"%\"REG_d, \"%ecx\", \"%\"REG_D, \"%esi\"\n\n            );\n\n#if COMPILE_TEMPLATE_MMX2\n\n        } //if MMX2 can't be used\n\n#endif\n\n#else\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n#endif /* ARCH_X86 */\n\n    }\n\n    if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) {\n\n        int i;\n\n        //FIXME all pal and rgb srcFormats could do this convertion as well\n\n        //FIXME all scalers more complex than bilinear could do half of this transform\n\n        if(c->srcRange) {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (dst[i     ]*1799 + 4081085)>>11; //1469\n\n                dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; //1469\n\n            }\n\n        } else {\n\n            for (i=0; i<dstWidth; i++) {\n\n                dst[i     ]= (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n                dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 998, "prediction": "0", "true_label": "0", "raw_text": "Question: float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 999, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)\n\n{\n\n   return pthread_equal(thread1->thread, thread2->thread);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1000, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,\n\n                                                            uint32_t val)\n\n{\n\n    IVShmemState *s = opaque;\n\n\n\n    uint64_t write_one = 1;\n\n    uint16_t dest = val >> 16;\n\n    uint16_t vector = val & 0xff;\n\n\n\n    addr &= 0xfc;\n\n\n\n    IVSHMEM_DPRINTF(\"writing to addr \" TARGET_FMT_plx \"\\n\", addr);\n\n    switch (addr)\n\n    {\n\n        case INTRMASK:\n\n            ivshmem_IntrMask_write(s, val);\n\n            break;\n\n\n\n        case INTRSTATUS:\n\n            ivshmem_IntrStatus_write(s, val);\n\n            break;\n\n\n\n        case DOORBELL:\n\n            /* check that dest VM ID is reasonable */\n\n            if ((dest < 0) || (dest > s->max_peer)) {\n\n                IVSHMEM_DPRINTF(\"Invalid destination VM ID (%d)\\n\", dest);\n\n                break;\n\n            }\n\n\n\n            /* check doorbell range */\n\n            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {\n\n                IVSHMEM_DPRINTF(\"Writing %\" PRId64 \" to VM %d on vector %d\\n\",\n\n                                                    write_one, dest, vector);\n\n                if (write(s->peers[dest].eventfds[vector],\n\n                                                    &(write_one), 8) != 8) {\n\n                    IVSHMEM_DPRINTF(\"error writing to eventfd\\n\");\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            IVSHMEM_DPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1001, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_outs(DisasContext *s, TCGMemOp ot)\n\n{\n\n    if (use_icount)\n\n        gen_io_start();\n\n    gen_string_movl_A0_ESI(s);\n\n    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);\n\n\n\n    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);\n\n    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);\n\n    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);\n\n    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);\n\n\n\n    gen_op_movl_T0_Dshift(ot);\n\n    gen_op_add_reg_T0(s->aflag, R_ESI);\n\n    if (use_icount)\n\n        gen_io_end();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1002, "prediction": "0", "true_label": "0", "raw_text": "b));\n\n    printf(\"fcom(%f %f)=%04lx \\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    fpu_clear_exceptions();\n\n    asm(\"fucom %2\\n\"\n\n        \"fstsw %%ax\\n\"\n\n        : \"=a\" (fpus)\n\n        : \"t\" (a), \"u\" (b));\n\n    printf(\"fucom(%f %f)=%04lx\\n\",\n\n           a, b, fpus & (0x4500 | FPUS_EMASK));\n\n    if (TEST_FCOMI) {\n\n        /* test f(u)comi instruction */\n\n        fpu_clear_exceptions();\n\n        asm(\"fcomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fcomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n        fpu_clear_exceptions();\n\n        asm(\"fucomi %3, %2\\n\"\n\n            \"fstsw %%ax\\n\"\n\n            \"pushf\\n\"\n\n            \"pop %0\\n\"\n\n            : \"=r\" (eflags), \"=a\" (fpus)\n\n            : \"t\" (a), \"u\" (b));\n\n        printf(\"fucomi(%f %f)=%04lx %02lx\\n\",\n\n               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));\n\n    }\n\n    fpu_clear_exceptions();\n\n    asm volatile(\"fxam\\n\"\n\n                 \"fstsw %%ax\\n\"\n\n                 : \"=a\" (fpus)\n\n                 : \"t\" (a));\n\n    printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700);\n\n    fpu_clear_exceptions();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1003, "prediction": "0", "true_label": "1", "raw_text": " handled below */\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr) + xlat;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(cpu, section, vaddr, paddr, xlat,\n\n                                            prot, &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    te = &env->tlb_table[mmu_idx][index];\n\n\n\n    /* do not discard the translation in te, evict it into a victim tlb */\n\n    env->tlb_v_table[mmu_idx][vidx] = *te;\n\n    env->iotlb_v[mmu_idx][vidx] = env->iotlb[mmu_idx][index];\n\n\n\n    /* refill the tlb */\n\n    env->iotlb[mmu_idx][index].addr = iotlb - vaddr;\n\n    env->iotlb[mmu_idx][index].attrs = attrs;\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && cpu_physical_memory_is_clean(\n\n                        memory_region_get_ram_addr(section->mr) + xlat)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1004, "prediction": "1", "true_label": "1", "raw_text": "Question: static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,\n\n                                       const uint8_t *key, size_t nkey,\n\n                                       Error **errp)\n\n{\n\n    QCryptoCipherBuiltin *ctxt;\n\n\n\n    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {\n\n        error_setg(errp, \"Unsupported cipher mode %d\", cipher->mode);\n\n        return -1;\n\n    }\n\n\n\n    ctxt = g_new0(QCryptoCipherBuiltin, 1);\n\n\n\n    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);\n\n    memcpy(ctxt->state.desrfb.key, key, nkey);\n\n    ctxt->state.desrfb.nkey = nkey;\n\n\n\n\n    ctxt->free = qcrypto_cipher_free_des_rfb;\n\n    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;\n\n    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;\n\n    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;\n\n\n\n    cipher->opaque = ctxt;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1005, "prediction": "0", "true_label": "0", "raw_text": "address_space_memory,\n\n                                            ccw.cda + sizeof(linfo.queue)\n\n                                            + sizeof(linfo.align),\n\n                                            MEMTXATTRS_UNSPECIFIED,\n\n                                            NULL);\n\n        linfo.num = address_space_lduw_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(linfo.queue)\n\n                                          + sizeof(linfo.align)\n\n                                          + sizeof(linfo.index),\n\n                                          MEMTXATTRS_UNSPECIFIED,\n\n                                          NULL);\n\n        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);\n\n    } else {\n\n        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.index = address_space_lduw_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(info.desc)\n\n                                           + sizeof(info.res0),\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.num = address_space_lduw_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.avail = address_space_ldq_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(info.desc)\n\n                                          + sizeof(info.res0)\n\n                                          + sizeof(info.index)\n\n                                          + sizeof(info.num),\n\n                                          MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.used = address_space_ldq_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index)\n\n                                         + sizeof(info.num)\n\n                                         + sizeof(info.avail),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        ret = virtio_ccw_set_vqs(sch, &info, NULL);\n\n    }\n\n    sch->curr_status.scsw.count = 0;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1006, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1007, "prediction": "0", "true_label": "0", "raw_text": "Question: int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)\n\n{\n\n    return kvm_irqchip_assign_irqfd(s, fd, virq, true);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1008, "prediction": "0", "true_label": "0", "raw_text": "Question: static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    NetCharDriver *s = chr->opaque;\n\n    gsize bytes_read = 0;\n\n    GIOStatus status;\n\n\n\n    if (s->max_size == 0)\n\n        return FALSE;\n\n    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),\n\n                                     &bytes_read, NULL);\n\n    s->bufcnt = bytes_read;\n\n    s->bufptr = s->bufcnt;\n\n    if (status != G_IO_STATUS_NORMAL) {\n\n        return FALSE;\n\n    }\n\n\n\n    s->bufptr = 0;\n\n    while (s->max_size > 0 && s->bufptr < s->bufcnt) {\n\n        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);\n\n        s->bufptr++;\n\n        s->max_size = qemu_chr_be_can_write(chr);\n\n    }\n\n\n\n    return TRUE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1009, "prediction": "0", "true_label": "1", "raw_text": " pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1010, "prediction": "0", "true_label": "0", "raw_text": "Question: static int raw_init_encoder(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = (AVFrame *)avctx->priv_data;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->codec_tag = findFourCC(avctx->pix_fmt);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1011, "prediction": "0", "true_label": "1", "raw_text": "Progressive Segmented Frame mode: not supported (yet)\\n\");\n\n        return -1;\n\n    }\n\n    if(get_bits1(gb)) { //Display Info - decoding is not affected by it\n\n        int w, h, ar = 0;\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display extended info:\\n\");\n\n        w = get_bits(gb, 14);\n\n        h = get_bits(gb, 14);\n\n        av_log(v->s.avctx, AV_LOG_INFO, \"Display dimensions: %ix%i\\n\", w, h);\n\n        //TODO: store aspect ratio in AVCodecContext\n\n        if(get_bits1(gb))\n\n            ar = get_bits(gb, 4);\n\n        if(ar == 15) {\n\n            w = get_bits(gb, 8);\n\n            h = get_bits(gb, 8);\n\n        }\n\n\n\n        if(get_bits1(gb)){ //framerate stuff\n\n            if(get_bits1(gb)) {\n\n                get_bits(gb, 16);\n\n            } else {\n\n                get_bits(gb, 8);\n\n                get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        if(get_bits1(gb)){\n\n            v->color_prim = get_bits(gb, 8);\n\n            v->transfer_char = get_bits(gb, 8);\n\n            v->matrix_coef = get_bits(gb, 8);\n\n        }\n\n    }\n\n\n\n    v->hrd_param_flag = get_bits1(gb);\n\n    if(v->hrd_param_flag) {\n\n        int i;\n\n        v->hrd_num_leaky_buckets = get_bits(gb, 5);\n\n        get_bits(gb, 4); //bitrate exponent\n\n        get_bits(gb, 4); //buffer size exponent\n\n        for(i = 0; i < v->hrd_num_leaky_buckets; i++) {\n\n            get_bits(gb, 16); //hrd_rate[n]\n\n            get_bits(gb, 16); //hrd_buffer[n]\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1012, "prediction": "0", "true_label": "1", "raw_text": "Question: int page_unprotect(target_ulong address, uintptr_t pc, void *puc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(addr, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1013, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1014, "prediction": "0", "true_label": "0", "raw_text": "Question: static int film_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 4)\n\n        return 0;\n\n\n\n    if (AV_RB32(&p->buf[0]) != FILM_TAG)\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1015, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,\n\n                       unsigned int size, int mem_index)\n\n{\n\n    int l1 = gen_new_label();\n\n    TCGv taddr = tcg_temp_local_new();\n\n    TCGv tval = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    dc->postinc = 0;\n\n    cris_evaluate_flags(dc);\n\n\n\n    tcg_gen_mov_tl(taddr, addr);\n\n    tcg_gen_mov_tl(tval, val);\n\n\n\n    /* Store only if F flag isn't set */\n\n    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n    if (size == 1) {\n\n        tcg_gen_qemu_st8(tval, taddr, mem_index);\n\n    } else if (size == 2) {\n\n        tcg_gen_qemu_st16(tval, taddr, mem_index);\n\n    } else {\n\n        tcg_gen_qemu_st32(tval, taddr, mem_index);\n\n    }\n\n    gen_set_label(l1);\n\n    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */\n\n    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(tval);\n\n    tcg_temp_free(taddr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1016, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ide_trim_bh_cb(void *opaque)\n\n{\n\n    TrimAIOCB *iocb = opaque;\n\n\n\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n\n\n\n    qemu_bh_delete(iocb->bh);\n\n    iocb->bh = NULL;\n\n    qemu_aio_unref(iocb);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1017, "prediction": "0", "true_label": "0", "raw_text": "64_t *gdev = argptr + 8;\n\n            int i;\n\n\n\n            *(uint32_t*)argptr = tswap32(count);\n\n            for (i = 0; i < count; i++) {\n\n                *gdev = tswap64(*hdev);\n\n                gdev++;\n\n                hdev++;\n\n            }\n\n            break;\n\n        }\n\n        case DM_LIST_VERSIONS:\n\n        {\n\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n\n            int vers_size = thunk_type_size(arg_type, 0);\n\n\n\n            while (1) {\n\n                uint32_t next = vers->next;\n\n                if (next) {\n\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n\n                }\n\n                if (remaining_data < vers->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + vers_size, vers->name);\n\n                cur_data += vers->next;\n\n                remaining_data -= vers->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                vers = (void*)vers + next;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            ret = -TARGET_EINVAL;\n\n            goto out;\n\n        }\n\n        unlock_user(argptr, guest_data, guest_data_size);\n\n\n\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n\n        if (!argptr) {\n\n            ret = -TARGET_EFAULT;\n\n            goto out;\n\n        }\n\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n\n        unlock_user(argptr, arg, target_size);\n\n    }\n\nout:\n\n    if (big_buf) {\n\n        free(big_buf);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1018, "prediction": "0", "true_label": "0", "raw_text": "Question: static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)\n\n{\n\n    InputStream        *ist = s->opaque;\n\n    DXVA2Context       *ctx = ist->hwaccel_ctx;\n\n    int                ret;\n\n\n\n    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    ret = av_frame_copy_props(ctx->tmp_frame, frame);\n\n    if (ret < 0) {\n\n        av_frame_unref(ctx->tmp_frame);\n\n        return ret;\n\n    }\n\n\n\n    av_frame_unref(frame);\n\n    av_frame_move_ref(frame, ctx->tmp_frame);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1019, "prediction": "0", "true_label": "1", "raw_text": "\n\n            else\n\n                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);\n\n            AV_WN32A(s->intra4x4_pred_mode_left, modes);\n\n        }\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                vp8_pred8x8c_prob_intra);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {\n\n        // inter MB, 16.2\n\n        if (vp56_rac_get_prob_branchy(c, s->prob->last))\n\n            mb->ref_frame =\n\n                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */\n\n                                                      : VP56_FRAME_GOLDEN;\n\n        else\n\n            mb->ref_frame = VP56_FRAME_PREVIOUS;\n\n        s->ref_count[mb->ref_frame - 1]++;\n\n\n\n        // motion vectors, 16.3\n\n        decode_mvs(s, mb, mb_x, mb_y, layout);\n\n    } else {\n\n        // intra MB, 16.1\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);\n\n\n\n        if (mb->mode == MODE_I4x4)\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                s->prob->pred8x8c);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n        mb->partitioning     = VP8_SPLITMVMODE_NONE;\n\n        AV_ZERO32(&mb->bmv[0]);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1020, "prediction": "0", "true_label": "1", "raw_text": "16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1021, "prediction": "0", "true_label": "0", "raw_text": "Question: static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)\n\n{\n\n    int i;\n\n    int vlc    = get_bits1(&q->gb);\n\n    int start  = cplband[p->js_subband_start];\n\n    int end    = cplband[p->subbands - 1];\n\n    int length = end - start + 1;\n\n\n\n    if (start > end)\n\n        return;\n\n\n\n    if (vlc)\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);\n\n    else\n\n        for (i = 0; i < length; i++)\n\n            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1022, "prediction": "0", "true_label": "1", "raw_text": "Question: static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1023, "prediction": "0", "true_label": "0", "raw_text": "Question: static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){\n\n    int i,j,k,m;\n\n    double l2tab[256];\n\n\n\n    for(i=1; i<256; i++)\n\n        l2tab[i]= log2(i/256.0);\n\n\n\n    for(i=0; i<256; i++){\n\n        double best_len[256];\n\n        double p= i/256.0;\n\n\n\n        for(j=0; j<256; j++)\n\n            best_len[j]= 1<<30;\n\n\n\n        for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){\n\n            double occ[256]={0};\n\n            double len=0;\n\n            occ[j]=1.0;\n\n            for(k=0; k<256; k++){\n\n                double newocc[256]={0};\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        len -=occ[m]*(     p *l2tab[    m]\n\n                                      + (1-p)*l2tab[256-m]);\n\n                    }\n\n                }\n\n                if(len < best_len[k]){\n\n                    best_len[k]= len;\n\n                    best_state[i][k]= j;\n\n                }\n\n                for(m=0; m<256; m++){\n\n                    if(occ[m]){\n\n                        newocc[    one_state[    m]] += occ[m]*   p ;\n\n                        newocc[256-one_state[256-m]] += occ[m]*(1-p);\n\n                    }\n\n                }\n\n                memcpy(occ, newocc, sizeof(occ));\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1024, "prediction": "0", "true_label": "0", "raw_text": "Question: static int get_pcm(HEVCContext *s, int x, int y)\n\n{\n\n    int log2_min_pu_size = s->sps->log2_min_pu_size;\n\n    int x_pu             = x >> log2_min_pu_size;\n\n    int y_pu             = y >> log2_min_pu_size;\n\n\n\n    if (x < 0 || x_pu >= s->sps->min_pu_width ||\n\n        y < 0 || y_pu >= s->sps->min_pu_height)\n\n        return 2;\n\n    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1025, "prediction": "0", "true_label": "0", "raw_text": " new_extradata_size,\n\n                                       &h->ps, &h->is_avc, &h->nal_length_size,\n\n                                       avctx->err_recognition, avctx);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size);\n\n    if (buf_index < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        buf_size = 0;\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            return 0;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        ff_h264_field_end(h, &h->slice_ctx[0], 0);\n\n\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||\n\n                                   h->next_output_pic->recovered)) {\n\n            if (!h->next_output_pic->recovered)\n\n                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;\n\n\n\n            ret = output_frame(h, pict, h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    }\n\n\n\n    assert(pict->buf[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1026, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)\n\n{\n\n    if (bin < 7) {\n\n        if ((b0 + 256) == b1)\n\n            a = 384;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else if (bin < 20) {\n\n        if ((b0 + 256) == b1)\n\n            a = 320;\n\n        else if (b0 > b1)\n\n            a = FFMAX(0, a - 64);\n\n    }\n\n    else {\n\n        a = FFMAX(0, a - 128);\n\n    }\n\n\n\n    return a;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1027, "prediction": "0", "true_label": "0", "raw_text": "0(8)\n\n            \"pand                    %%mm7, %%mm3       \\n\\t\" // Y0Y0 Y0Y0(12)\n\n            \"packuswb                %%mm1, %%mm0       \\n\\t\" // YYYY YYYY(0)\n\n            \"packuswb                %%mm3, %%mm2       \\n\\t\" // YYYY YYYY(8)\n\n\n\n            MOVNTQ\"                  %%mm0,  (%1, %%\"REG_a\", 2) \\n\\t\"\n\n            MOVNTQ\"                  %%mm2, 8(%1, %%\"REG_a\", 2) \\n\\t\"\n\n\n\n            \"add                        $8, %%\"REG_a\"   \\n\\t\"\n\n            \"cmp                        %4, %%\"REG_a\"   \\n\\t\"\n\n            \" jb                        1b              \\n\\t\"\n\n\n\n            ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth)\n\n            : \"memory\", \"%\"REG_a\n\n        );\n\n#else\n\n        long i;\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            udst[i]     = src[4*i+1];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n            vdst[i]     = src[4*i+3];\n\n        }\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n\n\n        for (i=0; i<chromWidth; i++) {\n\n            ydst[2*i+0]     = src[4*i+0];\n\n            ydst[2*i+1]     = src[4*i+2];\n\n        }\n\n#endif\n\n        udst += chromStride;\n\n        vdst += chromStride;\n\n        ydst += lumStride;\n\n        src  += srcStride;\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(EMMS\"       \\n\\t\"\n\n                     SFENCE\"     \\n\\t\"\n\n                     :::\"memory\");\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1028, "prediction": "1", "true_label": "0", "raw_text": "Question: static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,\n\n                                                  const char *name,\n\n                                                  BlockDriverState **pbs,\n\n                                                  AioContext **paio,\n\n                                                  Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvDirtyBitmap *bitmap;\n\n    AioContext *aio_context;\n\n\n\n    if (!node) {\n\n        error_setg(errp, \"Node cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    if (!name) {\n\n        error_setg(errp, \"Bitmap name cannot be NULL\");\n\n        return NULL;\n\n    }\n\n    bs = bdrv_lookup_bs(node, node, NULL);\n\n    if (!bs) {\n\n        error_setg(errp, \"Node '%s' not found\", node);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    bitmap = bdrv_find_dirty_bitmap(bs, name);\n\n    if (!bitmap) {\n\n        error_setg(errp, \"Dirty bitmap '%s' not found\", name);\n\n        goto fail;\n\n    }\n\n\n\n    if (pbs) {\n\n        *pbs = bs;\n\n    }\n\n    if (paio) {\n\n        *paio = aio_context;\n\n    } else {\n\n        aio_context_release(aio_context);\n\n    }\n\n\n\n    return bitmap;\n\n\n\n fail:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1029, "prediction": "0", "true_label": "1", "raw_text": "    |   Y   | u-boot\n\n     *     Y    |   N   | kernel\n\n     *\n\n     * This ensures backwards compatibility with how we used to expose\n\n     * -kernel to users but allows them to run through u-boot as well.\n\n     */\n\n    if (bios_name == NULL) {\n\n        if (machine->kernel_filename) {\n\n            bios_name = machine->kernel_filename;\n\n        } else {\n\n            bios_name = \"u-boot.e500\";\n\n        }\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    bios_size = load_elf(filename, NULL, NULL, &bios_entry, &loadaddr, NULL,\n\n                         1, ELF_MACHINE, 0);\n\n    if (bios_size < 0) {\n\n        /*\n\n         * Hrm. No ELF image? Try a uImage, maybe someone is giving us an\n\n         * ePAPR compliant kernel\n\n         */\n\n        kernel_size = load_uimage(filename, &bios_entry, &loadaddr, NULL,\n\n                                  NULL, NULL);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load firmware '%s'\\n\", filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Reserve space for dtb */\n\n    dt_base = (loadaddr + bios_size + DTC_LOAD_PAD) & ~DTC_PAD_MASK;\n\n\n\n    dt_size = ppce500_prep_device_tree(machine, params, dt_base,\n\n                                       initrd_base, initrd_size,\n\n                                       kernel_base, kernel_size);\n\n    if (dt_size < 0) {\n\n        fprintf(stderr, \"couldn't load device tree\\n\");\n\n        exit(1);\n\n    }\n\n    assert(dt_size < DTB_MAX_SIZE);\n\n\n\n    boot_info = env->load_info;\n\n    boot_info->entry = bios_entry;\n\n    boot_info->dt_base = dt_base;\n\n    boot_info->dt_size = dt_size;\n\n\n\n    if (kvm_enabled()) {\n\n        kvmppc_init();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1030, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1031, "prediction": "0", "true_label": "0", "raw_text": "Question: static int segment_hls_window(AVFormatContext *s, int last)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    int i, ret = 0;\n\n    char buf[1024];\n\n\n\n    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n\n                              &s->interrupt_callback, NULL)) < 0)\n\n        goto fail;\n\n\n\n    avio_printf(seg->pb, \"#EXTM3U\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-VERSION:3\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time);\n\n    avio_printf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n                FFMAX(0, seg->number - seg->size));\n\n\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n           FFMAX(0, seg->number - seg->size));\n\n\n\n    for (i = FFMAX(0, seg->number - seg->size);\n\n         i < seg->number; i++) {\n\n        avio_printf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time);\n\n        if (seg->entry_prefix) {\n\n            avio_printf(seg->pb, \"%s\", seg->entry_prefix);\n\n        }\n\n        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);\n\n        if (ret < 0) {\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        avio_printf(seg->pb, \"%s\\n\", buf);\n\n    }\n\n\n\n    if (last)\n\n        avio_printf(seg->pb, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n\n    avio_closep(&seg->pb);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1032, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1033, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1034, "prediction": "0", "true_label": "1", "raw_text": " buf, buf_end);\n\n                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { //PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM\n\n        for(y = 0; y < avctx->height ; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(row, avctx->width, buf, buf_end);\n\n        }\n\n    } else { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n        for (y = 0; y < avctx->height ; y++) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);\n\n            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1035, "prediction": "0", "true_label": "1", "raw_text": "val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 2;\n\n        }else if(s->out_format == FMT_H263 || s->encoding || (s->avctx->debug&FF_DEBUG_MV) || (s->avctx->debug_mv)){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 3;\n\n        }\n\n        if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)\n\n        }\n\n        pic->qstride= s->mb_stride;\n\n        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))\n\n    }\n\n\n\n    /* It might be nicer if the application would keep track of these\n\n     * but it would require an API change. */\n\n    memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);\n\n    s->prev_pict_types[0]= s->pict_type;\n\n    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && s->prev_pict_types[pic->age] == B_TYPE)\n\n        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.\n\n\n\n    return 0;\n\nfail: //for the CHECKED_ALLOCZ macro\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1036, "prediction": "1", "true_label": "1", "raw_text": "Question: static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\n    if (get_bits(&ctx->gb, 5) != 0x1F) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\n        return -1;\n    ctx->prev_frame_type = ctx->frame_type;\n    ctx->frame_type      = get_bits(&ctx->gb, 3);\n    if (ctx->frame_type >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\n        return -1;\n    ctx->frame_num = get_bits(&ctx->gb, 8);\n    if (ctx->frame_type == FRAMETYPE_INTRA) {\n        ctx->gop_invalid = 1;\n        if (decode_gop_header(ctx, avctx))\n            return -1;\n        ctx->gop_invalid = 0;\n    if (ctx->frame_type != FRAMETYPE_NULL) {\n        ctx->frame_flags = get_bits(&ctx->gb, 8);\n        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\n        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n        /* skip unknown extension if any */\n        if (ctx->frame_flags & 0x20)\n            skip_hdr_extension(&ctx->gb); /* XXX: untested */\n        /* decode macroblock huffman codebook */\n        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\n            return -1;\n        skip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\n    align_get_bits(&ctx->gb);\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1037, "prediction": "0", "true_label": "1", "raw_text": "->sdt_packet_period = INT_MAX;\n\n    }\n\n\n\n    // output a PCR as soon as possible\n\n    service->pcr_packet_count = service->pcr_packet_period;\n\n    ts->pat_packet_count      = ts->pat_packet_period - 1;\n\n    ts->sdt_packet_count      = ts->sdt_packet_period - 1;\n\n\n\n    if (ts->mux_rate == 1)\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate VBR, \");\n\n    else\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate %d, \", ts->mux_rate);\n\n    av_log(s, AV_LOG_VERBOSE,\n\n           \"pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\\n\",\n\n           service->pcr_packet_period,\n\n           ts->sdt_packet_period, ts->pat_packet_period);\n\n\n\n    if (ts->m2ts_mode == -1) {\n\n        if (av_match_ext(s->filename, \"m2ts\")) {\n\n            ts->m2ts_mode = 1;\n\n        } else {\n\n            ts->m2ts_mode = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&pids);\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st    = s->streams[i];\n\n        ts_st = st->priv_data;\n\n        if (ts_st) {\n\n            av_freep(&ts_st->payload);\n\n            if (ts_st->amux) {\n\n                avformat_free_context(ts_st->amux);\n\n                ts_st->amux = NULL;\n\n            }\n\n        }\n\n        av_freep(&st->priv_data);\n\n    }\n\n\n\n    for (i = 0; i < ts->nb_services; i++) {\n\n        service = ts->services[i];\n\n        av_freep(&service->provider_name);\n\n        av_freep(&service->name);\n\n        av_freep(&service);\n\n    }\n\n    av_freep(&ts->services);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1038, "prediction": "1", "true_label": "1", "raw_text": "3, 11);\n\n    ADD(11, 15);\n\n\n\n    out[ 0] = val0;\n\n    out[16] = val1;\n\n    out[ 8] = val2;\n\n    out[24] = val3;\n\n    out[ 4] = val4;\n\n    out[20] = val5;\n\n    out[12] = val6;\n\n    out[28] = val7;\n\n    out[ 2] = val8;\n\n    out[18] = val9;\n\n    out[10] = val10;\n\n    out[26] = val11;\n\n    out[ 6] = val12;\n\n    out[22] = val13;\n\n    out[14] = val14;\n\n    out[30] = val15;\n\n\n\n    ADD(24, 28);\n\n    ADD(28, 26);\n\n    ADD(26, 30);\n\n    ADD(30, 25);\n\n    ADD(25, 29);\n\n    ADD(29, 27);\n\n    ADD(27, 31);\n\n\n\n    out[ 1] = val16 + val24;\n\n    out[17] = val17 + val25;\n\n    out[ 9] = val18 + val26;\n\n    out[25] = val19 + val27;\n\n    out[ 5] = val20 + val28;\n\n    out[21] = val21 + val29;\n\n    out[13] = val22 + val30;\n\n    out[29] = val23 + val31;\n\n    out[ 3] = val24 + val20;\n\n    out[19] = val25 + val21;\n\n    out[11] = val26 + val22;\n\n    out[27] = val27 + val23;\n\n    out[ 7] = val28 + val18;\n\n    out[23] = val29 + val19;\n\n    out[15] = val30 + val17;\n\n    out[31] = val31;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1039, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_op_movl_seg_T0_vm(int seg_reg)\n\n{\n\n    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);\n\n    tcg_gen_st32_tl(cpu_T[0], cpu_env, \n\n                    offsetof(CPUX86State,segs[seg_reg].selector));\n\n    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);\n\n    tcg_gen_st_tl(cpu_T[0], cpu_env, \n\n                  offsetof(CPUX86State,segs[seg_reg].base));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1040, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vc1_v_overlap_c(uint8_t* src, int stride)\n\n{\n\n    int i;\n\n    int a, b, c, d;\n\n    int d1, d2;\n\n    int rnd = 1;\n\n    for(i = 0; i < 8; i++) {\n\n        a = src[-2*stride];\n\n        b = src[-stride];\n\n        c = src[0];\n\n        d = src[stride];\n\n        d1 = (a - d + 3 + rnd) >> 3;\n\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n\n\n        src[-2*stride] = a - d1;\n\n        src[-stride] = b - d2;\n\n        src[0] = c + d2;\n\n        src[stride] = d + d1;\n\n        src++;\n\n        rnd = !rnd;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1041, "prediction": "0", "true_label": "1", "raw_text": "Question: void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1042, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_rdhwr(DisasContext *ctx, int rt, int rd)\n\n{\n\n    TCGv t0;\n\n\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* The Linux kernel will emulate rdhwr if it's not supported natively.\n\n       Therefore only check the ISA in system mode.  */\n\n    check_insn(ctx, ISA_MIPS32R2);\n\n#endif\n\n    t0 = tcg_temp_new();\n\n\n\n    switch (rd) {\n\n    case 0:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cpunum(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 1:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_synci_step(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 2:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_cc(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 3:\n\n        save_cpu_state(ctx, 1);\n\n        gen_helper_rdhwr_ccres(t0, cpu_env);\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n    case 29:\n\n#if defined(CONFIG_USER_ONLY)\n\n        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));\n\n        gen_store_gpr(t0, rt);\n\n        break;\n\n#else\n\n        /* XXX: Some CPUs implement this in hardware.\n\n           Not supported yet. */\n\n#endif\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"rdhwr\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n    tcg_temp_free(t0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1043, "prediction": "0", "true_label": "1", "raw_text": "Question: static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1044, "prediction": "0", "true_label": "0", "raw_text": " 0; i < f->plane_count; i++) {\n\n        PlaneContext *const p = &fs->plane[i];\n\n        int idx               = get_symbol(c, state, 0);\n\n        if (idx > (unsigned)f->quant_table_count) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        p->quant_table_index = idx;\n\n        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n\n        context_count = f->context_count[idx];\n\n\n\n        if (p->context_count < context_count) {\n\n            av_freep(&p->state);\n\n            av_freep(&p->vlc_state);\n\n        }\n\n        p->context_count = context_count;\n\n    }\n\n\n\n    ps = get_symbol(c, state, 0);\n\n    if (ps == 1) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 1;\n\n    } else if (ps == 2) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 0;\n\n    } else if (ps == 3) {\n\n        f->cur->interlaced_frame = 0;\n\n    }\n\n    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);\n\n    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);\n\n\n\n    if (av_image_check_sar(f->width, f->height,\n\n                           f->cur->sample_aspect_ratio) < 0) {\n\n        av_log(f->avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n\n               f->cur->sample_aspect_ratio.num,\n\n               f->cur->sample_aspect_ratio.den);\n\n        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1045, "prediction": "0", "true_label": "1", "raw_text": "Question: int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)\n\n{\n\n\n\n    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,\n\n                            sizeof(diag_501), 0) ||\n\n        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,\n\n                            sizeof(diag_501), 1)) {\n\n        return -EINVAL;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1046, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1047, "prediction": "0", "true_label": "0", "raw_text": "_t *)alac->frame.extended_data[ch_index + ch];\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n        }}\n\n        break;\n\n    case 24: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                alac->output_samples_buffer[ch][i] <<= 8;\n\n        }}\n\n        break;\n\n    }\n\n    }else{\n\n        switch(alac->sample_size) {\n\n        case 16: {\n\n            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 24: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 32: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1048, "prediction": "0", "true_label": "0", "raw_text": ";\n\n                        curbits += 21;\n\n                    } else {\n\n                        int c = av_clip(quant(t, Q), 0, 8191);\n\n                        di = t - c*cbrtf(c)*IQ;\n\n                        curbits += av_log2(c)*2 - 4 + 1;\n\n                    }\n\n                } else {\n\n                    di = t - vec[k]*IQ;\n\n                }\n\n                if (vec[k] != 0.0f)\n\n                    curbits++;\n\n                rd += di*di;\n\n            }\n\n        } else {\n\n            for (k = 0; k < dim; k++) {\n\n                float di = in[i+k] - vec[k]*IQ;\n\n                rd += di*di;\n\n            }\n\n        }\n\n        cost    += rd * lambda + curbits;\n\n        resbits += curbits;\n\n        if (cost >= uplim)\n\n            return uplim;\n\n        if (pb) {\n\n            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);\n\n            if (BT_UNSIGNED)\n\n                for (j = 0; j < dim; j++)\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)\n\n                        put_bits(pb, 1, in[i+j] < 0.0f);\n\n            if (BT_ESC) {\n\n                for (j = 0; j < 2; j++) {\n\n                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {\n\n                        int coef = av_clip(quant(fabsf(in[i+j]), Q), 0, 8191);\n\n                        int len = av_log2(coef);\n\n\n\n                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);\n\n                        put_bits(pb, len, coef & ((1 << len) - 1));\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (bits)\n\n        *bits = resbits;\n\n    return cost;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1049, "prediction": "0", "true_label": "0", "raw_text": "64_t ts;\n\n                    int ns, hh, mm, ss;\n\n                    int tns, thh, tmm, tss;\n\n                    tns = cur_stream->ic->duration/1000000LL;\n\n                    thh = tns/3600;\n\n                    tmm = (tns%3600)/60;\n\n                    tss = (tns%60);\n\n                    frac = x/cur_stream->width;\n\n                    ns = frac*tns;\n\n                    hh = ns/3600;\n\n                    mm = (ns%3600)/60;\n\n                    ss = (ns%60);\n\n                    fprintf(stderr, \"Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \\n\", frac*100,\n\n                            hh, mm, ss, thh, tmm, tss);\n\n                    ts = frac*cur_stream->ic->duration;\n\n                    if (cur_stream->ic->start_time != AV_NOPTS_VALUE)\n\n                        ts += cur_stream->ic->start_time;\n\n                    stream_seek(cur_stream, ts, 0, 0);\n\n                }\n\n            }\n\n            break;\n\n        case SDL_VIDEORESIZE:\n\n            if (cur_stream) {\n\n                screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0,\n\n                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);\n\n                screen_width = cur_stream->width = event.resize.w;\n\n                screen_height= cur_stream->height= event.resize.h;\n\n            }\n\n            break;\n\n        case SDL_QUIT:\n\n        case FF_QUIT_EVENT:\n\n            do_exit(cur_stream);\n\n            break;\n\n        case FF_ALLOC_EVENT:\n\n            video_open(event.user.data1);\n\n            alloc_picture(event.user.data1);\n\n            break;\n\n        case FF_REFRESH_EVENT:\n\n            video_refresh(event.user.data1);\n\n            cur_stream->refresh=0;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1050, "prediction": "0", "true_label": "1", "raw_text": "Question: static int sox_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    int ret, size;\n\n\n\n    if (url_feof(s->pb))\n\n        return AVERROR_EOF;\n\n\n\n    size = SOX_SAMPLES*s->streams[0]->codec->block_align;\n\n    ret = av_get_packet(s->pb, pkt, size);\n\n    if (ret < 0)\n\n        return AVERROR(EIO);\n\n\n    pkt->stream_index = 0;\n\n    pkt->size = ret;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1051, "prediction": "1", "true_label": "1", "raw_text": "Question: static av_cold int svq1_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVQ1Context * const s = avctx->priv_data;\n\n\n\n    dsputil_init(&s->dsp, avctx);\n\n    avctx->coded_frame= (AVFrame*)&s->picture;\n\n\n\n    s->frame_width = avctx->width;\n\n    s->frame_height = avctx->height;\n\n\n\n    s->y_block_width = (s->frame_width + 15) / 16;\n\n    s->y_block_height = (s->frame_height + 15) / 16;\n\n\n\n    s->c_block_width = (s->frame_width / 4 + 15) / 16;\n\n    s->c_block_height = (s->frame_height / 4 + 15) / 16;\n\n\n\n    s->avctx= avctx;\n\n    s->m.avctx= avctx;\n\n\n    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));\n\n    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));\n\n    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));\n\n    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));\n\n    h263_encode_init(&s->m); //mv_penalty\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1052, "prediction": "0", "true_label": "1", "raw_text": " -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1053, "prediction": "0", "true_label": "1", "raw_text": "->linesize;\n\n            s->dsp.emulated_edge_mc(uvbuf , ptr_cb, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            s->dsp.emulated_edge_mc(uvbuf + 16, ptr_cr, s->uvlinesize, 9,\n\n                                    9 + field_based,\n\n                                    uvsrc_x, uvsrc_y << field_based,\n\n                                    h_edge_pos >> 1, v_edge_pos >> 1);\n\n            ptr_cb = uvbuf;\n\n            ptr_cr = uvbuf + 16;\n\n        }\n\n    }\n\n\n\n    // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f.data\n\n    if (bottom_field) {\n\n        dest_y  += s->linesize;\n\n        dest_cb += s->uvlinesize;\n\n        dest_cr += s->uvlinesize;\n\n    }\n\n\n\n    if (field_select) {\n\n        ptr_y   += s->linesize;\n\n        ptr_cb  += s->uvlinesize;\n\n        ptr_cr  += s->uvlinesize;\n\n    }\n\n\n\n    sx = (sx << 2) >> lowres;\n\n    sy = (sy << 2) >> lowres;\n\n    pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);\n\n\n\n    if (!CONFIG_GRAY || !(s->flags & CODEC_FLAG_GRAY)) {\n\n        uvsx = (uvsx << 2) >> lowres;\n\n        uvsy = (uvsy << 2) >> lowres;\n\n        pix_op[op_index](dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n        pix_op[op_index](dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift,\n\n                         uvsx, uvsy);\n\n    }\n\n    // FIXME h261 lowres loop filter\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1054, "prediction": "0", "true_label": "1", "raw_text": " xmin * desc->nb_components;\n\n                    if (s->bits_per_color_id == 2) {\n\n                        // 32-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&r));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&g));\n\n                            *ptr_x++ = exr_flt2uint(bytestream_get_le32(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a));\n\n                        }\n\n                    } else {\n\n                        // 16-bit\n\n                        for (x = 0; x < xdelta; x++) {\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&r));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&g));\n\n                            *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&b));\n\n                            if (alpha_channel_buffer)\n\n                                *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a));\n\n                        }\n\n                    }\n\n\n\n                    // Zero out the end if xmax+1 is not w\n\n                    memset(ptr_x, 0, axmax);\n\n\n\n                    red_channel_buffer   += scan_line_size;\n\n                    green_channel_buffer += scan_line_size;\n\n                    blue_channel_buffer  += scan_line_size;\n\n                    if (alpha_channel_buffer)\n\n                        alpha_channel_buffer += scan_line_size;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    // Zero out the end if ymax+1 is not h\n\n    for (y = ymax + 1; y < avctx->height; y++) {\n\n        memset(ptr, 0, out_line_size);\n\n        ptr += stride;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1055, "prediction": "0", "true_label": "1", "raw_text": "Question: static void csrhci_reset(struct csrhci_s *s)\n\n{\n\n    s->out_len = 0;\n\n    s->out_size = FIFO_LEN;\n\n    s->in_len = 0;\n\n    s->baud_delay = NANOSECONDS_PER_SECOND;\n\n    s->enable = 0;\n\n    s->in_hdr = INT_MAX;\n\n    s->in_data = INT_MAX;\n\n\n\n    s->modem_state = 0;\n\n    /* After a while... (but sooner than 10ms) */\n\n    s->modem_state |= CHR_TIOCM_CTS;\n\n\n\n    memset(&s->bd_addr, 0, sizeof(bdaddr_t));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1056, "prediction": "0", "true_label": "1", "raw_text": "Question: void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tunsigned i;\n\n\tunsigned num_pixels = src_size >> 1;\n\n\t\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1057, "prediction": "0", "true_label": "1", "raw_text": "Question: int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1058, "prediction": "0", "true_label": "1", "raw_text": "Question: static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1059, "prediction": "0", "true_label": "1", "raw_text": "Question: static void check_add_res(HEVCDSPContext h, int bit_depth)\n\n{\n\n    int i;\n\n    LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);\n\n    LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);\n\n    LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);\n\n\n\n    for (i = 2; i <= 5; i++) {\n\n        int block_size = 1 << i;\n\n        int size = block_size * block_size;\n\n        ptrdiff_t stride = block_size << (bit_depth > 8);\n\n        declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);\n\n\n\n        randomize_buffers(res0, size);\n\n        randomize_buffers2(dst0, size);\n\n        memcpy(res1, res0, sizeof(*res0) * size);\n\n        memcpy(dst1, dst0, size);\n\n\n\n        if (check_func(h.add_residual[i - 2], \"add_res_%dx%d_%d\", block_size, block_size, bit_depth)) {\n\n            call_ref(dst0, res0, stride);\n\n            call_new(dst1, res1, stride);\n\n            if (memcmp(dst0, dst1, size))\n\n                fail();\n\n            bench_new(dst1, res1, stride);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1060, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_validate_fail_union_flat(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefFlatUnion *tmp = NULL;\n\n    Error *errp = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\");\n\n\n\n    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefFlatUnion(tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1061, "prediction": "0", "true_label": "0", "raw_text": "Question: void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)\n\n{\n\n#if defined(DEBUG_MMU)\n\n    printf(\"CR4 update: CR4=%08x\\n\", (uint32_t)env->cr[4]);\n\n#endif\n\n    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=\n\n        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {\n\n        tlb_flush(env, 1);\n\n    }\n\n    /* SSE handling */\n\n    if (!(env->cpuid_features & CPUID_SSE))\n\n        new_cr4 &= ~CR4_OSFXSR_MASK;\n\n    if (new_cr4 & CR4_OSFXSR_MASK)\n\n        env->hflags |= HF_OSFXSR_MASK;\n\n    else\n\n        env->hflags &= ~HF_OSFXSR_MASK;\n\n\n\n    env->cr[4] = new_cr4;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1062, "prediction": "1", "true_label": "0", "raw_text": "rives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1063, "prediction": "0", "true_label": "1", "raw_text": "Question: static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1064, "prediction": "0", "true_label": "0", "raw_text": "\n{\n\n    LJpegEncContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    const int width  = avctx->width;\n\n    const int height = avctx->height;\n\n    const int mb_width  = (width  + s->hsample[0] - 1) / s->hsample[0];\n\n    const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0];\n\n    int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE;\n\n    int ret, header_bits;\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        max_pkt_size += width * height * 3 * 3;\n\n    else {\n\n        max_pkt_size += mb_width * mb_height * 3 * 4\n\n                        * s->hsample[0] * s->vsample[0];\n\n    }\n\n    if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", max_pkt_size);\n\n        return ret;\n\n    }\n\n\n\n    init_put_bits(&pb, pkt->data, pkt->size);\n\n\n\n    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,\n\n                                   s->matrix);\n\n\n\n    header_bits = put_bits_count(&pb);\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)\n\n        ret = ljpeg_encode_bgr(avctx, &pb, pict);\n\n    else\n\n        ret = ljpeg_encode_yuv(avctx, &pb, pict);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(&pb, header_bits);\n\n\n\n    flush_put_bits(&pb);\n\n    pkt->size   = put_bits_ptr(&pb) - pb.buf;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1065, "prediction": "0", "true_label": "1", "raw_text": "\n\n            if ((ret = avfilter_open(&scale, f, \"Input equalizer\")) < 0)\n\n                return ret;\n\n\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\", c->w, c->h, c->sws_param);\n\n            if ((ret = avfilter_init_filter(scale, scale_param, NULL)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n\n\n            if ((ret = avfilter_insert_filter(buffer_filter->outputs[0], scale, 0, 0)) < 0) {\n\n                avfilter_free(scale);\n\n                return ret;\n\n            }\n\n            scale->outputs[0]->time_base = scale->inputs[0]->time_base;\n\n\n\n            scale->outputs[0]->format= c->pix_fmt;\n\n        } else if (!strcmp(scale->filter->name, \"scale\")) {\n\n            snprintf(scale_param, sizeof(scale_param)-1, \"%d:%d:%s\",\n\n                     scale->outputs[0]->w, scale->outputs[0]->h, c->sws_param);\n\n            scale->filter->init(scale, scale_param, NULL);\n\n        }\n\n\n\n        c->pix_fmt = scale->inputs[0]->format = picref->format;\n\n        c->w       = scale->inputs[0]->w      = picref->video->w;\n\n        c->h       = scale->inputs[0]->h      = picref->video->h;\n\n\n\n        link = scale->outputs[0];\n\n        if ((ret =  link->srcpad->config_props(link)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    c->picref = avfilter_get_video_buffer(outlink, AV_PERM_WRITE,\n\n                                          picref->video->w, picref->video->h);\n\n    av_image_copy(c->picref->data, c->picref->linesize,\n\n                  picref->data, picref->linesize,\n\n                  picref->format, picref->video->w, picref->video->h);\n\n    avfilter_copy_buffer_ref_props(c->picref, picref);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1066, "prediction": "-1", "true_label": "1", "raw_text": " {\n        pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0];\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0],\n                   sps->bit_depth_luma);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1],\n                   sps->bit_depth_luma);\n    init_dequant_tables(pps, sps);\n    if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        pps->chroma_qp_diff = 1;\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(avctx, AV_LOG_DEBUG,\n               \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\");\n    remove_pps(ps, pps_id);\n    ps->pps_list[pps_id] = pps_buf;\n    return 0;\nfail:\n    av_buffer_unref(&pps_buf);\n    return ret;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1067, "prediction": "1", "true_label": "1", "raw_text": "Question: static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)\n\n{\n\n    trace_qxl_spice_monitors_config(qxl->id);\n\n    if (replay) {\n\n        /*\n\n         * don't use QXL_COOKIE_TYPE_IO:\n\n         *  - we are not running yet (post_load), we will assert\n\n         *    in send_events\n\n         *  - this is not a guest io, but a reply, so async_io isn't set.\n\n         */\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->guest_monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(\n\n                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,\n\n                    0));\n\n    } else {\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n        if (qxl->max_outputs) {\n\n            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,\n\n                                                qxl->max_outputs);\n\n        }\n\n#endif\n\n        qxl->guest_monitors_config = qxl->ram->monitors_config;\n\n        spice_qxl_monitors_config_async(&qxl->ssd.qxl,\n\n                qxl->ram->monitors_config,\n\n                MEMSLOT_GROUP_GUEST,\n\n                (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_IO,\n\n                                          QXL_IO_MONITORS_CONFIG_ASYNC));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1068, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1069, "prediction": "0", "true_label": "0", "raw_text": "Question: static void spapr_cpu_core_host_initfn(Object *obj)\n\n{\n\n    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);\n\n    char *name = g_strdup_printf(\"%s-\" TYPE_POWERPC_CPU, \"host\");\n\n    ObjectClass *oc = object_class_by_name(name);\n\n\n\n    g_assert(oc);\n\n    g_free((void *)name);\n\n    core->cpu_class = oc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1070, "prediction": "0", "true_label": "0", "raw_text": "_fragment + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if (i + 1 < s->fragment_height) {\n\n                s->all_fragments[current_fragment + s->fragment_width].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) {\n\n                s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width + 1;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            /* C planes */\n\n            c_fragment = s->u_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            c_fragment = s->v_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            debug_init(\"\\n\");\n\n\n\n            if (j + 2 <= s->fragment_width)\n\n                current_fragment += 2;\n\n            else \n\n                current_fragment++;\n\n            current_macroblock++;\n\n        }\n\n\n\n        current_fragment += s->fragment_width;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1071, "prediction": "0", "true_label": "0", "raw_text": "Question: void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; m68k_cpu_defs[i].name; i++) {\n\n        (*cpu_fprintf)(f, \"%s\\n\", m68k_cpu_defs[i].name);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1072, "prediction": "1", "true_label": "0", "raw_text": "Question: int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,\n\n                              PCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(dev->bus);\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n        return 0;\n\n    }\n\n\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, bsel, slot);\n\n    } else {\n\n        disable_device(s, bsel, slot);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1073, "prediction": "0", "true_label": "0", "raw_text": "Question: static void frame_start(H264Context *h){\n\n    MpegEncContext * const s = &h->s;\n\n    int i;\n\n\n\n    MPV_frame_start(s, s->avctx);\n\n    ff_er_frame_start(s);\n\n\n\n    assert(s->linesize && s->uvlinesize);\n\n\n\n    for(i=0; i<16; i++){\n\n        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n    for(i=0; i<4; i++){\n\n        h->block_offset[16+i]=\n\n        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n        h->block_offset[24+16+i]=\n\n        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);\n\n    }\n\n\n\n    /* can't be in alloc_tables because linesize isn't known there.\n\n     * FIXME: redo bipred weight to not require extra buffer? */\n\n    if(!s->obmc_scratchpad)\n\n        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);\n\n\n\n//    s->decode= (s->flags&CODEC_FLAG_PSNR) || !s->encoding || s->current_picture.reference /*|| h->contains_intra*/ || 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1074, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1075, "prediction": "0", "true_label": "1", "raw_text": "Question: void qmp_guest_file_flush(int64_t handle, Error **errp)\n\n{\n\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n\n    FILE *fh;\n\n    int ret;\n\n\n\n    if (!gfh) {\n\n        return;\n\n    }\n\n\n\n    fh = gfh->fh;\n\n    ret = fflush(fh);\n\n    if (ret == EOF) {\n\n        error_setg_errno(errp, errno, \"failed to flush file\");\n\n\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1076, "prediction": "0", "true_label": "0", "raw_text": "Question: static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture * const ref1 = &h->ref_list[1][0];\n\n    int j, old_ref, rfield;\n\n    int start= mbafi ? 16                      : 0;\n\n    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];\n\n    int interl= mbafi || s->picture_structure != PICT_FRAME;\n\n\n\n    /* bogus; fills in for missing frames */\n\n    memset(map[list], 0, sizeof(map[list]));\n\n\n\n    for(rfield=0; rfield<2; rfield++){\n\n        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){\n\n            int poc = ref1->ref_poc[colfield][list][old_ref];\n\n\n\n            if     (!interl)\n\n                poc |= 3;\n\n            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed\n\n                poc= (poc&~3) + rfield + 1;\n\n\n\n            for(j=start; j<end; j++){\n\n                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {\n\n                    int cur_ref= mbafi ? (j-16)^field : j;\n\n                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;\n\n                    if(rfield == field || !interl)\n\n                        map[list][old_ref] = cur_ref;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1077, "prediction": "0", "true_label": "0", "raw_text": "Question: static void compute_frame_duration(int *pnum, int *pden,\n\n                                   AVFormatContext *s, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        *pnum = st->codec.frame_rate_base;\n\n        *pden = st->codec.frame_rate;\n\n        if (pc && pc->repeat_pict) {\n\n            *pden *= 2;\n\n            *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1078, "prediction": "0", "true_label": "1", "raw_text": ") {\n            timeout = 0;\n        }\n        if (select_ret > 0) {\n            pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds);\n        }\n    }\n    g_main_context_prepare(context, &max_priority);\n    n_poll_fds = g_main_context_query(context, max_priority, &poll_timeout,\n                                      poll_fds, ARRAY_SIZE(poll_fds));\n    g_assert(n_poll_fds <= ARRAY_SIZE(poll_fds));\n    for (i = 0; i < w->num; i++) {\n        poll_fds[n_poll_fds + i].fd = (DWORD_PTR)w->events[i];\n        poll_fds[n_poll_fds + i].events = G_IO_IN;\n    }\n    if (poll_timeout < 0) {\n        poll_timeout_ns = -1;\n    } else {\n        poll_timeout_ns = (int64_t)poll_timeout * (int64_t)SCALE_MS;\n    }\n    poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);\n    qemu_mutex_unlock_iothread();\n    g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);\n    qemu_mutex_lock_iothread();\n    if (g_poll_ret > 0) {\n        for (i = 0; i < w->num; i++) {\n            w->revents[i] = poll_fds[n_poll_fds + i].revents;\n        }\n        for (i = 0; i < w->num; i++) {\n            if (w->revents[i] && w->func[i]) {\n                w->func[i](w->opaque[i]);\n            }\n        }\n    }\n    if (g_main_context_check(context, max_priority, poll_fds, n_poll_fds)) {\n        g_main_context_dispatch(context);\n    }\n    return select_ret || g_poll_ret;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1079, "prediction": "1", "true_label": "1", "raw_text": "Question: int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (drv->bdrv_snapshot_delete) {\n\n        return drv->bdrv_snapshot_delete(bs, snapshot_id);\n\n    }\n\n    if (bs->file) {\n\n        return bdrv_snapshot_delete(bs->file, snapshot_id);\n\n    }\n\n    return -ENOTSUP;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1080, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint32_t val;\n\n\n\n    val = bswap32(cpu_inl(addr & IOPORTS_MASK));\n\n    return val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1081, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qemu_fill_buffer(QEMUFile *f)\n\n{\n\n    int len;\n\n\n\n    if (f->is_writable)\n\n        return;\n\n    if (f->is_file) {\n\n        fseek(f->outfile, f->buf_offset, SEEK_SET);\n\n        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);\n\n        if (len < 0)\n\n            len = 0;\n\n    } else {\n\n        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,\n\n                         f->buf, IO_BUF_SIZE);\n\n        if (len < 0)\n\n            len = 0;\n\n    }\n\n    f->buf_index = 0;\n\n    f->buf_size = len;\n\n    f->buf_offset += len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1082, "prediction": "0", "true_label": "0", "raw_text": "Question: void net_hub_check_clients(void)\n\n{\n\n    NetHub *hub;\n\n    NetHubPort *port;\n\n    NetClientState *peer;\n\n\n\n    QLIST_FOREACH(hub, &hubs, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QLIST_FOREACH(port, &hub->ports, next) {\n\n            peer = port->nc.peer;\n\n            if (!peer) {\n\n                fprintf(stderr, \"Warning: hub port %s has no peer\\n\",\n\n                        port->nc.name);\n\n                continue;\n\n            }\n\n\n\n            switch (peer->info->type) {\n\n            case NET_CLIENT_DRIVER_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_DRIVER_USER:\n\n            case NET_CLIENT_DRIVER_TAP:\n\n            case NET_CLIENT_DRIVER_SOCKET:\n\n            case NET_CLIENT_DRIVER_VDE:\n\n            case NET_CLIENT_DRIVER_VHOST_USER:\n\n                has_host_dev = 1;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic) {\n\n            warn_report(\"vlan %d with no nics\", hub->id);\n\n        }\n\n        if (has_nic && !has_host_dev) {\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    hub->id);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1083, "prediction": "1", "true_label": "0", "raw_text": "Question: DVDemuxContext* dv_init_demux(AVFormatContext *s)\n\n{\n\n    DVDemuxContext *c;\n\n\n\n    c = av_mallocz(sizeof(DVDemuxContext));\n\n    if (!c)\n\n        return NULL;\n\n\n\n    c->vst = av_new_stream(s, 0);\n\n    c->ast[0] = av_new_stream(s, 0);\n\n    if (!c->vst || !c->ast[0])\n\n        goto fail;\n\n    av_set_pts_info(c->vst, 64, 1, 30000);\n\n    av_set_pts_info(c->ast[0], 64, 1, 30000);\n\n\n\n    c->fctx = s;\n\n    c->ast[1] = NULL;\n\n    c->ach = 0;\n\n    c->frames = 0;\n\n    c->abytes = 0;\n\n    c->audio_pkt[0].size = 0;\n\n    c->audio_pkt[1].size = 0;\n\n    \n\n    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;\n\n    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;\n\n    c->vst->codec.bit_rate = 25000000;\n\n    \n\n    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;\n\n    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;\n\n   \n\n    s->ctx_flags |= AVFMTCTX_NOHEADER; \n\n    \n\n    return c;\n\n    \n\nfail:\n\n    if (c->vst)\n\n        av_free(c->vst);\n\n    if (c->ast[0])\n\n        av_free(c->ast[0]);\n\n    av_free(c);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1084, "prediction": "0", "true_label": "0", "raw_text": "co_pwrite_zeroes(bs, offset, num,\n\n                                             flags & bs->supported_zero_flags);\n\n            if (ret != -ENOTSUP && (flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_zero_flags & BDRV_REQ_FUA)) {\n\n                need_flush = true;\n\n            }\n\n        } else {\n\n            assert(!bs->supported_zero_flags);\n\n        }\n\n\n\n        if (ret == -ENOTSUP) {\n\n            /* Fall back to bounce buffer if write zeroes is unsupported */\n\n            BdrvRequestFlags write_flags = flags & ~BDRV_REQ_ZERO_WRITE;\n\n\n\n            if ((flags & BDRV_REQ_FUA) &&\n\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n\n                /* No need for bdrv_driver_pwrite() to do a fallback\n\n                 * flush on each chunk; use just one at the end */\n\n                write_flags &= ~BDRV_REQ_FUA;\n\n                need_flush = true;\n\n            }\n\n            num = MIN(num, max_transfer);\n\n            iov.iov_len = num;\n\n            if (iov.iov_base == NULL) {\n\n                iov.iov_base = qemu_try_blockalign(bs, num);\n\n                if (iov.iov_base == NULL) {\n\n                    ret = -ENOMEM;\n\n                    goto fail;\n\n                }\n\n                memset(iov.iov_base, 0, num);\n\n            }\n\n            qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n            ret = bdrv_driver_pwritev(bs, offset, num, &qiov, write_flags);\n\n\n\n            /* Keep bounce buffer around if it is big enough for all\n\n             * all future requests.\n\n             */\n\n            if (num < max_transfer) {\n\n                qemu_vfree(iov.iov_base);\n\n                iov.iov_base = NULL;\n\n            }\n\n        }\n\n\n\n        offset += num;\n\n        bytes -= num;\n\n    }\n\n\n\nfail:\n\n    if (ret == 0 && need_flush) {\n\n        ret = bdrv_co_flush(bs);\n\n    }\n\n    qemu_vfree(iov.iov_base);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1085, "prediction": "0", "true_label": "0", "raw_text": "Question: static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_put_be32s(f, &q->queue[i]);\n\n\n\n    qemu_put_sbe32s(f, &q->next);\n\n    qemu_put_sbe32s(f, &q->priority);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1086, "prediction": "0", "true_label": "0", "raw_text": "_EPCHAR_H)) {\n\n\n\n        /*  EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */\n\n        if (ehci->usbsts & USBSTS_REC) {\n\n            ehci_clear_usbsts(ehci, USBSTS_REC);\n\n        } else {\n\n            DPRINTF(\"FETCHQH:  QH 0x%08x. H-bit set, reclamation status reset\"\n\n                       \" - done processing\\n\", q->qhaddr);\n\n            ehci_set_state(ehci, async, EST_ACTIVE);\n\n            q = NULL;\n\n            goto out;\n\n        }\n\n    }\n\n\n\n#if EHCI_DEBUG\n\n    if (q->qhaddr != q->qh.next) {\n\n    DPRINTF(\"FETCHQH:  QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\",\n\n               q->qhaddr,\n\n               q->qh.epchar & QH_EPCHAR_H,\n\n               q->qh.token & QTD_TOKEN_HALT,\n\n               q->qh.token & QTD_TOKEN_ACTIVE,\n\n               q->qh.next);\n\n    }\n\n#endif\n\n\n\n    reload = get_field(q->qh.epchar, QH_EPCHAR_RL);\n\n    if (reload) {\n\n        set_field(&q->qh.altnext_qtd, reload, QH_ALTNEXT_NAKCNT);\n\n    }\n\n\n\n    if (q->qh.token & QTD_TOKEN_HALT) {\n\n        ehci_set_state(ehci, async, EST_HORIZONTALQH);\n\n\n\n    } else if ((q->qh.token & QTD_TOKEN_ACTIVE) && (q->qh.current_qtd > 0x1000)) {\n\n        q->qtdaddr = q->qh.current_qtd;\n\n        ehci_set_state(ehci, async, EST_FETCHQTD);\n\n\n\n    } else {\n\n        /*  EHCI spec version 1.0 Section 4.10.2 */\n\n        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);\n\n    }\n\n\n\nout:\n\n    return q;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1087, "prediction": "0", "true_label": "0", "raw_text": "Question: static void omap_rtc_reset(struct omap_rtc_s *s)\n\n{\n\n    struct tm tm;\n\n\n\n    s->interrupts = 0;\n\n    s->comp_reg = 0;\n\n    s->running = 0;\n\n    s->pm_am = 0;\n\n    s->auto_comp = 0;\n\n    s->round = 0;\n\n    s->tick = qemu_get_clock(rt_clock);\n\n    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));\n\n    s->alarm_tm.tm_mday = 0x01;\n\n    s->status = 1 << 7;\n\n    qemu_get_timedate(&tm, 0);\n\n    s->ti = mktimegm(&tm);\n\n\n\n    omap_rtc_alarm_update(s);\n\n    omap_rtc_tick(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1088, "prediction": "0", "true_label": "1", "raw_text": "->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    PXA2xxState *mpu;\n\n    TC6393xbState *tmio;\n\n    DeviceState *scp0, *scp1;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa255\";\n\n\n\n    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);\n\n\n\n    memory_region_init_ram(rom, NULL, \"tosa.rom\", TOSA_ROM, &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n    tmio = tc6393xb_init(address_space_mem, 0x10000000,\n\n            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));\n\n\n\n    scp0 = sysbus_create_simple(\"scoop\", 0x08800000, NULL);\n\n    scp1 = sysbus_create_simple(\"scoop\", 0x14800040, NULL);\n\n\n\n    tosa_gpio_setup(mpu, scp0, scp1, tmio);\n\n\n\n    tosa_microdrive_attach(mpu);\n\n\n\n    tosa_tg_init(mpu);\n\n\n\n    tosa_binfo.kernel_filename = kernel_filename;\n\n    tosa_binfo.kernel_cmdline = kernel_cmdline;\n\n    tosa_binfo.initrd_filename = initrd_filename;\n\n    tosa_binfo.board_id = 0x208;\n\n    arm_load_kernel(mpu->cpu, &tosa_binfo);\n\n    sl_bootparam_write(SL_PXA_PARAM_BASE);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1089, "prediction": "1", "true_label": "1", "raw_text": "Question: static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 1090, "prediction": "0", "true_label": "1", "raw_text": "Question: struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1091, "prediction": "0", "true_label": "0", "raw_text": "fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    // Write the initial BAT\n\n    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    memset(buf, 0xFF, 512);\n\n    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {\n\n        if (write(fd, buf, 512) != 512) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    // Prepare the Dynamic Disk Header\n\n    memset(buf, 0, 1024);\n\n\n\n    memcpy(dyndisk_header->magic, \"cxsparse\", 8);\n\n\n\n    /*\n\n     * Note: The spec is actually wrong here for data_offset, it says\n\n     * 0xFFFFFFFF, but MS tools expect all 64 bits to be set.\n\n     */\n\n    dyndisk_header->data_offset = be64_to_cpu(0xFFFFFFFFFFFFFFFFULL);\n\n    dyndisk_header->table_offset = be64_to_cpu(3 * 512);\n\n    dyndisk_header->version = be32_to_cpu(0x00010000);\n\n    dyndisk_header->block_size = be32_to_cpu(block_size);\n\n    dyndisk_header->max_table_entries = be32_to_cpu(num_bat_entries);\n\n\n\n    dyndisk_header->checksum = be32_to_cpu(vpc_checksum(buf, 1024));\n\n\n\n    // Write the header\n\n    if (lseek(fd, 512, SEEK_SET) < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    if (write(fd, buf, 1024) != 1024) {\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1092, "prediction": "0", "true_label": "0", "raw_text": "Question: static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count < 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        return snap_count;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1093, "prediction": "0", "true_label": "0", "raw_text": "\n\n                *fsr = 0x00d; /* permission fault */\n\n                return true;\n\n            }\n\n\n\n            matchregion = n;\n\n            hit = true;\n\n\n\n            if (base & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region base\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, base, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n            if ((limit + 1) & ~TARGET_PAGE_MASK) {\n\n                qemu_log_mask(LOG_UNIMP,\n\n                              \"MPU_RBAR[%d]: No support for MPU region limit\"\n\n                              \"address of 0x%\" PRIx32 \". Minimum alignment is \"\n\n                              \"%d\\n\",\n\n                              n, limit, TARGET_PAGE_BITS);\n\n                continue;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!hit) {\n\n        /* background fault */\n\n        *fsr = 0;\n\n        return true;\n\n    }\n\n\n\n    if (matchregion == -1) {\n\n        /* hit using the background region */\n\n        get_phys_addr_pmsav7_default(env, mmu_idx, address, prot);\n\n    } else {\n\n        uint32_t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2);\n\n        uint32_t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1);\n\n\n\n        if (m_is_system_region(env, address)) {\n\n            /* System space is always execute never */\n\n            xn = 1;\n\n        }\n\n\n\n        *prot = simple_ap_to_rw_prot(env, mmu_idx, ap);\n\n        if (*prot && !xn) {\n\n            *prot |= PAGE_EXEC;\n\n        }\n\n        /* We don't need to look the attribute up in the MAIR0/MAIR1\n\n         * registers because that only tells us about cacheability.\n\n         */\n\n    }\n\n\n\n    *fsr = 0x00d; /* Permission fault */\n\n    return !(*prot & (1 << access_type));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1094, "prediction": "0", "true_label": "1", "raw_text": "Question: static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,\n\n                           uint64_t off, uint32_t max_count)\n\n{\n\n    ssize_t err;\n\n    size_t offset = 7;\n\n    int read_count;\n\n    int64_t xattr_len;\n\n    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);\n\n    VirtQueueElement *elem = v->elems[pdu->idx];\n\n\n\n    xattr_len = fidp->fs.xattr.len;\n\n    read_count = xattr_len - off;\n\n    if (read_count > max_count) {\n\n        read_count = max_count;\n\n    } else if (read_count < 0) {\n\n        /*\n\n         * read beyond XATTR value\n\n         */\n\n        read_count = 0;\n\n    }\n\n    err = pdu_marshal(pdu, offset, \"d\", read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n\n\n    err = v9fs_pack(elem->in_sg, elem->in_num, offset,\n\n                    ((char *)fidp->fs.xattr.value) + off,\n\n                    read_count);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n    offset += err;\n\n    return offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1095, "prediction": "0", "true_label": "1", "raw_text": "Question: static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1096, "prediction": "0", "true_label": "1", "raw_text": " }\n\n\n\n            /* go over the rest */\n\n            while (i < slen && old_buf[i] == new_buf[i]) {\n\n                zrun_len++;\n\n                i++;\n\n            }\n\n        }\n\n\n\n        /* buffer unchanged */\n\n        if (zrun_len == slen) {\n\n            return 0;\n\n        }\n\n\n\n        /* skip last zero run */\n\n        if (i == slen) {\n\n            return d;\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, zrun_len);\n\n\n\n        zrun_len = 0;\n\n        nzrun_start = new_buf + i;\n\n\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] != new_buf[i]) {\n\n            i++;\n\n            nzrun_len++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed, use of 32-bit long okay */\n\n        if (!res) {\n\n            /* truncation to 32-bit long okay */\n\n            long mask = (long)0x0101010101010101ULL;\n\n            while (i < slen) {\n\n                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);\n\n                if ((xor - mask) & ~xor & (mask << 7)) {\n\n                    /* found the end of an nzrun within the current long */\n\n                    while (old_buf[i] != new_buf[i]) {\n\n                        nzrun_len++;\n\n                        i++;\n\n                    }\n\n                    break;\n\n                } else {\n\n                    i += sizeof(long);\n\n                    nzrun_len += sizeof(long);\n\n                }\n\n            }\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, nzrun_len);\n\n        /* overflow */\n\n        if (d + nzrun_len > dlen) {\n\n            return -1;\n\n        }\n\n        memcpy(dst + d, nzrun_start, nzrun_len);\n\n        d += nzrun_len;\n\n        nzrun_len = 0;\n\n    }\n\n\n\n    return d;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1097, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold void init_atrac3_transforms(ATRAC3Context *q) {\n\n    float enc_window[256];\n\n    int i;\n\n\n\n    /* Generate the mdct window, for details see\n\n     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */\n\n    for (i=0 ; i<256; i++)\n\n        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;\n\n\n\n    if (!mdct_window[0])\n\n        for (i=0 ; i<256; i++) {\n\n            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);\n\n            mdct_window[511-i] = mdct_window[i];\n\n        }\n\n\n\n    /* Initialize the MDCT transform. */\n\n    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1098, "prediction": "0", "true_label": "1", "raw_text": ")\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1099, "prediction": "1", "true_label": "1", "raw_text": "Question: void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)\n\n{\n\n    LM32JuartState *s = LM32_JUART(d);\n\n    unsigned char ch = jtx & 0xff;\n\n\n\n    trace_lm32_juart_set_jtx(s->jtx);\n\n\n\n    s->jtx = jtx;\n\n    if (s->chr) {\n\n\n\n        qemu_chr_fe_write_all(s->chr, &ch, 1);\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1100, "prediction": "0", "true_label": "1", "raw_text": "Question: static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n\n                                    AVPacket *pkt, uint64_t display_duration)\n\n{\n\n    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',')\n\n        layer = ++ptr;\n\n    for (; *ptr!=',' && ptr<end-1; ptr++);\n\n    if (*ptr == ',') {\n\n        int64_t end_pts = pkt->pts + display_duration;\n\n        int sc = matroska->time_scale * pkt->pts / 10000000;\n\n        int ec = matroska->time_scale * end_pts  / 10000000;\n\n        int sh, sm, ss, eh, em, es, len;\n\n        sh = sc/360000;  sc -= 360000*sh;\n\n        sm = sc/  6000;  sc -=   6000*sm;\n\n        ss = sc/   100;  sc -=    100*ss;\n\n        eh = ec/360000;  ec -= 360000*eh;\n\n        em = ec/  6000;  ec -=   6000*em;\n\n        es = ec/   100;  ec -=    100*es;\n\n        *ptr++ = '\\0';\n\n        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;\n\n        if (!(line = av_malloc(len)))\n\n            return;\n\n        snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\",\n\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);\n\n        av_free(pkt->data);\n\n        pkt->data = line;\n\n        pkt->size = strlen(line);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1101, "prediction": "1", "true_label": "0", "raw_text": "Question: send_msg(\n\n    VSCMsgType type,\n\n    uint32_t reader_id,\n\n    const void *msg,\n\n    unsigned int length\n\n) {\n\n    VSCMsgHeader mhHeader;\n\n\n\n    qemu_mutex_lock(&socket_to_send_lock);\n\n\n\n    if (verbose > 10) {\n\n        printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\",\n\n               type, reader_id, length, length);\n\n    }\n\n\n\n    mhHeader.type = htonl(type);\n\n    mhHeader.reader_id = 0;\n\n    mhHeader.length = htonl(length);\n\n    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));\n\n    g_byte_array_append(socket_to_send, (guint8 *)msg, length);\n\n    g_idle_add(socket_prepare_sending, NULL);\n\n\n\n    qemu_mutex_unlock(&socket_to_send_lock);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1102, "prediction": "0", "true_label": "0", "raw_text": "Question: void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){\n\n    int i, j;\n\n    int dc = (((dctcoef*)block)[0] + 32) >> 6;\n\n    pixel *dst = (pixel*)_dst;\n\n    stride >>= sizeof(pixel)-1;\n\n    for( j = 0; j < 4; j++ )\n\n    {\n\n        for( i = 0; i < 4; i++ )\n\n            dst[i] = av_clip_pixel( dst[i] + dc );\n\n        dst += stride;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1103, "prediction": "0", "true_label": "0", "raw_text": " width;\n\n        int Rc[3] = { 0, 0, 0 };\n\n\n\n        width = avctx->width * 3;\n\n        for (i = 0; i < avctx->height; i++) {\n\n            for (j = 2; j >= 0; j--) {\n\n                ls_encode_line(state, &pb2, last + j, cur + j, Rc[j],\n\n                               width, 3, j, 8);\n\n                Rc[j] = last[j];\n\n            }\n\n            last = cur;\n\n            cur += p->linesize[0];\n\n        }\n\n    }\n\n\n\n    av_freep(&zero);\n\n    av_freep(&state);\n\n\n\n    /* the specification says that after doing 0xff escaping unused bits in\n\n     * the last byte must be set to 0, so just append 7 \"optional\" zero-bits\n\n     * to avoid special-casing. */\n\n    put_bits(&pb2, 7, 0);\n\n    size = put_bits_count(&pb2);\n\n    flush_put_bits(&pb2);\n\n    /* do escape coding */\n\n    init_get_bits(&gb, buf2, size);\n\n    size -= 7;\n\n    while (get_bits_count(&gb) < size) {\n\n        int v;\n\n        v = get_bits(&gb, 8);\n\n        put_bits(&pb, 8, v);\n\n        if (v == 0xFF) {\n\n            v = get_bits(&gb, 7);\n\n            put_bits(&pb, 8, v);\n\n        }\n\n    }\n\n    avpriv_align_put_bits(&pb);\n\n    av_freep(&buf2);\n\n\n\n    /* End of image */\n\n    put_marker(&pb, EOI);\n\n    flush_put_bits(&pb);\n\n\n\n    emms_c();\n\n\n\n    pkt->size   = put_bits_count(&pb) >> 3;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n    return 0;\n\n\n\nmemfail:\n\n    av_packet_unref(pkt);\n\n    av_freep(&buf2);\n\n    av_freep(&state);\n\n    av_freep(&zero);\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1104, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_vc1_decode_blocks(VC1Context *v)\n\n{\n\n\n\n    v->s.esc3_level_length = 0;\n\n    if (v->x8_type) {\n\n        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);\n\n\n\n        ff_er_add_slice(&v->s.er, 0, 0,\n\n                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n    } else {\n\n        v->cur_blk_idx     =  0;\n\n        v->left_blk_idx    = -1;\n\n        v->topleft_blk_idx =  1;\n\n        v->top_blk_idx     =  2;\n\n        switch (v->s.pict_type) {\n\n        case AV_PICTURE_TYPE_I:\n\n            if (v->profile == PROFILE_ADVANCED)\n\n                vc1_decode_i_blocks_adv(v);\n\n            else\n\n                vc1_decode_i_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_P:\n\n            if (v->p_frame_skipped)\n\n                vc1_decode_skip_blocks(v);\n\n            else\n\n                vc1_decode_p_blocks(v);\n\n            break;\n\n        case AV_PICTURE_TYPE_B:\n\n            if (v->bi_type) {\n\n                if (v->profile == PROFILE_ADVANCED)\n\n                    vc1_decode_i_blocks_adv(v);\n\n                else\n\n                    vc1_decode_i_blocks(v);\n\n            } else\n\n                vc1_decode_b_blocks(v);\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1105, "prediction": "0", "true_label": "1", "raw_text": "Question: paint_mouse_pointer(XImage *image, struct x11_grab *s)\n\n{\n\n    int x_off = s->x_off;\n\n    int y_off = s->y_off;\n\n    int width = s->width;\n\n    int height = s->height;\n\n    Display *dpy = s->dpy;\n\n    XFixesCursorImage *xcim;\n\n    int x, y;\n\n    int line, column;\n\n    int to_line, to_column;\n\n    int image_addr, xcim_addr;\n\n\n\n    xcim = XFixesGetCursorImage(dpy);\n\n\n\n    x = xcim->x - xcim->xhot;\n\n    y = xcim->y - xcim->yhot;\n\n\n\n    to_line = FFMIN((y + xcim->height), (height + y_off));\n\n    to_column = FFMIN((x + xcim->width), (width + x_off));\n\n\n\n    for (line = FFMAX(y, y_off); line < to_line; line++) {\n\n        for (column = FFMAX(x, x_off); column < to_column; column++) {\n\n            xcim_addr = (line - y) * xcim->width + column - x;\n\n\n\n            if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel\n\n                image_addr = ((line - y_off) * width + column - x_off) * 4;\n\n\n\n                image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);\n\n                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);\n\n                image->data[image_addr+2] = (unsigned char)(xcim->pixels[xcim_addr] >> 16);\n\n            }\n\n        }\n\n    }\n\n\n\n    XFree(xcim);\n\n    xcim = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1106, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint64_t boston_platreg_read(void *opaque, hwaddr addr,\n\n                                    unsigned size)\n\n{\n\n    BostonState *s = opaque;\n\n    uint32_t gic_freq, val;\n\n\n\n    if (size != 4) {\n\n        qemu_log_mask(LOG_UNIMP, \"%uB platform register read\", size);\n\n        return 0;\n\n    }\n\n\n\n    switch (addr & 0xffff) {\n\n    case PLAT_FPGA_BUILD:\n\n    case PLAT_CORE_CL:\n\n    case PLAT_WRAPPER_CL:\n\n        return 0;\n\n    case PLAT_DDR3_STATUS:\n\n        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;\n\n    case PLAT_MMCM_DIV:\n\n        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;\n\n        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;\n\n        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;\n\n        return val;\n\n    case PLAT_BUILD_CFG:\n\n        val = PLAT_BUILD_CFG_PCIE0_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE1_EN;\n\n        val |= PLAT_BUILD_CFG_PCIE2_EN;\n\n        return val;\n\n    case PLAT_DDR_CFG:\n\n        val = s->mach->ram_size / G_BYTE;\n\n        assert(!(val & ~PLAT_DDR_CFG_SIZE));\n\n        val |= PLAT_DDR_CFG_MHZ;\n\n        return val;\n\n    default:\n\n        qemu_log_mask(LOG_UNIMP, \"Read platform register 0x%\" HWADDR_PRIx,\n\n                      addr & 0xffff);\n\n        return 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1107, "prediction": "1", "true_label": "0", "raw_text": "Question: int avfilter_register(AVFilter *filter)\n\n{\n\n    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)\n\n        return -1;\n\n\n\n    registered_avfilters[next_registered_avfilter_idx++] = filter;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1108, "prediction": "1", "true_label": "1", "raw_text": "Question: void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1109, "prediction": "0", "true_label": "1", "raw_text": "device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1110, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,\n\n                                             ptrdiff_t buf_stride,\n\n                                             ptrdiff_t src_stride,\n\n                                             int block_w, int block_h,\n\n                                             int src_x, int src_y, int w, int h)\n\n{\n\n    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,\n\n                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,\n\n                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1111, "prediction": "0", "true_label": "1", "raw_text": " AV_RB16(tx3g_ptr);\n\n    tx3g_ptr += 2;\n\n\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n\n\n        box_size += 3;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp = av_malloc(sizeof(*m->ftab_temp));\n\n        if (!m->ftab_temp) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        m->ftab_temp->fontID = AV_RB16(tx3g_ptr);\n\n        tx3g_ptr += 2;\n\n        font_length = *tx3g_ptr++;\n\n\n\n        box_size = box_size + font_length;\n\n        if (avctx->extradata_size < box_size) {\n\n            mov_text_cleanup_ftab(m);\n\n            m->ftab_entries = 0;\n\n            return -1;\n\n        }\n\n        m->ftab_temp->font = av_malloc(font_length + 1);\n\n        if (!m->ftab_temp->font) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(m->ftab_temp->font, tx3g_ptr, font_length);\n\n        m->ftab_temp->font[font_length] = '\\0';\n\n        av_dynarray_add(&m->ftab, &m->count_f, m->ftab_temp);\n\n        if (!m->ftab) {\n\n            mov_text_cleanup_ftab(m);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        tx3g_ptr = tx3g_ptr + font_length;\n\n    }\n\n    for (i = 0; i < m->ftab_entries; i++) {\n\n        if (style_fontID == m->ftab[i]->fontID)\n\n            m->d.font = m->ftab[i]->font;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1112, "prediction": "0", "true_label": "1", "raw_text": "Question: static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1113, "prediction": "0", "true_label": "1", "raw_text": "Question: int qemu_init_main_loop(void)\n\n{\n\n    int ret;\n\n\n\n    ret = qemu_signal_init();\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_init_sigbus();\n\n\n\n    return qemu_event_init();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1114, "prediction": "0", "true_label": "1", "raw_text": "Question: envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1115, "prediction": "0", "true_label": "0", "raw_text": "s);\n\n        ff_end_tag(pb, avi->movi_list);\n\n\n\n        if (avi->riff_id == 1)\n\n            avi_write_idx1(s);\n\n\n\n        ff_end_tag(pb, avi->riff_start);\n\n        avi->movi_list = avi_start_new_riff(s, pb, \"AVIX\", \"movi\");\n\n    }\n\n\n\n    avi_stream2fourcc(tag, stream_index, par->codec_type);\n\n    if (pkt->flags & AV_PKT_FLAG_KEY)\n\n        flags = 0x10;\n\n    if (par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avist->audio_strm_length += size;\n\n\n\n    if (s->pb->seekable) {\n\n        int err;\n\n        AVIIndex *idx = &avist->indexes;\n\n        int cl = idx->entry / AVI_INDEX_CLUSTER_SIZE;\n\n        int id = idx->entry % AVI_INDEX_CLUSTER_SIZE;\n\n        if (idx->ents_allocated <= idx->entry) {\n\n            if ((err = av_reallocp(&idx->cluster,\n\n                                   (cl + 1) * sizeof(*idx->cluster))) < 0) {\n\n                idx->ents_allocated = 0;\n\n                idx->entry          = 0;\n\n                return err;\n\n            }\n\n            idx->cluster[cl] =\n\n                av_malloc(AVI_INDEX_CLUSTER_SIZE * sizeof(AVIIentry));\n\n            if (!idx->cluster[cl])\n\n                return -1;\n\n            idx->ents_allocated += AVI_INDEX_CLUSTER_SIZE;\n\n        }\n\n\n\n        idx->cluster[cl][id].flags = flags;\n\n        idx->cluster[cl][id].pos   = avio_tell(pb) - avi->movi_list;\n\n        idx->cluster[cl][id].len   = size;\n\n        idx->entry++;\n\n    }\n\n\n\n    avio_write(pb, tag, 4);\n\n    avio_wl32(pb, size);\n\n    avio_write(pb, pkt->data, size);\n\n    if (size & 1)\n\n        avio_w8(pb, 0);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1116, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)\n\n{\n\n    if (err != CUDA_SUCCESS) {\n\n        av_log(avctx, AV_LOG_FATAL, \">> %s - failed with error code 0x%x\\n\", func, err);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1117, "prediction": "0", "true_label": "0", "raw_text": " \"%\"PRIu64, nb_streams_frames[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_frames\", \"N/A\");\n\n    if (nb_streams_packets[stream_idx]) print_fmt    (\"nb_read_packets\", \"%\"PRIu64, nb_streams_packets[stream_idx]);\n\n    else                                print_str_opt(\"nb_read_packets\", \"N/A\");\n\n    if (do_show_data)\n\n        writer_print_data(w, \"extradata\", dec_ctx->extradata,\n\n                                          dec_ctx->extradata_size);\n\n\n\n    /* Print disposition information */\n\n#define PRINT_DISPOSITION(flagname, name) do {                                \\\n\n        print_int(name, !!(stream->disposition & AV_DISPOSITION_##flagname)); \\\n\n    } while (0)\n\n\n\n    if (do_show_stream_disposition) {\n\n    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION);\n\n    PRINT_DISPOSITION(DEFAULT,          \"default\");\n\n    PRINT_DISPOSITION(DUB,              \"dub\");\n\n    PRINT_DISPOSITION(ORIGINAL,         \"original\");\n\n    PRINT_DISPOSITION(COMMENT,          \"comment\");\n\n    PRINT_DISPOSITION(LYRICS,           \"lyrics\");\n\n    PRINT_DISPOSITION(KARAOKE,          \"karaoke\");\n\n    PRINT_DISPOSITION(FORCED,           \"forced\");\n\n    PRINT_DISPOSITION(HEARING_IMPAIRED, \"hearing_impaired\");\n\n    PRINT_DISPOSITION(VISUAL_IMPAIRED,  \"visual_impaired\");\n\n    PRINT_DISPOSITION(CLEAN_EFFECTS,    \"clean_effects\");\n\n    PRINT_DISPOSITION(ATTACHED_PIC,     \"attached_pic\");\n\n    writer_print_section_footer(w);\n\n    }\n\n\n\n    show_tags(w, stream->metadata, in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS);\n\n\n\n    writer_print_section_footer(w);\n\n    av_bprint_finalize(&pbuf, NULL);\n\n    fflush(stdout);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1118, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n\n                            const uint32_t *quant) {\n\n    int coeff, i, n;\n\n    int8_t ac;\n\n    uint8_t dc = get_bits(gb, 8);\n\n\n\n    // block not coded\n\n    if (dc == 255)\n\n\n\n\n    // number of non-zero coefficients\n\n    coeff = get_bits(gb, 6);\n\n    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n\n\n\n\n    // normally we would only need to clear the (63 - coeff) last values,\n\n    // but since we do not know where they are we just clear the whole block\n\n    memset(block, 0, 64 * sizeof(DCTELEM));\n\n\n\n    // 2 bits per coefficient\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 2);\n\n        if (ac == -2)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 4 bits per coefficient\n\n    ALIGN(4);\n\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 4);\n\n        if (ac == -8)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 8 bits per coefficient\n\n    ALIGN(8);\n\n    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 8);\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    PUT_COEFF(dc);\n\n    return 1;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1119, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_neon_trn_u16(TCGv t0, TCGv t1)\n\n{\n\n    TCGv rd, tmp;\n\n\n\n    rd = new_tmp();\n\n    tmp = new_tmp();\n\n\n\n    tcg_gen_shli_i32(rd, t0, 16);\n\n    tcg_gen_andi_i32(tmp, t1, 0xffff);\n\n    tcg_gen_or_i32(rd, rd, tmp);\n\n    tcg_gen_shri_i32(t1, t1, 16);\n\n    tcg_gen_andi_i32(tmp, t0, 0xffff0000);\n\n    tcg_gen_or_i32(t1, t1, tmp);\n\n    tcg_gen_mov_i32(t0, rd);\n\n\n\n    dead_tmp(tmp);\n\n    dead_tmp(rd);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1120, "prediction": "0", "true_label": "0", "raw_text": "Question: static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)\n\n{\n\n    if (buf_size < 13)\n\n        return AVERROR_INVALIDDATA;\n\n    if (memcmp(buf, \"FLV\", 3))\n\n        return AVERROR_INVALIDDATA;\n\n    buf      += 13;\n\n    buf_size -= 13;\n\n    while (buf_size >= 11 + 4) {\n\n        int type = buf[0];\n\n        int size = AV_RB24(&buf[1]) + 11 + 4;\n\n        if (size > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n        if (type == 8 || type == 9) {\n\n            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))\n\n                return AVERROR_INVALIDDATA;\n\n            os->extra_packet_sizes[os->nb_extra_packets] = size;\n\n            os->extra_packets[os->nb_extra_packets] = av_malloc(size);\n\n            if (!os->extra_packets[os->nb_extra_packets])\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);\n\n            os->nb_extra_packets++;\n\n        } else if (type == 0x12) {\n\n            if (os->metadata)\n\n                return AVERROR_INVALIDDATA;\n\n            os->metadata_size = size - 11 - 4;\n\n            os->metadata      = av_malloc(os->metadata_size);\n\n            if (!os->metadata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(os->metadata, buf + 11, os->metadata_size);\n\n        }\n\n        buf      += size;\n\n        buf_size -= size;\n\n    }\n\n    if (!os->metadata)\n\n        return AVERROR_INVALIDDATA;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1121, "prediction": "1", "true_label": "1", "raw_text": "Question: restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n    __get_user(regs->CP0_EPC, &sc->sc_pc);\n\n\n\n    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);\n\n    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);\n\n\n\n    for (i = 1; i < 32; ++i) {\n\n        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);\n\n    }\n\n\n\n    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);\n\n    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);\n\n    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);\n\n    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);\n\n    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);\n\n    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);\n\n    {\n\n        uint32_t dsp;\n\n        __get_user(dsp, &sc->sc_dsp);\n\n        cpu_wrdsp(dsp, 0x3ff, regs);\n\n    }\n\n\n\n    for (i = 0; i < 32; ++i) {\n\n        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);\n\n    }\n\n\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1122, "prediction": "0", "true_label": "0", "raw_text": " = 0;\n\n\n\n    if (s->prnsts & SDHC_SPACE_AVAILABLE) {\n\n        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n            s->norintsts |= SDHC_NIS_WBUFRDY;\n\n        }\n\n        sdhci_update_irq(s);\n\n        return;\n\n    }\n\n\n\n    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {\n\n        if (s->blkcnt == 0) {\n\n            return;\n\n        } else {\n\n            s->blkcnt--;\n\n        }\n\n    }\n\n\n\n    for (index = 0; index < (s->blksize & 0x0fff); index++) {\n\n        sd_write_data(s->card, s->fifo_buffer[index]);\n\n    }\n\n\n\n    /* Next data can be written through BUFFER DATORT register */\n\n    s->prnsts |= SDHC_SPACE_AVAILABLE;\n\n\n\n    /* Finish transfer if that was the last block of data */\n\n    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||\n\n            ((s->trnmod & SDHC_TRNS_MULTI) &&\n\n            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {\n\n        s->norintsts |= SDHC_NIS_WBUFRDY;\n\n    }\n\n\n\n    /* Generate Block Gap Event if requested and if not the last block */\n\n    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&\n\n            s->blkcnt > 0) {\n\n        s->prnsts &= ~SDHC_DOING_WRITE;\n\n        if (s->norintstsen & SDHC_EISEN_BLKGAP) {\n\n            s->norintsts |= SDHC_EIS_BLKGAP;\n\n        }\n\n        SDHCI_GET_CLASS(s)->end_data_transfer(s);\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1123, "prediction": "0", "true_label": "0", "raw_text": "Question: static AHCIQState *ahci_boot(void)\n\n{\n\n    AHCIQState *s;\n\n    const char *cli;\n\n\n\n    s = g_malloc0(sizeof(AHCIQState));\n\n\n\n    cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\"\n\n        \",format=qcow2\"\n\n        \" -M q35 \"\n\n        \"-device ide-hd,drive=drive0 \"\n\n        \"-global ide-hd.ver=%s\";\n\n    s->parent = qtest_pc_boot(cli, tmp_path, \"testdisk\", \"version\");\n\n    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);\n\n\n\n    /* Verify that we have an AHCI device present. */\n\n    s->dev = get_ahci_device(&s->fingerprint);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1124, "prediction": "0", "true_label": "0", "raw_text": "Question: void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1125, "prediction": "0", "true_label": "0", "raw_text": "Question: mst_fpga_readb(void *opaque, target_phys_addr_t addr)\n\n{\n\n\tmst_irq_state *s = (mst_irq_state *) opaque;\n\n\n\n\tswitch (addr) {\n\n\tcase MST_LEDDAT1:\n\n\t\treturn s->leddat1;\n\n\tcase MST_LEDDAT2:\n\n\t\treturn s->leddat2;\n\n\tcase MST_LEDCTRL:\n\n\t\treturn s->ledctrl;\n\n\tcase MST_GPSWR:\n\n\t\treturn s->gpswr;\n\n\tcase MST_MSCWR1:\n\n\t\treturn s->mscwr1;\n\n\tcase MST_MSCWR2:\n\n\t\treturn s->mscwr2;\n\n\tcase MST_MSCWR3:\n\n\t\treturn s->mscwr3;\n\n\tcase MST_MSCRD:\n\n\t\treturn s->mscrd;\n\n\tcase MST_INTMSKENA:\n\n\t\treturn s->intmskena;\n\n\tcase MST_INTSETCLR:\n\n\t\treturn s->intsetclr;\n\n\tcase MST_PCMCIA0:\n\n\t\treturn s->pcmcia0;\n\n\tcase MST_PCMCIA1:\n\n\t\treturn s->pcmcia1;\n\n\tdefault:\n\n\t\tprintf(\"Mainstone - mst_fpga_readb: Bad register offset \"\n\n\t\t\t\"0x\" TARGET_FMT_plx \" \\n\", addr);\n\n\t}\n\n\treturn 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1126, "prediction": "0", "true_label": "0", "raw_text": "Question: static int pci_piix_ide_initfn(PCIIDEState *d)\n\n{\n\n    uint8_t *pci_conf = d->dev.config;\n\n\n\n    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode\n\n    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);\n\n\n\n    qemu_register_reset(piix3_reset, d);\n\n\n\n    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);\n\n\n\n    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);\n\n\n\n    pci_piix_init_ports(d);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1127, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    DeviceState *qdev = DEVICE(vpci_dev);\n\n    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);\n\n    virtio_net_set_netclient_name(&dev->vdev, qdev->id,\n\n                                  object_get_typename(OBJECT(qdev)));\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1128, "prediction": "0", "true_label": "0", "raw_text": "_realize(VIOsPAPRDevice *dev, Error **errp)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n    int ret;\n\n\n\n    if (nvram->blk) {\n\n        nvram->size = blk_getlength(nvram->blk);\n\n\n\n        ret = blk_set_perm(nvram->blk,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,\n\n                           BLK_PERM_ALL, errp);\n\n        if (ret < 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n    }\n\n\n\n    nvram->buf = g_malloc0(nvram->size);\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        error_setg(errp, \"spapr-nvram must be between %d and %d bytes in size\",\n\n                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return;\n\n    }\n\n\n\n    if (nvram->blk) {\n\n        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);\n\n\n\n        if (alen != nvram->size) {\n\n            error_setg(errp, \"can't read spapr-nvram contents\");\n\n            return;\n\n        }\n\n    } else if (nb_prom_envs > 0) {\n\n        /* Create a system partition to pass the -prom-env variables */\n\n        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);\n\n        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],\n\n                                         nvram->size - MIN_NVRAM_SIZE / 4);\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_NVRAM_FETCH, \"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(RTAS_NVRAM_STORE, \"nvram-store\", rtas_nvram_store);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1129, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO.\n"}], [{"ID": 1130, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,\n\n                                    const uint8_t *src1, const uint8_t *src2,\n\n                                    long width, uint32_t *unused)\n\n{\n\n    RENAME(nvXXtoUV)(dstU, dstV, src1, width);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1131, "prediction": "0", "true_label": "0", "raw_text": "Question: int ff_thread_init(AVCodecContext *avctx)\n\n{\n\n    if (avctx->thread_opaque) {\n\n        av_log(avctx, AV_LOG_ERROR, \"avcodec_thread_init is ignored after avcodec_open\\n\");\n\n        return -1;\n\n    }\n\n\n\n#if HAVE_W32THREADS\n\n    w32thread_init();\n\n#endif\n\n\n\n    if (avctx->codec) {\n\n        validate_thread_parameters(avctx);\n\n\n\n        if (avctx->active_thread_type&FF_THREAD_SLICE)\n\n            return thread_init(avctx);\n\n        else if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            return frame_thread_init(avctx);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1132, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1133, "prediction": "0", "true_label": "0", "raw_text": "blk->conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!blk->serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(blk->conf.bs);\n\n        if (*dinfo->serial) {\n\n            blk->serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = blk->conf.bs;\n\n    s->conf = &blk->conf;\n\n    s->blk = blk;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, s->conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(s->conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1134, "prediction": "1", "true_label": "1", "raw_text": "2_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                src = src8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n            return -1;\n            break;\n        samples = (short *) dst_int32_t;\n        break;\n    case CODEC_ID_PCM_LXF:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        //unpack and de-planerize\n        for (i = 0; i < n; i++) {\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract low 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract high 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n        src += n * avctx->channels * 5;\n        samples = (short *) dst_int32_t;\n        break;\n    default:\n        return -1;\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n    return src - buf;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1135, "prediction": "0", "true_label": "1", "raw_text": "Question: static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,\n\n                             uint64_t value)\n\n{\n\n    if (ri->crm > 8) {\n\n        return EXCP_UDEF;\n\n    }\n\n    env->cp15.c6_region[ri->crm] = value;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1136, "prediction": "0", "true_label": "1", "raw_text": "]);\n\n        }\n\n        printf(\"\\n=== end dumping device descriptor data ===\\n\");\n\n    }\n\n#endif\n\n\n\n\n\n    /* start unconfigured -- we'll wait for the guest to set a configuration */\n\n    if (!usb_host_claim_interfaces(dev, 0)) {\n\n        goto fail;\n\n    }\n\n\n\n    usb_ep_init(&dev->dev);\n\n    usb_linux_update_endp_table(dev);\n\n\n\n    if (speed == -1) {\n\n        struct usbdevfs_connectinfo ci;\n\n\n\n        ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\n\n        if (ret < 0) {\n\n            perror(\"usb_host_device_open: USBDEVFS_CONNECTINFO\");\n\n            goto fail;\n\n        }\n\n\n\n        if (ci.slow) {\n\n            speed = USB_SPEED_LOW;\n\n        } else {\n\n            speed = USB_SPEED_HIGH;\n\n        }\n\n    }\n\n    dev->dev.speed = speed;\n\n    dev->dev.speedmask = (1 << speed);\n\n    if (dev->dev.speed == USB_SPEED_HIGH && usb_linux_full_speed_compat(dev)) {\n\n        dev->dev.speedmask |= USB_SPEED_MASK_FULL;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n\n\n    if (!prod_name || prod_name[0] == '\\0') {\n\n        snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    } else {\n\n        pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                prod_name);\n\n    }\n\n\n\n    ret = usb_device_attach(&dev->dev);\n\n    if (ret) {\n\n        goto fail;\n\n    }\n\n\n\n    /* USB devio uses 'write' flag to check for async completions */\n\n    qemu_set_fd_handler(dev->fd, NULL, async_complete, dev);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (dev->fd != -1) {\n\n        close(dev->fd);\n\n        dev->fd = -1;\n\n    }\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1137, "prediction": "0", "true_label": "1", "raw_text": "Question: static int esp_pci_scsi_init(PCIDevice *dev)\n\n{\n\n    PCIESPState *pci = PCI_ESP(dev);\n\n    DeviceState *d = DEVICE(dev);\n\n    ESPState *s = &pci->esp;\n\n    uint8_t *pci_conf;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* Interrupt pin A */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    s->dma_memory_read = esp_pci_dma_memory_read;\n\n    s->dma_memory_write = esp_pci_dma_memory_write;\n\n    s->dma_opaque = pci;\n\n    s->chip_id = TCHI_AM53C974;\n\n    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,\n\n                          \"esp-io\", 0x80);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);\n\n    s->irq = pci_allocate_irq(dev);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1138, "prediction": "0", "true_label": "1", "raw_text": " void copy_frame(Jpeg2000EncoderContext *s)\n\n{\n\n    int tileno, compno, i, y, x;\n\n    uint8_t *line;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){\n\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (s->planar){\n\n            for (compno = 0; compno < s->ncomponents; compno++){\n\n                Jpeg2000Component *comp = tile->comp + compno;\n\n                int *dst = comp->data;\n\n                line = s->picture.data[compno]\n\n                       + comp->coord[1][0] * s->picture.linesize[compno]\n\n                       + comp->coord[0][0];\n\n                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){\n\n                    uint8_t *ptr = line;\n\n                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)\n\n                        *dst++ = *ptr++ - (1 << 7);\n\n                    line += s->picture.linesize[compno];\n\n                }\n\n            }\n\n        } else{\n\n            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0]\n\n                   + tile->comp[0].coord[0][0] * s->ncomponents;\n\n\n\n            i = 0;\n\n            for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){\n\n                uint8_t *ptr = line;\n\n                for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){\n\n                    for (compno = 0; compno < s->ncomponents; compno++){\n\n                        tile->comp[compno].data[i] = *ptr++  - (1 << 7);\n\n                    }\n\n                }\n\n                line += s->picture.linesize[0];\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1139, "prediction": "0", "true_label": "0", "raw_text": "Question: static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return telldir(fs->dir);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1140, "prediction": "0", "true_label": "0", "raw_text": "in  = insamplesref->audio->nb_samples;\n\n    int n_out       = FFMAX(n_in * aresample->ratio * 2, 1);\n\n    AVFilterLink *const outlink = inlink->dst->outputs[0];\n\n    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);\n\n    int ret;\n\n\n\n    if(!outsamplesref)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);\n\n    outsamplesref->format                = outlink->format;\n\n    outsamplesref->audio->channel_layout = outlink->channel_layout;\n\n    outsamplesref->audio->sample_rate    = outlink->sample_rate;\n\n\n\n    if(insamplesref->pts != AV_NOPTS_VALUE) {\n\n        int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den);\n\n        int64_t outpts= swr_next_pts(aresample->swr, inpts);\n\n        aresample->next_pts =\n\n        outsamplesref->pts  = (outpts + inlink->sample_rate/2) / inlink->sample_rate;\n\n    } else {\n\n        outsamplesref->pts  = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    n_out = swr_convert(aresample->swr, outsamplesref->extended_data, n_out,\n\n                                 (void *)insamplesref->extended_data, n_in);\n\n    if (n_out <= 0) {\n\n        avfilter_unref_buffer(outsamplesref);\n\n        avfilter_unref_buffer(insamplesref);\n\n        return 0;\n\n    }\n\n\n\n    outsamplesref->audio->nb_samples  = n_out;\n\n\n\n    ret = ff_filter_samples(outlink, outsamplesref);\n\n    aresample->req_fullfilled= 1;\n\n    avfilter_unref_buffer(insamplesref);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1141, "prediction": "0", "true_label": "0", "raw_text": "Question: static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    unsigned int i, entries;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n    entries = get_be32(pb);\n\n    if(entries >= UINT_MAX / sizeof(MOV_stts_t))\n\n        return -1;\n\n\n\n    sc->ctts_count = entries;\n\n    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));\n\n    if (!sc->ctts_data)\n\n        return -1;\n\n    dprintf(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    for(i=0; i<entries; i++) {\n\n        int count    =get_be32(pb);\n\n        int duration =get_be32(pb);\n\n\n\n        if (duration < 0) {\n\n            av_log(c->fc, AV_LOG_ERROR, \"negative ctts, ignoring\\n\");\n\n            sc->ctts_count = 0;\n\n            url_fskip(pb, 8 * (entries - i - 1));\n\n            break;\n\n        }\n\n        sc->ctts_data[i].count   = count;\n\n        sc->ctts_data[i].duration= duration;\n\n\n\n        sc->time_rate= ff_gcd(sc->time_rate, duration);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1142, "prediction": "0", "true_label": "1", "raw_text": "Question: int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1143, "prediction": "0", "true_label": "1", "raw_text": "Question: void commit_active_start(BlockDriverState *bs, BlockDriverState *base,\n\n                         int64_t speed,\n\n                         BlockdevOnError on_error,\n\n                         BlockDriverCompletionFunc *cb,\n\n                         void *opaque, Error **errp)\n\n{\n\n    int64_t length, base_length;\n\n    int orig_base_flags;\n\n\n\n    orig_base_flags = bdrv_get_flags(base);\n\n\n\n    if (bdrv_reopen(base, bs->open_flags, errp)) {\n\n        return;\n\n    }\n\n\n\n    length = bdrv_getlength(bs);\n\n    if (length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", bs->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    base_length = bdrv_getlength(base);\n\n    if (base_length < 0) {\n\n        error_setg(errp, \"Unable to determine length of %s\", base->filename);\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    if (length > base_length) {\n\n        if (bdrv_truncate(base, length) < 0) {\n\n            error_setg(errp, \"Top image %s is larger than base image %s, and \"\n\n                             \"resize of base image failed\",\n\n                             bs->filename, base->filename);\n\n            goto error_restore_flags;\n\n        }\n\n    }\n\n\n\n    bdrv_ref(base);\n\n    mirror_start_job(bs, base, speed, 0, 0,\n\n                     on_error, on_error, cb, opaque, errp,\n\n                     &commit_active_job_driver, false, base);\n\n    if (error_is_set(errp)) {\n\n        goto error_restore_flags;\n\n    }\n\n\n\n    return;\n\n\n\nerror_restore_flags:\n\n    /* ignore error and errp for bdrv_reopen, because we want to propagate\n\n     * the original error */\n\n    bdrv_reopen(base, orig_base_flags, NULL);\n\n    return;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1144, "prediction": "0", "true_label": "1", "raw_text": "ZLIB: {\n        z_stream zstream = {0};\n        if (inflateInit(&zstream) != Z_OK)\n        zstream.next_in = data;\n        zstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            zstream.avail_out = pkt_size - zstream.total_out;\n            zstream.next_out = pkt_data + zstream.total_out;\n            result = inflate(&zstream, Z_NO_FLUSH);\n        } while (result==Z_OK && pkt_size<10000000);\n        pkt_size = zstream.total_out;\n        inflateEnd(&zstream);\n        if (result != Z_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n#if CONFIG_BZLIB\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n        bz_stream bzstream = {0};\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n        bzstream.next_in = data;\n        bzstream.avail_in = isize;\n        do {\n            pkt_size *= 3;\n            pkt_data = av_realloc(pkt_data, pkt_size);\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n            result = BZ2_bzDecompress(&bzstream);\n        } while (result==BZ_OK && pkt_size<10000000);\n        pkt_size = bzstream.total_out_lo32;\n        BZ2_bzDecompressEnd(&bzstream);\n        if (result != BZ_STREAM_END)\n            goto failed;\n        break;\n    }\n#endif\n    default:\n    }\n    *buf = pkt_data;\n    *buf_size = pkt_size;\n    return 0;\n failed:\n    av_free(pkt_data);\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1145, "prediction": "0", "true_label": "0", "raw_text": "Question: void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1146, "prediction": "0", "true_label": "0", "raw_text": "Question: static int virtio_serial_init_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n    VirtIODevice *vdev;\n\n\n\n    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&\n\n        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */\n\n        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */\n\n        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;\n\n\n\n    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);\n\n    if (!vdev) {\n\n        return -1;\n\n    }\n\n    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED\n\n                                        ? proxy->serial.max_virtserial_ports + 1\n\n                                        : proxy->nvectors;\n\n    virtio_init_pci(proxy, vdev,\n\n                    PCI_VENDOR_ID_REDHAT_QUMRANET,\n\n                    PCI_DEVICE_ID_VIRTIO_CONSOLE,\n\n                    proxy->class_code, 0x00);\n\n    proxy->nvectors = vdev->nvectors;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1147, "prediction": "0", "true_label": "0", "raw_text": "Question: static CharDriverState *qmp_chardev_open_serial(const char *id,\n\n                                                ChardevBackend *backend,\n\n                                                ChardevReturn *ret,\n\n                                                Error **errp)\n\n{\n\n    ChardevHostdev *serial = backend->serial;\n\n    int fd;\n\n\n\n    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);\n\n    if (fd < 0) {\n\n        return NULL;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n    return qemu_chr_open_tty_fd(fd);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1148, "prediction": "0", "true_label": "0", "raw_text": "Question: void alpha_pci_vga_setup(PCIBus *pci_bus)\n\n{\n\n    switch (vga_interface_type) {\n\n#ifdef CONFIG_SPICE\n\n    case VGA_QXL:\n\n        pci_create_simple(pci_bus, -1, \"qxl-vga\");\n\n        return;\n\n#endif\n\n    case VGA_CIRRUS:\n\n        pci_cirrus_vga_init(pci_bus);\n\n        return;\n\n    case VGA_VMWARE:\n\n        if (pci_vmsvga_init(pci_bus)) {\n\n            return;\n\n        }\n\n        break;\n\n    }\n\n    /* If VGA is enabled at all, and one of the above didn't work, then\n\n       fallback to Standard VGA.  */\n\n    if (vga_interface_type != VGA_NONE) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1149, "prediction": "0", "true_label": "0", "raw_text": "Question: struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)\n\n{\n\n    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);\n\n    struct omap_uart_s *s = omap_uart_init(base, irq,\n\n                    fclk, iclk, txdma, rxdma, chr);\n\n    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,\n\n                    omap_uart_writefn, s);\n\n\n\n    s->ta = ta;\n\n    s->base = base;\n\n\n\n    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1150, "prediction": "0", "true_label": "0", "raw_text": " (useful if the volume is created\\n\"\n\n           \"       prior to running qemu-img)\\n\"\n\n           \"\\n\"\n\n           \"Parameters to check subcommand:\\n\"\n\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n\n           \"       hiding corruption that has already occurred.\\n\"\n\n           \"\\n\"\n\n           \"Parameters to convert subcommand:\\n\"\n\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n\n           \"       process (defaults to 8)\\n\"\n\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n\n           \"\\n\"\n\n           \"Parameters to snapshot subcommand:\\n\"\n\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n\n           \"  '-c' creates a snapshot\\n\"\n\n           \"  '-d' deletes a snapshot\\n\"\n\n           \"  '-l' lists all snapshots in the given image\\n\"\n\n           \"\\n\"\n\n           \"Parameters to compare subcommand:\\n\"\n\n           \"  '-f' first image format\\n\"\n\n           \"  '-F' second image format\\n\"\n\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n\n           \"\\n\"\n\n           \"Parameters to dd subcommand:\\n\"\n\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n\n           \"(default: 512)\\n\"\n\n           \"  'count=N' copy only N input blocks\\n\"\n\n           \"  'if=FILE' read from FILE\\n\"\n\n           \"  'of=FILE' write to FILE\\n\"\n\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n\n    bdrv_iterate_format(format_print, NULL);\n\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1151, "prediction": "0", "true_label": "0", "raw_text": "Question: static void coroutine_fn bdrv_create_co_entry(void *opaque)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    CreateCo *cco = opaque;\n\n    assert(cco->drv);\n\n\n\n    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);\n\n    if (local_err) {\n\n        error_propagate(&cco->err, local_err);\n\n    }\n\n    cco->ret = ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1152, "prediction": "0", "true_label": "0", "raw_text": "Question: void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)\n\n{\n\n    target_ulong old, val, mask;\n\n    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;\n\n    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {\n\n        mask |= 1 << CP0EnHi_EHINV;\n\n    }\n\n\n\n    /* 1k pages not implemented */\n\n#if defined(TARGET_MIPS64)\n\n    if (env->insn_flags & ISA_MIPS32R6) {\n\n        int entryhi_r = extract64(arg1, 62, 2);\n\n        int config0_at = extract32(env->CP0_Config0, 13, 2);\n\n        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;\n\n        if ((entryhi_r == 2) ||\n\n            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {\n\n            /* skip EntryHi.R field if new value is reserved */\n\n            mask &= ~(0x3ull << 62);\n\n        }\n\n    }\n\n    mask &= env->SEGMask;\n\n#endif\n\n    old = env->CP0_EntryHi;\n\n    val = (arg1 & mask) | (old & ~mask);\n\n    env->CP0_EntryHi = val;\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        sync_c0_entryhi(env, env->current_tc);\n\n    }\n\n    /* If the ASID changes, flush qemu's TLB.  */\n\n    if ((old & env->CP0_EntryHi_ASID_mask) !=\n\n        (val & env->CP0_EntryHi_ASID_mask)) {\n\n        cpu_mips_tlb_flush(env);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1153, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool vmxnet3_verify_driver_magic(hwaddr dshmem)\n\n{\n\n    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1154, "prediction": "0", "true_label": "1", "raw_text": "Question: ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)\n\n{\n\n    ram_addr_t ram_addr;\n\n\n\n    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {\n\n        fprintf(stderr, \"Bad ram pointer %p\\n\", ptr);\n\n        abort();\n\n    }\n\n    return ram_addr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1155, "prediction": "0", "true_label": "1", "raw_text": "3F) + 3;\n\n            src_pos = bytestream2_get_le16(&s->gb);\n\n            av_dlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[src_pos + i];\n\n            dest_index += count;\n\n\n\n        } else if (opcode > 0x80) {\n\n\n\n            count = opcode & 0x3F;\n\n            av_dlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count);\n\n            CHECK_COUNT();\n\n            bytestream2_get_buffer(&s->gb, &dest[dest_index], count);\n\n            dest_index += count;\n\n\n\n        } else {\n\n\n\n            count = ((opcode & 0x70) >> 4) + 3;\n\n            src_pos = bytestream2_get_byte(&s->gb) | ((opcode & 0x0F) << 8);\n\n            av_dlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, src_pos);\n\n            CHECK_COUNT();\n\n            CHECK_COPY(dest_index - src_pos);\n\n            for (i = 0; i < count; i++)\n\n                dest[dest_index + i] = dest[dest_index - src_pos + i];\n\n            dest_index += count;\n\n        }\n\n    }\n\n\n\n    /* validate that the entire destination buffer was filled; this is\n\n     * important for decoding frame maps since each vector needs to have a\n\n     * codebook entry; it is not important for compressed codebooks because\n\n     * not every entry needs to be filled */\n\n    if (check_size)\n\n        if (dest_index < dest_size)\n\n            av_log(s->avctx, AV_LOG_ERROR, \"decode_format80 problem: decode finished with dest_index (%d) < dest_size (%d)\\n\",\n\n                dest_index, dest_size);\n\n\n\n    return 0; // let's display what we decoded anyway\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1156, "prediction": "0", "true_label": "1", "raw_text": " += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *v++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *u++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *v++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 2) {\n\n                if (width & 1) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1157, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1158, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_qemu_strtoul_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    res = 999;\n\n    endptr = &f;\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1159, "prediction": "0", "true_label": "1", "raw_text": "Question: static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1160, "prediction": "0", "true_label": "1", "raw_text": "Question: qio_channel_websock_source_dispatch(GSource *source,\n\n                                    GSourceFunc callback,\n\n                                    gpointer user_data)\n\n{\n\n    QIOChannelFunc func = (QIOChannelFunc)callback;\n\n    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;\n\n    GIOCondition cond = 0;\n\n\n\n    if (wsource->wioc->rawinput.offset) {\n\n        cond |= G_IO_IN;\n\n    }\n\n    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {\n\n        cond |= G_IO_OUT;\n\n    }\n\n\n\n    return (*func)(QIO_CHANNEL(wsource->wioc),\n\n                   (cond & wsource->condition),\n\n                   user_data);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1161, "prediction": "0", "true_label": "0", "raw_text": "_append(method, ifctx);\n\n\n\n    elsectx = aml_else();\n\n    aml_append(elsectx, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(4), NULL),\n\n                                  aml_name(\"CDW1\")));\n\n    aml_append(elsectx, aml_return(aml_arg(3)));\n\n    aml_append(method, elsectx);\n\n    aml_append(dev, method);\n\n\n\n    method = aml_method(\"_DSM\", 4, AML_NOTSERIALIZED);\n\n\n\n    /* PCI Firmware Specification 3.0\n\n     * 4.6.1. _DSM for PCI Express Slot Information\n\n     * The UUID in _DSM in this context is\n\n     * {E5C937D0-3553-4D7A-9117-EA4D19C3434D}\n\n     */\n\n    UUID = aml_touuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\");\n\n    ifctx = aml_if(aml_equal(aml_arg(0), UUID));\n\n    ifctx1 = aml_if(aml_equal(aml_arg(2), aml_int(0)));\n\n    uint8_t byte_list[1] = {1};\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(ifctx1, aml_return(buf));\n\n    aml_append(ifctx, ifctx1);\n\n    aml_append(method, ifctx);\n\n\n\n    byte_list[0] = 0;\n\n    buf = aml_buffer(1, byte_list);\n\n    aml_append(method, aml_return(buf));\n\n    aml_append(dev, method);\n\n\n\n    Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\n\n    aml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\n\n    aml_append(dev, dev_rp0);\n\n    aml_append(scope, dev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1162, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vmdk_parent_open(BlockDriverState *bs)\n\n{\n\n    char *p_name;\n\n    char desc[DESC_SIZE + 1];\n\n    BDRVVmdkState *s = bs->opaque;\n\n\n\n    desc[DESC_SIZE] = '\\0';\n\n    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n\n        return -1;\n\n    }\n\n\n\n    if ((p_name = strstr(desc,\"parentFileNameHint\")) != NULL) {\n\n        char *end_name;\n\n\n\n        p_name += sizeof(\"parentFileNameHint\") + 1;\n\n        if ((end_name = strchr(p_name,'\\\"')) == NULL)\n\n            return -1;\n\n        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)\n\n            return -1;\n\n\n\n        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1163, "prediction": "0", "true_label": "0", "raw_text": "Question: static MemoryRegionSection address_space_do_translate(AddressSpace *as,\n\n                                                      hwaddr addr,\n\n                                                      hwaddr *xlat,\n\n                                                      hwaddr *plen,\n\n                                                      bool is_write,\n\n                                                      bool is_mmio)\n\n{\n\n    IOMMUTLBEntry iotlb;\n\n    MemoryRegionSection *section;\n\n    MemoryRegion *mr;\n\n\n\n    for (;;) {\n\n        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);\n\n        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);\n\n        mr = section->mr;\n\n\n\n        if (!mr->iommu_ops) {\n\n            break;\n\n        }\n\n\n\n        iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n\n                | (addr & iotlb.addr_mask));\n\n        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n\n        if (!(iotlb.perm & (1 << is_write))) {\n\n            goto translate_fail;\n\n        }\n\n\n\n        as = iotlb.target_as;\n\n    }\n\n\n\n    *xlat = addr;\n\n\n\n    return *section;\n\n\n\ntranslate_fail:\n\n    return (MemoryRegionSection) { .mr = &io_mem_unassigned };\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1164, "prediction": "0", "true_label": "0", "raw_text": "Question: static void read_guest_mem(void)\n\n{\n\n    uint32_t *guest_mem;\n\n    gint64 end_time;\n\n    int i, j;\n\n    size_t size;\n\n\n\n    g_mutex_lock(data_mutex);\n\n\n\n    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;\n\n    while (!fds_num) {\n\n        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {\n\n            /* timeout has passed */\n\n            g_assert(fds_num);\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* check for sanity */\n\n    g_assert_cmpint(fds_num, >, 0);\n\n    g_assert_cmpint(fds_num, ==, memory.nregions);\n\n\n\n    /* iterate all regions */\n\n    for (i = 0; i < fds_num; i++) {\n\n\n\n        /* We'll check only the region statring at 0x0*/\n\n        if (memory.regions[i].guest_phys_addr != 0x0) {\n\n            continue;\n\n        }\n\n\n\n        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);\n\n\n\n        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;\n\n\n\n        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,\n\n                         MAP_SHARED, fds[i], 0);\n\n\n\n        g_assert(guest_mem != MAP_FAILED);\n\n        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));\n\n\n\n        for (j = 0; j < 256; j++) {\n\n            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);\n\n            uint32_t b = guest_mem[j];\n\n\n\n            g_assert_cmpint(a, ==, b);\n\n        }\n\n\n\n        munmap(guest_mem, memory.regions[i].memory_size);\n\n    }\n\n\n\n    g_assert_cmpint(1, ==, 1);\n\n    g_mutex_unlock(data_mutex);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1165, "prediction": "0", "true_label": "1", "raw_text": "],\n\n                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma->nb_sent);\n\n        rdma->control_ready_expected = 0;\n\n    }\n\n\n\n    if (wr_id == RDMA_WRID_RDMA_WRITE) {\n\n        uint64_t chunk =\n\n            (wc.wr_id & RDMA_WRID_CHUNK_MASK) >> RDMA_WRID_CHUNK_SHIFT;\n\n        uint64_t index =\n\n            (wc.wr_id & RDMA_WRID_BLOCK_MASK) >> RDMA_WRID_BLOCK_SHIFT;\n\n        RDMALocalBlock *block = &(rdma->local_ram_blocks.block[index]);\n\n\n\n        DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \"\n\n                 \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\",\n\n                 print_wrid(wr_id), wr_id, rdma->nb_sent, index, chunk,\n\n                 block->local_host_addr, (void *)block->remote_host_addr);\n\n\n\n        clear_bit(chunk, block->transit_bitmap);\n\n\n\n        if (rdma->nb_sent > 0) {\n\n            rdma->nb_sent--;\n\n        }\n\n\n\n        if (!rdma->pin_all) {\n\n            /*\n\n             * FYI: If one wanted to signal a specific chunk to be unregistered\n\n             * using LRU or workload-specific information, this is the function\n\n             * you would call to do so. That chunk would then get asynchronously\n\n             * unregistered later.\n\n             */\n\n#ifdef RDMA_UNREGISTRATION_EXAMPLE\n\n            qemu_rdma_signal_unregister(rdma, index, chunk, wc.wr_id);\n\n#endif\n\n        }\n\n    } else {\n\n        DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\",\n\n            print_wrid(wr_id), wr_id, rdma->nb_sent);\n\n    }\n\n\n\n    *wr_id_out = wc.wr_id;\n\n    if (byte_len) {\n\n        *byte_len = wc.byte_len;\n\n    }\n\n\n\n    return  0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1166, "prediction": "1", "true_label": "1", "raw_text": "Question: static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    uint32_t minor_ver;\n\n    int comp_brand_size;\n\n    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */\n\n    char* comp_brands_str;\n\n    uint8_t type[5] = {0};\n\n\n\n    avio_read(pb, type, 4);\n\n    if (strcmp(type, \"qt  \"))\n\n        c->isom = 1;\n\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n\n    minor_ver = avio_rb32(pb); /* minor version */\n\n    snprintf(minor_ver_str, sizeof(minor_ver_str), \"%\"PRIu32\"\", minor_ver);\n\n    av_dict_set(&c->fc->metadata, \"minor_version\", minor_ver_str, 0);\n\n\n\n    comp_brand_size = atom.size - 8;\n\n    if (comp_brand_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n\n    if (!comp_brands_str)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, comp_brands_str, comp_brand_size);\n\n    comp_brands_str[comp_brand_size] = 0;\n\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n\n    av_freep(&comp_brands_str);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1167, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1168, "prediction": "0", "true_label": "0", "raw_text": "\n\n\n\n    GET_V(st->codec->extradata_size, tmp < (1<<30));\n\n    if(st->codec->extradata_size){\n\n        st->codec->extradata= av_mallocz(st->codec->extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        get_buffer(bc, st->codec->extradata, st->codec->extradata_size);\n\n    }\n\n\n\n    if (st->codec->codec_type == CODEC_TYPE_VIDEO){\n\n        GET_V(st->codec->width , tmp > 0)\n\n        GET_V(st->codec->height, tmp > 0)\n\n        st->codec->sample_aspect_ratio.num= get_v(bc);\n\n        st->codec->sample_aspect_ratio.den= get_v(bc);\n\n        if((!st->codec->sample_aspect_ratio.num) != (!st->codec->sample_aspect_ratio.den)){\n\n            av_log(s, AV_LOG_ERROR, \"invalid aspect ratio\\n\");\n\n            return -1;\n\n        }\n\n        get_v(bc); /* csp type */\n\n    }else if (st->codec->codec_type == CODEC_TYPE_AUDIO){\n\n        GET_V(st->codec->sample_rate , tmp > 0)\n\n        tmp= get_v(bc); // samplerate_den\n\n        if(tmp > st->codec->sample_rate){\n\n            av_log(s, AV_LOG_ERROR, \"bleh, libnut muxed this ;)\\n\");\n\n            st->codec->sample_rate= tmp;\n\n        }\n\n        GET_V(st->codec->channels, tmp > 0)\n\n    }\n\n    if(skip_reserved(bc, end) || get_checksum(bc)){\n\n        av_log(s, AV_LOG_ERROR, \"Stream header %d checksum mismatch\\n\", stream_id);\n\n        return -1;\n\n    }\n\n    stc->time_base= &nut->time_base[stc->time_base_id];\n\n    av_set_pts_info(s->streams[stream_id], 63, stc->time_base->num, stc->time_base->den);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1169, "prediction": "0", "true_label": "1", "raw_text": ";\n\n\n\n    s = src;\n\n    d = dest;\n\n    d_end = d + dest_len;\n\n    dataleft = AV_RL32(s);\n\n    s += 4;\n\n    memset(queue, 0x20, QUEUE_SIZE);\n\n    if (AV_RL32(s) == 0x56781234) {\n\n        s += 4;\n\n        qpos = 0x111;\n\n        speclen = 0xF + 3;\n\n    } else {\n\n        qpos = 0xFEE;\n\n        speclen = 100;  /* no speclen */\n\n    }\n\n\n\n    while (dataleft > 0) {\n\n        tag = *s++;\n\n        if ((tag == 0xFF) && (dataleft > 8)) {\n\n            if (d + 8 > d_end)\n\n                return;\n\n            for (i = 0; i < 8; i++) {\n\n                queue[qpos++] = *d++ = *s++;\n\n                qpos &= QUEUE_MASK;\n\n            }\n\n            dataleft -= 8;\n\n        } else {\n\n            for (i = 0; i < 8; i++) {\n\n                if (dataleft == 0)\n\n                    break;\n\n                if (tag & 0x01) {\n\n                    if (d + 1 > d_end)\n\n                        return;\n\n                    queue[qpos++] = *d++ = *s++;\n\n                    qpos &= QUEUE_MASK;\n\n                    dataleft--;\n\n                } else {\n\n                    chainofs = *s++;\n\n                    chainofs |= ((*s & 0xF0) << 4);\n\n                    chainlen = (*s++ & 0x0F) + 3;\n\n                    if (chainlen == speclen)\n\n                        chainlen = *s++ + 0xF + 3;\n\n                    if (d + chainlen > d_end)\n\n                        return;\n\n                    for (j = 0; j < chainlen; j++) {\n\n                        *d = queue[chainofs++ & QUEUE_MASK];\n\n                        queue[qpos++] = *d++;\n\n                        qpos &= QUEUE_MASK;\n\n                    }\n\n                    dataleft -= chainlen;\n\n                }\n\n                tag >>= 1;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1170, "prediction": "-1", "true_label": "1", "raw_text": "Question: void scsi_req_cancel(SCSIRequest *req)\n\n{\n\n    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->aiocb) {\n\n        blk_aio_cancel(req->aiocb);\n\n    } else {\n\n        scsi_req_cancel_complete(req);\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1171, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1172, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,\n\n                                            uint16_t code, const char *reason)\n\n{\n\n    struct iovec iov;\n\n    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));\n\n    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =\n\n        cpu_to_be16(code);\n\n    ioc->rawoutput.offset += 2;\n\n    if (reason) {\n\n        buffer_append(&ioc->rawoutput, reason, strlen(reason));\n\n    }\n\n    iov.iov_base = ioc->rawoutput.buffer;\n\n    iov.iov_len = ioc->rawoutput.offset;\n\n    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,\n\n                               &iov, 1, iov.iov_len);\n\n    buffer_reset(&ioc->rawoutput);\n\n    qio_channel_websock_write_wire(ioc, NULL);\n\n    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1173, "prediction": "0", "true_label": "0", "raw_text": "MR offset matches hw/acpi/core.c */\n\n    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);\n\n    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);\n\n    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);\n\n    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);\n\n    /* EVT, CNT, TMR length matches hw/acpi/core.c */\n\n    fadt->pm1_evt_len = 4;\n\n    fadt->pm1_cnt_len = 2;\n\n    fadt->pm_tmr_len = 4;\n\n    fadt->gpe0_blk_len = pm->gpe0_blk_len;\n\n    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */\n\n    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */\n\n    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |\n\n                              (1 << ACPI_FADT_F_PROC_C1) |\n\n                              (1 << ACPI_FADT_F_SLP_BUTTON) |\n\n                              (1 << ACPI_FADT_F_RTC_S4));\n\n    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);\n\n    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs\n\n     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used\n\n     */\n\n    if (max_cpus > 8) {\n\n        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);\n\n    }\n\n    fadt->century = RTC_CENTURY;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1174, "prediction": "0", "true_label": "0", "raw_text": "Question: void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)\n\n{\n\n    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);\n\n\n\n    if (val & ACPI_BITMASK_SLEEP_ENABLE) {\n\n        /* change suspend type */\n\n        uint16_t sus_typ = (val >> 10) & 7;\n\n        switch(sus_typ) {\n\n        case 0: /* soft power off */\n\n            qemu_system_shutdown_request();\n\n            break;\n\n        case 1:\n\n            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.\n\n               Pretend that resume was caused by power button */\n\n            ar->pm1.evt.sts |=\n\n                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);\n\n            qemu_system_reset_request();\n\n            qemu_irq_raise(ar->pm1.cnt.cmos_s3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1175, "prediction": "0", "true_label": "0", "raw_text": "Question: static void win32_rearm_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct qemu_alarm_win32 *data = t->priv;\n\n    uint64_t nearest_delta_us;\n\n\n\n    if (!active_timers[QEMU_TIMER_REALTIME] &&\n\n                !active_timers[QEMU_TIMER_VIRTUAL])\n\n        return;\n\n\n\n    nearest_delta_us = qemu_next_deadline_dyntick();\n\n    nearest_delta_us /= 1000;\n\n\n\n    timeKillEvent(data->timerId);\n\n\n\n    data->timerId = timeSetEvent(1,\n\n                        data->period,\n\n                        host_alarm_handler,\n\n                        (DWORD)t,\n\n                        TIME_ONESHOT | TIME_PERIODIC);\n\n\n\n    if (!data->timerId) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(data->period);\n\n        exit(1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1176, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qapi_dealloc_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QapiDeallocVisitor *qov = to_qov(v);\n\n    void **obj = qapi_dealloc_pop(qov);\n\n    if (obj) {\n\n        g_free(*obj);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1177, "prediction": "0", "true_label": "1", "raw_text": " path[1024];\n\n    char file[1024], file_prefix[1024];\n\n    int input_path_len;\n\n    const char *p;\n\n\n\n    p = strrchr(input, '/');\n\n    if (!p) {\n\n        input_path_len = 0;\n\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n\n        pstrcpy(path, sizeof(path), \".\");\n\n    } else {\n\n        input_path_len = p - input + 1;\n\n        memcpy(path, input, input_path_len);\n\n        if (input_path_len > sizeof(path) - 1)\n\n            input_path_len = sizeof(path) - 1;\n\n        path[input_path_len] = '\\0';\n\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n\n    }\n\n#ifdef DEBUG_COMPLETION\n\n    monitor_printf(cur_mon, \"input='%s' path='%s' prefix='%s'\\n\",\n\n                   input, path, file_prefix);\n\n#endif\n\n    ffs = opendir(path);\n\n    if (!ffs)\n\n        return;\n\n    for(;;) {\n\n        struct stat sb;\n\n        d = readdir(ffs);\n\n        if (!d)\n\n            break;\n\n\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n\n            memcpy(file, input, input_path_len);\n\n            if (input_path_len < sizeof(file))\n\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n\n                        d->d_name);\n\n            /* stat the file to find out if it's a directory.\n\n             * In that case add a slash to speed up typing long paths\n\n             */\n\n            stat(file, &sb);\n\n            if(S_ISDIR(sb.st_mode))\n\n                pstrcat(file, sizeof(file), \"/\");\n\n            readline_add_completion(cur_mon->rs, file);\n\n        }\n\n    }\n\n    closedir(ffs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1178, "prediction": "0", "true_label": "1", "raw_text": "Question: static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1179, "prediction": "0", "true_label": "1", "raw_text": "Question: static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1180, "prediction": "0", "true_label": "1", "raw_text": "ch] = 1;\n\n\n\n    if (s->seekable_tile) {\n\n        ave_mean = get_bits(&s->gb, s->bits_per_sample);\n\n        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);\n\n    }\n\n\n\n    if (s->seekable_tile) {\n\n        if (s->do_inter_ch_decorr)\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);\n\n        else\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);\n\n        i++;\n\n    }\n\n    for (; i < tile_size; i++) {\n\n        int quo = 0, rem, rem_bits, residue;\n\n        while(get_bits1(&s->gb)) {\n\n            quo++;\n\n            if (get_bits_left(&s->gb) <= 0)\n\n                return -1;\n\n        }\n\n        if (quo >= 32)\n\n            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);\n\n\n\n        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);\n\n        if (ave_mean <= 1)\n\n            residue = quo;\n\n        else {\n\n            rem_bits = av_ceil_log2(ave_mean);\n\n            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;\n\n            residue  = (quo << rem_bits) + rem;\n\n        }\n\n\n\n        s->ave_sum[ch] = residue + s->ave_sum[ch] -\n\n                         (s->ave_sum[ch] >> s->movave_scaling);\n\n\n\n        if (residue & 1)\n\n            residue = -(residue >> 1) - 1;\n\n        else\n\n            residue = residue >> 1;\n\n        s->channel_residues[ch][i] = residue;\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1181, "prediction": "0", "true_label": "0", "raw_text": "Question: static int cinaudio_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    CinAudioContext *cin = avctx->priv_data;\n\n    const uint8_t *src = buf;\n\n    int16_t *samples = data;\n\n    int delta;\n\n\n\n    buf_size = FFMIN(buf_size, *data_size/2);\n\n\n\n    delta = cin->delta;\n\n    if (cin->initial_decode_frame) {\n\n        cin->initial_decode_frame = 0;\n\n        delta = (int16_t)AV_RL16(src); src += 2;\n\n        *samples++ = delta;\n\n        buf_size -= 2;\n\n    }\n\n    while (buf_size > 0) {\n\n        delta += cinaudio_delta16_table[*src++];\n\n        delta = av_clip_int16(delta);\n\n        *samples++ = delta;\n\n        --buf_size;\n\n    }\n\n    cin->delta = delta;\n\n\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n\n\n    return src - buf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1182, "prediction": "0", "true_label": "0", "raw_text": "_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + 2]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[0][0];\n\n    my += r->dmv[0][1];\n\n    for(j = 0; j < 2; j++){\n\n        for(i = 0; i < 2; i++){\n\n            for(k = 0; k < 2; k++){\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1183, "prediction": "1", "true_label": "0", "raw_text": "Question: int qemu_paio_init(struct qemu_paioinit *aioinit)\n\n{\n\n    int ret;\n\n\n\n    ret = pthread_attr_init(&attr);\n\n    if (ret) die2(ret, \"pthread_attr_init\");\n\n\n\n    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n    if (ret) die2(ret, \"pthread_attr_setdetachstate\");\n\n\n\n    TAILQ_INIT(&request_list);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1184, "prediction": "0", "true_label": "0", "raw_text": "Question: dprint(int level, const char *fmt, ...)\n\n{\n\n    va_list args;\n\n\n\n    if (level <= debug) {\n\n        va_start(args, fmt);\n\n        vfprintf(stderr, fmt, args);\n\n        va_end(args);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1185, "prediction": "0", "true_label": "0", "raw_text": "Question: static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1186, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1187, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vhost_verify_ring_mappings(struct vhost_dev *dev,\n\n                                      uint64_t start_addr,\n\n                                      uint64_t size)\n\n{\n\n    int i, j;\n\n    int r = 0;\n\n    const char *part_name[] = {\n\n        \"descriptor table\",\n\n        \"available ring\",\n\n        \"used ring\"\n\n    };\n\n\n\n    for (i = 0; i < dev->nvqs; ++i) {\n\n        struct vhost_virtqueue *vq = dev->vqs + i;\n\n\n\n        j = 0;\n\n        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,\n\n                                           vq->desc_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,\n\n                                           vq->avail_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n\n\n        j++;\n\n        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,\n\n                                           vq->used_size, start_addr, size);\n\n        if (!r) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (r == -ENOMEM) {\n\n        error_report(\"Unable to map %s for ring %d\", part_name[j], i);\n\n    } else if (r == -EBUSY) {\n\n        error_report(\"%s relocated for ring %d\", part_name[j], i);\n\n    }\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1188, "prediction": "0", "true_label": "0", "raw_text": ";\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = addr - block->offset;\n\n        if (offset < block->length) {\n\n            vaddr = block->host + offset;\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (xen_enabled()) {\n\n                abort();\n\n            } else {\n\n                flags = MAP_FIXED;\n\n                munmap(vaddr, length);\n\n                if (mem_path) {\n\n#if defined(__linux__) && !defined(TARGET_S390X)\n\n                    if (block->fd) {\n\n#ifdef MAP_POPULATE\n\n                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :\n\n                            MAP_PRIVATE;\n\n#else\n\n                        flags |= MAP_PRIVATE;\n\n#endif\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, block->fd, offset);\n\n                    } else {\n\n                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, -1, 0);\n\n                    }\n\n#else\n\n                    abort();\n\n#endif\n\n                } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                    flags |= MAP_SHARED | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                flags, -1, 0);\n\n#else\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                flags, -1, 0);\n\n#endif\n\n                }\n\n                if (area != vaddr) {\n\n                    fprintf(stderr, \"Could not remap addr: \"\n\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n\n                            length, addr);\n\n                    exit(1);\n\n                }\n\n                memory_try_enable_merging(vaddr, length);\n\n                qemu_ram_setup_dump(vaddr, length);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1189, "prediction": "0", "true_label": "1", "raw_text": "Question: const char *object_get_typename(Object *obj)\n\n{\n\n    return obj->class->type->name;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1190, "prediction": "0", "true_label": "0", "raw_text": " (first in list).\\n\",\n\n               av_get_pix_fmt_name(ctx->decode_format));\n\n        if (i > 1) {\n\n            // There was a choice, and we picked randomly.  Warn the user\n\n            // that they might want to choose intelligently instead.\n\n            av_log(ctx, AV_LOG_WARNING, \"Using randomly chosen decode \"\n\n                   \"format %s.\\n\", av_get_pix_fmt_name(ctx->decode_format));\n\n        }\n\n    }\n\n\n\n    // Ensure the picture size is supported by the hardware.\n\n    ctx->decode_width  = avctx->coded_width;\n\n    ctx->decode_height = avctx->coded_height;\n\n    if (ctx->decode_width  < constraints->min_width  ||\n\n        ctx->decode_height < constraints->min_height ||\n\n        ctx->decode_width  > constraints->max_width  ||\n\n        ctx->decode_height >constraints->max_height) {\n\n        av_log(ctx, AV_LOG_ERROR, \"VAAPI hardware does not support image \"\n\n               \"size %dx%d (constraints: width %d-%d height %d-%d).\\n\",\n\n               ctx->decode_width, ctx->decode_height,\n\n               constraints->min_width,  constraints->max_width,\n\n               constraints->min_height, constraints->max_height);\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n\n\n    // Decide how many reference frames we need.  This might be doable more\n\n    // nicely based on the codec and input stream?\n\n    ctx->decode_surfaces = DEFAULT_SURFACES;\n\n    // For frame-threaded decoding, one additional surfaces is needed for\n\n    // each thread.\n\n    if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n        ctx->decode_surfaces += avctx->thread_count;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_hwframe_constraints_free(&constraints);\n\n    av_freep(&hwconfig);\n\n    vaDestroyConfig(hwctx->display, ctx->va_config);\n\n    av_freep(&profile_list);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1191, "prediction": "0", "true_label": "0", "raw_text": "_frame(ctx, *out_data, *out_size);\n\n\n\n        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;\n\n    }\n\n\n\n    marker = data[size - 1];\n\n    if ((marker & 0xe0) == 0xc0) {\n\n        int nbytes = 1 + ((marker >> 3) & 0x3);\n\n        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;\n\n\n\n        if (size >= idx_sz && data[size - idx_sz] == marker) {\n\n            const uint8_t *idx = data + size + 1 - idx_sz;\n\n            int first = 1;\n\n\n\n            switch (nbytes) {\n\n#define case_n(a, rd) \\\n\n            case a: \\\n\n                while (n_frames--) { \\\n\n                    int sz = rd; \\\n\n                    idx += a; \\\n\n                    if (sz > size) { \\\n\n                        s->n_frames = 0; \\\n\n                        av_log(avctx, AV_LOG_ERROR, \\\n\n                               \"Superframe packet size too big: %d > %d\\n\", \\\n\n                               sz, size); \\\n\n                        return AVERROR_INVALIDDATA; \\\n\n                    } \\\n\n                    if (first) { \\\n\n                        first = 0; \\\n\n                        *out_data = data; \\\n\n                        *out_size = sz; \\\n\n                        s->n_frames = n_frames; \\\n\n                    } else { \\\n\n                        s->size[n_frames] = sz; \\\n\n                    } \\\n\n                    data += sz; \\\n\n                    size -= sz; \\\n\n                } \\\n\n                parse_frame(ctx, *out_data, *out_size); \\\n\n                return *out_size\n\n\n\n                case_n(1, *idx);\n\n                case_n(2, AV_RL16(idx));\n\n                case_n(3, AV_RL24(idx));\n\n                case_n(4, AV_RL32(idx));\n\n            }\n\n        }\n\n    }\n\n\n\n    *out_data = data;\n\n    *out_size = size;\n\n    parse_frame(ctx, data, size);\n\n\n\n    return size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1192, "prediction": "0", "true_label": "1", "raw_text": "Question: static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1193, "prediction": "0", "true_label": "1", "raw_text": "Question: static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1194, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1195, "prediction": "0", "true_label": "1", "raw_text": "Question: static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)\n\n{\n\n    int i, len, sz;\n\n    GetBitContext gb;\n\n    int code_table[64];\n\n\n\n    /* get the rle codes (at most 64 bytes) */\n\n    init_get_bits(&gb, src, 64 * 8);\n\n    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {\n\n        code_table[i] = get_sbits(&gb, 4);\n\n        sz += FFABS(code_table[i]);\n\n    }\n\n    src += (get_bits_count(&gb) + 7) / 8;\n\n\n\n    /* do the rle unpacking */\n\n    for (i = 0; i < 64 && dst_size > 0; i++) {\n\n        len = code_table[i];\n\n        if (len < 0) {\n\n            len = -len;\n\n            memset(dst, *src++, FFMIN(len, dst_size));\n\n        } else {\n\n            memcpy(dst, src, FFMIN(len, dst_size));\n\n            src += len;\n\n        }\n\n        dst += len;\n\n        dst_size -= len;\n\n    }\n\n    return src;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1196, "prediction": "1", "true_label": "1", "raw_text": "Question: bool bdrv_is_first_non_filter(BlockDriverState *candidate)\n\n{\n\n    BlockDriverState *bs;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    /* walk down the bs forest recursively */\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        bool perm;\n\n\n\n        /* try to recurse in this top level bs */\n\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n\n\n        /* candidate is the first non filter */\n\n        if (perm) {\n\n            return true;\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1197, "prediction": "-1", "true_label": "1", "raw_text": " .hdr.request = VHOST_USER_SET_MEM_TABLE,\n\n        .hdr.flags = VHOST_USER_VERSION,\n\n    };\n\n\n\n    if (reply_supported) {\n\n        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;\n\n    }\n\n\n\n    for (i = 0; i < dev->mem->nregions; ++i) {\n\n        struct vhost_memory_region *reg = dev->mem->regions + i;\n\n        ram_addr_t offset;\n\n        MemoryRegion *mr;\n\n\n\n        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);\n\n        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,\n\n                                     &offset);\n\n        fd = memory_region_get_fd(mr);\n\n        if (fd > 0) {\n\n            msg.payload.memory.regions[fd_num].userspace_addr = reg->userspace_addr;\n\n            msg.payload.memory.regions[fd_num].memory_size  = reg->memory_size;\n\n            msg.payload.memory.regions[fd_num].guest_phys_addr = reg->guest_phys_addr;\n\n            msg.payload.memory.regions[fd_num].mmap_offset = offset;\n\n            assert(fd_num < VHOST_MEMORY_MAX_NREGIONS);\n\n            fds[fd_num++] = fd;\n\n        }\n\n    }\n\n\n\n    msg.payload.memory.nregions = fd_num;\n\n\n\n    if (!fd_num) {\n\n        error_report(\"Failed initializing vhost-user memory map, \"\n\n                     \"consider using -object memory-backend-file share=on\");\n\n        return -1;\n\n    }\n\n\n\n    msg.hdr.size = sizeof(msg.payload.memory.nregions);\n\n    msg.hdr.size += sizeof(msg.payload.memory.padding);\n\n    msg.hdr.size += fd_num * sizeof(VhostUserMemoryRegion);\n\n\n\n    if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (reply_supported) {\n\n        return process_message_reply(dev, &msg);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1198, "prediction": "0", "true_label": "1", "raw_text": " == 0) {\n        /* padding is always necessary even if EOF, so we add it here */\n        memset(dummy_buf, 0, sizeof(dummy_buf));\n        buf = dummy_buf;\n    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */\n        /* add a new packet descriptor */\n        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);\n        s->cur_frame_start_index = i;\n        s->cur_frame_offset[i]   = s->cur_offset;\n        s->cur_frame_end[i]      = s->cur_offset + buf_size;\n        s->cur_frame_pts[i]      = pts;\n        s->cur_frame_dts[i]      = dts;\n        s->cur_frame_pos[i]      = pos;\n    }\n    if (s->fetch_timestamp) {\n        s->fetch_timestamp = 0;\n        s->last_pts        = s->pts;\n        s->last_dts        = s->dts;\n        s->last_pos        = s->pos;\n        ff_fetch_timestamp(s, 0, 0, 0);\n    }\n    /* WARNING: the returned index can be negative */\n    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,\n                                    poutbuf_size, buf, buf_size);\n    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes\n    /* update the file pointer */\n    if (*poutbuf_size) {\n        /* fill the data for the current frame */\n        s->frame_offset = s->next_frame_offset;\n        /* offset of the next frame */\n        s->next_frame_offset = s->cur_offset + index;\n        s->fetch_timestamp   = 1;\n    }\n    if (index < 0)\n        index = 0;\n    s->cur_offset += index;\n    return index;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1199, "prediction": "-1", "true_label": "1", "raw_text": "Question: static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,\n\n                          int nb_sectors, QEMUIOVector *qiov,\n\n                          int offset)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    request.type = NBD_CMD_READ;\n\n    request.from = sector_num * 512;\n\n    request.len = nb_sectors * 512;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, qiov, offset);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1200, "prediction": "0", "true_label": "1", "raw_text": "Question: static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)\n\n{\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    while(buf + 48 <= buf_end) {\n\n        int dir_length, name_size, first_sector, depth;\n\n        uint64_t file_length;\n\n        const uint8_t *name;\n\n        if (ff_guidcmp(buf, dir_entry_guid)) {\n\n            av_log(s, AV_LOG_ERROR, \"unknown guid \"FF_PRI_GUID\", expected dir_entry_guid; \"\n\n                   \"remaining directory entries ignored\\n\", FF_ARG_GUID(buf));\n\n            break;\n\n        }\n\n        dir_length  = AV_RL16(buf + 16);\n\n        file_length = AV_RL64(buf + 24);\n\n        name_size   = 2 * AV_RL32(buf + 32);\n\n        if (buf + 48 + name_size > buf_end) {\n\n            av_log(s, AV_LOG_ERROR, \"filename exceeds buffer size; remaining directory entries ignored\\n\");\n\n            break;\n\n        }\n\n        first_sector = AV_RL32(buf + 40 + name_size);\n\n        depth        = AV_RL32(buf + 44 + name_size);\n\n\n\n        /* compare file name; test optional null terminator */\n\n        name = buf + 40;\n\n        if (name_size >= filename_size &&\n\n            !memcmp(name, filename, filename_size) &&\n\n            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))\n\n            return wtvfile_open_sector(first_sector, file_length, depth, s);\n\n\n\n        buf += dir_length;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1201, "prediction": "0", "true_label": "1", "raw_text": " } else {\n\n                h[1][0] = H11[1][e][b];\n\n                h[1][1] = H12[1][e][b];\n\n                h[1][2] = H21[1][e][b];\n\n                h[1][3] = H22[1][e][b];\n\n            }\n\n            }\n\n            //Interpolation\n\n            h_step[0][0] = AAC_MSUB31_V3(H11[0][e+1][b], h[0][0], width);\n\n            h_step[0][1] = AAC_MSUB31_V3(H12[0][e+1][b], h[0][1], width);\n\n            h_step[0][2] = AAC_MSUB31_V3(H21[0][e+1][b], h[0][2], width);\n\n            h_step[0][3] = AAC_MSUB31_V3(H22[0][e+1][b], h[0][3], width);\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n                h_step[1][0] = AAC_MSUB31_V3(H11[1][e+1][b], h[1][0], width);\n\n                h_step[1][1] = AAC_MSUB31_V3(H12[1][e+1][b], h[1][1], width);\n\n                h_step[1][2] = AAC_MSUB31_V3(H21[1][e+1][b], h[1][2], width);\n\n                h_step[1][3] = AAC_MSUB31_V3(H22[1][e+1][b], h[1][3], width);\n\n            }\n\n            ps->dsp.stereo_interpolate[!PS_BASELINE && ps->enable_ipdopd](\n\n                l[k] + start + 1, r[k] + start + 1,\n\n                h, h_step, stop - start);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1202, "prediction": "-1", "true_label": "1", "raw_text": "report(QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n\n    } else if (qobject_type(obj) != QTYPE_QSTRING) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\", \"string\");\n\n\n    }\n\n\n\n    cmd_name = qstring_get_str(qobject_to_qstring(obj));\n\n\n\n    if (invalid_qmp_mode(mon, cmd_name)) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    }\n\n\n\n    /*\n\n     * XXX: We need this special case until we get info handlers\n\n     * converted into 'query-' commands\n\n     */\n\n    if (compare_cmd(cmd_name, \"info\")) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    } else if (strstart(cmd_name, \"query-\", &info_item)) {\n\n        cmd = monitor_find_command(\"info\");\n\n        qdict_put_obj(input, \"arguments\",\n\n                      qobject_from_jsonf(\"{ 'item': %s }\", info_item));\n\n    } else {\n\n        cmd = monitor_find_command(cmd_name);\n\n        if (!cmd || !monitor_handler_ported(cmd)) {\n\n            qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n        }\n\n    }\n\n\n\n    obj = qdict_get(input, \"arguments\");\n\n    if (!obj) {\n\n        args = qdict_new();\n\n\n\n\n    } else {\n\n        args = qobject_to_qdict(obj);\n\n        QINCREF(args);\n\n    }\n\n\n\n    QDECREF(input);\n\n\n\n    err = monitor_check_qmp_args(cmd, args);\n\n    if (err < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    if (monitor_handler_is_async(cmd)) {\n\n        qmp_async_cmd_handler(mon, cmd, args);\n\n    } else {\n\n        monitor_call_handler(mon, cmd, args);\n\n    }\n\n    goto out;\n\n\n\nerr_input:\n\n    QDECREF(input);\n\nerr_out:\n\n    monitor_protocol_emitter(mon, NULL);\n\nout:\n\n    QDECREF(args);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1203, "prediction": "0", "true_label": "0", "raw_text": "Question: static int idcin_decode_init(AVCodecContext *avctx)\n\n{\n\n    IdcinContext *s = avctx->priv_data;\n\n    int i, j, histogram_index = 0;\n\n    unsigned char *histograms;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the Huffman tables make it */\n\n    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  Id CIN video: expected extradata size of %d\\n\", HUFFMAN_TABLE_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    /* build the 256 Huffman decode trees */\n\n    histograms = (unsigned char *)s->avctx->extradata;\n\n    for (i = 0; i < 256; i++) {\n\n        for(j = 0; j < HUF_TOKENS; j++)\n\n            s->huff_nodes[i][j].count = histograms[histogram_index++];\n\n        huff_build_tree(s, i);\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1204, "prediction": "0", "true_label": "0", "raw_text": "Question: static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n\n{\n\n    int dx, dy, dw, dh;\n\n    int w_prev;\n\n    int w_best = 0, h_best = 0;\n\n\n\n    w_prev = w;\n\n\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n\n            break;\n\n        }\n\n\n\n        for (dx = x + dw; dx < x + w_prev;) {\n\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n\n                break;\n\n            }\n\n            dx += dw;\n\n        }\n\n\n\n        w_prev = dx - x;\n\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n\n            w_best = w_prev;\n\n            h_best = dy + dh - y;\n\n        }\n\n    }\n\n\n\n    *w_ptr = w_best;\n\n    *h_ptr = h_best;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1205, "prediction": "0", "true_label": "0", "raw_text": "Question: static RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    /* The list is protected by the iothread lock here.  */\n\n    block = ram_list.mru_block;\n\n    if (block && addr - block->offset < block->max_length) {\n\n        goto found;\n\n    }\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr - block->offset < block->max_length) {\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n\n    abort();\n\n\n\nfound:\n\n    ram_list.mru_block = block;\n\n    return block;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1206, "prediction": "1", "true_label": "0", "raw_text": "Question: static int usbnet_can_receive(VLANClientState *nc)\n\n{\n\n    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n        return 1;\n\n\n\n    return !s->in_len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 1207, "prediction": "-1", "true_label": "0", "raw_text": "cluster_size;\n\n        if (nb_sectors > 0xffffff)\n\n            nb_sectors = 0;\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->cluster_size * 2;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) { /* Saved Values */\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    switch (page) {\n\n    case 0x04:\n\n    case 0x05:\n\n    case 0x08:\n\n    case 0x2a:\n\n        p += mode_sense_page(req, page, p, page_control);\n\n        break;\n\n    case 0x3f:\n\n        p += mode_sense_page(req, 0x08, p, page_control);\n\n        p += mode_sense_page(req, 0x2a, p, page_control);\n\n        break;\n\n    default:\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    if (buflen > req->cmd.xfer)\n\n        buflen = req->cmd.xfer;\n\n    return buflen;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1208, "prediction": "0", "true_label": "0", "raw_text": " switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < tcg_op_defs_max; op++) {\n\n        const TCGOpDef *def = &tcg_op_defs[op];\n\n        if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n            /* Wrong entry in op definitions? */\n\n            if (def->used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!def->used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1209, "prediction": "0", "true_label": "1", "raw_text": "Question: void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n\n{\n\n    if (conf.log_to_monitor) {\n\n        if (cap) {\n\n            monitor_printf(default_mon, \"%s: \", cap);\n\n        }\n\n\n\n        monitor_vprintf(default_mon, fmt, ap);\n\n    }\n\n    else {\n\n        if (cap) {\n\n            fprintf (stderr, \"%s: \", cap);\n\n        }\n\n\n\n        vfprintf (stderr, fmt, ap);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1210, "prediction": "0", "true_label": "0", "raw_text": "Question: static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,\n\n                                  OGGStreamContext *oggstream, int bitexact)\n\n{\n\n    const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMAT_IDENT;\n\n    uint8_t *p;\n\n    if (extradata_size != 34)\n\n        return -1;\n\n    oggstream->header_len[0] = 51;\n\n    oggstream->header[0] = av_mallocz(51); // per ogg flac specs\n\n    p = oggstream->header[0];\n\n    bytestream_put_byte(&p, 0x7F);\n\n    bytestream_put_buffer(&p, \"FLAC\", 4);\n\n    bytestream_put_byte(&p, 1); // major version\n\n    bytestream_put_byte(&p, 0); // minor version\n\n    bytestream_put_be16(&p, 1); // headers packets without this one\n\n    bytestream_put_buffer(&p, \"fLaC\", 4);\n\n    bytestream_put_byte(&p, 0x00); // streaminfo\n\n    bytestream_put_be24(&p, 34);\n\n    bytestream_put_buffer(&p, extradata, 34);\n\n    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;\n\n    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);\n\n    p = oggstream->header[1];\n\n    bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment\n\n    bytestream_put_be24(&p, oggstream->header_len[1] - 4);\n\n    bytestream_put_le32(&p, strlen(vendor));\n\n    bytestream_put_buffer(&p, vendor, strlen(vendor));\n\n    bytestream_put_le32(&p, 0); // user comment list length\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1211, "prediction": "1", "true_label": "0", "raw_text": " < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 5, c->abits[band][ch]);\n\n\n\n    if (SUBSUBFRAMES > 1) {\n\n        /* Transition mode: none for each channel and subband */\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                put_bits(&c->pb, 1, 0); /* codebook A4 */\n\n    }\n\n\n\n    /* Scale factors */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 7, c->scale_factor[band][ch]);\n\n\n\n    /* Joint subband scale factor codebook select: not transmitted */\n\n    /* Scale factors for joint subband coding: not transmitted */\n\n    /* Stereo down-mix coefficients: not transmitted */\n\n    /* Dynamic range coefficient: not transmitted */\n\n    /* Stde information CRC check word: not transmitted */\n\n    /* VQ encoded high frequency subbands: not transmitted */\n\n\n\n    /* LFE data: 8 samples and scalefactor */\n\n    if (c->lfe_channel) {\n\n        for (i = 0; i < DCA_LFE_SAMPLES; i++)\n\n            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);\n\n        put_bits(&c->pb, 8, c->lfe_scale_factor);\n\n    }\n\n\n\n    /* Audio data (subsubframes) */\n\n    for (ss = 0; ss < SUBSUBFRAMES ; ss++)\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                    put_subframe_samples(c, ss, band, ch);\n\n\n\n    /* DSYNC */\n\n    put_bits(&c->pb, 16, 0xffff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1212, "prediction": "0", "true_label": "0", "raw_text": "Question: static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n\n\n    count/=2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for(i=0; i<count; i++){\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1213, "prediction": "0", "true_label": "0", "raw_text": "Question: static int start_auth_vencrypt_subauth(VncState *vs)\n\n{\n\n    switch (vs->vd->subauth) {\n\n    case VNC_AUTH_VENCRYPT_TLSNONE:\n\n    case VNC_AUTH_VENCRYPT_X509NONE:\n\n       VNC_DEBUG(\"Accept TLS auth none\\n\");\n\n       vnc_write_u32(vs, 0); /* Accept auth completion */\n\n       vnc_read_when(vs, protocol_client_init, 1);\n\n       break;\n\n\n\n    case VNC_AUTH_VENCRYPT_TLSVNC:\n\n    case VNC_AUTH_VENCRYPT_X509VNC:\n\n       VNC_DEBUG(\"Start TLS auth VNC\\n\");\n\n       return start_auth_vnc(vs);\n\n\n\n    default: /* Should not be possible, but just in case */\n\n       VNC_DEBUG(\"Reject auth %d\\n\", vs->vd->auth);\n\n       vnc_write_u8(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Unsupported authentication type\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1214, "prediction": "0", "true_label": "0", "raw_text": "Question: iscsi_unmap_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to unmap data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1215, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_notify(struct subchannel_id schid)\n\n{\n\n    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1216, "prediction": "0", "true_label": "0", "raw_text": "Question: static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n\n\n    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);\n\n    kvm_mce_broadcast_rest(env);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1217, "prediction": "0", "true_label": "0", "raw_text": " NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size / flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1218, "prediction": "0", "true_label": "0", "raw_text": " & 0x3;\n\n    uint8_t wt = (ctx->opcode >> 16) & 0x1f;\n\n    int64_t s16 = (int16_t)ctx->opcode;\n\n\n\n    check_msa_access(ctx);\n\n\n\n    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    switch (op1) {\n\n    case OPC_BZ_V:\n\n    case OPC_BNZ_V:\n\n        {\n\n            TCGv_i64 t0 = tcg_temp_new_i64();\n\n            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);\n\n            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?\n\n                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);\n\n            tcg_gen_trunc_i64_tl(bcond, t0);\n\n            tcg_temp_free_i64(t0);\n\n        }\n\n        break;\n\n    case OPC_BZ_B:\n\n    case OPC_BZ_H:\n\n    case OPC_BZ_W:\n\n    case OPC_BZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        break;\n\n    case OPC_BNZ_B:\n\n    case OPC_BNZ_H:\n\n    case OPC_BNZ_W:\n\n    case OPC_BNZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0);\n\n        break;\n\n    }\n\n\n\n    ctx->btarget = ctx->pc + (s16 << 2) + 4;\n\n\n\n    ctx->hflags |= MIPS_HFLAG_BC;\n\n    ctx->hflags |= MIPS_HFLAG_BDS32;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1219, "prediction": "0", "true_label": "0", "raw_text": "Question: static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *ret;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return ret;\n\n\n\nout: \n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1220, "prediction": "0", "true_label": "0", "raw_text": "x).\\n\",\n\n                       ctx->va_rt_format, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRTFormat,\n\n                .value = ctx->va_rt_format,\n\n            };\n\n            break;\n\n        case VAConfigAttribRateControl:\n\n            if (!(ctx->va_rc_mode & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Rate control mode %#x \"\n\n                       \"is not supported (mask: %#x).\\n\",\n\n                       ctx->va_rc_mode, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRateControl,\n\n                .value = ctx->va_rc_mode,\n\n            };\n\n            break;\n\n        case VAConfigAttribEncMaxRefFrames:\n\n        {\n\n            unsigned int ref_l0 = attr[i].value & 0xffff;\n\n            unsigned int ref_l1 = (attr[i].value >> 16) & 0xffff;\n\n\n\n            if (avctx->gop_size > 1 && ref_l0 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"P frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (avctx->max_b_frames > 0 && ref_l1 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"B frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        break;\n\n        default:\n\n            av_assert0(0 && \"Unexpected config attribute.\");\n\n        }\n\n    }\n\n\n\n    err = 0;\n\nfail:\n\n    av_freep(&profiles);\n\n    av_freep(&entrypoints);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1221, "prediction": "0", "true_label": "0", "raw_text": "\n\n        pkt->data[16] = 16;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGR24:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 24;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGRA:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 32;         /* bpp */\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Pixel format '%s' not supported.\\n\",\n\n               av_get_pix_fmt_name(avctx->pix_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    bpp = pkt->data[16] >> 3;\n\n\n\n    out = pkt->data + 18;  /* skip past the header we just output */\n\n\n\n    /* try RLE compression */\n\n    if (avctx->coder_type != FF_CODER_TYPE_RAW)\n\n        datasize = targa_encode_rle(out, picsize, p, bpp, avctx->width, avctx->height);\n\n\n\n    /* if that worked well, mark the picture as RLE compressed */\n\n    if(datasize >= 0)\n\n        pkt->data[2] |= 8;\n\n\n\n    /* if RLE didn't make it smaller, go back to no compression */\n\n    else datasize = targa_encode_normal(out, p, bpp, avctx->width, avctx->height);\n\n\n\n    out += datasize;\n\n\n\n    /* The standard recommends including this section, even if we don't use\n\n     * any of the features it affords. TODO: take advantage of the pixel\n\n     * aspect ratio and encoder ID fields available? */\n\n    memcpy(out, \"\\0\\0\\0\\0\\0\\0\\0\\0TRUEVISION-XFILE.\", 26);\n\n\n\n    pkt->size   = out + 26 - pkt->data;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1222, "prediction": "1", "true_label": "1", "raw_text": "\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1223, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qdm2_init(QDM2Context *q) {\n\n    static int inited = 0;\n\n\n\n    if (inited != 0)\n\n        return;\n\n    inited = 1;\n\n\n\n    qdm2_init_vlc();\n\n    ff_mpa_synth_init(mpa_window);\n\n    softclip_table_init();\n\n    rnd_table_init();\n\n    init_noise_samples();\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"init done\\n\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1224, "prediction": "0", "true_label": "1", "raw_text": "Question: static int encode_frame(FlacEncodeContext *s)\n\n{\n\n    int ch, count;\n\n\n\n    count = count_frame_header(s);\n\n\n\n    for (ch = 0; ch < s->channels; ch++)\n\n        count += encode_residual_ch(s, ch);\n\n\n\n    count += (8 - (count & 7)) & 7; // byte alignment\n\n    count += 16;                    // CRC-16\n\n\n\n    return count >> 3;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1225, "prediction": "0", "true_label": "0", "raw_text": " ret;\n\n        }\n\n    } else {\n\n        /* Begin the rebuild, use QEMU emulated list bits */\n\n        pdev->config[PCI_CAPABILITY_LIST] = 0;\n\n        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;\n\n        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;\n\n    }\n\n\n\n    /* Use emulated next pointer to allow dropping caps */\n\n    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);\n\n\n\n    switch (cap_id) {\n\n    case PCI_CAP_ID_MSI:\n\n        ret = vfio_msi_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_EXP:\n\n        vfio_check_pcie_flr(vdev, pos);\n\n        ret = vfio_setup_pcie_cap(vdev, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_MSIX:\n\n        ret = vfio_msix_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_PM:\n\n        vfio_check_pm_reset(vdev, pos);\n\n        vdev->pm_cap = pos;\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_AF:\n\n        vfio_check_af_flr(vdev, pos);\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    default:\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"\n\n                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,\n\n                     vdev->host.bus, vdev->host.slot, vdev->host.function,\n\n                     cap_id, size, pos, ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1226, "prediction": "0", "true_label": "0", "raw_text": " = 0xffff;\n\n                            } else {\n\n                                insns_left = env->icount_extra;\n\n                            }\n\n                            env->icount_extra -= insns_left;\n\n                            env->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(insns_left, tb);\n\n                            }\n\n                            env->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit();\n\n                        }\n\n                    }\n\n                }\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        }\n\n    } /* for(;;) */\n\n\n\n\n\n#if defined(TARGET_I386)\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n#elif defined(TARGET_ARM)\n\n    /* XXX: Save/restore host fpu exception state?.  */\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_M68K)\n\n    cpu_m68k_flush_flags(env, env->cc_op);\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->sr = (env->sr & 0xffe0)\n\n              | env->cc_dest | (env->cc_x << 4);\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n\n\n    /* restore global registers */\n\n#include \"hostregs_helper.h\"\n\n\n\n    /* fail safe : never use cpu_single_env outside cpu_exec() */\n\n    cpu_single_env = NULL;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1227, "prediction": "0", "true_label": "0", "raw_text": ": /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1228, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool migrate_caps_check(bool *cap_list,\n\n                               MigrationCapabilityStatusList *params,\n\n                               Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *cap;\n\n    bool old_postcopy_cap;\n\n\n\n    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        cap_list[cap->value->capability] = cap->value->state;\n\n    }\n\n\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {\n\n        error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"\n\n                   \"block migration\");\n\n        error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");\n\n        return false;\n\n    }\n\n#endif\n\n\n\n    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {\n\n        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {\n\n            /* The decompression threads asynchronously write into RAM\n\n             * rather than use the atomic copies needed to avoid\n\n             * userfaulting.  It should be possible to fix the decompression\n\n             * threads for compatibility in future.\n\n             */\n\n            error_setg(errp, \"Postcopy is not currently compatible \"\n\n                       \"with compression\");\n\n            return false;\n\n        }\n\n\n\n        /* This check is reasonably expensive, so only when it's being\n\n         * set the first time, also it's only the destination that needs\n\n         * special support.\n\n         */\n\n        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&\n\n            !postcopy_ram_supported_by_host()) {\n\n            /* postcopy_ram_supported_by_host will have emitted a more\n\n             * detailed message\n\n             */\n\n            error_setg(errp, \"Postcopy is not supported\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1229, "prediction": "0", "true_label": "0", "raw_text": "Question: static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(bdrv_get_stats(s->bs), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    bdrv_error_action(s->bs, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1230, "prediction": "0", "true_label": "1", "raw_text": "\n\n    MAC(b0, W3, row[3]);\n\n    b1 = MUL(W3, row[1]);\n\n    MAC(b1, -W7, row[3]);\n\n    b2 = MUL(W5, row[1]);\n\n    MAC(b2, -W1, row[3]);\n\n    b3 = MUL(W7, row[1]);\n\n    MAC(b3, -W5, row[3]);\n\n\n\n    if (AV_RN64A(row + 4)) {\n\n        a0 +=   W4*row[4] + W6*row[6];\n\n        a1 += - W4*row[4] - W2*row[6];\n\n        a2 += - W4*row[4] + W2*row[6];\n\n        a3 +=   W4*row[4] - W6*row[6];\n\n\n\n        MAC(b0,  W5, row[5]);\n\n        MAC(b0,  W7, row[7]);\n\n\n\n        MAC(b1, -W1, row[5]);\n\n        MAC(b1, -W5, row[7]);\n\n\n\n        MAC(b2,  W7, row[5]);\n\n        MAC(b2,  W3, row[7]);\n\n\n\n        MAC(b3,  W3, row[5]);\n\n        MAC(b3, -W1, row[7]);\n\n    }\n\n\n\n    row[0] = (a0 + b0) >> (ROW_SHIFT + extra_shift);\n\n    row[7] = (a0 - b0) >> (ROW_SHIFT + extra_shift);\n\n    row[1] = (a1 + b1) >> (ROW_SHIFT + extra_shift);\n\n    row[6] = (a1 - b1) >> (ROW_SHIFT + extra_shift);\n\n    row[2] = (a2 + b2) >> (ROW_SHIFT + extra_shift);\n\n    row[5] = (a2 - b2) >> (ROW_SHIFT + extra_shift);\n\n    row[3] = (a3 + b3) >> (ROW_SHIFT + extra_shift);\n\n    row[4] = (a3 - b3) >> (ROW_SHIFT + extra_shift);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1231, "prediction": "0", "true_label": "1", "raw_text": "Question: struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1232, "prediction": "0", "true_label": "0", "raw_text": "(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]);\n\n\n\n        qemu_check_nic_model(&nd_table[1], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[1]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]);\n\n    }\n\n\n\n    highbank_binfo.ram_size = ram_size;\n\n    highbank_binfo.kernel_filename = kernel_filename;\n\n    highbank_binfo.kernel_cmdline = kernel_cmdline;\n\n    highbank_binfo.initrd_filename = initrd_filename;\n\n    /* highbank requires a dtb in order to boot, and the dtb will override\n\n     * the board ID. The following value is ignored, so set it to -1 to be\n\n     * clear that the value is meaningless.\n\n     */\n\n    highbank_binfo.board_id = -1;\n\n    highbank_binfo.nb_cpus = smp_cpus;\n\n    highbank_binfo.loader_start = 0;\n\n    highbank_binfo.write_secondary_boot = hb_write_secondary;\n\n    highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1233, "prediction": "0", "true_label": "0", "raw_text": "00) | ((address >> 10) & 0x3fc);\n\n\t} else {\n\n\t    /* Fine pagetable.  */\n\n\t    table = (desc & 0xfffff000) | ((address >> 8) & 0xffc);\n\n\t}\n\n        desc = ldl_phys(table);\n\n        switch (desc & 3) {\n\n        case 0: /* Page translation fault.  */\n\n            code = 7;\n\n            goto do_fault;\n\n        case 1: /* 64k page.  */\n\n            phys_addr = (desc & 0xffff0000) | (address & 0xffff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 2: /* 4k page.  */\n\n            phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 3: /* 1k page.  */\n\n\t    if (type == 1) {\n\n\t\tif (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n\t\t    phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n\t\t} else {\n\n\t\t    /* Page translation fault.  */\n\n\t\t    code = 7;\n\n\t\t    goto do_fault;\n\n\t\t}\n\n\t    } else {\n\n\t\tphys_addr = (desc & 0xfffffc00) | (address & 0x3ff);\n\n\t    }\n\n            ap = (desc >> 4) & 3;\n\n            break;\n\n        default:\n\n            /* Never happens, but compiler isn't smart enough to tell.  */\n\n            abort();\n\n        }\n\n        code = 15;\n\n    }\n\n    *prot = check_ap(env, ap, domain, access_type, is_user);\n\n    if (!*prot) {\n\n        /* Access permission fault.  */\n\n        goto do_fault;\n\n    }\n\n    *phys_ptr = phys_addr;\n\n    return 0;\n\ndo_fault:\n\n    return code | (domain << 4);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1234, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n\n{\n\n    uint16_t list_bytes =\n\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,\n\n                                  devRead.rxFilterConf.mfTableLen);\n\n\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n\n    if (!s->mcast_list) {\n\n        if (s->mcast_list_len == 0) {\n\n            VMW_CFPRN(\"Current multicast list is empty\");\n\n        } else {\n\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n\n                      s->mcast_list_len);\n\n        }\n\n        s->mcast_list_len = 0;\n\n    } else {\n\n        int i;\n\n        hwaddr mcast_list_pa =\n\n            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,\n\n                                      devRead.rxFilterConf.mfTablePA);\n\n\n\n        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);\n\n\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n\n        for (i = 0; i < s->mcast_list_len; i++) {\n\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1235, "prediction": "0", "true_label": "0", "raw_text": "->sw_format         = sw_desc->comp[0].depth > 8 ?\n\n                                        AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;\n\n        frames_ctx->initial_pool_size = dpb_size;\n\n\n\n        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error initializing internal frames context\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n    params.ulWidth             = avctx->coded_width;\n\n    params.ulHeight            = avctx->coded_height;\n\n    params.ulTargetWidth       = avctx->coded_width;\n\n    params.ulTargetHeight      = avctx->coded_height;\n\n    params.bitDepthMinus8      = sw_desc->comp[0].depth - 8;\n\n    params.OutputFormat        = params.bitDepthMinus8 ?\n\n                                 cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;\n\n    params.CodecType           = cuvid_codec_type;\n\n    params.ChromaFormat        = cuvid_chroma_format;\n\n    params.ulNumDecodeSurfaces = dpb_size;\n\n    params.ulNumOutputSurfaces = 1;\n\n\n\n    ret = nvdec_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    pool = av_mallocz(sizeof(*pool));\n\n    if (!pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    pool->dpb_size = dpb_size;\n\n\n\n    ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool,\n\n                                             nvdec_decoder_frame_alloc, av_free);\n\n    if (!ctx->decoder_pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    ff_nvdec_decode_uninit(avctx);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1236, "prediction": "0", "true_label": "1", "raw_text": ";\n\n    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;\n\n    int nb_sns, i, ret, available;\n\n    int total;\n\n    int *available_snapshots;\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n\n\n    if (nb_sns == 0) {\n\n        monitor_printf(mon, \"There is no snapshot available.\\n\");\n\n        return;\n\n    }\n\n\n\n    available_snapshots = g_malloc0(sizeof(int) * nb_sns);\n\n    total = 0;\n\n    for (i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        available = 1;\n\n        bs1 = NULL;\n\n\n\n        while ((bs1 = bdrv_next(bs1))) {\n\n            if (bdrv_can_snapshot(bs1) && bs1 != bs) {\n\n                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);\n\n                if (ret < 0) {\n\n                    available = 0;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (available) {\n\n            available_snapshots[total] = i;\n\n            total++;\n\n        }\n\n    }\n\n\n\n    if (total > 0) {\n\n        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);\n\n        monitor_printf(mon, \"\\n\");\n\n        for (i = 0; i < total; i++) {\n\n            sn = &sn_tab[available_snapshots[i]];\n\n            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"There is no suitable snapshot available\\n\");\n\n    }\n\n\n\n    g_free(sn_tab);\n\n    g_free(available_snapshots);\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1237, "prediction": "0", "true_label": "1", "raw_text": "Question: int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],\n\n                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],\n\n                        int i, int zero_nhood, int16_t qmul[2])\n\n{\n\n    uint8_t *token_prob = probs[i][zero_nhood];\n\n    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n\n        return 0;\n\n    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1238, "prediction": "0", "true_label": "1", "raw_text": "Question: static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n\n{\n\n    cirrus_fill_t rop_func;\n\n\n\n    if (blit_is_unsafe(s)) {\n\n        return 0;\n\n    }\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\n             s->cirrus_blt_dstpitch,\n\n             s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t     s->cirrus_blt_height);\n\n    cirrus_bitblt_reset(s);\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1239, "prediction": "1", "true_label": "1", "raw_text": " pkt->pts, s->audio_frame_count);\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else if (s->decode_map_chunk_offset) {\n\n\n\n        /* send both the decode map and the video data together */\n\n\n\n        if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size))\n\n            return CHUNK_NOMEM;\n\n\n\n        if (s->has_palette) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (pal) {\n\n                memcpy(pal, s->palette, AVPALETTE_SIZE);\n\n                s->has_palette = 0;\n\n\n\n\n\n        pkt->pos= s->decode_map_chunk_offset;\n\n        avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET);\n\n        s->decode_map_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data, s->decode_map_chunk_size) !=\n\n            s->decode_map_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        avio_seek(pb, s->video_chunk_offset, SEEK_SET);\n\n        s->video_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data + s->decode_map_chunk_size,\n\n            s->video_chunk_size) != s->video_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        pkt->stream_index = s->video_stream_index;\n\n        pkt->pts = s->video_pts;\n\n\n\n        av_dlog(NULL, \"sending video frame with pts %\"PRId64\"\\n\", pkt->pts);\n\n\n\n        s->video_pts += s->frame_pts_inc;\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else {\n\n\n\n        avio_seek(pb, s->next_chunk_offset, SEEK_SET);\n\n        chunk_type = CHUNK_DONE;\n\n\n\n\n\n\n    return chunk_type;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1240, "prediction": "0", "true_label": "0", "raw_text": "_align_put_bits(pb);\n\n    skip_put_bytes(pb, s->prefix_bytes);\n\n    put_bits(pb, 8, quant_idx);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n\n        for (orientation = !!level; orientation < 4; orientation++)\n\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (p = 0; p < 3; p++) {\n\n        int bytes_start, bytes_len, pad_s, pad_c;\n\n        bytes_start = put_bits_count(pb) >> 3;\n\n        put_bits(pb, 8, 0);\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                encode_subband(s, pb, slice_x, slice_y,\n\n                               &s->plane[p].band[level][orientation],\n\n                               quants[level][orientation]);\n\n            }\n\n        }\n\n        avpriv_align_put_bits(pb);\n\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n\n        if (p == 2) {\n\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        } else {\n\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        }\n\n        pb->buf[bytes_start] = pad_s;\n\n        flush_put_bits(pb);\n\n        skip_put_bytes(pb, pad_c);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1241, "prediction": "1", "true_label": "0", "raw_text": "Question: static void do_info_commands(Monitor *mon, QObject **ret_data)\n\n{\n\n    QList *cmd_list;\n\n    const mon_cmd_t *cmd;\n\n\n\n    cmd_list = qlist_new();\n\n\n\n    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&\n\n            !compare_cmd(cmd->name, \"info\")) {\n\n            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));\n\n        }\n\n    }\n\n\n\n    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {\n\n            char buf[128];\n\n            snprintf(buf, sizeof(buf), \"query-%s\", cmd->name);\n\n            qlist_append_obj(cmd_list, get_cmd_dict(buf));\n\n        }\n\n    }\n\n\n\n    *ret_data = QOBJECT(cmd_list);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes\n"}], [{"ID": 1242, "prediction": "0", "true_label": "0", "raw_text": "Question: static void spapr_msi_write(void *opaque, hwaddr addr,\n\n                            uint64_t data, unsigned size)\n\n{\n\n    sPAPRPHBState *phb = opaque;\n\n    int ndev = addr >> 16;\n\n    int vec = ((addr & 0xFFFF) >> 2) | data;\n\n    uint32_t irq = phb->msi_table[ndev].irq + vec;\n\n\n\n    trace_spapr_pci_msi_write(addr, data, irq);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1243, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        pxa2xx_i2c_write(s->i2c[1], addr, value);\n\n        return;\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR:\n\n        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);\n\n        s->pm_regs[addr >> 2] |= value & 0x15;\n\n        break;\n\n\n\n    case PSSR:\t/* Read-clean registers */\n\n    case RCSR:\n\n    case PKSR:\n\n        s->pm_regs[addr >> 2] &= ~value;\n\n        break;\n\n\n\n    default:\t/* Read-write registers */\n\n        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {\n\n            s->pm_regs[addr >> 2] = value;\n\n            break;\n\n        }\n\n\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1244, "prediction": "0", "true_label": "0", "raw_text": "Question: CPUX86State *cpu_x86_init(void)\n\n{\n\n    CPUX86State *env;\n\n    int i;\n\n    static int inited;\n\n\n\n    cpu_x86_tblocks_init();\n\n\n\n    env = malloc(sizeof(CPUX86State));\n\n    if (!env)\n\n        return NULL;\n\n    memset(env, 0, sizeof(CPUX86State));\n\n    /* basic FPU init */\n\n    for(i = 0;i < 8; i++)\n\n        env->fptags[i] = 1;\n\n    env->fpuc = 0x37f;\n\n    /* flags setup */\n\n    env->eflags = 0;\n\n\n\n    /* init various static tables */\n\n    if (!inited) {\n\n        inited = 1;\n\n        optimize_flags_init();\n\n    }\n\n    return env;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1245, "prediction": "1", "true_label": "0", "raw_text": "Question: void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1246, "prediction": "0", "true_label": "0", "raw_text": "Question: static int parallel_parse(const char *devname)\n\n{\n\n    static int index = 0;\n\n    char label[32];\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_PARALLEL_PORTS) {\n\n        fprintf(stderr, \"qemu: too many parallel ports\\n\");\n\n        exit(1);\n\n    }\n\n    snprintf(label, sizeof(label), \"parallel%d\", index);\n\n    parallel_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!parallel_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not connect parallel device\"\n\n                \" to character backend '%s'\\n\", devname);\n\n        return -1;\n\n    }\n\n    index++;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1247, "prediction": "0", "true_label": "0", "raw_text": "Question: START_TEST(qfloat_destroy_test)\n\n{\n\n    QFloat *qf = qfloat_from_double(0.0);\n\n    QDECREF(qf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1248, "prediction": "0", "true_label": "0", "raw_text": "Question: static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    int err;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);\n\n    if (err) {\n\n        return err;\n\n    }\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        /* Actual credentials are part of extended attrs */\n\n        uid_t tmp_uid;\n\n        gid_t tmp_gid;\n\n        mode_t tmp_mode;\n\n        dev_t tmp_dev;\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.uid\", &tmp_uid,\n\n                    sizeof(uid_t)) > 0) {\n\n            stbuf->st_uid = tmp_uid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.gid\", &tmp_gid,\n\n                    sizeof(gid_t)) > 0) {\n\n            stbuf->st_gid = tmp_gid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.mode\",\n\n                    &tmp_mode, sizeof(mode_t)) > 0) {\n\n            stbuf->st_mode = tmp_mode;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.rdev\", &tmp_dev,\n\n                        sizeof(dev_t)) > 0) {\n\n                stbuf->st_rdev = tmp_dev;\n\n        }\n\n    }\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1249, "prediction": "0", "true_label": "0", "raw_text": "Question: void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1250, "prediction": "0", "true_label": "0", "raw_text": "Question: static int usb_host_init(void)\n\n{\n\n    const struct libusb_pollfd **poll;\n\n    int i, rc;\n\n\n\n    if (ctx) {\n\n        return 0;\n\n    }\n\n    rc = libusb_init(&ctx);\n\n    if (rc != 0) {\n\n        return -1;\n\n    }\n\n    libusb_set_debug(ctx, loglevel);\n\n\n\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n\n                                usb_host_del_fd,\n\n                                ctx);\n\n    poll = libusb_get_pollfds(ctx);\n\n    if (poll) {\n\n        for (i = 0; poll[i] != NULL; i++) {\n\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n\n        }\n\n    }\n\n    free(poll);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1251, "prediction": "0", "true_label": "0", "raw_text": " (!id && !name) {\n\n        error_setg(errp, \"Name or id must be provided\");\n\n        goto out_aio_context;\n\n    }\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, \"Device '%s' has no medium\", device);\n\n        goto out_aio_context;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n\n        goto out_aio_context;\n\n    }\n\n\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n    if (!ret) {\n\n        error_setg(errp,\n\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n\n                   \"device '%s'\",\n\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    aio_context_release(aio_context);\n\n\n\n    info = g_new0(SnapshotInfo, 1);\n\n    info->id = g_strdup(sn.id_str);\n\n    info->name = g_strdup(sn.name);\n\n    info->date_nsec = sn.date_nsec;\n\n    info->date_sec = sn.date_sec;\n\n    info->vm_state_size = sn.vm_state_size;\n\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n\n\n\n    return info;\n\n\n\nout_aio_context:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1252, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n    virtio_notify(vdev, vq);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1253, "prediction": "0", "true_label": "0", "raw_text": "Question: bool timer_pending(QEMUTimer *ts)\n\n{\n\n    QEMUTimer *t;\n\n    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {\n\n        if (t == ts) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1254, "prediction": "0", "true_label": "0", "raw_text": "(avctx, AV_LOG_ERROR,\n\n               \"Failed to create encoder: %s\\n\", opus_strerror(ret));\n\n        return ff_opus_error_to_averror(ret);\n\n    }\n\n\n\n    ret = libopus_configure_encoder(avctx, enc, &opus->opts);\n\n    if (ret != OPUS_OK) {\n\n        ret = ff_opus_error_to_averror(ret);\n\n        goto fail;\n\n    }\n\n\n\n    header_size = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0);\n\n    avctx->extradata = av_malloc(header_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!avctx->extradata) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate extradata.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    avctx->extradata_size = header_size;\n\n\n\n    opus->samples = av_mallocz(frame_size * avctx->channels *\n\n                               av_get_bytes_per_sample(avctx->sample_fmt));\n\n    if (!opus->samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate samples buffer.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = opus_multistream_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&avctx->delay));\n\n    if (ret != OPUS_OK)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Unable to get number of lookahead samples: %s\\n\",\n\n               opus_strerror(ret));\n\n\n\n    libopus_write_header(avctx, opus->stream_count, coupled_stream_count,\n\n                         opus_vorbis_channel_map[avctx->channels - 1]);\n\n\n\n    ff_af_queue_init(avctx, &opus->afq);\n\n\n\n    opus->enc = enc;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opus_multistream_encoder_destroy(enc);\n\n    av_freep(&avctx->extradata);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1255, "prediction": "0", "true_label": "0", "raw_text": ");\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\n\t\t\t        env, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb8, (char *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+5));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1256, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcp_chr_telnet_init(QIOChannel *ioc)\n\n{\n\n    char buf[3];\n\n    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */\n\n    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1257, "prediction": "1", "true_label": "1", "raw_text": "Question: static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1258, "prediction": "0", "true_label": "1", "raw_text": "Question: static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1259, "prediction": "0", "true_label": "1", "raw_text": "Question: static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1260, "prediction": "0", "true_label": "1", "raw_text": "Question: static void cpu_handle_ioreq(void *opaque)\n\n{\n\n    XenIOState *state = opaque;\n\n    ioreq_t *req = cpu_get_ioreq(state);\n\n\n\n    handle_buffered_iopage(state);\n\n    if (req) {\n\n        ioreq_t copy = *req;\n\n\n\n        xen_rmb();\n\n        handle_ioreq(state, &copy);\n\n        req->data = copy.data;\n\n\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n\n                    \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\",\n\n                    req->state, req->data_is_ptr, req->addr,\n\n                    req->data, req->count, req->size, req->type);\n\n            destroy_hvm_domain(false);\n\n            return;\n\n        }\n\n\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n\n\n        /*\n\n         * We do this before we send the response so that the tools\n\n         * have the opportunity to pick up on the reset before the\n\n         * guest resumes and does a hlt with interrupts disabled which\n\n         * causes Xen to powerdown the domain.\n\n         */\n\n        if (runstate_is_running()) {\n\n            if (qemu_shutdown_requested_get()) {\n\n                destroy_hvm_domain(false);\n\n            }\n\n            if (qemu_reset_requested_get()) {\n\n                qemu_system_reset(VMRESET_REPORT);\n\n                destroy_hvm_domain(true);\n\n            }\n\n        }\n\n\n\n        req->state = STATE_IORESP_READY;\n\n        xenevtchn_notify(state->xce_handle,\n\n                         state->ioreq_local_port[state->send_vcpu]);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1261, "prediction": "-1", "true_label": "1", "raw_text": ".cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < sizeof(r->buf));\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, 36);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1262, "prediction": "0", "true_label": "1", "raw_text": "table, s->l1_size,\n\n                                     &expanded_clusters, &nb_clusters);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n\n     * necessary to flush the L2 table cache before trying to access the L2\n\n     * tables pointed to by inactive L1 entries (else we might try to expand\n\n     * zero clusters that have already been expanded); furthermore, it is also\n\n     * necessary to empty the L2 table cache, since it may contain tables which\n\n     * are now going to be modified directly on disk, bypassing the cache.\n\n     * qcow2_cache_empty() does both for us. */\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n\n            be64_to_cpus(&l1_table[j]);\n\n        }\n\n\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n\n                                         &expanded_clusters, &nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(expanded_clusters);\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1263, "prediction": "0", "true_label": "1", "raw_text": "Question: static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1264, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, int dstW, int y)\n\n{\n\n\tint i;\n\n\tswitch(c->dstFormat)\n\n\t{\n\n\tcase PIX_FMT_BGR32:\n\n\tcase PIX_FMT_RGB32:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint32_t)\n\n\t\t\t((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];\n\n\t\t\t((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];\n\n\t\t}\n\n\t\tbreak;\n\n\tcase PIX_FMT_RGB24:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint8_t)\n\n\t\t\t((uint8_t*)dest)[0]= r[Y1];\n\n\t\t\t((uint8_t*)dest)[1]= g[Y1];\n\n\t\t\t((uint8_t*)dest)[2]= b[Y1];\n\n\t\t\t((uint8_t*)dest)[3]= r[Y2];\n\n\t\t\t((uint8_t*)dest)[4]= g[Y2];\n\n\t\t\t((uint8_t*)dest)[5]= b[Y2];\n\n\t\t\tdest+=6;\n\n\t\t}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1265, "prediction": "0", "true_label": "1", "raw_text": "ts 1 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        } else {\n            av_assert2(pkt->dts == AV_NOPTS_VALUE || pkt->dts >= 0 || s->max_interleave_delta > 0);\n            if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) {\n                av_log(s, AV_LOG_WARNING,\n                    \"Packets poorly interleaved, failed to avoid negative \"\n                    \"timestamp %s in stream %d.\\n\"\n                    \"Try -max_interleave_delta 0 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        }\n    }\n    did_split = av_packet_split_side_data(pkt);\n    if (!s->internal->header_written) {\n        ret = s->internal->write_header_ret ? s->internal->write_header_ret : write_header_internal(s);\n        if (ret < 0)\n            goto fail;\n    }\n    if ((pkt->flags & AV_PKT_FLAG_UNCODED_FRAME)) {\n        AVFrame *frame = (AVFrame *)pkt->data;\n        av_assert0(pkt->size == UNCODED_FRAME_PACKET_SIZE);\n        ret = s->oformat->write_uncoded_frame(s, pkt->stream_index, &frame, 0);\n        av_frame_free(&frame);\n    } else {\n        ret = s->oformat->write_packet(s, pkt);\n    }\n    if (s->pb && ret >= 0) {\n        if (s->flush_packets && s->flags & AVFMT_FLAG_FLUSH_PACKETS)\n            avio_flush(s->pb);\n        if (s->pb->error < 0)\n            ret = s->pb->error;\n    }\nfail:\n    if (did_split)\n        av_packet_merge_side_data(pkt);\n    if (ret < 0) {\n        pkt->pts = pts_backup;\n        pkt->dts = dts_backup;\n    }\n    return ret;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1266, "prediction": "0", "true_label": "1", "raw_text": "Question: static void read_sgi_header(ByteIOContext *f, SGIInfo *info)\n{\n    info->magic = (unsigned short) get_be16(f);\n    info->rle = get_byte(f);\n    info->bytes_per_channel = get_byte(f);\n    info->dimension = (unsigned short)get_be16(f);\n    info->xsize = (unsigned short) get_be16(f);\n    info->ysize = (unsigned short) get_be16(f);\n    info->zsize = (unsigned short) get_be16(f);\n#ifdef DEBUG\n    printf(\"sgi header fields:\\n\");\n    printf(\"  magic: %d\\n\", info->magic);\n    printf(\"    rle: %d\\n\", info->rle);\n    printf(\"    bpc: %d\\n\", info->bytes_per_channel);\n    printf(\"    dim: %d\\n\", info->dimension);\n    printf(\"  xsize: %d\\n\", info->xsize);\n    printf(\"  ysize: %d\\n\", info->ysize);\n    printf(\"  zsize: %d\\n\", info->zsize);\n#endif\n    return;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1267, "prediction": "0", "true_label": "1", "raw_text": ".  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]);\n\n        for (i = 0; i < 8; i++) {\n\n            smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256));\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n\tint max_bus;\n\n        int bus, unit;\n\n        void *scsi;\n\n\n\n        max_bus = drive_get_max_bus(IF_SCSI);\n\n\n\n\tfor (bus = 0; bus <= max_bus; bus++) {\n\n            scsi = lsi_scsi_init(pci_bus, -1);\n\n            for (unit = 0; unit < LSI_MAX_DEVS; unit++) {\n\n\t        index = drive_get_index(IF_SCSI, bus, unit);\n\n\t\tif (index == -1)\n\n\t\t    continue;\n\n\t\tlsi_scsi_attach(scsi, drives_table[index].bdrv, unit);\n\n\t    }\n\n        }\n\n    }\n\n\n\n    /* Add virtio block devices */\n\n    if (pci_enabled) {\n\n        int index;\n\n        int unit_id = 0;\n\n\n\n        while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {\n\n            virtio_blk_init(pci_bus, drives_table[index].bdrv);\n\n            unit_id++;\n\n        }\n\n    }\n\n\n\n    /* Add virtio balloon device */\n\n    if (pci_enabled)\n\n        virtio_balloon_init(pci_bus);\n\n\n\n    /* Add virtio console devices */\n\n    if (pci_enabled) {\n\n        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {\n\n            if (virtcon_hds[i])\n\n                virtio_console_init(pci_bus, virtcon_hds[i]);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1268, "prediction": "0", "true_label": "0", "raw_text": "_str;\n\n    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (!legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    host_port = strtol(buf, &end, 0);\n\n    if (*end != '\\0' || host_port < 1 || host_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &guest_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    guest_port = strtol(p, &end, 0);\n\n    if (*end != '\\0' || guest_port < 1 || guest_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n\n                          guest_port) < 0) {\n\n        error_report(\"could not set up host forwarding rule '%s'\",\n\n                     redir_str);\n\n        return -1;\n\n    }\n\n    return 0;\n\n\n\n fail_syntax:\n\n    error_report(\"invalid host forwarding rule '%s'\", redir_str);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1269, "prediction": "0", "true_label": "0", "raw_text": "pfault_token);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];\n\n            cs->kvm_run->s.regs.crs[i] = env->cregs[i];\n\n        }\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS;\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            sregs.acrs[i] = env->aregs[i];\n\n            sregs.crs[i] = env->cregs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Finally the prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        cs->kvm_run->s.regs.prefix = env->psa;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX;\n\n    } else {\n\n        /* prefix is only supported via sync regs */\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1270, "prediction": "0", "true_label": "0", "raw_text": "0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n    hp->hotplug_identifier = hp_id;\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {\n\n            spapr_hotplug_set_signalled(drc);\n\n        }\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_LMB:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_CPU:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {\n\n        hp->drc.count = cpu_to_be32(drc);\n\n    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {\n\n        hp->drc.index = cpu_to_be32(drc);\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1271, "prediction": "0", "true_label": "0", "raw_text": "Question: static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)\n\n{\n\n    USBHubPort *port;\n\n    USBDevice *dev;\n\n    int i, ret;\n\n\n\n    for(i = 0; i < NUM_PORTS; i++) {\n\n        port = &s->ports[i];\n\n        dev = port->port.dev;\n\n        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {\n\n            ret = usb_handle_packet(dev, p);\n\n            if (ret != USB_RET_NODEV) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return USB_RET_NODEV;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1272, "prediction": "1", "true_label": "1", "raw_text": "Question: BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                                  QEMUIOVector *qiov, int nb_sectors,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    if (bs->dirty_tracking) {\n\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,\n\n                               cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1273, "prediction": "1", "true_label": "0", "raw_text": "Question: av_cold void ff_dct_init_x86(DCTContext *s)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_SSE(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse;\n\n    if (EXTERNAL_SSE2(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse2;\n\n    if (EXTERNAL_AVX(cpu_flags))\n\n        s->dct32 = ff_dct32_float_avx;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1274, "prediction": "0", "true_label": "1", "raw_text": ")\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                for (i = 0; i < rle_code; i++) {\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    stream_byte = bytestream2_get_byteu(gb);\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                    pixel_ptr++;\n\n                    if (i + 1 == rle_code && odd_pixel)\n\n                        break;\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                    pixel_ptr++;\n\n                }\n\n\n\n                // if the RLE code is odd, skip a byte in the stream\n\n                if (extra_byte)\n\n                    bytestream2_skip(gb, 1);\n\n            }\n\n        } else {\n\n            // decode a run of data\n\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            for (i = 0; i < rle_code; i++) {\n\n                if (pixel_ptr >= avctx->width)\n\n                    break;\n\n                if ((i & 1) == 0)\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                else\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                pixel_ptr++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* one last sanity check on the way out */\n\n    if (bytestream2_get_bytes_left(gb)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n\n               bytestream2_get_bytes_left(gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1275, "prediction": "0", "true_label": "1", "raw_text": " void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1276, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_properties(const char *path, bool recurse)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': %s } }\", path);\n\n    g_assert(response);\n\n\n\n    if (!recurse) {\n\n        return;\n\n    }\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        bool is_child = strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL);\n\n        bool is_link = strstart(qdict_get_str(tuple, \"type\"), \"link<\", NULL);\n\n\n\n        if (is_child || is_link) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path, is_child);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': %s,\"\n\n                           \"                 'property': %s } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1277, "prediction": "0", "true_label": "1", "raw_text": " (thp->vst != 0)\n\n                break;\n\n\n\n            /* Video component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* The denominator and numerator are switched because 1/fps\n\n               is required.  */\n\n            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_id = CODEC_ID_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->width = avio_rb32(pb);\n\n            st->codec->height = avio_rb32(pb);\n\n            st->codec->sample_rate = av_q2d(thp->fps);\n\n            thp->vst = st;\n\n            thp->video_stream_index = st->index;\n\n\n\n            if (thp->version == 0x11000)\n\n                avio_rb32(pb); /* Unknown.  */\n\n        } else if (thp->components[i] == 1) {\n\n            if (thp->has_audio != 0)\n\n                break;\n\n\n\n            /* Audio component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_ADPCM_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->channels    = avio_rb32(pb); /* numChannels.  */\n\n            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */\n\n\n\n            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n            thp->audio_stream_index = st->index;\n\n            thp->has_audio = 1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1278, "prediction": "0", "true_label": "1", "raw_text": " g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1279, "prediction": "0", "true_label": "1", "raw_text": "6_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1280, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vinput->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    /* force virtio-1.0 */\n\n    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;\n\n    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1281, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_visitor_out_string(TestOutputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    char *string = (char *) \"Q E M U\";\n\n    Error *err = NULL;\n\n    QObject *obj;\n\n\n\n    visit_type_str(data->ov, &string, NULL, &err);\n\n    g_assert(!err);\n\n\n\n    obj = qmp_output_get_qobject(data->qov);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);\n\n\n\n    qobject_decref(obj);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1282, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    pcms->vmport = value;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1283, "prediction": "0", "true_label": "1", "raw_text": ")st->codec->height * sc->width) /\n\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n\n        }\n\n\n\n#if FF_API_R_FRAME_RATE\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n\n#endif\n\n    }\n\n\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n\n    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&\n\n        TAG_IS_AVCI(st->codec->codec_tag)) {\n\n        ret = ff_generate_avci_extradata(st);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    switch (st->codec->codec_id) {\n\n#if CONFIG_H261_DECODER\n\n    case AV_CODEC_ID_H261:\n\n#endif\n\n#if CONFIG_H263_DECODER\n\n    case AV_CODEC_ID_H263:\n\n#endif\n\n#if CONFIG_MPEG4_DECODER\n\n    case AV_CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width = 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->stsc_data);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n    av_freep(&sc->stps_data);\n\n    av_freep(&sc->elst_data);\n\n    av_freep(&sc->rap_group);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1284, "prediction": "0", "true_label": "1", "raw_text": "Question: static int buffer_empty(Buffer *buffer)\n\n{\n\n    return buffer->offset == 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1285, "prediction": "0", "true_label": "1", "raw_text": "Question: static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1286, "prediction": "0", "true_label": "1", "raw_text": " if(s->flags & CODEC_FLAG_GLOBAL_HEADER){\n\n\n\n            s->avctx->extradata= av_malloc(1024);\n\n            init_put_bits(&s->pb, s->avctx->extradata, 1024);\n\n            \n\n            mpeg4_encode_visual_object_header(s);\n\n            mpeg4_encode_vol_header(s, 0, 0);\n\n\n\n//            ff_mpeg4_stuffing(&s->pb); ?\n\n            flush_put_bits(&s->pb);\n\n            s->avctx->extradata_size= (put_bits_count(&s->pb)+7)>>3;\n\n        }\n\n        \n\n        break;\n\n    case CODEC_ID_H263P:\n\n        if(s->umvplus)\n\n            s->fcode_tab= umv_fcode_tab;\n\n        if(s->modified_quant){\n\n            s->min_qcoeff= -2047;\n\n            s->max_qcoeff=  2047;\n\n        }else{\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        break;\n\n        //Note for mpeg4 & h263 the dc-scale table will be set per frame as needed later \n\n    case CODEC_ID_FLV1:\n\n        if (s->h263_flv > 1) {\n\n            s->min_qcoeff= -1023;\n\n            s->max_qcoeff=  1023;\n\n        } else {\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n        break;\n\n    default: //nothing needed default table allready set in mpegvideo.c\n\n        s->min_qcoeff= -127;\n\n        s->max_qcoeff=  127;\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1287, "prediction": "0", "true_label": "0", "raw_text": "0))) {\n\n                ret = qcow2_get_refcount(bs,\n\n                                         data_offset >> s->cluster_bits,\n\n                                         &refcount);\n\n                if (ret < 0) {\n\n                    /* don't print message nor increment check_errors */\n\n                    continue;\n\n                }\n\n                if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n                    fprintf(stderr, \"%s OFLAG_COPIED data cluster: \"\n\n                            \"l2_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                            fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                                    \"ERROR\",\n\n                            l2_entry, refcount);\n\n                    if (fix & BDRV_FIX_ERRORS) {\n\n                        l2_table[j] = cpu_to_be64(refcount == 1\n\n                                    ? l2_entry |  QCOW_OFLAG_COPIED\n\n                                    : l2_entry & ~QCOW_OFLAG_COPIED);\n\n                        l2_dirty = true;\n\n                        res->corruptions_fixed++;\n\n                    } else {\n\n                        res->corruptions++;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (l2_dirty) {\n\n            ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2,\n\n                                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table; metadata \"\n\n                        \"overlap check failed: %s\\n\", strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n\n\n            ret = bdrv_pwrite(bs->file, l2_offset, l2_table,\n\n                              s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\",\n\n                        strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_vfree(l2_table);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1288, "prediction": "0", "true_label": "0", "raw_text": "base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1289, "prediction": "0", "true_label": "1", "raw_text": "1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s2[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];\n\n    }\n\n#ifdef HAVE_MMX\n\n\tasm(\n\n\t\tEMMS\" \\n\\t\"\n\n\t\tSFENCE\" \\n\\t\"\n\n\t\t::: \"memory\"\n\n\t\t);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1290, "prediction": "0", "true_label": "1", "raw_text": "Question: static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1291, "prediction": "0", "true_label": "0", "raw_text": "Question: static int output_data_internal(MLPDecodeContext *m, unsigned int substr,\n\n                                uint8_t *data, unsigned int *data_size, int is32)\n\n{\n\n    SubStream *s = &m->substream[substr];\n\n    unsigned int i, out_ch = 0;\n\n    int32_t *data_32 = (int32_t*) data;\n\n    int16_t *data_16 = (int16_t*) data;\n\n\n\n    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))\n\n        return -1;\n\n\n\n    for (i = 0; i < s->blockpos; i++) {\n\n        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {\n\n            int mat_ch = s->ch_assign[out_ch];\n\n            int32_t sample = m->sample_buffer[i][mat_ch]\n\n                          << s->output_shift[mat_ch];\n\n            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;\n\n            if (is32) *data_32++ = sample << 8;\n\n            else      *data_16++ = sample >> 8;\n\n        }\n\n    }\n\n\n\n    *data_size = i * out_ch * (is32 ? 4 : 2);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1292, "prediction": "0", "true_label": "1", "raw_text": " (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1293, "prediction": "0", "true_label": "1", "raw_text": "Question: inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n\n\n    src1 += c->chrSrcOffset;\n\n    src2 += c->chrSrcOffset;\n\n\n\n    if (c->chrToYV12) {\n\n        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst, dstWidth);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1294, "prediction": "0", "true_label": "1", "raw_text": "Question: void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1295, "prediction": "0", "true_label": "1", "raw_text": "Question: static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1296, "prediction": "0", "true_label": "1", "raw_text": "_betls(f, &env->tlb.tlb6[i].EPN);\n\n        }\n\n    }\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->pb[i]);\n\n    for (i = 0; i < 1024; i++)\n\n        qemu_get_betls(f, &env->spr[i]);\n\n    ppc_store_sdr1(env, sdr1);\n\n    qemu_get_be32s(f, &env->vscr);\n\n    qemu_get_be64s(f, &env->spe_acc);\n\n    qemu_get_be32s(f, &env->spe_fscr);\n\n    qemu_get_betls(f, &env->msr_mask);\n\n    qemu_get_be32s(f, &env->flags);\n\n    qemu_get_sbe32s(f, &env->error_code);\n\n    qemu_get_be32s(f, &env->pending_interrupts);\n\n    qemu_get_be32s(f, &env->irq_input_state);\n\n    for (i = 0; i < POWERPC_EXCP_NB; i++)\n\n        qemu_get_betls(f, &env->excp_vectors[i]);\n\n    qemu_get_betls(f, &env->excp_prefix);\n\n    qemu_get_betls(f, &env->ivor_mask);\n\n    qemu_get_betls(f, &env->ivpr_mask);\n\n    qemu_get_betls(f, &env->hreset_vector);\n\n    qemu_get_betls(f, &env->nip);\n\n    qemu_get_betls(f, &env->hflags);\n\n    qemu_get_betls(f, &env->hflags_nmsr);\n\n    qemu_get_sbe32s(f, &env->mmu_idx);\n\n    qemu_get_sbe32(f); /* Discard unused power_mode */\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1297, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_qemu_strtoul_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1298, "prediction": "0", "true_label": "0", "raw_text": "6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n\n\n        if (ver_offset) {\n\n            dst1 = __msa_srari_h(hz_out3, 5);\n\n            dst3 = __msa_srari_h(hz_out4, 5);\n\n            dst5 = __msa_srari_h(hz_out5, 5);\n\n            dst7 = __msa_srari_h(hz_out6, 5);\n\n        } else {\n\n            dst1 = __msa_srari_h(hz_out2, 5);\n\n            dst3 = __msa_srari_h(hz_out3, 5);\n\n            dst5 = __msa_srari_h(hz_out4, 5);\n\n            dst7 = __msa_srari_h(hz_out5, 5);\n\n        }\n\n\n\n        SAT_SH4_SH(dst1, dst3, dst5, dst7, 7);\n\n\n\n        dst0 = __msa_aver_s_h(dst0, dst1);\n\n        dst1 = __msa_aver_s_h(dst2, dst3);\n\n        dst2 = __msa_aver_s_h(dst4, dst5);\n\n        dst3 = __msa_aver_s_h(dst6, dst7);\n\n\n\n        PCKEV_B2_SB(dst1, dst0, dst3, dst2, src0, src1);\n\n        XORI_B2_128_SB(src0, src1);\n\n\n\n        ST4x4_UB(src0, src1, 0, 2, 0, 2, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out0 = hz_out4;\n\n        hz_out1 = hz_out5;\n\n        hz_out2 = hz_out6;\n\n        hz_out3 = hz_out7;\n\n        hz_out4 = hz_out8;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1299, "prediction": "0", "true_label": "1", "raw_text": "Question: static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1300, "prediction": "0", "true_label": "0", "raw_text": "Device *d;\n\n        int out_size, in_size;\n\n        if (req->elem.out_num < 1 || req->elem.in_num < 1) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        out_size = req->elem.out_sg[0].iov_len;\n\n        in_size = req->elem.in_sg[0].iov_len;\n\n        if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size ||\n\n            in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        if (req->elem.out_num > 1 && req->elem.in_num > 1) {\n\n            virtio_scsi_fail_cmd_req(req);\n\n            continue;\n\n        }\n\n\n\n        d = virtio_scsi_device_find(s, req->req.cmd->lun);\n\n        if (!d) {\n\n            req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET;\n\n            virtio_scsi_complete_req(req);\n\n            continue;\n\n        }\n\n        req->sreq = scsi_req_new(d, req->req.cmd->tag,\n\n                                 virtio_scsi_get_lun(req->req.cmd->lun),\n\n                                 req->req.cmd->cdb, req);\n\n\n\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n\n            int req_mode =\n\n                (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n\n\n            if (req->sreq->cmd.mode != req_mode ||\n\n                req->sreq->cmd.xfer > req->qsgl.size) {\n\n                req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN;\n\n                virtio_scsi_complete_req(req);\n\n                continue;\n\n            }\n\n        }\n\n\n\n        n = scsi_req_enqueue(req->sreq);\n\n        if (n) {\n\n            scsi_req_continue(req->sreq);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1301, "prediction": "1", "true_label": "0", "raw_text": "Question: CharDriverState *text_console_init(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    QemuConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    width = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (width == 0)\n\n        width = qemu_opt_get_number(opts, \"cols\", 0) * FONT_WIDTH;\n\n\n\n    height = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (height == 0)\n\n        height = qemu_opt_get_number(opts, \"rows\", 0) * FONT_HEIGHT;\n\n\n\n    if (width == 0 || height == 0) {\n\n        s = new_console(NULL, TEXT_CONSOLE);\n\n    } else {\n\n        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);\n\n    }\n\n\n\n    if (!s) {\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n\n\n    s->chr = chr;\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n    chr->opaque = s;\n\n    chr->chr_set_echo = text_console_set_echo;\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1302, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1: return eepro100_read1(s, addr);\n\n    case 2: return eepro100_read2(s, addr);\n\n    case 4: return eepro100_read4(s, addr);\n\n    default: abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1303, "prediction": "1", "true_label": "0", "raw_text": "Question: bool vring_should_notify(VirtIODevice *vdev, Vring *vring)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* Flush out used index updates. This is paired\n\n     * with the barrier that the Guest executes when enabling\n\n     * interrupts. */\n\n    smp_mb();\n\n\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n\n        unlikely(!vring_more_avail(vdev, vring))) {\n\n        return true;\n\n    }\n\n\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n\n        return !(vring_get_avail_flags(vdev, vring) &\n\n                 VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n    old = vring->signalled_used;\n\n    v = vring->signalled_used_valid;\n\n    new = vring->signalled_used = vring->last_used_idx;\n\n    vring->signalled_used_valid = true;\n\n\n\n    if (unlikely(!v)) {\n\n        return true;\n\n    }\n\n\n\n    return vring_need_event(vring_used_event(&vring->vr), new, old);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1304, "prediction": "0", "true_label": "0", "raw_text": "rate_mode(avctx->bit_rate, avctx);\n\n        s->enc_bitrate = avctx->bit_rate;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, 32))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n\n\n    if (frame) {\n\n        if (frame->nb_samples < avctx->frame_size) {\n\n            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n            if (!flush_buf)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));\n\n            samples = flush_buf;\n\n            if (frame->nb_samples < avctx->frame_size - avctx->delay)\n\n                s->enc_last_frame = -1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {\n\n            av_freep(&flush_buf);\n\n            return ret;\n\n        }\n\n    } else {\n\n        if (s->enc_last_frame < 0)\n\n            return 0;\n\n        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n        if (!flush_buf)\n\n            return AVERROR(ENOMEM);\n\n        samples = flush_buf;\n\n        s->enc_last_frame = -1;\n\n    }\n\n\n\n    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,\n\n                                       avpkt->data, 0);\n\n    av_dlog(avctx, \"amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\\n\",\n\n            written, s->enc_mode, frame[0]);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    avpkt->size = written;\n\n    *got_packet_ptr = 1;\n\n    av_freep(&flush_buf);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1305, "prediction": "0", "true_label": "0", "raw_text": "Question: void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1306, "prediction": "0", "true_label": "1", "raw_text": " vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2packedXinC(c, \n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstY);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n\n\n\treturn dstY - lastDstY;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1307, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1308, "prediction": "0", "true_label": "1", "raw_text": "Question: void FUNC(ff_simple_idct)(DCTELEM *block)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctRowCondDC)(block + i*8);\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctSparseCol)(block + i);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1309, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)\n\n{\n\n    if (ohci->async_td &&\n\n        ohci->usb_packet.owner != NULL &&\n\n        ohci->usb_packet.owner->dev == dev) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1310, "prediction": "0", "true_label": "1", "raw_text": " by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec.stats_in);\n\n            avcodec_close(&ost->st->codec);\n\n        }\n\n    }\n\n    \n\n    /* close each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(&ist->st->codec);\n\n        }\n\n    }\n\n    \n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n    /* finished ! */\n\n    \n\n    ret = 0;\n\n fail1:\n\n    av_free(file_table);\n\n\n\n    if (ist_table) {\n\n        for(i=0;i<nb_istreams;i++) {\n\n            ist = ist_table[i];\n\n            av_free(ist);\n\n        }\n\n        av_free(ist_table);\n\n    }\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                fifo_free(&ost->fifo); /* works even if fifo is not\n\n                                          initialized but set to zero */\n\n                av_free(ost->pict_tmp.data[0]);\n\n                if (ost->video_resample)\n\n                    img_resample_close(ost->img_resample_ctx);\n\n                if (ost->audio_resample)\n\n                    audio_resample_close(ost->resample);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n fail:\n\n    ret = -ENOMEM;\n\n    goto fail1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1311, "prediction": "1", "true_label": "1", "raw_text": "c->object_type == AOT_ER_BSAC)\n            c->ext_chan_config = get_bits(&gb, 4);\n    } else {\n        c->ext_object_type = AOT_NULL;\n        c->ext_sample_rate = 0;\n    }\n    specific_config_bitindex = get_bits_count(&gb);\n    if (c->object_type == AOT_ALS) {\n        skip_bits(&gb, 5);\n        if (show_bits_long(&gb, 24) != MKBETAG('\\0','A','L','S'))\n            skip_bits_long(&gb, 24);\n        specific_config_bitindex = get_bits_count(&gb);\n        if (parse_config_ALS(&gb, c))\n            return -1;\n    }\n    if (c->ext_object_type != AOT_SBR && sync_extension) {\n        while (get_bits_left(&gb) > 15) {\n            if (show_bits(&gb, 11) == 0x2b7) { // sync extension\n                get_bits(&gb, 11);\n                c->ext_object_type = get_object_type(&gb);\n                if (c->ext_object_type == AOT_SBR && (c->sbr = get_bits1(&gb)) == 1)\n                    c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n                if (get_bits_left(&gb) > 11 && get_bits(&gb, 11) == 0x548)\n                    c->ps = get_bits1(&gb);\n                break;\n            } else\n                get_bits1(&gb); // skip 1 bit\n        }\n    }\n    //PS requires SBR\n    if (!c->sbr)\n        c->ps = 0;\n    //Limit implicit PS to the HE-AACv2 Profile\n    if ((c->ps == -1 && c->object_type != AOT_AAC_LC) || c->channels & ~0x01)\n        c->ps = 0;\n    return specific_config_bitindex;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1312, "prediction": "0", "true_label": "1", "raw_text": "_intra                         >> ((block_num + 1) * 4));\n\n            mv             = &s->current_picture.motion_val[0][s->block_index[block_num] - s->b8_stride * 2 - 2];\n\n        }\n\n        if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else {\n\n            idx = ((right_cbp >> 1) | block_cbp) & 5; // FIXME check\n\n            if (idx == 5) {\n\n                v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n            } else if (idx) {\n\n                if (idx == 1)\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq);\n\n                else\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n            }\n\n        }\n\n    }\n\n\n\n    dst -= 4;\n\n    ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> (block_num * 4)) & 0xf;\n\n    if (ttblk == TT_4X4 || ttblk == TT_4X8) {\n\n        idx = (block_cbp | (block_cbp >> 1)) & 5;\n\n        if (idx == 5) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else if (idx) {\n\n            if (idx == 1)\n\n                v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq);\n\n            else\n\n                v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1313, "prediction": "0", "true_label": "1", "raw_text": "Question: static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    int len;\n\n\n\n    for(;;) {\n\n        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);\n\n        if (len != TS_PACKET_SIZE)\n\n            return len < 0 ? len : AVERROR_EOF;\n\n        /* check packet sync byte */\n\n        if ((*data)[0] != 0x47) {\n\n            /* find a new packet start */\n\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n\n            if (mpegts_resync(s) < 0)\n\n                return AVERROR(EAGAIN);\n\n            else\n\n                continue;\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1314, "prediction": "0", "true_label": "0", "raw_text": "Question: int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)\n\n{\n\n    char *tail;\n\n    double srate = av_strtod(arg, &tail);\n\n    if (*tail || srate < 1 || (int)srate != srate) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Invalid sample rate '%s'\\n\", arg);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    *ret = srate;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1315, "prediction": "0", "true_label": "1", "raw_text": "Question: static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int32_t op2;\n\n    int32_t r1;\n\n    uint32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n    address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n    op2 = MASK_OP_ABS_OP2(ctx->opcode);\n\n\n\n    temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n    switch (op2) {\n\n    case OPC2_32_ABS_ST_A:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n    case OPC2_32_ABS_ST_D:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_DA:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_W:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n\n\n    }\n\n    tcg_temp_free(temp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1316, "prediction": "0", "true_label": "0", "raw_text": "Question: static void v9fs_readdir(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsFidState *fidp;\n\n    ssize_t retval = 0;\n\n    size_t offset = 7;\n\n    uint64_t initial_offset;\n\n    int32_t count;\n\n    uint32_t max_count;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqd\", &fid, &initial_offset, &max_count);\n\n\n\n    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (!fidp->fs.dir) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (initial_offset == 0) {\n\n        v9fs_co_rewinddir(pdu, fidp);\n\n    } else {\n\n        v9fs_co_seekdir(pdu, fidp, initial_offset);\n\n    }\n\n    count = v9fs_do_readdir(pdu, fidp, max_count);\n\n    if (count < 0) {\n\n        retval = count;\n\n        goto out;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"d\", count);\n\n    retval += count;\n\n    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1317, "prediction": "0", "true_label": "0", "raw_text": "Question: uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint32_t cc = 0;\n\n    int old_exc = cs->exception_index;\n\n    uint64_t asc = env->psw.mask & PSW_MASK_ASC;\n\n    uint64_t ret;\n\n    int flags;\n\n\n\n    /* XXX incomplete - has more corner cases */\n\n    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {\n\n        program_interrupt(env, PGM_SPECIAL_OP, 2);\n\n    }\n\n\n\n    cs->exception_index = old_exc;\n\n    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {\n\n        cc = 3;\n\n    }\n\n    if (cs->exception_index == EXCP_PGM) {\n\n        ret = env->int_pgm_code | 0x80000000;\n\n    } else {\n\n        ret |= addr & ~TARGET_PAGE_MASK;\n\n    }\n\n    cs->exception_index = old_exc;\n\n\n\n    env->cc_op = cc;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1318, "prediction": "0", "true_label": "0", "raw_text": "used_perm,\n\n                                  uint64_t new_shared_perm,\n\n                                  BdrvChild *ignore_child, Error **errp)\n\n{\n\n    BdrvChild *c;\n\n    uint64_t cumulative_perms = new_used_perm;\n\n    uint64_t cumulative_shared_perms = new_shared_perm;\n\n\n\n    /* There is no reason why anyone couldn't tolerate write_unchanged */\n\n    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);\n\n\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c == ignore_child) {\n\n            continue;\n\n        }\n\n\n\n        if ((new_used_perm & c->shared_perm) != new_used_perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which does not \"\n\n                             \"allow '%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        if ((c->perm & new_shared_perm) != c->perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which uses \"\n\n                             \"'%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        cumulative_perms |= c->perm;\n\n        cumulative_shared_perms &= c->shared_perm;\n\n    }\n\n\n\n    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1319, "prediction": "0", "true_label": "0", "raw_text": "Question: static void monitor_protocol_emitter(Monitor *mon, QObject *data)\n\n{\n\n    QDict *qmp;\n\n\n\n    qmp = qdict_new();\n\n\n\n    if (!monitor_has_error(mon)) {\n\n        /* success response */\n\n        if (data) {\n\n            assert(qobject_type(data) == QTYPE_QDICT);\n\n            qobject_incref(data);\n\n            qdict_put_obj(qmp, \"return\", data);\n\n        } else {\n\n            /* return an empty QDict by default */\n\n            qdict_put(qmp, \"return\", qdict_new());\n\n        }\n\n    } else {\n\n        /* error response */\n\n        qdict_put(mon->error->error, \"desc\", qerror_human(mon->error));\n\n        qdict_put(qmp, \"error\", mon->error->error);\n\n        QINCREF(mon->error->error);\n\n        QDECREF(mon->error);\n\n        mon->error = NULL;\n\n    }\n\n\n\n    if (mon->mc->id) {\n\n        qdict_put_obj(qmp, \"id\", mon->mc->id);\n\n        mon->mc->id = NULL;\n\n    }\n\n\n\n    monitor_json_emitter(mon, QOBJECT(qmp));\n\n    QDECREF(qmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1320, "prediction": "0", "true_label": "0", "raw_text": "cl_hrd_parameters_present_flag)\n\n        get_bits1(&h->gb);     /* low_delay_hrd_flag */\n\n    sps->pic_struct_present_flag = get_bits1(&h->gb);\n\n\n\n    sps->bitstream_restriction_flag = get_bits1(&h->gb);\n\n    if (sps->bitstream_restriction_flag) {\n\n        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */\n\n        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */\n\n        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */\n\n        sps->num_reorder_frames = get_ue_golomb(&h->gb);\n\n        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/\n\n\n\n        if (get_bits_left(&h->gb) < 0) {\n\n            sps->num_reorder_frames         = 0;\n\n            sps->bitstream_restriction_flag = 0;\n\n        }\n\n\n\n        if (sps->num_reorder_frames > 16U\n\n            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Clipping illegal num_reorder_frames %d\\n\",\n\n                   sps->num_reorder_frames);\n\n            sps->num_reorder_frames = 16;\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    if (get_bits_left(&h->gb) < 0) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"Overread VUI by %d bits\\n\", -get_bits_left(&h->gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1321, "prediction": "1", "true_label": "0", "raw_text": "Question: int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1322, "prediction": "0", "true_label": "0", "raw_text": "s->bus_num, s->addr, request, value, index);\n\n\n\n    switch (request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        return usb_host_set_address(s, value);\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        return usb_host_set_config(s, value & 0xff);\n\n\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        return usb_host_set_interface(s, index, value);\n\n    }\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    if (length > sizeof(dev->data_buf)) {\n\n        fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\",\n\n                length, sizeof(dev->data_buf));\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    aurb = async_alloc(s);\n\n    aurb->packet = p;\n\n\n\n    /*\n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is laid out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */\n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &dev->setup_buf;\n\n    urb->buffer_length = length + 8;\n\n\n\n    urb->usercontext = s;\n\n\n\n    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,\n\n                              urb->buffer_length, aurb->more);\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        DPRINTF(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    return USB_RET_ASYNC;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1323, "prediction": "0", "true_label": "1", "raw_text": "\n\n    ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);\n\n    if (!ctx->event[1]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Event\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media control.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->control = control;\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->media_event = media_event;\n\n\n\n    r = IMediaEvent_GetEventHandle(media_event, (void *) &media_event_handle);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event handle.\\n\");\n\n        goto error;\n\n    }\n\n    proc = GetCurrentProcess();\n\n    r = DuplicateHandle(proc, media_event_handle, proc, &ctx->event[0],\n\n                        0, 0, DUPLICATE_SAME_ACCESS);\n\n    if (!r) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not duplicate media event handle.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IMediaControl_Run(control);\n\n    if (r == S_FALSE) {\n\n        OAFilterState pfs;\n\n        r = IMediaControl_GetState(control, 0, &pfs);\n\n    }\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not run filter\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nerror:\n\n\n\n    if (devenum)\n\n        ICreateDevEnum_Release(devenum);\n\n\n\n    if (ret < 0)\n\n        dshow_read_close(avctx);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1324, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void s390_machine_initfn(Object *obj)\n\n{\n\n    object_property_add_bool(obj, \"aes-key-wrap\",\n\n                             machine_get_aes_key_wrap,\n\n                             machine_set_aes_key_wrap, NULL);\n\n    object_property_set_description(obj, \"aes-key-wrap\",\n\n            \"enable/disable AES key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"aes-key-wrap\", NULL);\n\n\n\n    object_property_add_bool(obj, \"dea-key-wrap\",\n\n                             machine_get_dea_key_wrap,\n\n                             machine_set_dea_key_wrap, NULL);\n\n    object_property_set_description(obj, \"dea-key-wrap\",\n\n            \"enable/disable DEA key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"dea-key-wrap\", NULL);\n\n    object_property_add_str(obj, \"loadparm\",\n\n            machine_get_loadparm, machine_set_loadparm, NULL);\n\n    object_property_set_description(obj, \"loadparm\",\n\n            \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\"\n\n            \" to upper case) to pass to machine loader, boot manager,\"\n\n            \" and guest kernel\",\n\n\n\n\n\n\n\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1325, "prediction": "0", "true_label": "0", "raw_text": " {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else if (s->pegasus_rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2]) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1326, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1327, "prediction": "1", "true_label": "0", "raw_text": "Question: int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n\n                              int64_t wanted_timestamp, int flags)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    a = -1;\n\n    b = nb_entries;\n\n\n\n    // Optimize appending index entries at the end.\n\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n\n        a = b - 1;\n\n\n\n    while (b - a > 1) {\n\n        m         = (a + b) >> 1;\n\n\n\n        // Search for the next non-discarded packet.\n\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n\n            m++;\n\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n\n                m = b - 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp >= wanted_timestamp)\n\n            b = m;\n\n        if (timestamp <= wanted_timestamp)\n\n            a = m;\n\n    }\n\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n\n        while (m >= 0 && m < nb_entries &&\n\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n\n\n    if (m == nb_entries)\n\n        return -1;\n\n    return m;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1328, "prediction": "0", "true_label": "1", "raw_text": "Question: static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)\n{\n    InputStream *ist = s->opaque;\n    FrameBuffer *buf;\n    int ret, i;\n    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)\n        return ret;\n    buf              = ist->buffer_pool;\n    ist->buffer_pool = buf->next;\n    buf->next        = NULL;\n    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {\n        av_freep(&buf->base[0]);\n        av_free(buf);\n        ist->dr1 = 0;\n        if ((ret = alloc_buffer(s, ist, &buf)) < 0)\n            return ret;\n    }\n    buf->refcount++;\n    frame->opaque        = buf;\n    frame->type          = FF_BUFFER_TYPE_USER;\n    frame->extended_data = frame->data;\n    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;\n    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {\n        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't\n        frame->data[i]     = buf->data[i];\n        frame->linesize[i] = buf->linesize[i];\n    }\n    return 0;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1329, "prediction": "0", "true_label": "0", "raw_text": " else\n\n                        lutlo = lut;\n\n\n\n                    if (luma < 255) {\n\n                        luthi = (histeq->antibanding == HISTEQ_ANTIBANDING_WEAK) ?\n\n                            (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 :\n\n                             histeq->LUT[luma + 1];\n\n                    } else\n\n                        luthi = lut;\n\n\n\n                    if (lutlo != luthi) {\n\n                        jran = LCG(jran);\n\n                        lut = lutlo + ((luthi - lutlo + 1) * jran) / LCG_M;\n\n                    }\n\n                }\n\n\n\n                GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n                if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) {\n\n                    r = (r * 255) / m;\n\n                    g = (g * 255) / m;\n\n                    b = (b * 255) / m;\n\n                } else {\n\n                    r = (r * lut) / luma;\n\n                    g = (g * lut) / luma;\n\n                    b = (b * lut) / luma;\n\n                }\n\n                dst[x + histeq->rgba_map[R]] = r;\n\n                dst[x + histeq->rgba_map[G]] = g;\n\n                dst[x + histeq->rgba_map[B]] = b;\n\n                oluma = (55 * r + 182 * g + 19 * b) >> 8;\n\n                histeq->out_histogram[oluma]++;\n\n            }\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"out[%d]: %u\\n\", x, histeq->out_histogram[x]);\n\n#endif\n\n\n\n    av_frame_free(&inpic);\n\n    return ff_filter_frame(outlink, outpic);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1330, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_visitor_in_native_list_int32(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1331, "prediction": "-1", "true_label": "0", "raw_text": "0) {\n\n            LOG(\"writing to file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        goto out;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = blk_co_flush(exp->blk);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = blk_co_discard(exp->blk, (request.from + exp->dev_offset)\n\n                                       / BDRV_SECTOR_SIZE,\n\n                             request.len / BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n    invalid_request:\n\n        reply.error = EINVAL;\n\n    error_reply:\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\ndone:\n\n    nbd_request_put(req);\n\n    return;\n\n\n\nout:\n\n    nbd_request_put(req);\n\n    client_close(client);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1332, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1333, "prediction": "0", "true_label": "0", "raw_text": "Question: void stl_phys_notdirty(hwaddr addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1334, "prediction": "0", "true_label": "0", "raw_text": "Question: static void compute_antialias_float(MPADecodeContext *s,\n\n                              GranuleDef *g)\n\n{\n\n    float *ptr;\n\n    int n, i;\n\n\n\n    /* we antialias only \"long\" bands */\n\n    if (g->block_type == 2) {\n\n        if (!g->switch_point)\n\n            return;\n\n        /* XXX: check this for 8000Hz case */\n\n        n = 1;\n\n    } else {\n\n        n = SBLIMIT - 1;\n\n    }\n\n\n\n    ptr = g->sb_hybrid + 18;\n\n    for(i = n;i > 0;i--) {\n\n        float tmp0, tmp1;\n\n        float *csa = &csa_table_float[0][0];\n\n#define FLOAT_AA(j)\\\n\n        tmp0= ptr[-1-j];\\\n\n        tmp1= ptr[   j];\\\n\n        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\\\n\n        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];\n\n\n\n        FLOAT_AA(0)\n\n        FLOAT_AA(1)\n\n        FLOAT_AA(2)\n\n        FLOAT_AA(3)\n\n        FLOAT_AA(4)\n\n        FLOAT_AA(5)\n\n        FLOAT_AA(6)\n\n        FLOAT_AA(7)\n\n\n\n        ptr += 18;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1335, "prediction": "0", "true_label": "1", "raw_text": "Question: PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    I440FXState *s;\n\n    PIIX3State *piix3;\n\n\n\n    dev = qdev_create(NULL, \"i440FX-pcihost\");\n\n    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));\n\n    b = pci_bus_new(&s->busdev.qdev, NULL, 0);\n\n    s->bus = b;\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, \"i440FX\");\n\n    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);\n\n\n\n    piix3 = DO_UPCAST(PIIX3State, dev,\n\n                                 pci_create_simple(b, -1, \"PIIX3\"));\n\n    piix3->pic = pic;\n\n    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);\n\n    (*pi440fx_state)->piix3 = piix3;\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255)\n\n        ram_size = 255;\n\n    (*pi440fx_state)->dev.config[0x57]=ram_size;\n\n\n\n    return b;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1336, "prediction": "0", "true_label": "1", "raw_text": "Question: uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1337, "prediction": "0", "true_label": "0", "raw_text": "Question: int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n\n{\n\n    int ret;\n\n\n\n    s->ext_audio_mask = 0;\n\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n\n        return ret;\n\n    s->gb_in = s->gb;\n\n\n\n    if ((ret = parse_frame_header(s)) < 0)\n\n        return ret;\n\n    if ((ret = alloc_sample_buffer(s)) < 0)\n\n        return ret;\n\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n\n        return ret;\n\n    if ((ret = parse_optional_info(s)) < 0)\n\n        return ret;\n\n\n\n    // Workaround for DTS in WAV\n\n    if (s->frame_size > size && s->frame_size < size + 4)\n\n        s->frame_size = size;\n\n\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1338, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1339, "prediction": "0", "true_label": "0", "raw_text": ";\n\n\n\n    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Codec extradata missing or too short.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;\n\n    s->frames = mp3Frames[s->chan_cfg];\n\n    if(!s->frames) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid channel config number.\\n\");\n\n        return -1;\n\n    }\n\n    avctx->channels = mp3Channels[s->chan_cfg];\n\n\n\n    /* Init the first mp3 decoder in standard way, so that all tables get builded\n\n     * We replace avctx->priv_data with the context of the first decoder so that\n\n     * decode_init() does not have to be changed.\n\n     * Other decoders will be inited here copying data from the first context\n\n     */\n\n    // Allocate zeroed memory for the first decoder context\n\n    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));\n\n    // Put decoder context in place to make init_decode() happy\n\n    avctx->priv_data = s->mp3decctx[0];\n\n    decode_init(avctx);\n\n    // Restore mp3on4 context pointer\n\n    avctx->priv_data = s;\n\n    s->mp3decctx[0]->adu_mode = 1; // Set adu mode\n\n\n\n    /* Create a separate codec/context for each frame (first is already ok).\n\n     * Each frame is 1 or 2 channels - up to 5 frames allowed\n\n     */\n\n    for (i = 1; i < s->frames; i++) {\n\n        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));\n\n        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;\n\n        s->mp3decctx[i]->adu_mode = 1;\n\n        s->mp3decctx[i]->avctx = avctx;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1340, "prediction": "1", "true_label": "0", "raw_text": "Question: _syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1341, "prediction": "0", "true_label": "1", "raw_text": "URLState *s = acb->common.bs->opaque;\n\n\n\n    qemu_bh_delete(acb->bh);\n\n    acb->bh = NULL;\n\n\n\n    size_t start = acb->sector_num * SECTOR_SIZE;\n\n    size_t end;\n\n\n\n    // In case we have the requested data already (e.g. read-ahead),\n\n    // we can just call the callback and be done.\n\n    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {\n\n        case FIND_RET_OK:\n\n            qemu_aio_release(acb);\n\n            // fall through\n\n        case FIND_RET_WAIT:\n\n            return;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    // No cache found, so let's start a new request\n\n    state = curl_init_state(s);\n\n    if (!state) {\n\n        acb->common.cb(acb->common.opaque, -EIO);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->start = 0;\n\n    acb->end = (acb->nb_sectors * SECTOR_SIZE);\n\n\n\n    state->buf_off = 0;\n\n    g_free(state->orig_buf);\n\n    state->buf_start = start;\n\n    state->buf_len = acb->end + s->readahead_size;\n\n    end = MIN(start + state->buf_len, s->len) - 1;\n\n    state->orig_buf = g_malloc(state->buf_len);\n\n    state->acb[0] = acb;\n\n\n\n    snprintf(state->range, 127, \"%zd-%zd\", start, end);\n\n    DPRINTF(\"CURL (AIO): Reading %d at %zd (%s)\\n\",\n\n            (acb->nb_sectors * SECTOR_SIZE), start, state->range);\n\n    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);\n\n\n\n    curl_multi_add_handle(s->multi, state->curl);\n\n\n\n    /* Tell curl it needs to kick things off */\n\n    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1342, "prediction": "0", "true_label": "1", "raw_text": "][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);\n\n                    if (score < min) {\n\n                        min = score;\n\n                        qscale = q;\n\n                    }\n\n                }\n\n                bits += ctx->mb_rc[qscale][mb].bits;\n\n                ctx->mb_qscale[mb] = qscale;\n\n                ctx->mb_bits[mb] = ctx->mb_rc[qscale][mb].bits;\n\n            }\n\n            bits = (bits+31)&~31; // padding\n\n            if (bits > ctx->frame_bits)\n\n                break;\n\n        }\n\n        //av_dlog(ctx->m.avctx, \"lambda %d, up %u, down %u, bits %d, frame %d\\n\",\n\n        //        lambda, last_higher, last_lower, bits, ctx->frame_bits);\n\n        if (end) {\n\n            if (bits > ctx->frame_bits)\n\n                return -1;\n\n            break;\n\n        }\n\n        if (bits < ctx->frame_bits) {\n\n            last_lower = FFMIN(lambda, last_lower);\n\n            if (last_higher != 0)\n\n                lambda = (lambda+last_higher)>>1;\n\n            else\n\n                lambda -= down_step;\n\n            down_step *= 5; // XXX tune ?\n\n            up_step = 1<<LAMBDA_FRAC_BITS;\n\n            lambda = FFMAX(1, lambda);\n\n            if (lambda == last_lower)\n\n                break;\n\n        } else {\n\n            last_higher = FFMAX(lambda, last_higher);\n\n            if (last_lower != INT_MAX)\n\n                lambda = (lambda+last_lower)>>1;\n\n            else if ((int64_t)lambda + up_step > INT_MAX)\n\n                return -1;\n\n            else\n\n                lambda += up_step;\n\n            up_step = FFMIN((int64_t)up_step*5, INT_MAX);\n\n            down_step = 1<<LAMBDA_FRAC_BITS;\n\n        }\n\n    }\n\n    //av_dlog(ctx->m.avctx, \"out lambda %d\\n\", lambda);\n\n    ctx->lambda = lambda;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1343, "prediction": "0", "true_label": "1", "raw_text": "\n\n            int n      = j;\n\n            x >>= 1;\n\n            if (type) {\n\n                int flag = x & 1;\n\n                x >>= 1;\n\n                if (n + x >= syncpoint_count + 1) {\n\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n\n                    goto fail;\n\n                }\n\n                while (x--)\n\n                    has_keyframe[n++] = flag;\n\n                has_keyframe[n++] = !flag;\n\n            } else {\n\n                while (x != 1) {\n\n                    if (n >= syncpoint_count + 1) {\n\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n\n                        goto fail;\n\n                    }\n\n                    has_keyframe[n++] = x & 1;\n\n                    x >>= 1;\n\n                }\n\n            }\n\n            if (has_keyframe[0]) {\n\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n\n                goto fail;\n\n            }\n\n            assert(n <= syncpoint_count + 1);\n\n            for (; j < n && j < syncpoint_count; j++) {\n\n                if (has_keyframe[j]) {\n\n                    uint64_t B, A = ffio_read_varlen(bc);\n\n                    if (!A) {\n\n                        A = ffio_read_varlen(bc);\n\n                        B = ffio_read_varlen(bc);\n\n                        // eor_pts[j][i] = last_pts + A + B\n\n                    } else\n\n                        B = 0;\n\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n\n                    last_pts += A + B;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    av_free(syncpoints);\n\n    av_free(has_keyframe);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1344, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1345, "prediction": "1", "true_label": "1", "raw_text": " = arg - drives_opt;\n\n    strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1346, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gic_complete_irq(gic_state * s, int cpu, int irq)\n\n{\n\n    int update = 0;\n\n    int cm = 1 << cpu;\n\n    DPRINTF(\"EOI %d\\n\", irq);\n\n    if (s->running_irq[cpu] == 1023)\n\n        return; /* No active IRQ.  */\n\n    if (irq != 1023) {\n\n        /* Mark level triggered interrupts as pending if they are still\n\n           raised.  */\n\n        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)\n\n                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {\n\n            DPRINTF(\"Set %d pending mask %x\\n\", irq, cm);\n\n            GIC_SET_PENDING(irq, cm);\n\n            update = 1;\n\n        }\n\n    }\n\n    if (irq != s->running_irq[cpu]) {\n\n        /* Complete an IRQ that is not currently running.  */\n\n        int tmp = s->running_irq[cpu];\n\n        while (s->last_active[tmp][cpu] != 1023) {\n\n            if (s->last_active[tmp][cpu] == irq) {\n\n                s->last_active[tmp][cpu] = s->last_active[irq][cpu];\n\n                break;\n\n            }\n\n            tmp = s->last_active[tmp][cpu];\n\n        }\n\n        if (update) {\n\n            gic_update(s);\n\n        }\n\n    } else {\n\n        /* Complete the current running IRQ.  */\n\n        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1347, "prediction": "0", "true_label": "0", "raw_text": "Question: static void init_dequant8_coeff_table(H264Context *h){\n\n    int i,q,x;\n\n    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly\n\n    h->dequant8_coeff[0] = h->dequant8_buffer[0];\n\n    h->dequant8_coeff[1] = h->dequant8_buffer[1];\n\n\n\n    for(i=0; i<2; i++ ){\n\n        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){\n\n            h->dequant8_coeff[1] = h->dequant8_buffer[0];\n\n            break;\n\n        }\n\n\n\n        for(q=0; q<52; q++){\n\n            int shift = div6[q];\n\n            int idx = rem6[q];\n\n            for(x=0; x<64; x++)\n\n                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =\n\n                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *\n\n                    h->pps.scaling_matrix8[i][x]) << shift;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1348, "prediction": "1", "true_label": "1", "raw_text": "Question: char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1349, "prediction": "1", "true_label": "1", "raw_text": "Question: PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1350, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_validate_fail_struct_nested(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1351, "prediction": "0", "true_label": "1", "raw_text": "Question: static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1352, "prediction": "1", "true_label": "1", "raw_text": "Question: static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1353, "prediction": "0", "true_label": "1", "raw_text": "jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    get_message_id = (*env)->GetMethodID(env, exception_class, \"getMessage\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method java/lang/Throwable.getMessage()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception, get_message_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Throwable.getMessage() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    if (name && message) {\n\n        av_bprintf(&bp, \"%s: %s\", name, message);\n\n    } else if (name && !message) {\n\n        av_bprintf(&bp, \"%s occurred\", name);\n\n    } else if (!name && message) {\n\n        av_bprintf(&bp, \"Exception: %s\", message);\n\n    } else {\n\n        av_log(log_ctx, AV_LOG_WARNING, \"Could not retreive exception name and message\\n\");\n\n        av_bprintf(&bp, \"Exception occurred\");\n\n    }\n\n\n\n    ret = av_bprint_finalize(&bp, error);\n\ndone:\n\n\n\n    av_free(name);\n\n    av_free(message);\n\n\n\n    if (class_class) {\n\n        (*env)->DeleteLocalRef(env, class_class);\n\n    }\n\n\n\n    if (exception_class) {\n\n        (*env)->DeleteLocalRef(env, exception_class);\n\n    }\n\n\n\n    if (string) {\n\n        (*env)->DeleteLocalRef(env, string);\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1354, "prediction": "1", "true_label": "1", "raw_text": "sdev, req->qtag);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        dprintf(\"VSCSI: Command complete err=%d\\n\", arg);\n\n        if (arg == 0) {\n\n            /* We handle overflows, not underflows for normal commands,\n\n             * but hopefully nobody cares\n\n             */\n\n            if (req->writing) {\n\n                res_out = req->data_len;\n\n            } else {\n\n                res_in = req->data_len;\n\n            }\n\n            vscsi_send_rsp(s, req, 0, res_in, res_out);\n\n        } else if (arg == CHECK_CONDITION) {\n\n            dprintf(\"VSCSI: Got CHECK_CONDITION, requesting sense...\\n\");\n\n            vscsi_send_request_sense(s, req);\n\n            return;\n\n        } else {\n\n            vscsi_send_rsp(s, req, arg, 0, 0);\n\n        }\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* \"arg\" is how much we have read for reads and how much we want\n\n     * to write for writes (ie, how much is to be DMA'd)\n\n     */\n\n    if (arg) {\n\n        buf = sdev->info->get_buf(sdev, tag);\n\n        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);\n\n    }\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc);\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* Start next chunk */\n\n    req->data_len -= rc;\n\n    if (req->writing) {\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    } else {\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes"}], [{"ID": 1355, "prediction": "0", "true_label": "0", "raw_text": "Question: void helper_store_sdr1(CPUPPCState *env, target_ulong val)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n\n\n    if (!env->external_htab) {\n\n        if (env->spr[SPR_SDR1] != val) {\n\n            ppc_store_sdr1(env, val);\n\n            tlb_flush(CPU(cpu));\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1356, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1357, "prediction": "1", "true_label": "0", "raw_text": "Question: sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n\n                                   uint64_t bus_offset,\n\n                                   uint32_t page_shift,\n\n                                   uint32_t nb_table,\n\n                                   bool vfio_accel)\n\n{\n\n    sPAPRTCETable *tcet;\n\n    char tmp[64];\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!nb_table) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));\n\n    tcet->liobn = liobn;\n\n    tcet->bus_offset = bus_offset;\n\n    tcet->page_shift = page_shift;\n\n    tcet->nb_table = nb_table;\n\n    tcet->vfio_accel = vfio_accel;\n\n\n\n    snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn);\n\n    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);\n\n\n\n    object_property_set_bool(OBJECT(tcet), true, \"realized\", NULL);\n\n\n\n    return tcet;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1358, "prediction": "0", "true_label": "1", "raw_text": "Question: static void debug_print_fis(uint8_t *fis, int cmd_len)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    int i;\n\n\n\n    fprintf(stderr, \"fis:\");\n\n    for (i = 0; i < cmd_len; i++) {\n\n        if ((i & 0xf) == 0) {\n\n            fprintf(stderr, \"\\n%02x:\",i);\n\n        }\n\n        fprintf(stderr, \"%02x \",fis[i]);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1359, "prediction": "0", "true_label": "0", "raw_text": "Constraint = s->max_nal_size;\n\n        } else {\n\n            if (avctx->rtp_payload_size) {\n\n                av_log(avctx,AV_LOG_DEBUG,\"Using RTP Payload size for uiMaxNalSize\");\n\n                param.uiMaxNalSize = avctx->rtp_payload_size;\n\n                param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = avctx->rtp_payload_size;\n\n            } else {\n\n                av_log(avctx,AV_LOG_ERROR,\"Invalid -max_nal_size, specify a valid max_nal_size to use -slice_mode dyn\\n\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((*s->encoder)->InitializeExt(s->encoder, &param) != cmResultSuccess) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Initialize failed\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {\n\n        SFrameBSInfo fbi = { 0 };\n\n        int i, size = 0;\n\n        (*s->encoder)->EncodeParameterSets(s->encoder, &fbi);\n\n        for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++)\n\n            size += fbi.sLayerInfo[0].pNalLengthInByte[i];\n\n        avctx->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        avctx->extradata_size = size;\n\n        memcpy(avctx->extradata, fbi.sLayerInfo[0].pBsBuf, size);\n\n    }\n\n\n\n    props = ff_add_cpb_side_data(avctx);\n\n    if (!props) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    props->max_bitrate = param.iMaxBitrate;\n\n    props->avg_bitrate = param.iTargetBitrate;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    svc_encode_close(avctx);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1360, "prediction": "0", "true_label": "0", "raw_text": " break;\n\n    case SM501_DC_CRT_FB_OFFSET:\n\n        s->dc_crt_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_CRT_H_TOT:\n\n        s->dc_crt_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_H_SYNC:\n\n        s->dc_crt_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_TOT:\n\n        s->dc_crt_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_SYNC:\n\n        s->dc_crt_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_HWC_ADDR:\n\n        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_HWC_LOC:\n\n        s->dc_crt_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_1_2:\n\n        s->dc_crt_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_3:\n\n        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:\n\n        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);\n\n        break;\n\n\n\n    default:\n\n        printf(\"sm501 disp ctrl : not implemented register write.\"\n\n               \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value);\n\n        abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1361, "prediction": "0", "true_label": "0", "raw_text": "\t%1, %%mm0\\n\\t\"\n\n\t\t\"movq\t8%1, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm3\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm1\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm2\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 8%0\"\n\n\t\t:\"=m\"(*(d+offs))\n\n\t\t:\"m\"(*(s+offs))\n\n\t\t:\"memory\");\n\n\toffs+=16;\n\n  }\n\n  __asm __volatile(SFENCE:::\"memory\");\n\n  __asm __volatile(EMMS:::\"memory\");\n\n#else\n\n   const uint16_t *s1=( uint16_t * )src;\n\n   uint16_t *d1=( uint16_t * )dst;\n\n   uint16_t *e=((uint8_t *)s1)+src_size;\n\n   while( s1<e ){\n\n     register int x=*( s1++ );\n\n     /* rrrrrggggggbbbbb\n\n        0rrrrrgggggbbbbb\n\n        0111 1111 1110 0000=0x7FE0\n\n        00000000000001 1111=0x001F */\n\n     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );\n\n   }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1362, "prediction": "0", "true_label": "1", "raw_text": "Question: static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n    int src_len, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    pd = dest;\n\n    if (src_len & 1)\n\n        *pd++ = *ps++;\n\n\n\n    src_len >>= 1;\n\n    i = 0;\n\n    do {\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_len);\n\n\n\n    return ps - src;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1363, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,\n\n                                           src - (stride * 2) +\n\n                                           sizeof(uint8_t), stride,\n\n                                           dst, stride);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1364, "prediction": "0", "true_label": "1", "raw_text": "Question: static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                        const uint8_t **poutbuf, int *poutbuf_size,\n\n                        const uint8_t *buf, int buf_size)\n\n{\n\n    VorbisParseContext *s = s1->priv_data;\n\n    int duration;\n\n\n\n    if (!s->vp && avctx->extradata && avctx->extradata_size) {\n\n        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);\n\n        if (!s->vp)\n\n            goto end;\n\n    }\n\n\n\n    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)\n\n        s1->duration = duration;\n\n\n\nend:\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only packet analysis */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1365, "prediction": "0", "true_label": "1", "raw_text": "\n\n    }\n\n    if (!pcms->above_4g_mem_size) {\n\n        block_len = ram_size;\n\n    } else {\n\n        /*\n\n         * Xen does not allocate the memory continuously, it keeps a\n\n         * hole of the size computed above or passed in.\n\n         */\n\n        block_len = (1ULL << 32) + pcms->above_4g_mem_size;\n\n    }\n\n    memory_region_init_ram(&ram_memory, NULL, \"xen.ram\", block_len,\n\n                           &error_abort);\n\n    *ram_memory_p = &ram_memory;\n\n    vmstate_register_ram_global(&ram_memory);\n\n\n\n    memory_region_init_alias(&ram_640k, NULL, \"xen.ram.640k\",\n\n                             &ram_memory, 0, 0xa0000);\n\n    memory_region_add_subregion(sysmem, 0, &ram_640k);\n\n    /* Skip of the VGA IO memory space, it will be registered later by the VGA\n\n     * emulated device.\n\n     *\n\n     * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load\n\n     * the Options ROM, so it is registered here as RAM.\n\n     */\n\n    memory_region_init_alias(&ram_lo, NULL, \"xen.ram.lo\",\n\n                             &ram_memory, 0xc0000,\n\n                             pcms->below_4g_mem_size - 0xc0000);\n\n    memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        memory_region_init_alias(&ram_hi, NULL, \"xen.ram.hi\",\n\n                                 &ram_memory, 0x100000000ULL,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1366, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);\n\n    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1367, "prediction": "0", "true_label": "1", "raw_text": "\n\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n\n         * on each side */\n\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n\n\n        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    w = s->source.width;\n\n    h = s->source.height;\n\n\n\n    /* fixme: allocate using real stride here */\n\n    s->sbsplit  = av_malloc(sbwidth * sbheight);\n\n    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));\n\n    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n\n    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    if (!s->sbsplit || !s->blmotion)\n\n        return AVERROR(ENOMEM);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1368, "prediction": "0", "true_label": "1", "raw_text": "80;\n\n        last_fragment  = buf[0] & 0x40;\n\n        fu_type        = buf[0] & 0x3f;\n\n\n\n        /* pass the HEVC FU header */\n\n        buf += RTP_HEVC_FU_HEADER_SIZE;\n\n        len -= RTP_HEVC_FU_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        av_dlog(ctx, \" FU type %d with %d bytes\\n\", fu_type, len);\n\n\n\n        if (len <= 0) {\n\n            /* sanity check for size of input packet: 1 byte payload at least */\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (first_fragment && last_fragment) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Illegal combination of S and E bit in RTP/HEVC packet\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1);\n\n        new_nal_header[1] = rtp_pl[1];\n\n\n\n        res = ff_h264_handle_frag_packet(pkt, buf, len, first_fragment,\n\n                                         new_nal_header, sizeof(new_nal_header));\n\n\n\n        break;\n\n    /* PACI packet */\n\n    case 50:\n\n        /* Temporal scalability control information (TSCI) */\n\n        avpriv_report_missing_feature(ctx, \"PACI packets for RTP/HEVC\\n\");\n\n        res = AVERROR_PATCHWELCOME;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1369, "prediction": "1", "true_label": "1", "raw_text": "Question: int avpriv_lock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1370, "prediction": "0", "true_label": "1", "raw_text": "Question: static int libschroedinger_encode_close(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    /* Close the encoder. */\n\n    schro_encoder_free(p_schro_params->encoder);\n\n\n\n    /* Free data in the output frame queue. */\n\n    ff_schro_queue_free(&p_schro_params->enc_frame_queue,\n\n                        libschroedinger_free_frame);\n\n\n\n\n\n    /* Free the encoder buffer. */\n\n    if (p_schro_params->enc_buf_size)\n\n        av_freep(&p_schro_params->enc_buf);\n\n\n\n    /* Free the video format structure. */\n\n    av_freep(&p_schro_params->format);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1371, "prediction": "0", "true_label": "0", "raw_text": "Question: static int cinepak_decode_frame(AVCodecContext *avctx,\n\n                                void *data, int *got_frame,\n\n                                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int ret = 0, buf_size = avpkt->size;\n\n    CinepakContext *s = avctx->priv_data;\n\n\n\n    s->data = buf;\n\n    s->size = buf_size;\n\n\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->palette_video) {\n\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n\n            s->frame->palette_has_changed = 1;\n\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n\n        }\n\n    }\n\n\n\n    if ((ret = cinepak_decode(s)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"cinepak_decode failed\\n\");\n\n    }\n\n\n\n    if (s->palette_video)\n\n        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);\n\n\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n\n        return ret;\n\n\n\n    *got_frame = 1;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1372, "prediction": "0", "true_label": "0", "raw_text": "\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    }\n\n    /* Register CLPD & LCD display */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register CPLD\\n\", __func__);\n\n#endif\n\n    taihu_cpld_init(sysmem, 0x50100000);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr,\n\n                        \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1373, "prediction": "1", "true_label": "1", "raw_text": "Question: static void *ff_avio_child_next(void *obj, void *prev)\n\n{\n\n    AVIOContext *s = obj;\n\n    AVIOInternal *internal = s->opaque;\n\n    return prev ? NULL : internal->h;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1374, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1375, "prediction": "0", "true_label": "1", "raw_text": "Question: static int update_dimensions(VP8Context *s, int width, int height)\n\n{\n\n    if (width  != s->avctx->width ||\n\n        height != s->avctx->height) {\n\n        if (av_image_check_size(width, height, 0, s->avctx))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        vp8_decode_flush_impl(s->avctx, 1, 0, 1);\n\n\n\n        avcodec_set_dimensions(s->avctx, width, height);\n\n    }\n\n\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n\n        !s->top_nnz || !s->top_border)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1376, "prediction": "1", "true_label": "1", "raw_text": "Question: int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp)\n\n{\n\n    int ret;\n\n    const char *type;\n\n\n\n    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);\n\n    if (ret <= 0) {\n\n        return ret;\n\n    }\n\n\n\n    be32_to_cpus(&reply->magic);\n\n\n\n    switch (reply->magic) {\n\n    case NBD_SIMPLE_REPLY_MAGIC:\n\n        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        trace_nbd_receive_simple_reply(reply->simple.error,\n\n                                       nbd_err_lookup(reply->simple.error),\n\n                                       reply->handle);\n\n        if (reply->simple.error == NBD_ESHUTDOWN) {\n\n            /* This works even on mingw which lacks a native ESHUTDOWN */\n\n            error_setg(errp, \"server shutting down\");\n\n            return -EINVAL;\n\n        }\n\n        break;\n\n    case NBD_STRUCTURED_REPLY_MAGIC:\n\n        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        type = nbd_reply_type_lookup(reply->structured.type);\n\n        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,\n\n                                                 reply->structured.type, type,\n\n                                                 reply->structured.handle,\n\n                                                 reply->structured.length);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);\n\n        return -EINVAL;\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1377, "prediction": "0", "true_label": "1", "raw_text": "2] == buf[1] &&                   \n\n                   s->mem[4] == buf[2] &&            \n\n                   s->mem[6] == buf[3] &&            \n\n                   s->mem[8] == buf[4] &&            \n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        avail = s->stop - index;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have receive something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1378, "prediction": "0", "true_label": "1", "raw_text": "Question: static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)\n\n{\n\n    int16_t tmp[146 + 60], *ptr0, *ptr1;\n\n    const int16_t *filter;\n\n    int i, t, off;\n\n\n\n    t = dec->offset2[quart];\n\n    if(t == 127){\n\n        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));\n\n        return;\n\n    }\n\n    for(i = 0; i < 146; i++)\n\n        tmp[i] = dec->filtbuf[i];\n\n    off = (t / 25) + dec->offset1[quart >> 1] + 18;\n\n\n    ptr0 = tmp + 145 - off;\n\n    ptr1 = tmp + 146;\n\n    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;\n\n    for(i = 0; i < 60; i++){\n\n        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;\n\n        ptr0++;\n\n        dec->newvec[i] = t;\n\n        ptr1[i] = t;\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1379, "prediction": "0", "true_label": "1", "raw_text": "Question: static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1380, "prediction": "0", "true_label": "1", "raw_text": "Question: static int net_slirp_init(VLANState *vlan)\n\n{\n\n    if (!slirp_inited) {\n\n        slirp_inited = 1;\n\n        slirp_init();\n\n    }\n\n    slirp_vc = qemu_new_vlan_client(vlan, \n\n                                    slirp_receive, NULL);\n\n    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), \"user redirector\");\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1381, "prediction": "0", "true_label": "1", "raw_text": " } else if (!strcmp(buf1, \"TUPLETYPE\")) {\n\n                pnm_get(s, tuple_type, sizeof(tuple_type));\n\n            } else if (!strcmp(buf1, \"ENDHDR\")) {\n\n                break;\n\n            } else {\n\n                return -1;\n\n            }\n\n        }\n\n        /* check that all tags are present */\n\n        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\\0')\n\n            return -1;\n\n        avctx->width = w;\n\n        avctx->height = h;\n\n        if (depth == 1) {\n\n            if (maxval == 1)\n\n                avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n            else \n\n                avctx->pix_fmt = PIX_FMT_GRAY8;\n\n        } else if (depth == 3) {\n\n            avctx->pix_fmt = PIX_FMT_RGB24;\n\n        } else if (depth == 4) {\n\n            avctx->pix_fmt = PIX_FMT_RGBA32;\n\n        } else {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    } else {\n\n        return -1;\n\n    }\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->width = atoi(buf1);\n\n    if (avctx->width <= 0)\n\n        return -1;\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->height = atoi(buf1);\n\n    if (avctx->height <= 0)\n\n        return -1;\n\n    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {\n\n        pnm_get(s, buf1, sizeof(buf1));\n\n    }\n\n\n\n    /* more check if YUV420 */\n\n    if (avctx->pix_fmt == PIX_FMT_YUV420P) {\n\n        if ((avctx->width & 1) != 0)\n\n            return -1;\n\n        h = (avctx->height * 2);\n\n        if ((h % 3) != 0)\n\n            return -1;\n\n        h /= 3;\n\n        avctx->height = h;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1382, "prediction": "0", "true_label": "0", "raw_text": "Question: void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    return address_space_rw(&address_space_memory, addr, buf, len, is_write);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1383, "prediction": "-1", "true_label": "0", "raw_text": "Question: static void v9fs_link(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t dfid, oldfid;\n\n    V9fsFidState *dfidp, *oldfidp;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    int err = 0;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n\n\n    dfidp = get_fid(pdu, dfid);\n\n    if (dfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    oldfidp = get_fid(pdu, oldfid);\n\n    if (oldfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, dfidp);\n\nout_nofid:\n\n    v9fs_string_free(&name);\n\n    complete_pdu(s, pdu, err);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: static void v9fs_link_ack(void *opaque)\n"}], [{"ID": 1384, "prediction": "1", "true_label": "0", "raw_text": "Question: int dxva2_init(AVCodecContext *s)\n\n{\n\n    InputStream *ist = s->opaque;\n\n    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    DXVA2Context *ctx;\n\n    int ret;\n\n\n\n    if (!ist->hwaccel_ctx) {\n\n        ret = dxva2_alloc(s);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    ctx = ist->hwaccel_ctx;\n\n\n\n    if (s->codec_id == AV_CODEC_ID_H264 &&\n\n        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {\n\n        av_log(NULL, loglevel, \"Unsupported H.264 profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (s->codec_id == AV_CODEC_ID_HEVC &&\n\n        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {\n\n        av_log(NULL, loglevel, \"Unsupported HEVC profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    av_buffer_unref(&ctx->hw_frames_ctx);\n\n\n\n    ret = dxva2_create_decoder(s);\n\n    if (ret < 0) {\n\n        av_log(NULL, loglevel, \"Error creating the DXVA2 decoder\\n\");\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1385, "prediction": "0", "true_label": "0", "raw_text": "Question: static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,\n\n                                         XenPTRegInfo *reg)\n\n{\n\n    PCIDevice *d = &s->dev;\n\n    XenPTRegion *region = NULL;\n\n    PCIIORegion *r;\n\n    int index = 0;\n\n\n\n    /* check 64bit BAR */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if ((0 < index) && (index < PCI_ROM_SLOT)) {\n\n        int type = s->real_device.io_regions[index - 1].type;\n\n\n\n        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)\n\n            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {\n\n            region = &s->bases[index - 1];\n\n            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {\n\n                return XEN_PT_BAR_FLAG_UPPER;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* check unused BAR */\n\n    r = &d->io_regions[index];\n\n    if (!xen_pt_get_bar_size(r)) {\n\n        return XEN_PT_BAR_FLAG_UNUSED;\n\n    }\n\n\n\n    /* for ExpROM BAR */\n\n    if (index == PCI_ROM_SLOT) {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n\n\n    /* check BAR I/O indicator */\n\n    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {\n\n        return XEN_PT_BAR_FLAG_IO;\n\n    } else {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1386, "prediction": "0", "true_label": "1", "raw_text": "strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&\n\n        avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Sample rates other than 8kHz are not \"\n\n               \"allowed when the compliance level is higher than unofficial. \"\n\n               \"Resample or reduce the compliance level.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if (avctx->sample_rate <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Samplerate is invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (avctx->bit_rate % avctx->sample_rate) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitrate - Samplerate combination is invalid\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;\n\n    if (c->code_size < 2 || c->code_size > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of bits %d\\n\", c->code_size);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    avctx->bits_per_coded_sample = c->code_size;\n\n\n\n    g726_reset(c, c->code_size - 2);\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    /* select a frame size that will end on a byte boundary and have a size of\n\n       approximately 1024 bytes */\n\n    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1387, "prediction": "0", "true_label": "1", "raw_text": "Question: static int dv_read_seek(AVFormatContext *s, int stream_index,\n\n                       int64_t timestamp, int flags)\n\n{\n\n    RawDVContext *r   = s->priv_data;\n\n    DVDemuxContext *c = r->dv_demux;\n\n    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);\n\n\n\n    dv_offset_reset(c, offset / c->sys->frame_size);\n\n\n\n    offset = avio_seek(s->pb, offset, SEEK_SET);\n\n    return (offset < 0) ? offset : 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1388, "prediction": "0", "true_label": "1", "raw_text": "Question: static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1389, "prediction": "0", "true_label": "0", "raw_text": " dv_vlc.table_size; i++){\n\n            int code = dv_vlc.table[i][0];\n\n            int len  = dv_vlc.table[i][1];\n\n            int level, run;\n\n\n\n            if (len < 0){ //more bits needed\n\n                run   = 0;\n\n                level = code;\n\n            } else {\n\n                run   = new_dv_vlc_run  [code] + 1;\n\n                level = new_dv_vlc_level[code];\n\n            }\n\n            ff_dv_rl_vlc[i].len   = len;\n\n            ff_dv_rl_vlc[i].level = level;\n\n            ff_dv_rl_vlc[i].run   = run;\n\n        }\n\n        ff_free_vlc(&dv_vlc);\n\n    }\n\n\n\n    /* Generic DSP setup */\n\n    ff_dsputil_init(&dsp, avctx);\n\n    ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp);\n\n    s->get_pixels = dsp.get_pixels;\n\n    s->ildct_cmp = dsp.ildct_cmp[5];\n\n\n\n    /* 88DCT setup */\n\n    s->fdct[0]     = dsp.fdct;\n\n    s->idct_put[0] = dsp.idct_put;\n\n    for (i = 0; i < 64; i++)\n\n       s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];\n\n\n\n    /* 248DCT setup */\n\n    s->fdct[1]     = dsp.fdct248;\n\n    s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP\n\n    memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);\n\n\n\n    avctx->coded_frame = &s->picture;\n\n    s->avctx = avctx;\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1390, "prediction": "0", "true_label": "1", "raw_text": "init(&q);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);\n\n\n\n    rc = quvi_parse(q, s->filename, &m);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);\n\n    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);\n\n    if (rc == QUVI_OK)\n\n        av_dict_set(&s->metadata, \"title\", pagetitle, 0);\n\n\n\n    for (i = 0; i < qc->fmtctx->nb_streams; i++) {\n\n        AVStream *st = avformat_new_stream(s, NULL);\n\n        AVStream *ist = qc->fmtctx->streams[i];\n\n        if (!st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);\n\n    }\n\n\n\n    return 0;\n\n\n\nquvi_fail:\n\n    av_log(s, AV_LOG_ERROR, \"%s\\n\", quvi_strerror(q, rc));\n\n    ret = AVERROR_EXTERNAL;\n\n\n\nend:\n\n    quvi_parse_close(&m);\n\n    quvi_close(&q);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1391, "prediction": "0", "true_label": "0", "raw_text": "Question: static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1392, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_flush_queued_packets(VLANClientState *vc)\n\n{\n\n    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {\n\n        VLANPacket *packet;\n\n        int ret;\n\n\n\n        packet = TAILQ_FIRST(&vc->vlan->send_queue);\n\n        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n\n\n        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);\n\n        if (ret == 0 && packet->sent_cb != NULL) {\n\n            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);\n\n            break;\n\n        }\n\n\n\n        if (packet->sent_cb)\n\n            packet->sent_cb(packet->sender, ret);\n\n\n\n        qemu_free(packet);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1393, "prediction": "0", "true_label": "1", "raw_text": "sse2;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_sse2;\n\n\n\n\n                c->h264_v_loop_filter_luma = ff_x264_deblock_v_luma_sse2;\n\n                c->h264_h_loop_filter_luma = ff_x264_deblock_h_luma_sse2;\n\n                c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_sse2;\n\n                c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_sse2;\n\n\n\n\n                c->h264_idct_add16 = ff_h264_idct_add16_sse2;\n\n                c->h264_idct_add8  = ff_h264_idct_add8_sse2;\n\n                c->h264_idct_add16intra = ff_h264_idct_add16intra_sse2;\n\n            }\n\n            if (mm_flags&AV_CPU_FLAG_SSSE3) {\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_ssse3;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_ssse3;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_ssse3;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_ssse3;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_ssse3;\n\n            }\n\n        }\n\n    }\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1394, "prediction": "0", "true_label": "0", "raw_text": " = ctx->blk_vlc.tab;\n\n        else\n\n            if (ff_ivi_dec_huff_desc(&ctx->gb, 1, IVI_BLK_HUFF,\n\n                                     &band->blk_vlc, avctx))\n\n                return AVERROR_INVALIDDATA;\n\n\n\n        /* select appropriate rvmap table for this band */\n\n        band->rvmap_sel = get_bits1(&ctx->gb) ? get_bits(&ctx->gb, 3) : 8;\n\n\n\n        /* decode rvmap probability corrections if any */\n\n        band->num_corr = 0; /* there is no corrections */\n\n        if (get_bits1(&ctx->gb)) {\n\n            band->num_corr = get_bits(&ctx->gb, 8); /* get number of correction pairs */\n\n            if (band->num_corr > 61) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Too many corrections: %d\\n\",\n\n                       band->num_corr);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* read correction pairs */\n\n            for (i = 0; i < band->num_corr * 2; i++)\n\n                band->corr[i] = get_bits(&ctx->gb, 8);\n\n        }\n\n    }\n\n\n\n    if (band->blk_size == 8) {\n\n        band->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    } else {\n\n        band->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    }\n\n\n\n    /* Indeo 4 doesn't use scale tables */\n\n    band->intra_scale = NULL;\n\n    band->inter_scale = NULL;\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1395, "prediction": "0", "true_label": "0", "raw_text": "\n\n    case TARGET_NR_lchown32:\n\n    case TARGET_NR_getuid32:\n\n    case TARGET_NR_getgid32:\n\n    case TARGET_NR_geteuid32:\n\n    case TARGET_NR_getegid32:\n\n    case TARGET_NR_setreuid32:\n\n    case TARGET_NR_setregid32:\n\n    case TARGET_NR_getgroups32:\n\n    case TARGET_NR_setgroups32:\n\n    case TARGET_NR_fchown32:\n\n    case TARGET_NR_setresuid32:\n\n    case TARGET_NR_getresuid32:\n\n    case TARGET_NR_setresgid32:\n\n    case TARGET_NR_getresgid32:\n\n    case TARGET_NR_chown32:\n\n    case TARGET_NR_setuid32:\n\n    case TARGET_NR_setgid32:\n\n    case TARGET_NR_setfsuid32:\n\n    case TARGET_NR_setfsgid32:\n\n    case TARGET_NR_pivot_root:\n\n    case TARGET_NR_mincore:\n\n    case TARGET_NR_madvise:\n\n    case TARGET_NR_getdents64:\n\n    case TARGET_NR_fcntl64:\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n    case TARGET_NR_readahead:\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported syscall: %d\\n\", num);\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1396, "prediction": "0", "true_label": "1", "raw_text": " = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,\n\n                                        reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    assert(reftable_size < INT_MAX / sizeof(uint64_t));\n\n    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,\n\n                      reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* Enter new reftable into the image header */\n\n    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);\n\n    reftable_offset_and_clusters.reftable_clusters =\n\n        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));\n\n    ret = bdrv_pwrite_sync(bs->file,\n\n                           offsetof(QCowHeader, refcount_table_offset),\n\n                           &reftable_offset_and_clusters,\n\n                           sizeof(reftable_offset_and_clusters));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        be64_to_cpus(&on_disk_reftable[refblock_index]);\n\n    }\n\n    s->refcount_table = on_disk_reftable;\n\n    s->refcount_table_offset = reftable_offset;\n\n    s->refcount_table_size = reftable_size;\n\n    update_max_refcount_table_index(s);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(on_disk_reftable);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1397, "prediction": "0", "true_label": "0", "raw_text": "_cum * (1.0 - is->audio_diff_avg_coef);\n\n\n\n                if (fabs(avg_diff) >= is->audio_diff_threshold) {\n\n                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);\n\n                    nb_samples = samples_size / n;\n\n\n\n                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    if (wanted_size < min_size)\n\n                        wanted_size = min_size;\n\n                    else if (wanted_size > max_size)\n\n                        wanted_size = max_size;\n\n\n\n                    /* add or remove samples to correction the synchro */\n\n                    if (wanted_size < samples_size) {\n\n                        /* remove samples */\n\n                        samples_size = wanted_size;\n\n                    } else if (wanted_size > samples_size) {\n\n                        uint8_t *samples_end, *q;\n\n                        int nb;\n\n\n\n                        /* add samples */\n\n                        nb = (samples_size - wanted_size);\n\n                        samples_end = (uint8_t *)samples + samples_size - n;\n\n                        q = samples_end + n;\n\n                        while (nb > 0) {\n\n                            memcpy(q, samples_end, n);\n\n                            q += n;\n\n                            nb -= n;\n\n                        }\n\n                        samples_size = wanted_size;\n\n                    }\n\n                }\n\n                av_dlog(NULL, \"diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\\n\",\n\n                        diff, avg_diff, samples_size - samples_size1,\n\n                        is->audio_clock, is->video_clock, is->audio_diff_threshold);\n\n            }\n\n        } else {\n\n            /* too big difference : may be initial PTS errors, so\n\n               reset A-V filter */\n\n            is->audio_diff_avg_count = 0;\n\n            is->audio_diff_cum       = 0;\n\n        }\n\n    }\n\n\n\n    return samples_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1398, "prediction": "0", "true_label": "1", "raw_text": "width  + 1) >> 1;\n\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n\n                                            : (planes[p].height + 1) >> 1;\n\n\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n\n        align_fac       = p ? 8 : 16;\n\n        width_aligned   = FFALIGN(b_width , align_fac);\n\n        height_aligned  = FFALIGN(b_height, align_fac);\n\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n\n            band->plane    = p;\n\n            band->band_num = b;\n\n            band->width    = b_width;\n\n            band->height   = b_height;\n\n            band->pitch    = width_aligned;\n\n            band->aheight  = height_aligned;\n\n            band->bufs[0]  = av_mallocz(buf_size);\n\n            band->bufs[1]  = av_mallocz(buf_size);\n\n            band->bufsize  = buf_size/2;\n\n            if (!band->bufs[0] || !band->bufs[1])\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* allocate the 3rd band buffer for scalability mode */\n\n            if (cfg->luma_bands > 1) {\n\n                band->bufs[2] = av_mallocz(buf_size);\n\n                if (!band->bufs[2])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            if (is_indeo4) {\n\n                band->bufs[3]  = av_mallocz(buf_size);\n\n                if (!band->bufs[3])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            /* reset custom vlc */\n\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1399, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int seqvideo_decode_init(AVCodecContext *avctx)\n{\n    SeqVideoContext *seq = avctx->priv_data;\n    seq->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    seq->frame = av_frame_alloc();\n    if (!seq->frame)\n        return AVERROR(ENOMEM);\n    return 0;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1400, "prediction": "0", "true_label": "1", "raw_text": "Question: static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1401, "prediction": "0", "true_label": "1", "raw_text": "Question: static int standard_decode_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0, index;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case P_TYPE: status = decode_p_picture_secondary_header(v); break;\n\n    case B_TYPE: status = decode_b_picture_secondary_header(v); break;\n\n    case BI_TYPE:\n\n    case I_TYPE: break; //Nothing needed as it's done in the epilog\n\n    }\n\n    if (status < 0) return FRAME_SKIPED;\n\n\n\n    /* AC Syntax */\n\n    v->ac_table_level = decode012(gb);\n\n    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)\n\n    {\n\n        v->ac2_table_level = decode012(gb);\n\n    }\n\n    /* DC Syntax */\n\n    index = decode012(gb);\n\n    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];\n\n    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];\n\n   \n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1402, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1403, "prediction": "0", "true_label": "1", "raw_text": "Question: static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)\n\n{\n\n    buf[0] = 0;\n\n    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);\n\n    AV_WB16(&buf[4], s->w);\n\n    AV_WB16(&buf[6], s->h);\n\n    AV_WB16(&buf[8], num_strips);\n\n\n\n    return CVID_HEADER_SIZE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1404, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1405, "prediction": "1", "true_label": "1", "raw_text": "Question: const AVOption *av_opt_next(void *obj, const AVOption *last)\n\n{\n\n    AVClass *class = *(AVClass**)obj;\n\n    if (!last && class->option[0].name) return class->option;\n\n    if (last && last[1].name)           return ++last;\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1406, "prediction": "0", "true_label": "1", "raw_text": "_sync_ipts(ost) * enc->sample_rate), av_fifo_size(ost->fifo)/(ost->st->codec->channels * 2));\n\n                avresample_set_compensation(ost->avr, comp, enc->sample_rate);\n\n            }\n\n        }\n\n    } else if (audio_sync_method == 0)\n\n        ost->sync_opts = lrintf(get_sync_ipts(ost, ist->last_dts) * enc->sample_rate) -\n\n                                av_fifo_size(ost->fifo) / (enc->channels * osize); // FIXME wrong\n\n\n\n    if (ost->audio_resample) {\n\n        buftmp = audio_buf;\n\n        size_out = avresample_convert(ost->avr, (void **)&buftmp,\n\n                                      allocated_audio_buf_size, out_linesize,\n\n                                      (void **)&buf, buf_linesize,\n\n                                      size / (dec->channels * isize));\n\n        size_out = size_out * enc->channels * osize;\n\n    } else {\n\n        buftmp = buf;\n\n        size_out = size;\n\n    }\n\n\n\n    /* now encode as many frames as possible */\n\n    if (!(enc->codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) {\n\n        /* output resampled raw samples */\n\n        if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"av_fifo_realloc2() failed\\n\");\n\n            exit_program(1);\n\n        }\n\n        av_fifo_generic_write(ost->fifo, buftmp, size_out, NULL);\n\n\n\n        frame_bytes = enc->frame_size * osize * enc->channels;\n\n\n\n        while (av_fifo_size(ost->fifo) >= frame_bytes) {\n\n            av_fifo_generic_read(ost->fifo, audio_buf, frame_bytes, NULL);\n\n            encode_audio_frame(s, ost, audio_buf, frame_bytes);\n\n        }\n\n    } else {\n\n        encode_audio_frame(s, ost, buftmp, size_out);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1407, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: /* LSL */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: /* LSR */\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: /* ASR */\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: /* ROR/RRX */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1408, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1409, "prediction": "0", "true_label": "0", "raw_text": "Question: static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1410, "prediction": "0", "true_label": "0", "raw_text": "Question: static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf),\n\n                term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1411, "prediction": "0", "true_label": "0", "raw_text": "Question: int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, size,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1412, "prediction": "0", "true_label": "0", "raw_text": "Question: static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1413, "prediction": "0", "true_label": "0", "raw_text": "sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);\n\n\n\n        ff_hevc_cabac_init(s, ctb_addr_ts);\n\n\n\n        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);\n\n\n\n        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;\n\n        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;\n\n        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;\n\n\n\n        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);\n\n        if (more_data < 0) {\n\n            s->tab_slice_address[ctb_addr_rs] = -1;\n\n            return more_data;\n\n        }\n\n\n\n\n\n        ctb_addr_ts++;\n\n        ff_hevc_save_states(s, ctb_addr_ts);\n\n        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);\n\n    }\n\n\n\n    if (x_ctb + ctb_size >= s->sps->width &&\n\n        y_ctb + ctb_size >= s->sps->height)\n\n        ff_hevc_hls_filter(s, x_ctb, y_ctb);\n\n\n\n    return ctb_addr_ts;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1414, "prediction": "0", "true_label": "1", "raw_text": " 2:\n\n            frame_size = (frame_size * 144000) / sample_rate;\n\n            frame_size += padding;\n\n            break;\n\n        default:\n\n        case 3:\n\n            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);\n\n            frame_size += padding;\n\n            break;\n\n        }\n\n        s->frame_size = frame_size;\n\n    } else {\n\n        /* if no frame size computed, signal it */\n\n        if (!s->free_format_frame_size)\n\n            return 1;\n\n        /* free format: compute bitrate and real frame size from the\n\n           frame size we extracted by reading the bitstream */\n\n        s->frame_size = s->free_format_frame_size;\n\n        switch(s->layer) {\n\n        case 1:\n\n            s->frame_size += padding  * 4;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 48000;\n\n            break;\n\n        case 2:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 144000;\n\n            break;\n\n        default:\n\n        case 3:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;\n\n            break;\n\n        }\n\n    }\n\n    s->sample_rate = sample_rate;\n\n    \n\n#if defined(DEBUG)\n\n    printf(\"layer%d, %d Hz, %d kbits/s, \",\n\n           s->layer, s->sample_rate, s->bit_rate);\n\n    if (s->nb_channels == 2) {\n\n        if (s->layer == 3) {\n\n            if (s->mode_ext & MODE_EXT_MS_STEREO)\n\n                printf(\"ms-\");\n\n            if (s->mode_ext & MODE_EXT_I_STEREO)\n\n                printf(\"i-\");\n\n        }\n\n        printf(\"stereo\");\n\n    } else {\n\n        printf(\"mono\");\n\n    }\n\n    printf(\"\\n\");\n\n#endif\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1415, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int init(AVFilterContext *ctx, const char *args)\n\n{\n\n    GradFunContext *gf = ctx->priv;\n\n    float thresh = 1.2;\n\n    int radius = 16;\n\n\n\n    if (args)\n\n        sscanf(args, \"%f:%d\", &thresh, &radius);\n\n\n\n    thresh = av_clipf(thresh, 0.51, 255);\n\n    gf->thresh = (1 << 15) / thresh;\n\n    gf->radius = av_clip((radius + 1) & ~1, 4, 32);\n\n\n\n    gf->blur_line = ff_gradfun_blur_line_c;\n\n    gf->filter_line = ff_gradfun_filter_line_c;\n\n\n\n    if (ARCH_X86)\n\n        ff_gradfun_init_x86(gf);\n\n\n\n    av_log(ctx, AV_LOG_VERBOSE, \"threshold:%.2f radius:%d\\n\", thresh, gf->radius);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1416, "prediction": "0", "true_label": "0", "raw_text": "Question: static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t    int enable)\n\n{\n\n\treturn kvm_set_migration_log(enable);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1417, "prediction": "0", "true_label": "0", "raw_text": "Question: static int64_t rtmp_read_seek(URLContext *s, int stream_index,\n\n                              int64_t timestamp, int flags)\n\n{\n\n    RTMP *r = s->priv_data;\n\n\n\n    if (flags & AVSEEK_FLAG_BYTE)\n\n        return AVERROR(ENOSYS);\n\n\n\n    /* seeks are in milliseconds */\n\n    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);\n\n    if (!RTMP_SendSeek(r, timestamp))\n\n        return -1;\n\n    return timestamp;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1418, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int mace_decode_init(AVCodecContext * avctx)\n\n{\n\n    MACEContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2)\n\n        return -1;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    avcodec_get_frame_defaults(&ctx->frame);\n\n    avctx->coded_frame = &ctx->frame;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1419, "prediction": "0", "true_label": "1", "raw_text": "4) {\n\n            mask >>= 25 + aExp;\n\n        }\n\n    } else {\n\n        mask = 0x00001fff;\n\n    }\n\n    if (aSig & mask) {\n\n        float_raise( float_flag_underflow STATUS_VAR );\n\n        roundingMode = STATUS(float_rounding_mode);\n\n        switch (roundingMode) {\n\n        case float_round_nearest_even:\n\n            increment = (mask + 1) >> 1;\n\n            if ((aSig & mask) == increment) {\n\n                increment = aSig & (increment << 1);\n\n            }\n\n            break;\n\n        case float_round_up:\n\n            increment = aSign ? 0 : mask;\n\n            break;\n\n        case float_round_down:\n\n            increment = aSign ? mask : 0;\n\n            break;\n\n        default: /* round_to_zero */\n\n            increment = 0;\n\n            break;\n\n        }\n\n        aSig += increment;\n\n        if (aSig >= 0x01000000) {\n\n            aSig >>= 1;\n\n            aExp++;\n\n        }\n\n    } else if (aExp < -14\n\n          && STATUS(float_detect_tininess) == float_tininess_before_rounding) {\n\n        float_raise( float_flag_underflow STATUS_VAR);\n\n    }\n\n\n\n    if (ieee) {\n\n        if (aExp > 15) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0);\n\n        }\n\n    } else {\n\n        if (aExp > 16) {\n\n            float_raise(float_flag_invalid | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n    }\n\n    if (aExp < -24) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    if (aExp < -14) {\n\n        aSig >>= -14 - aExp;\n\n        aExp = -14;\n\n    }\n\n    return packFloat16(aSign, aExp + 14, aSig >> 13);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1420, "prediction": "0", "true_label": "0", "raw_text": " = 0;\n\n    while (virtqueue_num_heads(vq, idx)) {\n\n        unsigned int max, num_bufs, indirect = 0;\n\n        target_phys_addr_t desc_pa;\n\n        int i;\n\n\n\n        max = vq->vring.num;\n\n        num_bufs = total_bufs;\n\n        i = virtqueue_get_head(vq, idx++);\n\n        desc_pa = vq->vring.desc;\n\n\n\n        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {\n\n            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {\n\n                error_report(\"Invalid size for indirect buffer table\");\n\n                exit(1);\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            indirect = 1;\n\n            max = vring_desc_len(desc_pa, i) / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            desc_pa = vring_desc_addr(desc_pa, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_WRITE) {\n\n                if (in_bytes > 0 &&\n\n                    (in_total += vring_desc_len(desc_pa, i)) >= in_bytes)\n\n                    return 1;\n\n            } else {\n\n                if (out_bytes > 0 &&\n\n                    (out_total += vring_desc_len(desc_pa, i)) >= out_bytes)\n\n                    return 1;\n\n            }\n\n        } while ((i = virtqueue_next_desc(desc_pa, i, max)) != max);\n\n\n\n        if (!indirect)\n\n            total_bufs = num_bufs;\n\n        else\n\n            total_bufs++;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1421, "prediction": "0", "true_label": "0", "raw_text": "Question: static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    FDCharDriver *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(FDCharDriver));\n\n    s->fd_in = io_channel_from_fd(fd_in);\n\n    s->fd_out = io_channel_from_fd(fd_out);\n\n    fcntl(fd_out, F_SETFL, O_NONBLOCK);\n\n    s->chr = chr;\n\n    chr->opaque = s;\n\n    chr->chr_add_watch = fd_chr_add_watch;\n\n    chr->chr_write = fd_chr_write;\n\n    chr->chr_update_read_handler = fd_chr_update_read_handler;\n\n    chr->chr_close = fd_chr_close;\n\n\n\n    qemu_chr_be_generic_open(chr);\n\n\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1422, "prediction": "0", "true_label": "0", "raw_text": "Question: static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    const int16_t *samples = (const int16_t *)frame->data[0];\n\n    int nb_samples, out_size, ret;\n\n\n\n    out_size = (frame->nb_samples + 1) / 2;\n\n    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))\n\n        return ret;\n\n\n\n    nb_samples = frame->nb_samples - (frame->nb_samples & 1);\n\n\n\n    if (avctx->trellis)\n\n        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);\n\n    else\n\n        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);\n\n\n\n    /* handle last frame with odd frame_size */\n\n    if (nb_samples < frame->nb_samples) {\n\n        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };\n\n        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1423, "prediction": "0", "true_label": "0", "raw_text": " s->palette, AVPALETTE_SIZE);\n\n            pal_exdata[trans*4 + 3*!HAVE_BIGENDIAN] = 0x00;\n\n        }\n\n    }\n\n    if (trans < 0)\n\n        honor_transparency = 0;\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, 2 * width * height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf + y_start*linesize + x_start;\n\n    if (honor_transparency) {\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        const uint8_t *ref = s->last_frame->data[0] + y_start*ref_linesize + x_start;\n\n\n\n        for (y = 0; y < height; y++) {\n\n            memcpy(s->tmpl, ptr, width);\n\n            for (x = 0; x < width; x++)\n\n                if (ref[x] == ptr[x])\n\n                    s->tmpl[x] = trans;\n\n            len += ff_lzw_encode(s->lzw, s->tmpl, width);\n\n            ptr += linesize;\n\n            ref += ref_linesize;\n\n        }\n\n    } else {\n\n        for (y = 0; y < height; y++) {\n\n            len += ff_lzw_encode(s->lzw, ptr, width);\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1424, "prediction": "1", "true_label": "0", "raw_text": "Question: static int openfile(char *name, int flags)\n\n{\n\n\tif (bs) {\n\n\t\tfprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\t\treturn 1;\n\n\t}\n\n\n\n\tbs = bdrv_new(\"hda\");\n\n\tif (!bs)\n\n\t\treturn 1;\n\n\n\n\tif (bdrv_open(bs, name, flags) == -1) {\n\n\t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name);\n\n\t\tbs = NULL;\n\n\t\treturn 1;\n\n\t}\n\n\n\n\treturn 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1425, "prediction": "0", "true_label": "0", "raw_text": "Question: static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);\n\n    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),\n\n                                  \"/e500-ccsr\"));\n\n\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);\n\n    d->config[PCI_HEADER_TYPE] =\n\n        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n\n\n    memory_region_init_alias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsr_space,\n\n                             0, int128_get64(ccsr->ccsr_space.size));\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1426, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n\n\n\n        do {\n\n            out[x] = 0.0;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1427, "prediction": "0", "true_label": "1", "raw_text": "));\n\n    if (!film->sample_table)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_set_pts_info(s->streams[i], 33, 1, film->base_clock);\n\n\n\n    audio_frame_counter = 0;\n\n    for (i = 0; i < film->sample_count; i++) {\n\n        /* load the next sample record and transfer it to an internal struct */\n\n        if (avio_read(pb, scratch, 16) != 16) {\n\n            av_free(film->sample_table);\n\n            return AVERROR(EIO);\n\n        }\n\n        film->sample_table[i].sample_offset =\n\n            data_offset + AV_RB32(&scratch[0]);\n\n        film->sample_table[i].sample_size = AV_RB32(&scratch[4]);\n\n        if (AV_RB32(&scratch[8]) == 0xFFFFFFFF) {\n\n            film->sample_table[i].stream = film->audio_stream_index;\n\n            film->sample_table[i].pts = audio_frame_counter;\n\n            film->sample_table[i].pts *= film->base_clock;\n\n            film->sample_table[i].pts /= film->audio_samplerate;\n\n\n\n            if (film->audio_type == CODEC_ID_ADPCM_ADX)\n\n                audio_frame_counter += (film->sample_table[i].sample_size * 32 /\n\n                    (18 * film->audio_channels));\n\n            else\n\n                audio_frame_counter += (film->sample_table[i].sample_size /\n\n                    (film->audio_channels * film->audio_bits / 8));\n\n        } else {\n\n            film->sample_table[i].stream = film->video_stream_index;\n\n            film->sample_table[i].pts = AV_RB32(&scratch[8]) & 0x7FFFFFFF;\n\n            film->sample_table[i].keyframe = (scratch[8] & 0x80) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    film->current_sample = 0;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1428, "prediction": "0", "true_label": "1", "raw_text": "Question: static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n\n{\n\n    int16_t *block = ctx->dct_block;\n\n    unsigned int pos;\n\n\n\n    ctx->bdsp.clear_block(block);\n\n\n\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n\n\n\n    for (pos = 1; pos < num_coeffs; pos++) {\n\n        uint32_t vlc, num_bits;\n\n        int value;\n\n        int coeff;\n\n\n\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n\n        if (!vlc) /* end-of-block code */\n\n            return 0;\n\n        if (vlc == -1)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        /* pos_add and num_bits are coded in the vlc code */\n\n        pos     += vlc & 15; // pos_add\n\n        num_bits = vlc >> 4; // num_bits\n\n\n\n        if (pos >= 64)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        value = get_bits(&ctx->gb, num_bits);\n\n\n\n        /* FFmpeg's IDCT behaves somewhat different from the original code, so\n\n         * a factor of 4 was added to the input */\n\n\n\n        coeff = vlcdec_lookup[num_bits][value];\n\n        if (pos < 3)\n\n            coeff *= 16;\n\n        else /* TODO Use >> 10 instead of / 1001 */\n\n            coeff = (coeff * qscale) / 1001;\n\n\n\n        block[ctx->scantable.permutated[pos]] = coeff;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1429, "prediction": "0", "true_label": "0", "raw_text": "_bits = 8*buf_size;\n\n\n\n                if (svq3_decode_slice_header(h))\n\n                    return -1;\n\n\n\n                /* TODO: support s->mb_skip_run */\n\n            }\n\n\n\n            mb_type = svq3_get_ue_golomb(&s->gb);\n\n\n\n            if (s->pict_type == FF_I_TYPE) {\n\n                mb_type += 8;\n\n            } else if (s->pict_type == FF_B_TYPE && mb_type >= 4) {\n\n                mb_type += 4;\n\n            }\n\n            if (mb_type > 33 || svq3_decode_mb(h, mb_type)) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"error while decoding MB %d %d\\n\", s->mb_x, s->mb_y);\n\n                return -1;\n\n            }\n\n\n\n            if (mb_type != 0) {\n\n                hl_decode_mb (h);\n\n            }\n\n\n\n            if (s->pict_type != FF_B_TYPE && !s->low_delay) {\n\n                s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] =\n\n                    (s->pict_type == FF_P_TYPE && mb_type < 8) ? (mb_type - 1) : -1;\n\n            }\n\n        }\n\n\n\n        ff_draw_horiz_band(s, 16*s->mb_y, 16);\n\n    }\n\n\n\n    MPV_frame_end(s);\n\n\n\n    if (s->pict_type == FF_B_TYPE || s->low_delay) {\n\n        *(AVFrame *) data = *(AVFrame *) &s->current_picture;\n\n    } else {\n\n        *(AVFrame *) data = *(AVFrame *) &s->last_picture;\n\n    }\n\n\n\n    avctx->frame_number = s->picture_number - 1;\n\n\n\n    /* Do not output the last pic after seeking. */\n\n    if (s->last_picture_ptr || s->low_delay) {\n\n        *data_size = sizeof(AVFrame);\n\n    }\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1430, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int rl2_decode_init(AVCodecContext *avctx)\n\n{\n\n    Rl2Context *s = avctx->priv_data;\n\n    int back_size;\n\n    int i;\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    avcodec_get_frame_defaults(&s->frame);\n\n\n\n    /** parse extra data */\n\n    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid extradata size\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** get frame_offset */\n\n    s->video_base = AV_RL16(&avctx->extradata[0]);\n\n    s->clr_count = AV_RL32(&avctx->extradata[2]);\n\n\n\n    if(s->video_base >= avctx->width * avctx->height){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid video_base\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** initialize palette */\n\n    for(i=0;i<AVPALETTE_COUNT;i++)\n\n        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);\n\n\n\n    /** decode background frame if present */\n\n    back_size = avctx->extradata_size - EXTRADATA1_SIZE;\n\n\n\n    if(back_size > 0){\n\n        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);\n\n        if(!back_frame)\n\n            return -1;\n\n        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,\n\n                           back_frame,avctx->width,0);\n\n        s->back_frame = back_frame;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1431, "prediction": "0", "true_label": "1", "raw_text": "Question: static void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1432, "prediction": "0", "true_label": "0", "raw_text": "\n\n\n\n            /* move apart */\n\n            center_val = nlsf[k - 1] + nlsf[k];\n\n            center_val = (center_val >> 1) + (center_val & 1); // rounded divide by 2\n\n            center_val = FFMIN(max_center, FFMAX(min_center, center_val));\n\n\n\n            nlsf[k - 1] = center_val - (min_delta[k] >> 1);\n\n            nlsf[k]     = nlsf[k - 1] + min_delta[k];\n\n        }\n\n    }\n\n\n\n    /* resort to the fall-back method, the standard method for LSF stabilization */\n\n\n\n    /* sort; as the LSFs should be nearly sorted, use insertion sort */\n\n    for (i = 1; i < order; i++) {\n\n        int j, value = nlsf[i];\n\n        for (j = i - 1; j >= 0 && nlsf[j] > value; j--)\n\n            nlsf[j + 1] = nlsf[j];\n\n        nlsf[j + 1] = value;\n\n    }\n\n\n\n    /* push forwards to increase distance */\n\n    if (nlsf[0] < min_delta[0])\n\n        nlsf[0] = min_delta[0];\n\n    for (i = 1; i < order; i++)\n\n        if (nlsf[i] < nlsf[i - 1] + min_delta[i])\n\n            nlsf[i] = nlsf[i - 1] + min_delta[i];\n\n\n\n    /* push backwards to increase distance */\n\n    if (nlsf[order-1] > 32768 - min_delta[order])\n\n        nlsf[order-1] = 32768 - min_delta[order];\n\n    for (i = order-2; i >= 0; i--)\n\n        if (nlsf[i] > nlsf[i + 1] - min_delta[i+1])\n\n            nlsf[i] = nlsf[i + 1] - min_delta[i+1];\n\n\n\n    return;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1433, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,\n\n                                         uint32_t val)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    UNIN_DPRINTF(\"config_writel addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    s->config_reg = val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1434, "prediction": "1", "true_label": "1", "raw_text": "Question: vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)\n{\n    struct vhost_vring_addr *vra = &vmsg->payload.addr;\n    unsigned int index = vra->index;\n    VubrVirtq *vq = &dev->vq[index];\n    DPRINT(\"vhost_vring_addr:\\n\");\n    DPRINT(\"    index:  %d\\n\", vra->index);\n    DPRINT(\"    flags:  %d\\n\", vra->flags);\n    DPRINT(\"    desc_user_addr:   0x%016llx\\n\", vra->desc_user_addr);\n    DPRINT(\"    used_user_addr:   0x%016llx\\n\", vra->used_user_addr);\n    DPRINT(\"    avail_user_addr:  0x%016llx\\n\", vra->avail_user_addr);\n    DPRINT(\"    log_guest_addr:   0x%016llx\\n\", vra->log_guest_addr);\n    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);\n    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);\n    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);\n    vq->log_guest_addr = vra->log_guest_addr;\n    DPRINT(\"Setting virtq addresses:\\n\");\n    DPRINT(\"    vring_desc  at %p\\n\", vq->desc);\n    DPRINT(\"    vring_used  at %p\\n\", vq->used);\n    DPRINT(\"    vring_avail at %p\\n\", vq->avail);\n    vq->last_used_index = vq->used->idx;\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1435, "prediction": "0", "true_label": "1", "raw_text": "\n\n    if (srcFormat == PIX_FMT_UYVY422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = uyvyToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = yuyvToYuv422Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = uyvyToYuv422Wrapper;\n\n\n\n    /* simple copy */\n\n    if ( srcFormat == dstFormat ||\n\n        (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P) ||\n\n        (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P) ||\n\n        (isPlanarYUV(srcFormat) && isGray(dstFormat)) ||\n\n        (isPlanarYUV(dstFormat) && isGray(srcFormat)) ||\n\n        (isGray(dstFormat) && isGray(srcFormat)) ||\n\n        (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat) &&\n\n         c->chrDstHSubSample == c->chrSrcHSubSample &&\n\n         c->chrDstVSubSample == c->chrSrcVSubSample &&\n\n         dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21 &&\n\n         srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21))\n\n    {\n\n        if (isPacked(c->srcFormat))\n\n            c->swScale = packedCopyWrapper;\n\n        else /* Planar YUV or gray */\n\n            c->swScale = planarCopyWrapper;\n\n    }\n\n\n\n    if (ARCH_BFIN)\n\n        ff_bfin_get_unscaled_swscale(c);\n\n    if (HAVE_ALTIVEC)\n\n        ff_swscale_get_unscaled_altivec(c);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1436, "prediction": "0", "true_label": "0", "raw_text": "Question: static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIDevice *pd = PCI_DEVICE(br);\n\n    PCIBus *parent = pd->bus;\n\n    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);\n\n    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &w->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n\n\n    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);\n\n\n\n    return w;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1437, "prediction": "0", "true_label": "0", "raw_text": "_tb_size;\n\n        int min_tu_width     = s->sps->min_tb_width;\n\n\n\n        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {\n\n            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);\n\n        }\n\n\n\n        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,\n\n                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);\n\n\n\n        // TODO: store cbf_luma somewhere else\n\n        if (lc->tt.cbf_luma) {\n\n            int i, j;\n\n            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)\n\n                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {\n\n                    int x_tu = (x0 + j) >> log2_min_tu_size;\n\n                    int y_tu = (y0 + i) >> log2_min_tu_size;\n\n                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;\n\n                }\n\n        }\n\n        if (!s->sh.disable_deblocking_filter_flag) {\n\n            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,\n\n                                                  lc->slice_or_tiles_up_boundary,\n\n                                                  lc->slice_or_tiles_left_boundary);\n\n            if (s->pps->transquant_bypass_enable_flag &&\n\n                lc->cu.cu_transquant_bypass_flag)\n\n                set_deblocking_bypass(s, x0, y0, log2_trafo_size);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1438, "prediction": "0", "true_label": "1", "raw_text": " (excl_range >= 16) {\n\n                *use_mask_ptr++    = 0;\n\n                *use_mask_ptr     &= 0xFFFF >> (excl_range - 16);\n\n            } else\n\n                *use_mask_ptr     &= 0xFFFF >> excl_range;\n\n        }\n\n\n\n    /* find the 'aidx'th offset that is not excluded */\n\n    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);\n\n    for (n = 0; n <= aidx; pulse_start++) {\n\n        for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ;\n\n        if (idx >= MAX_FRAMESIZE / 2) { // find from zero\n\n            if (use_mask[0])      idx = 0x0F;\n\n            else if (use_mask[1]) idx = 0x1F;\n\n            else if (use_mask[2]) idx = 0x2F;\n\n            else if (use_mask[3]) idx = 0x3F;\n\n            else if (use_mask[4]) idx = 0x4F;\n\n            else                  return;\n\n            idx -= av_log2_16bit(use_mask[idx >> 4]);\n\n        }\n\n        if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {\n\n            use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));\n\n            n++;\n\n            start_off = idx;\n\n        }\n\n    }\n\n\n\n    fcb->x[fcb->n] = start_off;\n\n    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;\n\n    fcb->n++;\n\n\n\n    /* set offset for next block, relative to start of that block */\n\n    n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag;\n\n    s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1439, "prediction": "0", "true_label": "1", "raw_text": "pb->eof_reached) {\n\n            avio_seek(s->pb, current_pos, SEEK_SET);\n\n            return;\n\n        }\n\n        avio_skip(s->pb, gsize - 24);\n\n        ff_get_guid(s->pb, &g);\n\n    }\n\n\n\n    {\n\n        int64_t itime, last_pos = -1;\n\n        int pct, ict;\n\n        int64_t av_unused gsize = avio_rl64(s->pb);\n\n        ff_get_guid(s->pb, &g);\n\n        itime = avio_rl64(s->pb);\n\n        pct   = avio_rl32(s->pb);\n\n        ict   = avio_rl32(s->pb);\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n\n\n        for (i = 0; i < ict; i++) {\n\n            int pktnum        = avio_rl32(s->pb);\n\n            int pktct         = avio_rl16(s->pb);\n\n            int64_t pos       = s->data_offset + s->packet_size * (int64_t)pktnum;\n\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n\n\n            if (pos != last_pos) {\n\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n\n                       pktnum, pktct, index_pts);\n\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n\n                last_pos = pos;\n\n            }\n\n        }\n\n        asf->index_read = ict > 0;\n\n    }\n\n    avio_seek(s->pb, current_pos, SEEK_SET);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1440, "prediction": "0", "true_label": "1", "raw_text": "Question: static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1441, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1442, "prediction": "0", "true_label": "1", "raw_text": "Question: static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1443, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)\n\n{\n\n    bool progress = false;\n\n    int64_t end_time;\n\n\n\n    assert(ctx->notify_me);\n\n    assert(ctx->walking_handlers > 0);\n\n    assert(ctx->poll_disable_cnt == 0);\n\n\n\n    trace_run_poll_handlers_begin(ctx, max_ns);\n\n\n\n    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;\n\n\n\n    do {\n\n        AioHandler *node;\n\n\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n                progress = true;\n\n            }\n\n\n\n            /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n        }\n\n    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);\n\n\n\n    trace_run_poll_handlers_end(ctx, progress);\n\n\n\n    return progress;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1444, "prediction": "0", "true_label": "0", "raw_text": "_REF);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        /* If malloc fails, reset len to avoid preserving an invalid value */\n\n        ctx->inflated_size = avctx->width * avctx->height * 3;\n\n        ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);\n\n        if (ret < 0) {\n\n            ctx->inflated_size = 0;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Inflate the frame after the 2 byte header */\n\n    ret = uncompress(ctx->inflated_buf, &ctx->inflated_size,\n\n                     avpkt->data + 2, avpkt->size - 2);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Deflate error %d.\\n\", ret);\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    /* When a keyframe is found, copy it (flipped) */\n\n    if (keyframe)\n\n        av_image_copy_plane(ctx->current->data[0] +\n\n                            ctx->current->linesize[0] * (avctx->height - 1),\n\n                            -1 * ctx->current->linesize[0],\n\n                            ctx->inflated_buf, avctx->width * 3,\n\n                            avctx->width * 3, avctx->height);\n\n    /* Otherwise sum the delta on top of the current frame */\n\n    else\n\n        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],\n\n                          ctx->inflated_buf, avctx->width * 3,\n\n                          avctx->width * 3, avctx->height);\n\n\n\n    /* Frame is ready to be output */\n\n    ret = av_frame_ref(frame, ctx->current);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Usual properties */\n\n    if (keyframe) {\n\n        frame->pict_type = AV_PICTURE_TYPE_I;\n\n        frame->key_frame = 1;\n\n    } else {\n\n        frame->pict_type = AV_PICTURE_TYPE_P;\n\n    }\n\n    *got_frame = 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1445, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1446, "prediction": "0", "true_label": "1", "raw_text": "Question: void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1447, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1448, "prediction": "0", "true_label": "1", "raw_text": "Question: static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1449, "prediction": "0", "true_label": "0", "raw_text": "Question: void memory_global_dirty_log_stop(void)\n\n{\n\n    global_dirty_log = false;\n\n\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n\n    memory_region_transaction_begin();\n\n    memory_region_update_pending = true;\n\n    memory_region_transaction_commit();\n\n\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1450, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1451, "prediction": "-1", "true_label": "0", "raw_text": "MANAGEMENT,\n\n        ENC_EXTERNAL_REQUEST,\n\n        ENC_MEDIA,\n\n        ENC_MULTIPLE_HOSTS,\n\n        ENC_DEVICE_BUSY,\n\n        ENC_RESERVED,\n\n    };\n\n    unsigned int max_len, used_len;\n\n\n\n    gesn_cdb = (void *)packet;\n\n    gesn_event_header = (void *)buf;\n\n\n\n    max_len = be16_to_cpu(gesn_cdb->len);\n\n\n\n    /* It is fine by the MMC spec to not support async mode operations */\n\n    if (!(gesn_cdb->polled & 0x01)) { /* asynchronous mode */\n\n        /* Only polling is supported, asynchronous mode is not. */\n\n        ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST,\n\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n\n        return;\n\n    }\n\n\n\n    /* polling mode operation */\n\n\n\n    /*\n\n     * These are the supported events.\n\n     *\n\n     * We currently only support requests of the 'media' type.\n\n     */\n\n    gesn_event_header->supported_events = NCR_MEDIA;\n\n\n\n    /*\n\n     * We use |= below to set the class field; other bits in this byte\n\n     * are reserved now but this is useful to do if we have to use the\n\n     * reserved fields later.\n\n     */\n\n    gesn_event_header->notification_class = 0;\n\n\n\n    /*\n\n     * Responses to requests are to be based on request priority.  The\n\n     * notification_class_request_type enum above specifies the\n\n     * priority: upper elements are higher prio than lower ones.\n\n     */\n\n    if (gesn_cdb->class & NCR_MEDIA) {\n\n        gesn_event_header->notification_class |= ENC_MEDIA;\n\n        used_len = event_status_media(s, buf);\n\n    } else {\n\n        gesn_event_header->notification_class = 0x80; /* No event available */\n\n        used_len = sizeof(*gesn_event_header);\n\n    }\n\n    gesn_event_header->len = cpu_to_be16(used_len\n\n                                         - sizeof(*gesn_event_header));\n\n    ide_atapi_cmd_reply(s, used_len, max_len);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1452, "prediction": "0", "true_label": "0", "raw_text": " = AV_RL32(src + slice * 4);\n\n        slice_size       = slice_data_end - slice_data_start;\n\n\n\n        if (!slice_size) {\n\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n\n                   \"yet a slice has a length of zero.\\n\");\n\n            goto fail;\n\n        }\n\n\n\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n\n                          (uint32_t *)(src + slice_data_start + c->slices * 4),\n\n                          (slice_data_end - slice_data_start + 3) >> 2);\n\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n\n\n        prev = 0x80;\n\n        for (j = sstart; j < send; j++) {\n\n            for (i = 0; i < width * step; i += step) {\n\n                pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);\n\n                if (pix < 0) {\n\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n\n                    goto fail;\n\n                }\n\n                if (use_pred) {\n\n                    prev += pix;\n\n                    pix   = prev;\n\n                }\n\n                dest[i] = pix;\n\n            }\n\n            if (get_bits_left(&gb) < 0) {\n\n                av_log(c->avctx, AV_LOG_ERROR,\n\n                        \"Slice decoding ran out of bits\\n\");\n\n                goto fail;\n\n            }\n\n            dest += stride;\n\n        }\n\n        if (get_bits_left(&gb) > 32)\n\n            av_log(c->avctx, AV_LOG_WARNING,\n\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n\n    }\n\n\n\n    ff_free_vlc(&vlc);\n\n\n\n    return 0;\n\nfail:\n\n    ff_free_vlc(&vlc);\n\n    return AVERROR_INVALIDDATA;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1453, "prediction": "0", "true_label": "0", "raw_text": ", oggstream);\n\n        flush = 1;\n\n    }\n\n\n\n    // avoid a continued page\n\n    if (!header && oggstream->page.size > 0 &&\n\n        MAX_PAGE_SIZE - oggstream->page.size < size) {\n\n        ogg_buffer_page(s, oggstream);\n\n    }\n\n\n\n    for (i = 0; i < total_segments; ) {\n\n        OGGPage *page = &oggstream->page;\n\n\n\n        segments = FFMIN(total_segments - i, 255 - page->segments_count);\n\n\n\n        if (i && !page->segments_count)\n\n            page->flags |= 1; // continued packet\n\n\n\n        memset(page->segments+page->segments_count, 255, segments - 1);\n\n        page->segments_count += segments - 1;\n\n\n\n        len = FFMIN(size, segments*255);\n\n        page->segments[page->segments_count++] = len - (segments-1)*255;\n\n        memcpy(page->data+page->size, p, len);\n\n        p += len;\n\n        size -= len;\n\n        i += segments;\n\n        page->size += len;\n\n\n\n        if (i == total_segments)\n\n            page->granule = granule;\n\n\n\n        if (!header) {\n\n            AVStream *st = s->streams[page->stream_index];\n\n\n\n            int64_t start = av_rescale_q(page->start_granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n            int64_t next  = av_rescale_q(page->granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n\n\n            if (page->segments_count == 255 ||\n\n                (ogg->pref_size     > 0 && page->size   >= ogg->pref_size) ||\n\n                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {\n\n                ogg_buffer_page(s, oggstream);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (flush && oggstream->page.granule != -1)\n\n        ogg_buffer_page(s, oggstream);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1454, "prediction": "0", "true_label": "0", "raw_text": ", 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n\n\n    assert(s->time>=0);\n\n    time_div= s->time/s->avctx->time_base.den;\n\n    time_mod= s->time%s->avctx->time_base.den;\n\n    time_incr= time_div - s->last_time_base;\n\n    assert(time_incr >= 0);\n\n    while(time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n\n    if (    s->pict_type == AV_PICTURE_TYPE_P\n\n        || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n\n    }\n\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n\n    if(!s->progressive_sequence){\n\n         put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);\n\n         put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    //FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code); /* fcode_for */\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code); /* fcode_back */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1455, "prediction": "0", "true_label": "0", "raw_text": "Question: static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, \n\n                      int nb_codes)\n\n{\n\n    uint8_t huff_size[256];\n\n    uint16_t huff_code[256];\n\n\n\n    memset(huff_size, 0, sizeof(huff_size));\n\n    build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n\n    \n\n    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1456, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1457, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1458, "prediction": "1", "true_label": "0", "raw_text": "Question: av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)\n\n{\n\n#if HAVE_YASM\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {\n\n#if ARCH_X86_32\n\n        if (mm_flags & AV_CPU_FLAG_MMX) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;\n\n        }\n\n#endif\n\n\n\n        if (mm_flags & AV_CPU_FLAG_SSE2) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;\n\n        }\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1459, "prediction": "0", "true_label": "0", "raw_text": "code = EXCP_ISI_PROT;\n\n                break;\n\n            case -3:\n\n\t\t/* No execute protection violation */\n\n                error_code = EXCP_ISI_NOEXEC;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = EXCP_ISI_DIRECT;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_DSI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_DSI_PROT;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |\n\n\t\t\tEXCP_DSI_ECXW;\n\n                    break;\n\n                default:\n\n\t\t    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n            }\n\n            if (rw)\n\n                error_code |= EXCP_DSI_STORE;\n\n\t    /* Store fault address */\n\n\t    env->spr[DAR] = address;\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1460, "prediction": "0", "true_label": "1", "raw_text": "Question: static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1461, "prediction": "0", "true_label": "0", "raw_text": "Question: static int sd_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    unsigned int datalen;\n\n\n\n    if (offset < s->inode.vdi_size) {\n\n        error_report(\"shrinking is not supported\");\n\n        return -EINVAL;\n\n    } else if (offset > SD_MAX_VDI_SIZE) {\n\n        error_report(\"too big image size\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n    s->inode.vdi_size = offset;\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    close(fd);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to update an inode.\");\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1462, "prediction": "1", "true_label": "0", "raw_text": "Question: static int rndis_parse(USBNetState *s, uint8_t *data, int length)\n\n{\n\n    uint32_t msg_type;\n\n    le32 *tmp = (le32 *) data;\n\n\n\n    msg_type = le32_to_cpup(tmp);\n\n\n\n    switch (msg_type) {\n\n    case RNDIS_INITIALIZE_MSG:\n\n        s->rndis_state = RNDIS_INITIALIZED;\n\n        return rndis_init_response(s, (rndis_init_msg_type *) data);\n\n\n\n    case RNDIS_HALT_MSG:\n\n        s->rndis_state = RNDIS_UNINITIALIZED;\n\n        return 0;\n\n\n\n    case RNDIS_QUERY_MSG:\n\n        return rndis_query_response(s, (rndis_query_msg_type *) data, length);\n\n\n\n    case RNDIS_SET_MSG:\n\n        return rndis_set_response(s, (rndis_set_msg_type *) data, length);\n\n\n\n    case RNDIS_RESET_MSG:\n\n        rndis_clear_responsequeue(s);\n\n        s->out_ptr = s->in_ptr = s->in_len = 0;\n\n        return rndis_reset_response(s, (rndis_reset_msg_type *) data);\n\n\n\n    case RNDIS_KEEPALIVE_MSG:\n\n        /* For USB: host does this every 5 seconds */\n\n        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);\n\n    }\n\n\n\n    return USB_RET_STALL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes\n"}], [{"ID": 1463, "prediction": "0", "true_label": "1", "raw_text": "\n\n    if (!sap->ann) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann[pos] = (1 << 5);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    if (localaddr.ss_family == AF_INET6)\n\n        sap->ann[pos] |= 0x10;\n\n#endif\n\n    pos++;\n\n    sap->ann[pos++] = 0; /* Authentication length */\n\n    AV_WB16(&sap->ann[pos], av_get_random_seed());\n\n    pos += 2;\n\n    if (localaddr.ss_family == AF_INET) {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr,\n\n               sizeof(struct in_addr));\n\n        pos += sizeof(struct in_addr);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    } else {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in6*)&localaddr)->sin6_addr,\n\n               sizeof(struct in6_addr));\n\n        pos += sizeof(struct in6_addr);\n\n#endif\n\n    }\n\n\n\n    av_strlcpy(&sap->ann[pos], \"application/sdp\", sap->ann_size - pos);\n\n    pos += strlen(&sap->ann[pos]) + 1;\n\n\n\n    if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos],\n\n                      sap->ann_size - pos)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    av_freep(&contexts);\n\n    av_log(s, AV_LOG_VERBOSE, \"SDP:\\n%s\\n\", &sap->ann[pos]);\n\n    pos += strlen(&sap->ann[pos]);\n\n    sap->ann_size = pos;\n\n\n\n    if (sap->ann_size > sap->ann_fd->max_packet_size) {\n\n        av_log(s, AV_LOG_ERROR, \"Announcement too large to send in one \"\n\n                                \"packet\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_free(contexts);\n\n    sap_write_close(s);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1464, "prediction": "0", "true_label": "1", "raw_text": "W_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);\n\n\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);\n\n    } else if (current_mv.pred_flag == PF_BI) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                   &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                   ref1->frame, &current_mv.mv[1], &current_mv);\n\n\n\n        chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);\n\n\n\n        chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1465, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    VirtIOBlockReq *req;\n\n    MultiReqBuffer mrb = {};\n\n\n\n    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start\n\n     * dataplane here instead of waiting for .set_status().\n\n     */\n\n    if (s->dataplane) {\n\n        virtio_blk_data_plane_start(s->dataplane);\n\n        return;\n\n    }\n\n\n\n    blk_io_plug(s->blk);\n\n\n\n    while ((req = virtio_blk_get_request(s))) {\n\n        virtio_blk_handle_request(req, &mrb);\n\n    }\n\n\n\n    if (mrb.num_reqs) {\n\n        virtio_blk_submit_multireq(s->blk, &mrb);\n\n    }\n\n\n\n    blk_io_unplug(s->blk);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1466, "prediction": "0", "true_label": "0", "raw_text": "Question: static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1467, "prediction": "0", "true_label": "0", "raw_text": "Question: static void realize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char link_name[256];\n\n    gchar *child_name;\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_realize(spapr_drc_index(drc));\n\n    /* NOTE: we do this as part of realize/unrealize due to the fact\n\n     * that the guest will communicate with the DRC via RTAS calls\n\n     * referencing the global DRC index. By unlinking the DRC\n\n     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it\n\n     * inaccessible by the guest, since lookups rely on this path\n\n     * existing in the composition tree\n\n     */\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(link_name, sizeof(link_name), \"%x\", spapr_drc_index(drc));\n\n    child_name = object_get_canonical_path_component(OBJECT(drc));\n\n    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);\n\n    object_property_add_alias(root_container, link_name,\n\n                              drc->owner, child_name, &err);\n\n    g_free(child_name);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,\n\n                     drc);\n\n    qemu_register_reset(drc_reset, drc);\n\n    trace_spapr_drc_realize_complete(spapr_drc_index(drc));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1468, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,\n\n                       int insn, int size, int sign)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_sign;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_sign = tcg_const_i32(sign);\n\n#ifdef TARGET_SPARC64\n\n    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);\n\n#else\n\n    {\n\n        TCGv_i64 t64 = tcg_temp_new_i64();\n\n        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);\n\n        tcg_gen_trunc_i64_tl(dst, t64);\n\n        tcg_temp_free_i64(t64);\n\n    }\n\n#endif\n\n    tcg_temp_free_i32(r_sign);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1469, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1470, "prediction": "0", "true_label": "0", "raw_text": "\n\n#else\n\n                a = args[i];\n\n#endif\n\n                s->gen_insn_data[num_insns][i] = a;\n\n            }\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, args[0]);\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, arg_label(args[0]), s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op->callo, op->calli, args,\n\n                               dead_args, sync_args);\n\n            break;\n\n        default:\n\n            /* Sanity check that we've not introduced any unhandled opcodes. */\n\n            if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n                tcg_abort();\n\n            }\n\n            /* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns */\n\n            tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args);\n\n            break;\n\n        }\n\n#ifndef NDEBUG\n\n        check_regs(s);\n\n#endif\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n\n           one operation beginning below the high water mark cannot overrun\n\n           the buffer completely.  Thus we can test for overflow after\n\n           generating code without having to check during generation.  */\n\n        if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) {\n\n            return -1;\n\n        }\n\n    }\n\n    tcg_debug_assert(num_insns >= 0);\n\n    s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n\n\n    /* Generate TB finalization at the end of block */\n\n    tcg_out_tb_finalize(s);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);\n\n\n\n    return tcg_current_code_size(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1471, "prediction": "-1", "true_label": "0", "raw_text": "handle_packet(dev, &ehci->ipacket);\n\n\n\n                if (ret != USB_RET_NODEV) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1472, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qmp_input_pop(Visitor *v, void **obj)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && tos->qapi == obj);\n\n    QSLIST_REMOVE_HEAD(&qiv->stack, node);\n\n    qmp_input_stack_object_free(tos);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1473, "prediction": "1", "true_label": "1", "raw_text": "\n\n        return AVERROR_IO;\n\n\n\n\n    total_frames = 0;\n\n    for (i = 0; i < vmd->frame_count; i++) {\n\n\n\n        current_offset = LE_32(&raw_frame_table[6 * i + 2]);\n\n\n\n        /* handle each entry in index block */\n\n        for (j = 0; j < vmd->frames_per_block; j++) {\n\n            int type;\n\n            uint32_t size;\n\n\n\n            get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD);\n\n            type = chunk[0];\n\n            size = LE_32(&chunk[2]);\n\n            if(!size)\n\n                continue;\n\n            switch(type) {\n\n            case 1: /* Audio Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                total_frames++;\n\n                break;\n\n            case 2: /* Video Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                vmd->frame_table[total_frames].stream_index = vmd->video_stream_index;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                vmd->frame_table[total_frames].pts = current_video_pts;\n\n                if (lastframe) {\n\n                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;\n\n\n                lastframe = total_frames;\n\n                total_frames++;\n\n                break;\n\n\n            current_offset += size;\n\n\n        current_video_pts += video_pts_inc;\n\n\n\n\n    av_free(raw_frame_table);\n\n\n\n    vmd->current_frame = 0;\n\n    vmd->frame_count = total_frames;\n\n\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1474, "prediction": "0", "true_label": "0", "raw_text": "2] = put_pixels16_y2_arm;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_arm;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_arm;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_arm;\n\n    c->put_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_pixels_tab[1][1] = put_pixels8_x2_arm;\n\n    c->put_pixels_tab[1][2] = put_pixels8_y2_arm;\n\n    c->put_pixels_tab[1][3] = put_pixels8_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_arm;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_arm;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels8_xy2_arm;\n\n\n\n#if HAVE_ARMV5TE\n\n    c->prefetch = ff_prefetch_arm;\n\n#endif\n\n\n\n#if HAVE_IWMMXT\n\n    dsputil_init_iwmmxt(c, avctx);\n\n#endif\n\n#if HAVE_ARMVFP\n\n    ff_float_init_arm_vfp(c, avctx);\n\n#endif\n\n#if HAVE_NEON\n\n    ff_dsputil_init_neon(c, avctx);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1475, "prediction": "1", "true_label": "0", "raw_text": "Question: av_cold void ff_h264_free_context(H264Context *h)\n\n{\n\n    int i;\n\n\n\n    ff_h264_free_tables(h);\n\n\n\n    if (h->DPB) {\n\n        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n\n            ff_h264_unref_picture(h, &h->DPB[i]);\n\n        av_freep(&h->DPB);\n\n    }\n\n\n\n    h->cur_pic_ptr = NULL;\n\n\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        av_freep(&h->slice_ctx[i].rbsp_buffer);\n\n    av_freep(&h->slice_ctx);\n\n    h->nb_slice_ctx = 0;\n\n\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n\n        av_freep(h->sps_buffers + i);\n\n\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n\n        av_freep(h->pps_buffers + i);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1476, "prediction": "0", "true_label": "1", "raw_text": "blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1477, "prediction": "0", "true_label": "1", "raw_text": "Question: int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n\n{\n\n    av_assert0(0);\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1478, "prediction": "0", "true_label": "1", "raw_text": "+1024);\n\n\n\n    latm_write_frame_header(s, &bs);\n\n\n\n    /* PayloadLengthInfo() */\n\n    for (i = 0; i <= pkt->size-255; i+=255)\n\n        put_bits(&bs, 8, 255);\n\n\n\n    put_bits(&bs, 8, pkt->size-i);\n\n\n\n    /* The LATM payload is written unaligned */\n\n\n\n    /* PayloadMux() */\n\n    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {\n\n        // Convert byte-aligned DSE to non-aligned.\n\n        // Due to the input format encoding we know that\n\n        // it is naturally byte-aligned in the input stream,\n\n        // so there are no padding bits to account for.\n\n        // To avoid having to add padding bits and rearrange\n\n        // the whole stream we just remove the byte-align flag.\n\n        // This allows us to remux our FATE AAC samples into latm\n\n        // files that are still playable with minimal effort.\n\n        put_bits(&bs, 8, pkt->data[0] & 0xfe);\n\n        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);\n\n    } else\n\n        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);\n\n\n\n    avpriv_align_put_bits(&bs);\n\n    flush_put_bits(&bs);\n\n\n\n    len = put_bits_count(&bs) >> 3;\n\n\n\n    if (len > 0x1fff)\n\n        goto too_large;\n\n\n\n    loas_header[1] |= (len >> 8) & 0x1f;\n\n    loas_header[2] |= len & 0xff;\n\n\n\n    avio_write(pb, loas_header, 3);\n\n    avio_write(pb, buf, len);\n\n\n\n    av_free(buf);\n\n\n\n    return 0;\n\n\n\ntoo_large:\n\n    av_log(s, AV_LOG_ERROR, \"LATM packet size larger than maximum size 0x1fff\\n\");\n\n    av_free(buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1479, "prediction": "0", "true_label": "1", "raw_text": "Question: static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1480, "prediction": "0", "true_label": "1", "raw_text": "Question: static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n\n                           int *x1, int *y1, int *x2, int *y2)\n\n{\n\n    int i, hs, ms, ss, he, me, se;\n\n\n\n    for (i=0; i<2; i++) {\n\n        /* try to read timestamps in either the first or second line */\n\n        int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n\n                       \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n\n                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,\n\n                       x1, x2, y1, y2);\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n        if (c >= 8) {\n\n            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n\n            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;\n\n            return buf;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1481, "prediction": "0", "true_label": "1", "raw_text": "48 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */\n\n        } else {\n\n            /* 4 KB page */\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            /* page directory entry */\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; /* align to 4MB */\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                /* page directory entry */\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1482, "prediction": "0", "true_label": "1", "raw_text": "Question: void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1483, "prediction": "0", "true_label": "0", "raw_text": "Question: static void compare_sec_rs_finalize(SocketReadState *sec_rs)\n\n{\n\n    CompareState *s = container_of(sec_rs, CompareState, sec_rs);\n\n\n\n    if (packet_enqueue(s, SECONDARY_IN)) {\n\n        trace_colo_compare_main(\"secondary: unsupported packet in\");\n\n    } else {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1484, "prediction": "0", "true_label": "1", "raw_text": "Question: FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1485, "prediction": "0", "true_label": "1", "raw_text": "DATA;\n\n    }\n\n\n\n    /* picture description */\n\n    desc_len = (len - picsize) * 2 + 1;\n\n    desc     = av_malloc(desc_len);\n\n    if (!desc)\n\n        return AVERROR(ENOMEM);\n\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    st  = avformat_new_stream(s, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n\n    asf_st = asf->asf_st[asf->nb_streams];\n\n    if (!asf_st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id           = id;\n\n    st->attached_pic              = pkt;\n\n    st->attached_pic.stream_index = asf_st->index = st->index;\n\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n\n\n    asf->nb_streams++;\n\n\n\n    if (*desc) {\n\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    } else\n\n        av_freep(&desc);\n\n\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&desc);\n\n    av_free_packet(&pkt);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1486, "prediction": "1", "true_label": "1", "raw_text": "Question: void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1487, "prediction": "0", "true_label": "1", "raw_text": "Question: static char *scsibus_get_dev_path(DeviceState *dev)\n\n{\n\n    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);\n\n    DeviceState *hba = dev->parent_bus->parent;\n\n    char *id = NULL;\n\n\n\n    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {\n\n        id = hba->parent_bus->info->get_dev_path(hba);\n\n    }\n\n    if (id) {\n\n        return g_strdup_printf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun);\n\n    } else {\n\n        return g_strdup_printf(\"%d:%d:%d\", d->channel, d->id, d->lun);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1488, "prediction": "0", "true_label": "0", "raw_text": "Question: static int eval_lpc_coeffs(const float *in, float *tgt, int n)\n\n{\n\n    int x, y;\n\n    double f0, f1, f2;\n\n\n\n    if (in[n] == 0)\n\n        return 0;\n\n\n\n    if ((f0 = *in) <= 0)\n\n        return 0;\n\n\n\n    in--; // To avoid a -1 subtraction in the inner loop\n\n\n\n    for (x=1; x <= n; x++) {\n\n        f1 = in[x+1];\n\n\n\n        for (y=0; y < x - 1; y++)\n\n            f1 += in[x-y]*tgt[y];\n\n\n\n        tgt[x-1] = f2 = -f1/f0;\n\n        for (y=0; y < x >> 1; y++) {\n\n            float temp = tgt[y] + tgt[x-y-2]*f2;\n\n            tgt[x-y-2] += tgt[y]*f2;\n\n            tgt[y] = temp;\n\n        }\n\n        if ((f0 += f1*f2) < 0)\n\n            return 0;\n\n    }\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1489, "prediction": "0", "true_label": "0", "raw_text": " 1.0;\n\n\n\n    s->in_buffer= s->in;\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map && !s->dither_method){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count= s->used_ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    set_audiodata_fmt(&s->postin, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->midbuf, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->preout, s->int_sample_fmt);\n\n\n\n    if(s->resample){\n\n        set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt);\n\n    }\n\n\n\n    s->dither = s->preout;\n\n\n\n    if(s->rematrix || s->dither_method)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1490, "prediction": "1", "true_label": "1", "raw_text": "Question: void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1491, "prediction": "0", "true_label": "1", "raw_text": ")\n\n{\n\n    XlnxEP108 *s = g_new0(XlnxEP108, 1);\n\n    Error *err = NULL;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    if (machine->ram_size > EP108_MAX_RAM_SIZE) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %llx\", machine->ram_size, EP108_MAX_RAM_SIZE);\n\n        machine->ram_size = EP108_MAX_RAM_SIZE;\n\n    }\n\n\n\n    if (machine->ram_size <= 0x08000000) {\n\n        qemu_log(\"WARNING: RAM size \" RAM_ADDR_FMT \" is small for EP108\",\n\n                 machine->ram_size);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ddr_ram, NULL, \"ddr-ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram);\n\n\n\n    xlnx_ep108_binfo.ram_size = machine->ram_size;\n\n    xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;\n\n    xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    xlnx_ep108_binfo.initrd_filename = machine->initrd_filename;\n\n    xlnx_ep108_binfo.loader_start = 0;\n\n    arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1492, "prediction": "0", "true_label": "1", "raw_text": "Question: static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n\n                        AVFilterInOut **open_outputs, AVClass *log_ctx)\n\n{\n\n    int pad = 0;\n\n\n\n    while (**buf == '[') {\n\n        char *name = parse_link_name(buf, log_ctx);\n\n        AVFilterInOut *match;\n\n\n\n        if (!name)\n\n            return AVERROR(EINVAL);\n\n\n\n        /* First check if the label is not in the open_outputs list */\n\n        match = extract_inout(name, open_outputs);\n\n\n\n        if (match) {\n\n            av_free(name);\n\n        } else {\n\n            /* Not in the list, so add it as an input */\n\n            match = av_mallocz(sizeof(AVFilterInOut));\n\n            match->name    = name;\n\n            match->pad_idx = pad;\n\n        }\n\n\n\n        insert_inout(curr_inputs, match);\n\n\n\n        *buf += strspn(*buf, WHITESPACES);\n\n        pad++;\n\n    }\n\n\n\n    return pad;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1493, "prediction": "0", "true_label": "1", "raw_text": "_idx[2][my]) {\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src1 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src2 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        } else {\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        }\n\n    } else {\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 3, 0);\n\n        mc_func[0][0](dst1, linesize, src1 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n        mc_func[0][0](dst2, linesize, src2 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1494, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,\n\n                             int width, int height)\n\n{\n\n    int src_wrap, x, y;\n\n    int r, g, b;\n\n    uint8_t *lum, *cb, *cr;\n\n    const uint8_t *p;\n\n\n\n    lum = dst->data[0];\n\n    cb = dst->data[1];\n\n    cr = dst->data[2];\n\n\n\n    src_wrap = src->linesize[0] - width * BPP;\n\n    p = src->data[0];\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            RGB_IN(r, g, b, p);\n\n            lum[0] = RGB_TO_Y_CCIR(r, g, b);\n\n            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);\n\n            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);\n\n            cb++;\n\n            cr++;\n\n            lum++;\n\n        }\n\n        p += src_wrap;\n\n        lum += dst->linesize[0] - width;\n\n        cb += dst->linesize[1] - width;\n\n        cr += dst->linesize[2] - width;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1495, "prediction": "0", "true_label": "0", "raw_text": "Question: static char *pcibus_get_fw_dev_path(DeviceState *dev)\n\n{\n\n    PCIDevice *d = (PCIDevice *)dev;\n\n    char path[50], name[33];\n\n    int off;\n\n\n\n    off = snprintf(path, sizeof(path), \"%s@%x\",\n\n                   pci_dev_fw_name(dev, name, sizeof name),\n\n                   PCI_SLOT(d->devfn));\n\n    if (PCI_FUNC(d->devfn))\n\n        snprintf(path + off, sizeof(path) + off, \",%x\", PCI_FUNC(d->devfn));\n\n    return strdup(path);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1496, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,\n\n                                                       const char *key,\n\n                                                       Error **errp)\n\n{\n\n    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];\n\n    char *accept = NULL, *response = NULL;\n\n    size_t responselen;\n\n\n\n    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,\n\n              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,\n\n                            combined_key,\n\n                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                            QIO_CHANNEL_WEBSOCK_GUID_LEN,\n\n                            &accept,\n\n                            errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);\n\n    responselen = strlen(response);\n\n    buffer_reserve(&ioc->encoutput, responselen);\n\n    buffer_append(&ioc->encoutput, response, responselen);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1497, "prediction": "0", "true_label": "1", "raw_text": "Question: void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1498, "prediction": "1", "true_label": "1", "raw_text": "val);\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args[4] = args[4];\n                gen_args[5] = args[5];\n                gen_args += 6;\n            args += 6;\n        case INDEX_op_call:\n            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);\n            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {\n                for (i = 0; i < nb_globals; i++) {\n                    reset_temp(i);\n            for (i = 0; i < (args[0] >> 16); i++) {\n                reset_temp(args[i + 1]);\n            i = nb_call_args + 3;\n            while (i) {\n                *gen_args = *args;\n                args++;\n                gen_args++;\n                i--;\n            /* Default case: we do know nothing about operation so no\n               propagation is done.  We trash everything if the operation\n               is the end of a basic block, otherwise we only trash the\n               output args.  */\n            if (def->flags & TCG_OPF_BB_END) {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n            } else {\n                for (i = 0; i < def->nb_oargs; i++) {\n                    reset_temp(args[i]);\n            for (i = 0; i < def->nb_args; i++) {\n                gen_args[i] = args[i];\n            args += def->nb_args;\n            gen_args += def->nb_args;\n    return gen_args;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1499, "prediction": "1", "true_label": "1", "raw_text": " = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1500, "prediction": "0", "true_label": "0", "raw_text": "Question: static int ftp_current_dir(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    const char *command = \"PWD\\r\\n\";\n\n    const int pwd_codes[] = {257, 0};\n\n\n\n    if (!ftp_send_command(s, command, pwd_codes, &res))\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '\"') {\n\n            if (!start) {\n\n                start = res + i + 1;\n\n                continue;\n\n            }\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!end)\n\n        goto fail;\n\n\n\n    if (end > res && end[-1] == '/') {\n\n        end[-1] = '\\0';\n\n    } else\n\n        *end = '\\0';\n\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    return AVERROR(EIO);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1501, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_opts_print(QemuOpts *opts, void *dummy)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    fprintf(stderr, \"%s: %s:\", opts->list->name,\n\n            opts->id ? opts->id : \"<noid>\");\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1502, "prediction": "0", "true_label": "0", "raw_text": "ar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = linel + (x * pixelsize + compno*!planar);\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                linel += picture->linesize[plane] >> 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1503, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_run_all_timers(void)\n\n{\n\n    alarm_timer->pending = 0;\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->expired) {\n\n        alarm_timer->expired = 0;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    qemu_run_timers(vm_clock);\n\n    qemu_run_timers(rt_clock);\n\n    qemu_run_timers(host_clock);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1504, "prediction": "0", "true_label": "0", "raw_text": "_xendev(type, dom, dev);\n\n    if (xendev) {\n\n        return xendev;\n\n    }\n\n\n\n    /* init new xendev */\n\n    xendev = g_malloc0(ops->size);\n\n    xendev->type  = type;\n\n    xendev->dom   = dom;\n\n    xendev->dev   = dev;\n\n    xendev->ops   = ops;\n\n\n\n    snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\",\n\n             xendev->type, xendev->dom, xendev->dev);\n\n    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",\n\n             xendev->type, xendev->dev);\n\n\n\n    xendev->debug      = debug;\n\n    xendev->local_port = -1;\n\n\n\n    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);\n\n    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");\n\n        g_free(xendev);\n\n        return NULL;\n\n    }\n\n    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);\n\n\n\n    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {\n\n        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);\n\n        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {\n\n            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");\n\n            xc_evtchn_close(xendev->evtchndev);\n\n            g_free(xendev);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);\n\n\n\n    if (xendev->ops->alloc) {\n\n        xendev->ops->alloc(xendev);\n\n    }\n\n\n\n    return xendev;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1505, "prediction": "0", "true_label": "0", "raw_text": "dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1506, "prediction": "0", "true_label": "0", "raw_text": "sz, 8192);\n\n    ram_size = sz;\n\n    if (ram_size != sz) {\n\n        error_report(\"ram size too large\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* store value for the future use */\n\n    qemu_opt_set_number(opts, \"size\", ram_size, &error_abort);\n\n    *maxram_size = ram_size;\n\n\n\n    maxmem_str = qemu_opt_get(opts, \"maxmem\");\n\n    slots_str = qemu_opt_get(opts, \"slots\");\n\n    if (maxmem_str && slots_str) {\n\n        uint64_t slots;\n\n\n\n        sz = qemu_opt_get_size(opts, \"maxmem\", 0);\n\n        slots = qemu_opt_get_number(opts, \"slots\", 0);\n\n        if (sz < ram_size) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"maximum memory size (0x%\" PRIx64 \") must be at least \"\n\n                         \"the initial memory size (0x\" RAM_ADDR_FMT \")\",\n\n                         sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        } else if (sz > ram_size) {\n\n            if (!slots) {\n\n                error_report(\"invalid value of -m option: maxmem was \"\n\n                             \"specified, but no hotplug slots were specified\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        } else if (slots) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"memory slots were specified but maximum memory size \"\n\n                         \"(0x%\" PRIx64 \") is equal to the initial memory size \"\n\n                         \"(0x\" RAM_ADDR_FMT \")\", sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        *maxram_size = sz;\n\n        *ram_slots = slots;\n\n    } else if ((!maxmem_str && slots_str) ||\n\n            (maxmem_str && !slots_str)) {\n\n        error_report(\"invalid -m option value: missing \"\n\n                \"'%s' option\", slots_str ? \"maxmem\" : \"slots\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1507, "prediction": "0", "true_label": "0", "raw_text": "xffff;\n\n\n\n    bs->request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard =\n\n                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);\n\n        }\n\n        bs->bl.discard_alignment =\n\n            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);\n\n    } else {\n\n        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1508, "prediction": "0", "true_label": "0", "raw_text": "Question: static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1509, "prediction": "-1", "true_label": "0", "raw_text": " with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION &&\n\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&\n\n        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1510, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,\n\n                                int nPbH, int log2_cb_size, int part_idx,\n\n                                int merge_idx, MvField *mv)\n\n{\n\n    int singleMCLFlag = 0;\n\n    int nCS = 1 << log2_cb_size;\n\n    LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]);\n\n    int nPbW2 = nPbW;\n\n    int nPbH2 = nPbH;\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n\n\n    memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));\n\n\n\n    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {\n\n        singleMCLFlag = 1;\n\n        x0            = lc->cu.x;\n\n        y0            = lc->cu.y;\n\n        nPbW          = nCS;\n\n        nPbH          = nCS;\n\n        part_idx      = 0;\n\n    }\n\n\n\n    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n\n    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                    singleMCLFlag, part_idx,\n\n                                    merge_idx, mergecand_list);\n\n\n\n    if (mergecand_list[merge_idx].pred_flag[0] == 1 &&\n\n        mergecand_list[merge_idx].pred_flag[1] == 1 &&\n\n        (nPbW2 + nPbH2) == 12) {\n\n        mergecand_list[merge_idx].ref_idx[1]   = -1;\n\n        mergecand_list[merge_idx].pred_flag[1] = 0;\n\n    }\n\n\n\n    *mv = mergecand_list[merge_idx];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1511, "prediction": "0", "true_label": "1", "raw_text": "Question: int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,\n\n                              int cpuid, void *opaque)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    return s390x_write_all_elf64_notes(\"CORE\", f, cpu, cpuid, opaque);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1512, "prediction": "0", "true_label": "0", "raw_text": "\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            } else{\n\n                for (y = y0; y < y0 + 4 && y < height; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            }\n\n        }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1513, "prediction": "0", "true_label": "0", "raw_text": "Question: static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,\n\n                                       target_ulong *pte1p,\n\n                                       int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & HPTE64_R_R)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= HPTE64_R_R;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & HPTE64_R_C)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= HPTE64_R_C;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1514, "prediction": "0", "true_label": "0", "raw_text": "Question: BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,\n\n                           QEMUSGList *sg, uint64_t sector,\n\n                           void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,\n\n                       DMA_DIRECTION_TO_DEVICE);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1515, "prediction": "0", "true_label": "0", "raw_text": "_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n            case QCOW2_CLUSTER_UNALLOCATED:\n\n                if (full_discard || !bs->backing_hd) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_ZERO:\n\n                if (!full_discard) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_NORMAL:\n\n            case QCOW2_CLUSTER_COMPRESSED:\n\n                break;\n\n\n\n            default:\n\n                abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1516, "prediction": "0", "true_label": "0", "raw_text": "Question: static int64_t qemu_archipelago_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret;\n\n    BDRVArchipelagoState *s = bs->opaque;\n\n\n\n    ret = archipelago_volume_info(s);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1517, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPRMachineState *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,\n\n                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);\n\n    if (!pdev || !object_dynamic_cast(OBJECT(pdev), \"vfio-pci\")) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1518, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_acl_remove(qemu_acl *acl,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n        i++;\n\n        if (strcmp(entry->match, match) == 0) {\n\n            TAILQ_REMOVE(&acl->entries, entry, next);\n\n            return i;\n\n        }\n\n    }\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1519, "prediction": "0", "true_label": "0", "raw_text": "] = 0x00;      /* pi programming interface ro */\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */\n\n\n\n    c[0x10] = 0x01;      /* nabmar native audio mixer base\n\n                            address rw */\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      /* nabmbar native audio bus mastering\n\n                            base address rw */\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      /* svid subsystem vendor id rwo */\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      /* sid subsystem id rwo */\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      /* intr_ln interrupt line rw */\n\n    c[0x3d] = 0x01;      /* intr_pn interrupt pin ro */\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1520, "prediction": "0", "true_label": "0", "raw_text": "Question: static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                      const uint8_t **poutbuf, int *poutbuf_size,\n\n                      const uint8_t *buf, int buf_size)\n\n{\n\n    CookParseContext *s = s1->priv_data;\n\n\n\n    if (s->duration)\n\n        s1->duration = s->duration;\n\n    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)\n\n        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;\n\n\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only setting packet duration */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1521, "prediction": "0", "true_label": "0", "raw_text": ");\n\n        }\n\n\n\n        if (!av->rc_eq) {\n\n            av->rc_eq = av_strdup(\"tex^qComp\");\n\n            av_dict_set(&recommended, \"rc_eq\", \"tex^qComp\", 0);\n\n        }\n\n        if (!av->rc_max_rate) {\n\n            av->rc_max_rate = av->bit_rate * 2;\n\n            av_dict_set_int(&recommended, \"maxrate\", av->rc_max_rate, 0);\n\n        }\n\n\n\n        if (av->rc_max_rate && !av->rc_buffer_size) {\n\n            av->rc_buffer_size = av->rc_max_rate;\n\n            av_dict_set_int(&recommended, \"bufsize\", av->rc_buffer_size, 0);\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    } else {\n\n        switch(av->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (av->bit_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio bit rate is not set\\n\");\n\n            if (av->sample_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio sample rate is not set\\n\");\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (av->width == 0 || av->height == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"video size is not set\\n\");\n\n            break;\n\n        default:\n\n            av_assert0(0);\n\n        }\n\n    }\n\n\n\n    st = av_mallocz(sizeof(AVStream));\n\n    if (!st)\n\n        return;\n\n    av_dict_get_string(recommended, &enc_config, '=', ',');\n\n    av_dict_free(&recommended);\n\n    av_stream_set_recommended_encoder_configuration(st, enc_config);\n\n    st->codec = av;\n\n    stream->streams[stream->nb_streams++] = st;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1522, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1523, "prediction": "0", "true_label": "1", "raw_text": "Question: void compute_images_mse_16bit(PSNRContext *s,\n\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n\n                        int w, int h, double mse[4])\n\n{\n\n    int i, c, j;\n\n\n\n    for (c = 0; c < s->nb_components; c++) {\n\n        const int outw = s->planewidth[c];\n\n        const int outh = s->planeheight[c];\n\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n\n        const int ref_linesize = ref_linesizes[c] / 2;\n\n        const int main_linesize = main_linesizes[c] / 2;\n\n        uint64_t m = 0;\n\n\n\n        for (i = 0; i < outh; i++) {\n\n            for (j = 0; j < outw; j++)\n\n                m += pow2(main_line[j] - ref_line[j]);\n\n            ref_line += ref_linesize;\n\n            main_line += main_linesize;\n\n        }\n\n        mse[c] = m / (double)(outw * outh);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1524, "prediction": "1", "true_label": "1", "raw_text": "Question: putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1525, "prediction": "0", "true_label": "0", "raw_text": "Question: uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint32_t cc = 0;\n\n\n\n    if (!(destlen || srclen)) {\n\n        return cc;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {\n\n        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;\n\n        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;\n\n        if (v1 != v2) {\n\n            cc = (v1 < v2) ? 1 : 2;\n\n            break;\n\n        }\n\n    }\n\n\n\n    set_length(env, r1 + 1, destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1526, "prediction": "0", "true_label": "0", "raw_text": "Question: void *bios_linker_loader_cleanup(GArray *linker)\n\n{\n\n    return g_array_free(linker, false);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1527, "prediction": "0", "true_label": "0", "raw_text": "Question: const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,\n\n                                             hwaddr ptex, int n)\n\n{\n\n    ppc_hash_pte64_t *hptes = NULL;\n\n    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;\n\n\n\n    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {\n\n        /*\n\n         * HTAB is controlled by KVM. Fetch into temporary buffer\n\n         */\n\n        hptes = g_malloc(HASH_PTEG_SIZE_64);\n\n        kvmppc_read_hptes(hptes, ptex, n);\n\n    } else if (cpu->env.external_htab) {\n\n        /*\n\n         * HTAB is controlled by QEMU. Just point to the internally\n\n         * accessible PTEG.\n\n         */\n\n        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);\n\n    } else if (cpu->env.htab_base) {\n\n        hwaddr plen = n * HASH_PTE_SIZE_64;\n\n        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,\n\n                                 &plen, false);\n\n        if (plen < (n * HASH_PTE_SIZE_64)) {\n\n            hw_error(\"%s: Unable to map all requested HPTEs\\n\", __func__);\n\n        }\n\n    }\n\n    return hptes;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1528, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1529, "prediction": "0", "true_label": "0", "raw_text": " 1, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_EJECT_METHOD, aml_int(i), aml_arg(0)))\n\n        );\n\n        aml_append(dev, method);\n\n\n\n        aml_append(sb_scope, dev);\n\n    }\n\n\n\n    /* build this code:\n\n     *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n     */\n\n    /* Arg0 = Processor ID = APIC ID */\n\n    method = aml_method(AML_NOTIFY_METHOD, 2, AML_NOTSERIALIZED);\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));\n\n        aml_append(ifctx,\n\n            aml_notify(aml_name(\"CP%.02X\", i), aml_arg(1))\n\n        );\n\n        aml_append(method, ifctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\"\n\n     *\n\n     * Note: The ability to create variable-sized packages was first\n\n     * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages\n\n     * ith up to 255 elements. Windows guests up to win2k8 fail when\n\n     * VarPackageOp is used.\n\n     */\n\n    pkg = acpi_cpus <= 255 ? aml_package(acpi_cpus) :\n\n                             aml_varpackage(acpi_cpus);\n\n\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n\n        aml_append(pkg, aml_int(b));\n\n    }\n\n    aml_append(sb_scope, aml_name_decl(CPU_ON_BITMAP, pkg));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1530, "prediction": "0", "true_label": "0", "raw_text": "Question: e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n    unsigned int index = (addr & 0x1ffff) >> 2;\n\n\n\n    if (index < NREADOPS && macreg_readops[index])\n\n    {\n\n        return macreg_readops[index](s, index);\n\n    }\n\n    DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1531, "prediction": "-1", "true_label": "1", "raw_text": "Question: static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: 0x90000000\n"}], [{"ID": 1532, "prediction": "0", "true_label": "0", "raw_text": "PRED  ] = ff_pred4x4_tm_vp8_mmxext;\n\n            h->pred4x4  [VERT_PRED    ] = ff_pred4x4_vertical_vp8_mmxext;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_sse;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse;\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE2) {\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse2;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_sse2;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_sse2;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSSE3) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_ssse3;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_ssse3;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_ssse3;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_ssse3;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_ssse3;\n\n        }\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1533, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline abi_long target_to_host_timespec(struct timespec *host_ts,\n\n                                               abi_ulong target_addr)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))\n\n        return -TARGET_EFAULT;\n\n    host_ts->tv_sec = tswapal(target_ts->tv_sec);\n\n    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 0);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1534, "prediction": "0", "true_label": "0", "raw_text": "Question: void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)\n\n{\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1535, "prediction": "0", "true_label": "0", "raw_text": ") * bpp): 2;\n\n\n\n    for (k = 0; k < bpp; k++) {\n\n        poff0 = bytestream2_get_be32(&off0);\n\n        poff1 = bytestream2_get_be32(&off1);\n\n\n\n        if (!poff0)\n\n            continue;\n\n\n\n        if (2LL * poff0 >= buf_end - buf)\n\n            return;\n\n\n\n        if (2LL * poff1 >= buf_end - buf)\n\n            return;\n\n\n\n        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));\n\n        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));\n\n\n\n        while ((bytestream2_peek_be16(&ogb)) != 0xFFFF) {\n\n            uint32_t offset = bytestream2_get_be16(&ogb);\n\n            int16_t cnt = bytestream2_get_be16(&ogb);\n\n            uint16_t data;\n\n\n\n            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;\n\n            if (cnt < 0) {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                cnt = -cnt;\n\n                data = bytestream2_get_be16(&dgb);\n\n                for (i = 0; i < cnt; i++) {\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            } else {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                for (i = 0; i < cnt; i++) {\n\n                    data = bytestream2_get_be16(&dgb);\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1536, "prediction": "0", "true_label": "0", "raw_text": "Question: static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1537, "prediction": "1", "true_label": "0", "raw_text": "Question: void serial_realize_core(SerialState *s, Error **errp)\n\n{\n\n    if (!qemu_chr_fe_backend_connected(&s->chr)) {\n\n        error_setg(errp, \"Can't create serial device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);\n\n\n\n    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);\n\n    qemu_register_reset(serial_reset, s);\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,\n\n                             serial_event, NULL, s, NULL, true);\n\n    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);\n\n    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);\n\n    serial_reset(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1538, "prediction": "0", "true_label": "0", "raw_text": "0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1539, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint8_t eeprom24c0x_read(void)\n\n{\n\n    logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\",\n\n        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);\n\n    return eeprom.sda;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1540, "prediction": "0", "true_label": "0", "raw_text": "Question: static void blockdev_do_action(int kind, void *data, Error **errp)\n\n{\n\n    TransactionAction action;\n\n    TransactionActionList list;\n\n\n\n    action.kind = kind;\n\n    action.data = data;\n\n    list.value = &action;\n\n    list.next = NULL;\n\n    qmp_transaction(&list, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1541, "prediction": "0", "true_label": "0", "raw_text": "t\"\n\n            \"punpcklbw %%mm3, %%mm5         \\n\\t\"\n\n            \"punpcklbw %%mm6, %%mm4         \\n\\t\"\n\n            \"punpckhbw %%mm3, %%mm1         \\n\\t\"\n\n            \"punpckhbw %%mm6, %%mm0         \\n\\t\"\n\n            \"movq      %%mm5, %%mm3         \\n\\t\"\n\n            \"movq      %%mm1, %%mm6         \\n\\t\"\n\n            \"punpcklwd %%mm4, %%mm5         \\n\\t\"\n\n            \"punpcklwd %%mm0, %%mm1         \\n\\t\"\n\n            \"punpckhwd %%mm4, %%mm3         \\n\\t\"\n\n            \"punpckhwd %%mm0, %%mm6         \\n\\t\"\n\n            \"movd      %%mm5, (%0)          \\n\\t\"\n\n            \"punpckhdq %%mm5, %%mm5         \\n\\t\"\n\n            \"movd      %%mm5, (%0, %2)      \\n\\t\"\n\n            \"movd      %%mm3, (%0, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm3, %%mm3         \\n\\t\"\n\n            \"movd      %%mm3, (%0, %3)      \\n\\t\"\n\n            \"movd      %%mm1, (%1)          \\n\\t\"\n\n            \"punpckhdq %%mm1, %%mm1         \\n\\t\"\n\n            \"movd      %%mm1, (%1, %2)      \\n\\t\"\n\n            \"movd      %%mm6, (%1, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm6, %%mm6         \\n\\t\"\n\n            \"movd      %%mm6, (%1, %3)      \\n\\t\"\n\n            :: \"r\"(src),\n\n               \"r\"(src + 4 * stride),\n\n               \"r\"((x86_reg)stride),\n\n               \"r\"((x86_reg)(3 * stride))\n\n            );\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1542, "prediction": "0", "true_label": "0", "raw_text": " else if (dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPACK;\n\n    }\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER ||\n\n        dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1543, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)\n\n{\n\n    switch (drc->state) {\n\n    case SPAPR_DRC_STATE_PHYSICAL_POWERON:\n\n        return RTAS_OUT_SUCCESS; /* Nothing to do */\n\n    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:\n\n        break; /* see below */\n\n    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:\n\n        return RTAS_OUT_PARAM_ERROR; /* not allowed */\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* if the guest is configuring a device attached to this DRC, we\n\n     * should reset the configuration state at this point since it may\n\n     * no longer be reliable (guest released device and needs to start\n\n     * over, or unplug occurred so the FDT is no longer valid)\n\n     */\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;\n\n\n\n    if (drc->unplug_requested) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_isolation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1544, "prediction": "0", "true_label": "0", "raw_text": "Question: static void input_linux_event_mouse(void *opaque)\n\n{\n\n    InputLinux *il = opaque;\n\n    struct input_event event;\n\n    int rc;\n\n\n\n    for (;;) {\n\n        rc = read(il->fd, &event, sizeof(event));\n\n        if (rc != sizeof(event)) {\n\n            if (rc < 0 && errno != EAGAIN) {\n\n                fprintf(stderr, \"%s: read: %s\\n\", __func__, strerror(errno));\n\n                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);\n\n                close(il->fd);\n\n            }\n\n            break;\n\n        }\n\n\n\n        input_linux_handle_mouse(il, &event);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1545, "prediction": "0", "true_label": "0", "raw_text": "Question: int float64_eq( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1546, "prediction": "0", "true_label": "0", "raw_text": "Question: static always_inline void gen_cmp(TCGCond cond,\n\n                                  int ra, int rb, int rc,\n\n                                  int islit, uint8_t lit)\n\n{\n\n    int l1, l2;\n\n    TCGv tmp;\n\n\n\n    if (unlikely(rc == 31))\n\n    return;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    if (ra != 31) {\n\n        tmp = tcg_temp_new(TCG_TYPE_I64);\n\n        tcg_gen_mov_i64(tmp, cpu_ir[ra]);\n\n    } else\n\n        tmp = tcg_const_i64(0);\n\n    if (islit)\n\n        tcg_gen_brcondi_i64(cond, tmp, lit, l1);\n\n    else\n\n        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);\n\n\n\n    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i64(cpu_ir[rc], 1);\n\n    gen_set_label(l2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1547, "prediction": "0", "true_label": "1", "raw_text": "Question: static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1548, "prediction": "0", "true_label": "0", "raw_text": "Question: static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    /* ??? Register memory space.  */\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1549, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rng_random_set_filename(Object *obj, const char *filename,\n\n                                 Error **errp)\n\n{\n\n    RngBackend *b = RNG_BACKEND(obj);\n\n    RndRandom *s = RNG_RANDOM(obj);\n\n\n\n    if (b->opened) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    if (s->filename) {\n\n        g_free(s->filename);\n\n    }\n\n\n\n    s->filename = g_strdup(filename);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1550, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,\n\n                                           sPAPRMachineState *spapr,\n\n                                           uint32_t token, uint32_t nargs,\n\n                                           target_ulong args, uint32_t nret,\n\n                                           target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    if (!spapr_phb_eeh_available(sphb)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    /*\n\n     * We always have PE address of form \"00BB0001\". \"BB\"\n\n     * represents the bus number of PE's primary bus.\n\n     */\n\n    option = rtas_ld(args, 3);\n\n    switch (option) {\n\n    case RTAS_GET_PE_ADDR:\n\n        addr = rtas_ld(args, 0);\n\n        pdev = spapr_pci_find_dev(spapr, buid, addr);\n\n        if (!pdev) {\n\n            goto param_error_exit;\n\n        }\n\n\n\n        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);\n\n        break;\n\n    case RTAS_GET_PE_MODE:\n\n        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);\n\n        break;\n\n    default:\n\n        goto param_error_exit;\n\n    }\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1551, "prediction": "0", "true_label": "0", "raw_text": "Question: static void migrate_fd_completed(MigrationState *s)\n\n{\n\n    DPRINTF(\"setting completed state\\n\");\n\n    migrate_fd_cleanup(s);\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_COMPLETED;\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    }\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1552, "prediction": "0", "true_label": "0", "raw_text": "Question: static unsigned int dec_adds_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"adds.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZVC);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t/* Size can only be qi or hi.  */\n\n\tt_gen_sext(t0, cpu_R[dc->op1], size);\n\n\tcris_alu(dc, CC_OP_ADD,\n\n\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1553, "prediction": "0", "true_label": "0", "raw_text": "Question: static void create_map(vorbis_context *vc, unsigned floor_number)\n\n{\n\n    vorbis_floor *floors = vc->floors;\n\n    vorbis_floor0 *vf;\n\n    int idx;\n\n    int blockflag, n;\n\n    int32_t *map;\n\n\n\n    for (blockflag = 0; blockflag < 2; ++blockflag) {\n\n        n = vc->blocksize[blockflag] / 2;\n\n        floors[floor_number].data.t0.map[blockflag] =\n\n            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel\n\n\n\n        map =  floors[floor_number].data.t0.map[blockflag];\n\n        vf  = &floors[floor_number].data.t0;\n\n\n\n        for (idx = 0; idx < n; ++idx) {\n\n            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *\n\n                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));\n\n            if (vf->bark_map_size-1 < map[idx])\n\n                map[idx] = vf->bark_map_size - 1;\n\n        }\n\n        map[n] = -1;\n\n        vf->map_size[blockflag] = n;\n\n    }\n\n\n\n    for (idx = 0; idx <= n; ++idx) {\n\n        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1554, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,\n\n                                  VirtIOSCSIReq *req)\n\n{\n\n    assert(req->elem.out_num && req->elem.in_num);\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    req->sreq = NULL;\n\n    req->req.buf = req->elem.out_sg[0].iov_base;\n\n    req->resp.buf = req->elem.in_sg[0].iov_base;\n\n\n\n    if (req->elem.out_num > 1) {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],\n\n                               &req->elem.out_addr[1],\n\n                               req->elem.out_num - 1);\n\n    } else {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],\n\n                               &req->elem.in_addr[1],\n\n                               req->elem.in_num - 1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1555, "prediction": "0", "true_label": "0", "raw_text": ":\n\n        task_tag = be16_to_cpu(ui->task.task_tag);\n\n        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        req = usb_uas_find_request(uas, task_tag);\n\n        if (req && req->dev == dev) {\n\n            scsi_req_cancel(req->req);\n\n        }\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    case UAS_TMF_LOGICAL_UNIT_RESET:\n\n        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        qdev_reset_all(&dev->qdev);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    default:\n\n        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);\n\n        break;\n\n    }\n\n    return;\n\n\n\noverlapped_tag:\n\n    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);\n\n    return;\n\n\n\nbad_target:\n\n    /* FIXME: correct?  [see long comment in usb_uas_command()] */\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);\n\n    return;\n\n\n\nincorrect_lun:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1556, "prediction": "0", "true_label": "0", "raw_text": "Question: static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.dinfo) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1557, "prediction": "0", "true_label": "0", "raw_text": "Question: static int tcg_match_ori(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (type == TCG_TYPE_I32) {\n\n            /* All 32-bit ORs can be performed with 1 48-bit insn.  */\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    /* Look for negative values.  These are best to load with LGHI.  */\n\n    if (val < 0) {\n\n        if (val == (int16_t)val) {\n\n            return 0;\n\n        }\n\n        if (facilities & FACILITY_EXT_IMM) {\n\n            if (val == (int32_t)val) {\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1558, "prediction": "0", "true_label": "0", "raw_text": "Question: void OPPROTO op_addq_EDI_T0(void)\n\n{\n\n    EDI = (EDI + T0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1559, "prediction": "0", "true_label": "0", "raw_text": ", h_read);\n\n\n\n    /* hcall-bulk */\n\n    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);\n\n\n\n    /* hcall-dabr */\n\n    spapr_register_hypercall(H_SET_DABR, h_set_dabr);\n\n\n\n    /* hcall-splpar */\n\n    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);\n\n    spapr_register_hypercall(H_CEDE, h_cede);\n\n\n\n    /* processor register resource access h-calls */\n\n    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);\n\n    spapr_register_hypercall(H_SET_MODE, h_set_mode);\n\n\n\n    /* \"debugger\" hcalls (also used by SLOF). Note: We do -not- differenciate\n\n     * here between the \"CI\" and the \"CACHE\" variants, they will use whatever\n\n     * mapping attributes qemu is using. When using KVM, the kernel will\n\n     * enforce the attributes more strongly\n\n     */\n\n    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);\n\n    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);\n\n    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);\n\n\n\n    /* qemu/KVM-PPC specific hcalls */\n\n    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);\n\n\n\n    /* ibm,client-architecture-support support */\n\n    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1560, "prediction": "0", "true_label": "0", "raw_text": "_get_geometry(s->bs, &capacity);\n\n    memset(&blkcfg, 0, sizeof(blkcfg));\n\n    virtio_stq_p(vdev, &blkcfg.capacity, capacity);\n\n    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);\n\n    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);\n\n    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);\n\n    blkcfg.heads = conf->heads;\n\n    /*\n\n     * We must ensure that the block device capacity is a multiple of\n\n     * the logical block size. If that is not the case, let's use\n\n     * sector_mask to adopt the geometry to have a correct picture.\n\n     * For those devices where the capacity is ok for the given geometry\n\n     * we don't touch the sector value of the geometry, since some devices\n\n     * (like s390 dasd) need a specific value. Here the capacity is already\n\n     * cyls*heads*secs*blk_size and the sector value is not block size\n\n     * divided by 512 - instead it is the amount of blk_size blocks\n\n     * per track (cylinder).\n\n     */\n\n    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {\n\n        blkcfg.sectors = conf->secs & ~s->sector_mask;\n\n    } else {\n\n        blkcfg.sectors = conf->secs;\n\n    }\n\n    blkcfg.size_max = 0;\n\n    blkcfg.physical_block_exp = get_physical_block_exp(conf);\n\n    blkcfg.alignment_offset = 0;\n\n    blkcfg.wce = bdrv_enable_write_cache(s->bs);\n\n    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1561, "prediction": "0", "true_label": "0", "raw_text": "_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n            MIPS_DEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MDMX:\n\n        check_insn(ctx, ASE_MDMX);\n\n        /* MDMX: Not implemented. */\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, rs, imm);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1562, "prediction": "1", "true_label": "0", "raw_text": "Question: bool blk_dev_is_tray_open(BlockBackend *blk)\n\n{\n\n    if (blk->dev_ops && blk->dev_ops->is_tray_open) {\n\n        return blk->dev_ops->is_tray_open(blk->dev_opaque);\n\n    }\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1563, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int tdsc_init(AVCodecContext *avctx)\n\n{\n\n    TDSCContext *ctx = avctx->priv_data;\n\n    const AVCodec *codec;\n\n    int ret;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n\n\n    /* These needs to be set to estimate buffer and frame size */\n\n    if (!(avctx->width && avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Video size not set.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* This value should be large enough for a RAW-only frame plus headers */\n\n    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);\n\n    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Allocate reference and JPEG frame */\n\n    ctx->refframe = av_frame_alloc();\n\n    ctx->jpgframe = av_frame_alloc();\n\n    if (!ctx->refframe || !ctx->jpgframe)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* Prepare everything needed for JPEG decoding */\n\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n\n    if (!codec)\n\n        return AVERROR_BUG;\n\n    ctx->jpeg_avctx = avcodec_alloc_context3(codec);\n\n    if (!ctx->jpeg_avctx)\n\n        return AVERROR(ENOMEM);\n\n    ctx->jpeg_avctx->flags = avctx->flags;\n\n    ctx->jpeg_avctx->flags2 = avctx->flags2;\n\n    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;\n\n    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;\n\n    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Set the output pixel format on the reference frame */\n\n    ctx->refframe->format = avctx->pix_fmt;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1564, "prediction": "0", "true_label": "1", "raw_text": ", tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1565, "prediction": "0", "true_label": "0", "raw_text": "/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n    if (format != 7) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Intel H263 free format not supported\\n\");\n\n        return -1;\n\n    }\n\n    s->h263_plus = 0;\n\n\n\n    s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n    \n\n    s->unrestricted_mv = get_bits1(&s->gb); \n\n    s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"SAC not supported\\n\");\n\n        return -1;\t/* SAC: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        s->obmc= 1;\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Advanced Prediction Mode not supported\\n\");\n\n//        return -1;\t/* advanced prediction mode: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"PB frame mode no supported\\n\");\n\n        return -1;\t/* PB frame mode */\n\n    }\n\n\n\n    /* skip unknown header garbage */\n\n    skip_bits(&s->gb, 41);\n\n\n\n    s->qscale = get_bits(&s->gb, 5);\n\n    skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n\n\n    s->y_dc_scale_table=\n\n    s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1566, "prediction": "1", "true_label": "1", "raw_text": "Question: int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1567, "prediction": "0", "true_label": "1", "raw_text": "Question: static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1568, "prediction": "0", "true_label": "0", "raw_text": "Question: void uuid_unparse(const uuid_t uu, char *out)\n\n{\n\n    snprintf(out, 37, UUID_FMT,\n\n            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],\n\n            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1569, "prediction": "0", "true_label": "0", "raw_text": "Question: static int stellaris_enet_can_receive(void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return 1;\n\n\n\n    return (s->np < 31);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1570, "prediction": "0", "true_label": "0", "raw_text": "Question: void acpi_memory_unplug_cb(MemHotplugState *mem_st,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    /* nvdimm device hot unplug is not supported yet. */\n\n    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));\n\n    mdev->is_enabled = false;\n\n    mdev->dimm = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1571, "prediction": "0", "true_label": "0", "raw_text": "Question: alloc_f(int argc, char **argv)\n\n{\n\n\tint64_t offset;\n\n\tint nb_sectors;\n\n\tchar s1[64];\n\n\tint num;\n\n\tint ret;\n\n\tconst char *retstr;\n\n\n\n\toffset = cvtnum(argv[1]);\n\n\tif (offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (argc == 3)\n\n\t\tnb_sectors = cvtnum(argv[2]);\n\n\telse\n\n\t\tnb_sectors = 1;\n\n\n\n\tret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n\n\n\n\tcvtstr(offset, s1, sizeof(s1));\n\n\n\n\tretstr = ret ? \"allocated\" : \"not allocated\";\n\n\tif (nb_sectors == 1)\n\n\t\tprintf(\"sector %s at offset %s\\n\", retstr, s1);\n\n\telse\n\n\t\tprintf(\"%d/%d sectors %s at offset %s\\n\",\n\n\t\t\tnum, nb_sectors, retstr, s1);\n\n\treturn 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1572, "prediction": "0", "true_label": "1", "raw_text": "Question: static void hmp_cont_cb(void *opaque, int err)\n\n{\n\n    if (!err) {\n\n        qmp_cont(NULL);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1573, "prediction": "0", "true_label": "1", "raw_text": "WRITE_POLICY |\n\n                               MFI_INFO_LDOPS_READ_POLICY);\n\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n\n    info.stripe_sz_ops.min = 3;\n\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n\n    info.properties.rebuild_rate = 30;\n\n    info.properties.patrol_read_rate = 30;\n\n    info.properties.bgi_rate = 30;\n\n    info.properties.cc_rate = 30;\n\n    info.properties.recon_rate = 30;\n\n    info.properties.cache_flush_interval = 4;\n\n    info.properties.spinup_drv_cnt = 2;\n\n    info.properties.spinup_delay = 6;\n\n    info.properties.ecc_bucket_size = 15;\n\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n\n    info.properties.expose_encl_devices = 1;\n\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n\n                                       MFI_INFO_PDMIX_SATA |\n\n                                       MFI_INFO_PDMIX_LD);\n\n\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n\n    return MFI_STAT_OK;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1574, "prediction": "0", "true_label": "1", "raw_text": "get_buffer(c->parent_avctx, new);\n\n            pthread_mutex_unlock(&c->buffer_mutex);\n\n            if(ret<0)\n\n                return ret;\n\n            new->pts = frame->pts;\n\n            new->quality = frame->quality;\n\n            new->pict_type = frame->pict_type;\n\n            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,\n\n                          avctx->pix_fmt, avctx->width, avctx->height);\n\n            frame = new;\n\n        }\n\n\n\n        task.index = c->task_index;\n\n        task.indata = (void*)frame;\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_cond_signal(&c->task_fifo_cond);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n\n\n        c->task_index = (c->task_index+1) % BUFFER_SIZE;\n\n\n\n        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)\n\n            return 0;\n\n    }\n\n\n\n    if(c->task_index == c->finished_task_index)\n\n        return 0;\n\n\n\n    pthread_mutex_lock(&c->finished_task_mutex);\n\n    while (!c->finished_tasks[c->finished_task_index].outdata) {\n\n        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);\n\n    }\n\n    task = c->finished_tasks[c->finished_task_index];\n\n    *pkt = *(AVPacket*)(task.outdata);\n\n    av_freep(&c->finished_tasks[c->finished_task_index].outdata);\n\n    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;\n\n    pthread_mutex_unlock(&c->finished_task_mutex);\n\n\n\n    *got_packet_ptr = 1;\n\n\n\n    return task.return_code;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1575, "prediction": "0", "true_label": "0", "raw_text": "Question: int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (version_id > vmsd->version_id) {\n\n        return -EINVAL;\n\n    }\n\n    if (version_id < vmsd->minimum_version_id_old) {\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        return vmsd->load_state_old(f, opaque, version_id);\n\n    }\n\n    while(field->name) {\n\n        if (field->version_id <= version_id) {\n\n            void *base_addr = opaque + field->offset;\n\n            int ret, i, n_elems = 1;\n\n\n\n            if (field->flags & VMS_ARRAY) {\n\n                n_elems = field->num;\n\n            } else if (field->flags & VMS_VARRAY) {\n\n                n_elems = *(size_t *)(opaque+field->num_offset);\n\n            }\n\n            if (field->flags & VMS_POINTER) {\n\n                base_addr = *(void **)base_addr;\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + field->size * i;\n\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);\n\n                } else {\n\n                    ret = field->info->get(f, addr, field->size);\n\n\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n    if (vmsd->run_after_load)\n\n        return vmsd->run_after_load(opaque);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1576, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,\n\n                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)\n\n{\n\n    TCGReg tmp0 = TCG_TMP0;\n\n    TCGReg tmp1 = ret;\n\n\n\n    assert(ret != TCG_TMP0);\n\n    if (ret == ah || ret == bh) {\n\n        assert(ret != TCG_TMP1);\n\n        tmp1 = TCG_TMP1;\n\n    }\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n    case TCG_COND_NE:\n\n        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);\n\n        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);\n\n        break;\n\n\n\n    default:\n\n        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);\n\n        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);\n\n        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);\n\n        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);\n\n        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1577, "prediction": "0", "true_label": "0", "raw_text": "Question: static void display_mouse_define(DisplayChangeListener *dcl,\n\n                                 QEMUCursor *c)\n\n{\n\n    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);\n\n\n\n    qemu_mutex_lock(&ssd->lock);\n\n    if (c) {\n\n        cursor_get(c);\n\n    }\n\n    cursor_put(ssd->cursor);\n\n    ssd->cursor = c;\n\n    ssd->hot_x = c->hot_x;\n\n    ssd->hot_y = c->hot_y;\n\n    g_free(ssd->ptr_move);\n\n    ssd->ptr_move = NULL;\n\n    g_free(ssd->ptr_define);\n\n    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);\n\n    qemu_mutex_unlock(&ssd->lock);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1578, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void stw_phys_internal(hwaddr addr, uint32_t val,\n\n                                     enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n        io_mem_write(section->mr, addr, val, 2);\n\n    } else {\n\n        unsigned long addr1;\n\n        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            stw_le_p(ptr, val);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            stw_be_p(ptr, val);\n\n            break;\n\n        default:\n\n            stw_p(ptr, val);\n\n            break;\n\n        }\n\n        invalidate_and_set_dirty(addr1, 2);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1579, "prediction": "0", "true_label": "1", "raw_text": "+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        \n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j, \n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1580, "prediction": "0", "true_label": "0", "raw_text": "Question: static void opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else assert(0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1581, "prediction": "0", "true_label": "1", "raw_text": "\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n#else\n\n\t\tunsigned i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tudst[i] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t\tvdst[i] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1582, "prediction": "0", "true_label": "1", "raw_text": "Question: static int huf_uncompress(GetByteContext *gb,\n\n                          uint16_t *dst, int dst_size)\n\n{\n\n    int32_t src_size, im, iM;\n\n    uint32_t nBits;\n\n    uint64_t *freq;\n\n    HufDec *hdec;\n\n    int ret, i;\n\n\n\n    src_size = bytestream2_get_le32(gb);\n\n    im = bytestream2_get_le32(gb);\n\n    iM = bytestream2_get_le32(gb);\n\n    bytestream2_skip(gb, 4);\n\n    nBits = bytestream2_get_le32(gb);\n\n    if (im < 0 || im >= HUF_ENCSIZE ||\n\n        iM < 0 || iM >= HUF_ENCSIZE ||\n\n        src_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    bytestream2_skip(gb, 4);\n\n\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n\n    if (!freq || !hdec) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n\n        goto fail;\n\n\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n\n        goto fail;\n\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\n\n\nfail:\n\n    for (i = 0; i < HUF_DECSIZE; i++) {\n\n        if (hdec[i].p)\n\n            av_freep(&hdec[i].p);\n\n    }\n\n\n\n    av_free(freq);\n\n    av_free(hdec);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1583, "prediction": "-1", "true_label": "1", "raw_text": "_frame_start(HEVCContext *s)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int ret;\n\n\n\n    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n\n    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n\n\n\n    lc->start_of_tiles_x = 0;\n\n    s->is_decoded        = 0;\n\n\n\n\n    if (s->pps->tiles_enabled_flag)\n\n        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;\n\n\n\n    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n\n                              s->poc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ret = ff_hevc_frame_rps(s);\n\n    if (ret < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error constructing the frame RPS.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = set_side_data(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    av_frame_unref(s->output_frame);\n\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (s->ref)\n\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    s->ref = NULL;\n\n    return ret;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1584, "prediction": "0", "true_label": "1", "raw_text": "(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(buffer, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(buffer);\n\n    errno = serrno;\n\n    g_free(buffer);\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1585, "prediction": "0", "true_label": "1", "raw_text": "method_array (int sb, int channels, sb_int8_array coding_method)\n\n{\n\n    int j,k;\n\n    int ch;\n\n    int run, case_val;\n\n    int switchtable[23] = {0,5,1,5,5,5,5,5,2,5,5,5,5,5,5,5,3,5,5,5,5,5,4};\n\n\n\n    for (ch = 0; ch < channels; ch++) {\n\n        for (j = 0; j < 64; ) {\n\n            if((coding_method[ch][sb][j] - 8) > 22) {\n\n                run = 1;\n\n                case_val = 8;\n\n            } else {\n\n                switch (switchtable[coding_method[ch][sb][j]]) {\n\n                    case 0: run = 10; case_val = 10; break;\n\n                    case 1: run = 1; case_val = 16; break;\n\n                    case 2: run = 5; case_val = 24; break;\n\n                    case 3: run = 3; case_val = 30; break;\n\n                    case 4: run = 1; case_val = 30; break;\n\n                    case 5: run = 1; case_val = 8; break;\n\n                    default: run = 1; case_val = 8; break;\n\n                }\n\n            }\n\n            for (k = 0; k < run; k++)\n\n                if (j + k < 128)\n\n                    if (coding_method[ch][sb + (j + k) / 64][(j + k) % 64] > coding_method[ch][sb][j])\n\n                        if (k > 0) {\n\n                           SAMPLES_NEEDED\n\n                            //not debugged, almost never used\n\n                            memset(&coding_method[ch][sb][j + k], case_val, k * sizeof(int8_t));\n\n                            memset(&coding_method[ch][sb][j + k], case_val, 3 * sizeof(int8_t));\n\n                        }\n\n            j += run;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1586, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1587, "prediction": "0", "true_label": "1", "raw_text": "Question: int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1588, "prediction": "1", "true_label": "1", "raw_text": "Question: static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes\n"}], [{"ID": 1589, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])\n\n{\n\n    int i;\n\n    if (s->chroma_format == CHROMA_444) {\n\n        encode_block(s, block[0], 0);\n\n        encode_block(s, block[2], 2);\n\n        encode_block(s, block[4], 4);\n\n        encode_block(s, block[8], 8);\n\n        encode_block(s, block[5], 5);\n\n        encode_block(s, block[9], 9);\n\n\n\n        if (16*s->mb_x+8 < s->width) {\n\n            encode_block(s, block[1], 1);\n\n            encode_block(s, block[3], 3);\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[10], 10);\n\n            encode_block(s, block[7], 7);\n\n            encode_block(s, block[11], 11);\n\n        }\n\n    } else {\n\n        for(i=0;i<5;i++) {\n\n            encode_block(s, block[i], i);\n\n        }\n\n        if (s->chroma_format == CHROMA_420) {\n\n            encode_block(s, block[5], 5);\n\n        } else {\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[5], 5);\n\n            encode_block(s, block[7], 7);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1590, "prediction": "0", "true_label": "0", "raw_text": "Question: int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1591, "prediction": "0", "true_label": "0", "raw_text": "Question: static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1592, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,\n\n                                           stride, dst, stride, 16, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1593, "prediction": "0", "true_label": "0", "raw_text": "2] = rgba >> 8;\n\n        rgba_color[3] = rgba;\n\n    } else if (hex_offset ||\n\n               strspn(color_string2, \"0123456789ABCDEFabcdef\") == len) {\n\n        char *tail;\n\n        unsigned int rgba = strtoul(color_string2, &tail, 16);\n\n\n\n        if (*tail || (len != 6 && len != 8)) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid 0xRRGGBB[AA] color string: '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        if (len == 8) {\n\n            rgba_color[3] = rgba;\n\n            rgba >>= 8;\n\n        }\n\n        rgba_color[0] = rgba >> 16;\n\n        rgba_color[1] = rgba >> 8;\n\n        rgba_color[2] = rgba;\n\n    } else {\n\n        entry = bsearch(color_string2,\n\n                        color_table,\n\n                        FF_ARRAY_ELEMS(color_table),\n\n                        sizeof(ColorEntry),\n\n                        color_table_compare);\n\n        if (!entry) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Cannot find color '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        memcpy(rgba_color, entry->rgb_color, 3);\n\n    }\n\n\n\n    if (tail) {\n\n        unsigned long int alpha;\n\n        const char *alpha_string = tail;\n\n        if (!strncmp(alpha_string, \"0x\", 2)) {\n\n            alpha = strtoul(alpha_string, &tail, 16);\n\n        } else {\n\n            alpha = 255 * strtod(alpha_string, &tail);\n\n        }\n\n\n\n        if (tail == alpha_string || *tail || alpha > 255) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid alpha value specifier '%s' in '%s'\\n\",\n\n                   alpha_string, color_string);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        rgba_color[3] = alpha;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1594, "prediction": "0", "true_label": "0", "raw_text": "Question: static int raw_inactivate(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    uint64_t perm = 0;\n\n    uint64_t shared = BLK_PERM_ALL;\n\n\n\n    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1595, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qobject_incref(*obj);\n\n    qmp_output_add_obj(qov, name, *obj);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1596, "prediction": "0", "true_label": "0", "raw_text": "Question: static int setup_sigcontext(struct target_sigcontext *sc,\n\n                            CPUSH4State *regs, unsigned long mask)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n#define COPY(x)         __put_user(regs->x, &sc->sc_##x)\n\n    COPY(gregs[0]); COPY(gregs[1]);\n\n    COPY(gregs[2]); COPY(gregs[3]);\n\n    COPY(gregs[4]); COPY(gregs[5]);\n\n    COPY(gregs[6]); COPY(gregs[7]);\n\n    COPY(gregs[8]); COPY(gregs[9]);\n\n    COPY(gregs[10]); COPY(gregs[11]);\n\n    COPY(gregs[12]); COPY(gregs[13]);\n\n    COPY(gregs[14]); COPY(gregs[15]);\n\n    COPY(gbr); COPY(mach);\n\n    COPY(macl); COPY(pr);\n\n    COPY(sr); COPY(pc);\n\n#undef COPY\n\n\n\n    for (i=0; i<16; i++) {\n\n        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);\n\n    }\n\n    __put_user(regs->fpscr, &sc->sc_fpscr);\n\n    __put_user(regs->fpul, &sc->sc_fpul);\n\n\n\n    /* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1597, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1598, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool ept_emulation_fault(uint64_t ept_qual)\n\n{\n\n    int read, write;\n\n\n\n    /* EPT fault on an instruction fetch doesn't make sense here */\n\n    if (ept_qual & EPT_VIOLATION_INST_FETCH) {\n\n        return false;\n\n    }\n\n\n\n    /* EPT fault must be a read fault or a write fault */\n\n    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;\n\n    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;\n\n    if ((read | write) == 0) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * The EPT violation must have been caused by accessing a\n\n     * guest-physical address that is a translation of a guest-linear\n\n     * address.\n\n     */\n\n    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||\n\n        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1599, "prediction": "0", "true_label": "0", "raw_text": "; j++) {\n\n                A += alpSrc[j][i] * (unsigned)lumFilter[j];\n\n            }\n\n            A >>= 1;\n\n            A += 0x20002000;\n\n        }\n\n\n\n        // 8bit: 12+15=27; 16-bit: 12+19=31\n\n        Y  >>= 14; // 10\n\n        Y += 0x10000;\n\n        U  >>= 14;\n\n        V  >>= 14;\n\n\n\n        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit\n\n        Y -= c->yuv2rgb_y_offset;\n\n        Y *= c->yuv2rgb_y_coeff;\n\n        Y += 1 << 13; // 21\n\n        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n            dest += 4;\n\n        } else {\n\n            dest += 3;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1600, "prediction": "0", "true_label": "1", "raw_text": "_bswap16s(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LH, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 2:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 3:\n\n#if !defined(CONFIG_SOFTMMU)\n\n        tcg_out_mov(s, TCG_REG_V0, addr_reg1);\n\n        addr_reg1 = TCG_REG_V0;\n\n#endif\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 4);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg2, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg2, addr_reg1, 4);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    reloc_pc16(label2_ptr, (tcg_target_long) s->code_ptr);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1601, "prediction": "0", "true_label": "1", "raw_text": "ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1602, "prediction": "0", "true_label": "1", "raw_text": "Question: int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1603, "prediction": "-1", "true_label": "1", "raw_text": "Question: static int ftp_abort(URLContext *h)\n\n{\n\n    static const char *command = \"ABOR\\r\\n\";\n\n    int err;\n\n    static const int abor_codes[] = {225, 226, 0};\n\n    FTPContext *s = h->priv_data;\n\n\n\n    /* According to RCF 959:\n\n       \"ABOR command tells the server to abort the previous FTP\n\n       service command and any associated transfer of data.\"\n\n\n\n       There are FTP server implementations that don't response\n\n       to any commands during data transfer in passive mode (including ABOR).\n\n\n\n       This implementation closes data connection by force.\n\n    */\n\n\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n\n        ftp_close_both_connections(s);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    } else {\n\n        ftp_close_data_connection(s);\n\n    }\n\n\n\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n\n        /* wu-ftpd also closes control connection after data connection closing */\n\n        ffurl_closep(&s->conn_control);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1604, "prediction": "-1", "true_label": "1", "raw_text": "].timestamp;\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       return AVERROR(EAGAIN);\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1605, "prediction": "0", "true_label": "0", "raw_text": "2 + eeprom->addrbits) {\n\n            /* Got 2 start bits and 2 opcode bits, transfer all address bits. */\n\n            tick++;\n\n            address = ((address << 1) | eedi);\n\n            if (tick == 2 + 2 + eeprom->addrbits) {\n\n                logout(\"%s command, address = 0x%02x (value 0x%04x)\\n\",\n\n                       opstring[command], address, eeprom->contents[address]);\n\n                if (command == 2) {\n\n                    eedo = 0;\n\n                }\n\n                address = address % eeprom->size;\n\n                if (command == 0) {\n\n                    /* Command code in upper 2 bits of address. */\n\n                    switch (address >> (eeprom->addrbits - 2)) {\n\n                        case 0:\n\n                            logout(\"write disable command\\n\");\n\n                            eeprom->writable = 0;\n\n                            break;\n\n                        case 1:\n\n                            logout(\"write all command\\n\");\n\n                            break;\n\n                        case 2:\n\n                            logout(\"erase all command\\n\");\n\n                            break;\n\n                        case 3:\n\n                            logout(\"write enable command\\n\");\n\n                            eeprom->writable = 1;\n\n                            break;\n\n                    }\n\n                } else {\n\n                    /* Read, write or erase word. */\n\n                    eeprom->data = eeprom->contents[address];\n\n                }\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits + 16) {\n\n            /* Transfer 16 data bits. */\n\n            tick++;\n\n            if (command == 2) {\n\n                /* Read word. */\n\n                eedo = ((eeprom->data & 0x8000) != 0);\n\n            }\n\n            eeprom->data <<= 1;\n\n            eeprom->data += eedi;\n\n        } else {\n\n            logout(\"additional unneeded tick, not processed\\n\");\n\n        }\n\n    }\n\n    /* Save status of EEPROM. */\n\n    eeprom->tick = tick;\n\n    eeprom->eecs = eecs;\n\n    eeprom->eesk = eesk;\n\n    eeprom->eedo = eedo;\n\n    eeprom->address = address;\n\n    eeprom->command = command;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1606, "prediction": "0", "true_label": "0", "raw_text": "Question: static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1607, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1608, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    int64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    mr = host_memory_backend_get_memory(dimm->hostmem, errp);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_int(v, name, &value, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1609, "prediction": "0", "true_label": "0", "raw_text": "_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    /* XXX: disable buffered write as it's not supported */\n\n    //    pfl->cfi_table[0x2A] = 0x05;\n\n    pfl->cfi_table[0x2A] = 0x00;\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = nb_blocs - 1;\n\n    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = sector_len >> 8;\n\n    pfl->cfi_table[0x30] = sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n\n\n    return pfl;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1610, "prediction": "0", "true_label": "0", "raw_text": "Question: static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1611, "prediction": "0", "true_label": "1", "raw_text": "B:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL_4xx:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1612, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_xvmc_field_end(MpegEncContext *s)\n\n{\n\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n\n    assert(render);\n\n\n\n    if (render->filled_mv_blocks_num > 0)\n\n        ff_mpeg_draw_horiz_band(s, 0, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1613, "prediction": "0", "true_label": "1", "raw_text": "Question: void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1614, "prediction": "0", "true_label": "0", "raw_text": "_NOISE_FILTER)\n\n                {\n\n                    int o;\n\n                    int numOfNoises=0;\n\n\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        char *tail;\n\n                        ppMode->maxTmpNoise[numOfNoises]=\n\n                            strtol(options[o], &tail, 0);\n\n                        if(tail!=options[o]){\n\n                            numOfNoises++;\n\n                            numOfUnknownOptions--;\n\n                            if(numOfNoises >= 3) break;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK\n\n                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){\n\n                    int o;\n\n\n\n                    for(o=0; options[o]!=NULL && o<2; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        if(o==0) ppMode->baseDcDiff= val;\n\n                        else ppMode->flatnessThreshold= val;\n\n                    }\n\n                }\n\n                else if(filters[i].mask == FORCE_QUANT){\n\n                    int o;\n\n                    ppMode->forcedQuant= 15;\n\n\n\n                    for(o=0; options[o]!=NULL && o<1; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        ppMode->forcedQuant= val;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        if(!filterNameOk) ppMode->error++;\n\n        ppMode->error += numOfUnknownOptions;\n\n    }\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppMode->lumMode, ppMode->chromMode);\n\n    if(ppMode->error){\n\n        av_log(NULL, AV_LOG_ERROR, \"%d errors in postprocess string \\\"%s\\\"\\n\", ppMode->error, name);\n\n        av_free(ppMode);\n\n        return NULL;\n\n    }\n\n    return ppMode;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1615, "prediction": "1", "true_label": "1", "raw_text": "Question: int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1616, "prediction": "0", "true_label": "0", "raw_text": "Question: static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n\n{\n\n    uintptr_t host_start, host_map_start, host_end;\n\n\n\n    last_bss = TARGET_PAGE_ALIGN(last_bss);\n\n\n\n    /* ??? There is confusion between qemu_real_host_page_size and\n\n       qemu_host_page_size here and elsewhere in target_mmap, which\n\n       may lead to the end of the data section mapping from the file\n\n       not being mapped.  At least there was an explicit test and\n\n       comment for that here, suggesting that \"the file size must\n\n       be known\".  The comment probably pre-dates the introduction\n\n       of the fstat system call in target_mmap which does in fact\n\n       find out the size.  What isn't clear is if the workaround\n\n       here is still actually needed.  For now, continue with it,\n\n       but merge it with the \"normal\" mmap that would allocate the bss.  */\n\n\n\n    host_start = (uintptr_t) g2h(elf_bss);\n\n    host_end = (uintptr_t) g2h(last_bss);\n\n    host_map_start = (host_start + qemu_real_host_page_size - 1);\n\n    host_map_start &= -qemu_real_host_page_size;\n\n\n\n    if (host_map_start < host_end) {\n\n        void *p = mmap((void *)host_map_start, host_end - host_map_start,\n\n                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n        if (p == MAP_FAILED) {\n\n            perror(\"cannot mmap brk\");\n\n            exit(-1);\n\n        }\n\n\n\n        /* Since we didn't use target_mmap, make sure to record\n\n           the validity of the pages with qemu.  */\n\n        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);\n\n    }\n\n\n\n    if (host_start < host_map_start) {\n\n        memset((void *)host_start, 0, host_map_start - host_start);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1617, "prediction": "0", "true_label": "0", "raw_text": "2, load3);\n\n\n\n        dst0 = (v16i8) __msa_fill_w(load0);\n\n        dst1 = (v16i8) __msa_fill_w(load1);\n\n        dst2 = (v16i8) __msa_fill_w(load2);\n\n        dst3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        XORI_B_4VECS_SB(src0, src1, src2, src3, src0, src1, src2, src3, 128);\n\n\n\n        XORI_B_4VECS_SB(dst0, dst1, dst2, dst3, dst0, dst1, dst2, dst3, 128);\n\n\n\n        ILVR_B_4VECS_SH(src0, src1, src2, src3, dst0, dst1, dst2, dst3,\n\n                        temp0, temp1, temp2, temp3);\n\n\n\n        temp0 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp0);\n\n        temp1 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp1);\n\n        temp2 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp2);\n\n        temp3 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp3);\n\n\n\n        SRA_4VECS(temp0, temp1, temp2, temp3,\n\n                  temp0, temp1, temp2, temp3, denom);\n\n\n\n        temp0 = CLIP_UNSIGNED_CHAR_H(temp0);\n\n        temp1 = CLIP_UNSIGNED_CHAR_H(temp1);\n\n        temp2 = CLIP_UNSIGNED_CHAR_H(temp2);\n\n        temp3 = CLIP_UNSIGNED_CHAR_H(temp3);\n\n\n\n        PCKEV_B_STORE_4_BYTES_4(temp0, temp1, temp2, temp3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1618, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,\n\n                              TCGReg arg1, intptr_t arg2)\n\n{\n\n    int opi, opx;\n\n\n\n    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);\n\n    if (type == TCG_TYPE_I32) {\n\n        opi = LWZ, opx = LWZX;\n\n    } else {\n\n        opi = LD, opx = LDX;\n\n    }\n\n    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1619, "prediction": "0", "true_label": "0", "raw_text": "Question: void do_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    Error *err = NULL;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    bs1 = NULL;\n\n    while ((bs1 = bdrv_next(bs1))) {\n\n        if (bdrv_can_snapshot(bs1)) {\n\n            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);\n\n            if (err) {\n\n                monitor_printf(mon,\n\n                               \"Error while deleting snapshot on device '%s':\"\n\n                               \" %s\\n\",\n\n                               bdrv_get_device_name(bs),\n\n                               error_get_pretty(err));\n\n                error_free(err);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1620, "prediction": "0", "true_label": "0", "raw_text": "Question: void object_property_add(Object *obj, const char *name, const char *type,\n\n                         ObjectPropertyAccessor *get,\n\n                         ObjectPropertyAccessor *set,\n\n                         ObjectPropertyRelease *release,\n\n                         void *opaque, Error **errp)\n\n{\n\n    ObjectProperty *prop;\n\n\n\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n\n        if (strcmp(prop->name, name) == 0) {\n\n            error_setg(errp, \"attempt to add duplicate property '%s'\"\n\n                       \" to object (type '%s')\", name,\n\n                       object_get_typename(obj));\n\n            return;\n\n        }\n\n    }\n\n\n\n    prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->name = g_strdup(name);\n\n    prop->type = g_strdup(type);\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n    prop->release = release;\n\n    prop->opaque = opaque;\n\n\n\n    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1621, "prediction": "0", "true_label": "0", "raw_text": "model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    StrongARMState *s;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"sa1110\";\n\n    }\n\n\n\n    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(SA_CS0, NULL, \"collie.fl1\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 1);\n\n    pflash_cfi01_register(SA_CS1, NULL, \"collie.fl2\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    sysbus_create_simple(\"scoop\", 0x40800000, NULL);\n\n\n\n    collie_binfo.kernel_filename = kernel_filename;\n\n    collie_binfo.kernel_cmdline = kernel_cmdline;\n\n    collie_binfo.initrd_filename = initrd_filename;\n\n    collie_binfo.board_id = 0x208;\n\n    arm_load_kernel(s->cpu, &collie_binfo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1622, "prediction": "0", "true_label": "0", "raw_text": "TBL_DECLARE(altivec_avg_pixels16_num, 1);\n\n#ifdef ALTIVEC_USE_REFERENCE_C_CODE\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));\n\n      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));\n\n      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));\n\n      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#else /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;\n\n    register vector unsigned char perm = vec_lvsl(0, pixels);\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      pixelsv1 = vec_ld(0, (unsigned char*)pixels);\n\n      pixelsv2 = vec_ld(16, (unsigned char*)pixels);\n\n      blockv = vec_ld(0, block);\n\n      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);\n\n      blockv = vec_avg(blockv,pixelsv);\n\n      vec_st(blockv, 0, (unsigned char*)block);\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#endif /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1623, "prediction": "1", "true_label": "0", "raw_text": "Question: static void blk_send_response_all(struct XenBlkDev *blkdev)\n\n{\n\n    struct ioreq *ioreq;\n\n    int send_notify = 0;\n\n\n\n    while (!LIST_EMPTY(&blkdev->finished)) {\n\n        ioreq = LIST_FIRST(&blkdev->finished);\n\n\tsend_notify += blk_send_response_one(ioreq);\n\n\tioreq_release(ioreq);\n\n    }\n\n    if (send_notify)\n\n\txen_be_send_notify(&blkdev->xendev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 1624, "prediction": "0", "true_label": "0", "raw_text": "00c06 /* release 0.12.6 */\n\n    /* limit number of outputs based on setting limit */\n\n    if (qxl->max_outputs && qxl->max_outputs <= max_outputs) {\n\n        max_outputs = qxl->max_outputs;\n\n    }\n\n#endif\n\n\n\n    memset(&rom->client_monitors_config, 0,\n\n           sizeof(rom->client_monitors_config));\n\n    rom->client_monitors_config.count = monitors_config->num_of_monitors;\n\n    /* monitors_config->flags ignored */\n\n    if (rom->client_monitors_config.count >= max_outputs) {\n\n        trace_qxl_client_monitors_config_capped(qxl->id,\n\n                                monitors_config->num_of_monitors,\n\n                                max_outputs);\n\n        rom->client_monitors_config.count = max_outputs;\n\n    }\n\n    for (i = 0 ; i < rom->client_monitors_config.count ; ++i) {\n\n        VDAgentMonConfig *monitor = &monitors_config->monitors[i];\n\n        QXLURect *rect = &rom->client_monitors_config.heads[i];\n\n        /* monitor->depth ignored */\n\n        rect->left = monitor->x;\n\n        rect->top = monitor->y;\n\n        rect->right = monitor->x + monitor->width;\n\n        rect->bottom = monitor->y + monitor->height;\n\n    }\n\n    rom->client_monitors_config_crc = qxl_crc32(\n\n            (const uint8_t *)&rom->client_monitors_config,\n\n            sizeof(rom->client_monitors_config));\n\n    trace_qxl_client_monitors_config_crc(qxl->id,\n\n            sizeof(rom->client_monitors_config),\n\n            rom->client_monitors_config_crc);\n\n\n\n    trace_qxl_interrupt_client_monitors_config(qxl->id,\n\n                        rom->client_monitors_config.count,\n\n                        rom->client_monitors_config.heads);\n\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1625, "prediction": "0", "true_label": "0", "raw_text": "_NOTIFY_CFG;\n\n\n\n    proxy->notify_pio.offset = 0x0;\n\n    proxy->notify_pio.size = 0x4;\n\n    proxy->notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    /* subclasses can enforce modern, so do this unconditionally */\n\n    memory_region_init(&proxy->modern_bar, OBJECT(proxy), \"virtio-pci\",\n\n                       2 * QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *\n\n                       VIRTIO_QUEUE_MAX);\n\n\n\n    memory_region_init_alias(&proxy->modern_cfg,\n\n                             OBJECT(proxy),\n\n                             \"virtio-pci-cfg\",\n\n                             &proxy->modern_bar,\n\n                             0,\n\n                             memory_region_size(&proxy->modern_bar));\n\n\n\n    address_space_init(&proxy->modern_as, &proxy->modern_cfg, \"virtio-pci-cfg-as\");\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus) &&\n\n        !pci_bus_is_root(pci_dev->bus)) {\n\n        int pos;\n\n\n\n        pos = pcie_endpoint_cap_init(pci_dev, 0);\n\n        assert(pos > 0);\n\n\n\n        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);\n\n        assert(pos > 0);\n\n\n\n        /*\n\n         * Indicates that this function complies with revision 1.2 of the\n\n         * PCI Power Management Interface Specification.\n\n         */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_PMC, 0x3);\n\n    } else {\n\n        /*\n\n         * make future invocations of pci_is_express() return false\n\n         * and pci_config_size() return PCI_CONFIG_SPACE_SIZE.\n\n         */\n\n        pci_dev->cap_present &= ~QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);\n\n    if (k->realize) {\n\n        k->realize(proxy, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1626, "prediction": "0", "true_label": "0", "raw_text": ", avctx)) < 0)\n\n        return ret;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)\n\n        return AVERROR_INVALIDDATA;\n\n    if (!encoding && c->palette_size && c->bpp <= 8) {\n\n        avctx->pix_fmt = PIX_FMT_PAL8;\n\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n\n        if (c->palette_size != (1 << (c->bpp - 1)))\n\n            return AVERROR_INVALIDDATA;\n\n        avctx->pix_fmt = PIX_FMT_BGR24;\n\n    } else {\n\n        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",\n\n                              encoding, c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    p->reference = 0;\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    if (encoding) {\n\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n\n                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!c->new_video)\n\n            return AVERROR(ENOMEM);\n\n        if (c->bpp == 8)\n\n            cdxl_decode_ham8(c);\n\n        else\n\n            cdxl_decode_ham6(c);\n\n    } else {\n\n        cdxl_decode_rgb(c);\n\n    }\n\n    *data_size      = sizeof(AVFrame);\n\n    *(AVFrame*)data = c->frame;\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1627, "prediction": "0", "true_label": "1", "raw_text": "\n\n        dst += 4;\n\n    } while (i < c->video_size / 16);\n\n\n\n    opcode_size = bytestream2_get_le16(&c->gb);\n\n    bytestream2_skip(&c->gb, 2);\n\n\n\n    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    opcodes = pkt + bytestream2_tell(&c->gb);\n\n    bytestream2_skipu(&c->gb, opcode_size);\n\n\n\n    dst = c->frame[c->current_frame];\n\n\n\n    for (i = 0; i < c->height; i += 4, dst += c->width * 3)\n\n        for (j = 0; j < c->width; j += 4, dst += 4) {\n\n            int opcode, k = 0;\n\n            if (op > opcode_size)\n\n                return AVERROR_INVALIDDATA;\n\n            if (j & 4) {\n\n                opcode = opcodes[op] & 15;\n\n                op++;\n\n            } else {\n\n                opcode = opcodes[op] >> 4;\n\n            }\n\n\n\n            while (block_sequences[opcode][k]) {\n\n                offset = c->width * 2;\n\n                code   = block_sequences[opcode][k++];\n\n\n\n                switch (code) {\n\n                case 2:\n\n                    offset = 0;\n\n                case 3:\n\n                    color = bytestream2_get_byte(&c->gb);\n\n                case 4:\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_color_mask(dst + offset, c->width, mask, color);\n\n                    break;\n\n                case 5:\n\n                    offset = 0;\n\n                case 6:\n\n                    set_src_position(c, &src, &send);\n\n                case 7:\n\n                    if (src + offset + c->width + 4 > send)\n\n                        return AVERROR_INVALIDDATA;\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_src_mask(dst + offset, c->width, mask, src + offset);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1628, "prediction": "0", "true_label": "0", "raw_text": "Question: static void save_native_fp_fsave(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    uint16_t fpuc;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    asm volatile (\"fsave %0\" : : \"m\" (*fp));\n\n    env->fpuc = fp->fpuc;\n\n    env->fpstt = (fp->fpus >> 11) & 7;\n\n    env->fpus = fp->fpus & ~0x3800;\n\n    fptag = fp->fptag;\n\n    for(i = 0;i < 8; i++) {\n\n        env->fptags[i] = ((fptag & 3) == 3);\n\n        fptag >>= 2;\n\n    }\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    /* we must restore the default rounding state */\n\n    fpuc = 0x037f | (env->fpuc & (3 << 10));\n\n    asm volatile(\"fldcw %0\" : : \"m\" (fpuc));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1629, "prediction": "0", "true_label": "0", "raw_text": " }\n\n        if(url_feof(ic->pb)) {\n\n            av_init_packet(pkt);\n\n            pkt->data=NULL;\n\n            pkt->size=0;\n\n            pkt->stream_index= is->video_stream;\n\n            packet_queue_put(&is->videoq, pkt);\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret != AVERROR_EOF && url_ferror(ic->pb) == 0) {\n\n                SDL_Delay(100); /* wait for user event */\n\n                continue;\n\n            } else\n\n                break;\n\n        }\n\n        if (pkt->stream_index == is->audio_stream) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* disable interrupting */\n\n    global_video_state = NULL;\n\n\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        av_close_input_file(is->ic);\n\n        is->ic = NULL; /* safety */\n\n    }\n\n    url_set_interrupt_cb(NULL);\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1630, "prediction": "0", "true_label": "1", "raw_text": "\n        int table[2][16];\n        int prev[2][2];\n        int ch;\n        src += 4; // skip channel size\n        src += 4; // skip number of samples (already read)\n        for (i = 0; i < 32; i++)\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n        /* Initialize the previous sample.  */\n        for (i = 0; i < 4; i++)\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n        for (ch = 0; ch <= st; ch++) {\n            samples = (short *)c->frame.data[0] + ch;\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < nb_samples / 14; i++) {\n                int index = (*src >> 4) & 7;\n                unsigned int exp = *src++ & 15;\n                int factor1 = table[ch][index * 2];\n                int factor2 = table[ch][index * 2 + 1];\n                /* Decode 14 samples.  */\n                for (n = 0; n < 14; n++) {\n                    int32_t sampledat;\n                    if(n&1) sampledat = sign_extend(*src++, 4);\n                    else    sampledat = sign_extend(*src >> 4, 4);\n                    sampledat = ((prev[ch][0]*factor1\n                                + prev[ch][1]*factor2) >> 11) + (sampledat << exp);\n                    *samples = av_clip_int16(sampledat);\n                    prev[ch][1] = prev[ch][0];\n                    prev[ch][0] = *samples++;\n                    /* In case of stereo, skip one sample, this sample\n                       is for the other channel.  */\n                    samples += st;\n                }\n            }\n        }\n        break;\n    }\n    default:\n        return -1;\n    }\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n    return src - buf;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1631, "prediction": "0", "true_label": "1", "raw_text": "Question: static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1632, "prediction": "0", "true_label": "1", "raw_text": ";\n\n        ost->pix_fmts[0] = ost->st->codec->pix_fmt;\n\n        return ost->pix_fmts;\n\n    }\n\n    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {\n\n        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));\n\n    } else if (ost->enc->pix_fmts) {\n\n        const enum PixelFormat *p;\n\n        AVIOContext *s = NULL;\n\n        uint8_t *ret;\n\n        int len;\n\n\n\n        if (avio_open_dyn_buf(&s) < 0)\n\n            exit_program(1);\n\n\n\n        p = ost->enc->pix_fmts;\n\n        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };\n\n            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,\n\n                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };\n\n            }\n\n        }\n\n\n\n        for (; *p != PIX_FMT_NONE; p++)\n\n            avio_printf(s, \"%s:\", av_get_pix_fmt_name(*p));\n\n        len = avio_close_dyn_buf(s, &ret);\n\n        ret[len - 1] = 0;\n\n        return ret;\n\n    } else\n\n        return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1633, "prediction": "0", "true_label": "1", "raw_text": "Question: static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)\n\n{\n\n    char buffer[32];\n\n    if (time) {\n\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));\n\n        av_metadata_set2(metadata, \"creation_time\", buffer, 0);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1634, "prediction": "0", "true_label": "1", "raw_text": "id > HPET_NUM_TIMERS - 1) {\n\n            printf(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                return timer->config;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                return timer->config >> 32;\n\n            case HPET_TN_CMP: // comparator register\n\n                return timer->cmp;\n\n            case HPET_TN_CMP + 4:\n\n                return timer->cmp >> 32;\n\n            case HPET_TN_ROUTE:\n\n                return timer->fsb >> 32;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return s->capability;\n\n            case HPET_PERIOD:\n\n                return s->capability >> 32;\n\n            case HPET_CFG:\n\n                return s->config;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl \\n\");\n\n                return 0;\n\n            case HPET_COUNTER:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick;\n\n            case HPET_COUNTER + 4:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick >> 32;\n\n            case HPET_STATUS:\n\n                return s->isr;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1635, "prediction": "0", "true_label": "1", "raw_text": "Question: void usb_claim_port(USBDevice *dev, Error **errp)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    assert(dev->port == NULL);\n\n\n\n    if (dev->port_path) {\n\n        QTAILQ_FOREACH(port, &bus->free, next) {\n\n            if (strcmp(port->path, dev->port_path) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (port == NULL) {\n\n            error_setg(errp, \"usb port %s (bus %s) not found (in use?)\",\n\n                       dev->port_path, bus->qbus.name);\n\n            return;\n\n        }\n\n    } else {\n\n        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), \"usb-hub\") != 0) {\n\n            /* Create a new hub and chain it on */\n\n            usb_create_simple(bus, \"usb-hub\");\n\n        }\n\n        if (bus->nfree == 0) {\n\n            error_setg(errp, \"tried to attach usb device %s to a bus \"\n\n                       \"with no free ports\", dev->product_desc);\n\n            return;\n\n        }\n\n        port = QTAILQ_FIRST(&bus->free);\n\n    }\n\n    trace_usb_port_claim(bus->busnr, port->path);\n\n\n\n    QTAILQ_REMOVE(&bus->free, port, next);\n\n    bus->nfree--;\n\n\n\n    dev->port = port;\n\n    port->dev = dev;\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->used, port, next);\n\n    bus->nused++;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1636, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vmxnet3_update_features(VMXNET3State *s)\n\n{\n\n    uint32_t guest_features;\n\n    int rxcso_supported;\n\n\n\n    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,\n\n                                               devRead.misc.uptFeatures);\n\n\n\n    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);\n\n    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);\n\n    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);\n\n\n\n    VMW_CFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\",\n\n              s->lro_supported, rxcso_supported,\n\n              s->rx_vlan_stripping);\n\n    if (s->peer_has_vhdr) {\n\n        qemu_peer_set_offload(qemu_get_queue(s->nic),\n\n                        rxcso_supported,\n\n                        s->lro_supported,\n\n                        s->lro_supported,\n\n                        0,\n\n                        0);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1637, "prediction": "0", "true_label": "0", "raw_text": "Question: static int virtio_blk_exit_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n\n\n    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);\n\n    return virtio_exit_pci(pci_dev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1638, "prediction": "0", "true_label": "0", "raw_text": "3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A = 0xffff<<14;\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]    ) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1639, "prediction": "0", "true_label": "0", "raw_text": "Question: static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1640, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1641, "prediction": "0", "true_label": "0", "raw_text": "Question: static void parse_numa_distance(NumaDistOptions *dist, Error **errp)\n\n{\n\n    uint16_t src = dist->src;\n\n    uint16_t dst = dist->dst;\n\n    uint8_t val = dist->val;\n\n\n\n    if (src >= MAX_NODES || dst >= MAX_NODES) {\n\n        error_setg(errp,\n\n                   \"Invalid node %\" PRIu16\n\n                   \", max possible could be %\" PRIu16,\n\n                   MAX(src, dst), MAX_NODES);\n\n        return;\n\n    }\n\n\n\n    if (!numa_info[src].present || !numa_info[dst].present) {\n\n        error_setg(errp, \"Source/Destination NUMA node is missing. \"\n\n                   \"Please use '-numa node' option to declare it first.\");\n\n        return;\n\n    }\n\n\n\n    if (val < NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \"\n\n                   \"it shouldn't be less than %d.\",\n\n                   val, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    if (src == dst && val != NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"Local distance of node %d should be %d.\",\n\n                   src, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    numa_info[src].distance[dst] = val;\n\n    have_numa_distance = true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1642, "prediction": "0", "true_label": "1", "raw_text": "Question: static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1643, "prediction": "0", "true_label": "1", "raw_text": "Question: static int compare_int64(const void *a, const void *b)\n\n{\n\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n\n    return va < vb ? -1 : va > vb ? +1 : 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1644, "prediction": "0", "true_label": "1", "raw_text": "Question: uint32_t kvm_arch_get_supported_cpuid(CPUState *env, uint32_t function,\n\n                                      uint32_t index, int reg)\n\n{\n\n    struct kvm_cpuid2 *cpuid;\n\n    int i, max;\n\n    uint32_t ret = 0;\n\n    uint32_t cpuid_1_edx;\n\n\n\n    if (!kvm_check_extension(env->kvm_state, KVM_CAP_EXT_CPUID)) {\n\n        return -1U;\n\n    }\n\n\n\n    max = 1;\n\n    while ((cpuid = try_get_cpuid(env->kvm_state, max)) == NULL) {\n\n        max *= 2;\n\n    }\n\n\n\n    for (i = 0; i < cpuid->nent; ++i) {\n\n        if (cpuid->entries[i].function == function &&\n\n            cpuid->entries[i].index == index) {\n\n            switch (reg) {\n\n            case R_EAX:\n\n                ret = cpuid->entries[i].eax;\n\n                break;\n\n            case R_EBX:\n\n                ret = cpuid->entries[i].ebx;\n\n                break;\n\n            case R_ECX:\n\n                ret = cpuid->entries[i].ecx;\n\n                break;\n\n            case R_EDX:\n\n                ret = cpuid->entries[i].edx;\n\n                switch (function) {\n\n                case 1:\n\n                    /* KVM before 2.6.30 misreports the following features */\n\n                    ret |= CPUID_MTRR | CPUID_PAT | CPUID_MCE | CPUID_MCA;\n\n                    break;\n\n                case 0x80000001:\n\n                    /* On Intel, kvm returns cpuid according to the Intel spec,\n\n                     * so add missing bits according to the AMD spec:\n\n                     */\n\n                    cpuid_1_edx = kvm_arch_get_supported_cpuid(env, 1, 0, R_EDX);\n\n                    ret |= cpuid_1_edx & 0x183f7ff;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(cpuid);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1645, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,\n\n                          uint8_t **bufptr, DumpState *s)\n\n{\n\n    GuestPhysBlock *block = *blockptr;\n\n    hwaddr addr;\n\n    uint8_t *buf;\n\n\n\n    /* block == NULL means the start of the iteration */\n\n    if (!block) {\n\n        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n\n        *blockptr = block;\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        if (bufptr) {\n\n            *bufptr = block->host_addr;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    *pfnptr = *pfnptr + 1;\n\n    addr = pfn_to_paddr(*pfnptr);\n\n\n\n    if ((addr >= block->target_start) &&\n\n        (addr + s->page_size <= block->target_end)) {\n\n        buf = block->host_addr + (addr - block->target_start);\n\n    } else {\n\n        /* the next page is in the next block */\n\n        block = QTAILQ_NEXT(block, next);\n\n        *blockptr = block;\n\n        if (!block) {\n\n            return false;\n\n        }\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        buf = block->host_addr;\n\n    }\n\n\n\n    if (bufptr) {\n\n        *bufptr = buf;\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1646, "prediction": "0", "true_label": "0", "raw_text": "s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta != NULL) {\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            run_dependent_requests(s, l2meta);\n\n            g_free(l2meta);\n\n            l2meta = NULL;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    if (l2meta != NULL) {\n\n        run_dependent_requests(s, l2meta);\n\n        g_free(l2meta);\n\n    }\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1647, "prediction": "0", "true_label": "0", "raw_text": "Question: int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    uint8_t buf[256];\n\n    uint8_t type = value >> 8;\n\n    uint8_t index = value & 0xff;\n\n    int ret = -1;\n\n\n\n    switch(type) {\n\n    case USB_DT_DEVICE:\n\n        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n\n        trace_usb_desc_device(dev->addr, len, ret);\n\n        break;\n\n    case USB_DT_CONFIG:\n\n        if (index < desc->full->bNumConfigurations) {\n\n            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n\n        }\n\n        trace_usb_desc_config(dev->addr, index, len, ret);\n\n        break;\n\n    case USB_DT_STRING:\n\n        ret = usb_desc_string(dev, index, buf, sizeof(buf));\n\n        trace_usb_desc_string(dev->addr, index, len, ret);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,\n\n                dev->addr, type, len);\n\n        break;\n\n    }\n\n\n\n    if (ret > 0) {\n\n        if (ret > len) {\n\n            ret = len;\n\n        }\n\n        memcpy(dest, buf, ret);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1648, "prediction": "0", "true_label": "0", "raw_text": "Question: static void connex_init(MachineState *machine)\n\n{\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t connex_rom = 0x01000000;\n\n    uint32_t connex_ram = 0x04000000;\n\n\n\n    cpu = pxa255_init(address_space_mem, connex_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"connext.rom\", connex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, connex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 36 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 36));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1649, "prediction": "0", "true_label": "0", "raw_text": "Question: void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *notifier,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_read,\n\n                            AioPollFn *io_poll)\n\n{\n\n    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,\n\n                       (IOHandler *)io_read, NULL, io_poll, notifier);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1650, "prediction": "0", "true_label": "0", "raw_text": "Question: void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,\n\n                   uint8_t *iv, int decrypt)\n\n{\n\n    int i;\n\n\n\n    while (count > 0) {\n\n        if (decrypt) {\n\n            xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = dst[i] ^ iv[i];\n\n                memcpy(iv, src, 8);\n\n            }\n\n        } else {\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = src[i] ^ iv[i];\n\n                xtea_crypt_ecb(ctx, dst, dst, decrypt);\n\n                memcpy(iv, dst, 8);\n\n            } else {\n\n                xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n            }\n\n        }\n\n\n\n        src   += 8;\n\n        dst   += 8;\n\n        count -= 8;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1651, "prediction": "0", "true_label": "0", "raw_text": "Question: static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)\n\n{\n\n    AVRational time_base = {1, 1000};\n\n    uint32_t start, end;\n\n    AVChapter *chapter;\n\n    uint8_t *dst = NULL;\n\n    int taglen;\n\n    char tag[5];\n\n\n\n    decode_str(s, pb, 0, &dst, &len);\n\n    if (len < 16)\n\n        return;\n\n\n\n    start = avio_rb32(pb);\n\n    end   = avio_rb32(pb);\n\n    avio_skip(pb, 8);\n\n\n\n    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);\n\n    if (!chapter) {\n\n        av_free(dst);\n\n        return;\n\n    }\n\n\n\n    len -= 16;\n\n    while (len > 10) {\n\n        avio_read(pb, tag, 4);\n\n        tag[4] = 0;\n\n        taglen = avio_rb32(pb);\n\n        avio_skip(pb, 2);\n\n        len -= 10;\n\n        if (taglen < 0 || taglen > len) {\n\n            av_free(dst);\n\n            return;\n\n        }\n\n        if (tag[0] == 'T')\n\n            read_ttag(s, pb, taglen, &chapter->metadata, tag);\n\n        else\n\n            avio_skip(pb, taglen);\n\n        len -= taglen;\n\n    }\n\n\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);\n\n    av_free(dst);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1652, "prediction": "0", "true_label": "0", "raw_text": "Question: void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    unsigned long page_index;\n\n    int ret;\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n    page_index = ram_addr >> TARGET_PAGE_BITS;\n\n    if (!modified_ram_pages_table[page_index]) {\n\n#if 0\n\n        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);\n\n#endif\n\n        modified_ram_pages_table[page_index] = 1;\n\n        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;\n\n        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {\n\n            /* flush */\n\n#ifdef _WIN32\n\n            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                                  &nb_modified_ram_pages,\n\n                                  sizeof(nb_modified_ram_pages),\n\n                                  NULL, 0, &temp, NULL);\n\n#else\n\n            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                        &nb_modified_ram_pages);\n\n#endif\n\n            kqemu_reset_modified_ram_pages();\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1653, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                                 unsigned npfd, int64_t timeout)\n\n{\n\n    if (!ctx->epoll_available) {\n\n        return false;\n\n    }\n\n    if (aio_epoll_enabled(ctx)) {\n\n        return true;\n\n    }\n\n    if (npfd >= EPOLL_ENABLE_THRESHOLD) {\n\n        if (aio_epoll_try_enable(ctx)) {\n\n            return true;\n\n        } else {\n\n            aio_epoll_disable(ctx);\n\n        }\n\n    }\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1654, "prediction": "0", "true_label": "0", "raw_text": "Question: static void aarch64_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&aarch64_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {\n\n        aarch64_cpu_register(&aarch64_cpus[i]);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1655, "prediction": "0", "true_label": "0", "raw_text": "Question: static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1656, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline uint32_t nvic_gprio_mask(NVICState *s)\n\n{\n\n    return ~0U << (s->prigroup + 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1657, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_eventfd(int fds[2])\n\n{\n\n#ifdef CONFIG_EVENTFD\n\n    int ret;\n\n\n\n    ret = eventfd(0, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = ret;\n\n        qemu_set_cloexec(ret);\n\n        if ((fds[1] = dup(ret)) == -1) {\n\n            close(ret);\n\n            return -1;\n\n        }\n\n        qemu_set_cloexec(fds[1]);\n\n        return 0;\n\n    }\n\n\n\n    if (errno != ENOSYS) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    return qemu_pipe(fds);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1658, "prediction": "0", "true_label": "0", "raw_text": "Question: static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    return -ENOTSUP;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1659, "prediction": "0", "true_label": "0", "raw_text": "Question: void HELPER(wsr_ibreakenable)(uint32_t v)\n\n{\n\n    uint32_t change = v ^ env->sregs[IBREAKENABLE];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < env->config->nibreak; ++i) {\n\n        if (change & (1 << i)) {\n\n            tb_invalidate_phys_page_range(\n\n                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);\n\n        }\n\n    }\n\n    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1660, "prediction": "0", "true_label": "1", "raw_text": "Question: static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1661, "prediction": "0", "true_label": "1", "raw_text": "Question: static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1662, "prediction": "0", "true_label": "1", "raw_text": "Question: static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1663, "prediction": "0", "true_label": "0", "raw_text": "Question: static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n\n{\n\n    const uint8_t *src_end = src + src_size;\n\n    int x = 0, y = 0;\n\n\n\n#define INC_XY(n) \\\n\n    x += n; \\\n\n    if (x >= width) { \\\n\n        y++; \\\n\n        if (y >= height) \\\n\n            return 0; \\\n\n        x = 0; \\\n\n    }\n\n\n\n    while (src_end - src >= 2) {\n\n        uint8_t v = *src++;\n\n        if (v > 0 && v < 0xC0) {\n\n            do {\n\n                int length = FFMIN(v, width - x);\n\n                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n\n                INC_XY(length);\n\n                v   -= length;\n\n            } while (v > 0);\n\n            src++;\n\n        } else if (v >= 0xC1) {\n\n            v -= 0xC0;\n\n            do {\n\n                int length = FFMIN3(v, width - x, src_end - src);\n\n                if (src_end - src < length)\n\n                    break;\n\n                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);\n\n                INC_XY(length);\n\n                src += length;\n\n                v   -= length;\n\n            } while (v > 0);\n\n        } else {\n\n            avpriv_request_sample(avctx, \"opcode %d\", v);\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1664, "prediction": "0", "true_label": "0", "raw_text": " stream_index < 0 ? timestamp :\n\n                     av_rescale_rnd(timestamp, AV_TIME_BASE,\n\n                                    s->streams[stream_index]->time_base.den,\n\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n\n\n    if (s->duration < seek_timestamp)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* check first that the timestamp is valid for some playlist */\n\n        struct playlist *pls = c->playlists[i];\n\n        int seq_no;\n\n        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {\n\n            /* set segment now so we do not need to search again below */\n\n            pls->cur_seq_no = seq_no;\n\n            valid_for = i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (valid_for < 0)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* Reset reading */\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->input) {\n\n            ffurl_close(pls->input);\n\n            pls->input = NULL;\n\n        }\n\n        av_free_packet(&pls->pkt);\n\n        reset_packet(&pls->pkt);\n\n        pls->pb.eof_reached = 0;\n\n        /* Clear any buffered data */\n\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n\n        pls->pb.pos = 0;\n\n\n\n        pls->seek_timestamp = seek_timestamp;\n\n        pls->seek_flags = flags;\n\n\n\n        /* set closest segment seq_no for playlists not handled above */\n\n        if (valid_for != i)\n\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n\n    }\n\n\n\n    c->cur_timestamp = seek_timestamp;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1665, "prediction": "0", "true_label": "0", "raw_text": "_real_device(dev, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* intercept MSI-X entry page in the MMIO */\n\n    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n\n        assigned_dev_register_msix_mmio(dev, &local_err);\n\n        if (local_err) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* handle real device's MMIO/PIO BARs */\n\n    assigned_dev_register_regions(dev->real_device.regions,\n\n                                  dev->real_device.region_number, dev,\n\n                                  &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* handle interrupt routing */\n\n    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;\n\n    dev->intpin = e_intx;\n\n    dev->intx_route.mode = PCI_INTX_DISABLED;\n\n    dev->intx_route.irq = -1;\n\n\n\n    /* assign device to guest */\n\n    r = assign_device(dev);\n\n    if (r < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* assign legacy INTx to the device */\n\n    r = assign_intx(dev);\n\n    if (r < 0) {\n\n        goto assigned_out;\n\n    }\n\n\n\n    assigned_dev_load_option_rom(dev);\n\n\n\n    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);\n\n\n\n    return 0;\n\n\n\nassigned_out:\n\n    deassign_device(dev);\n\nout:\n\n    free_assigned_device(dev);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1666, "prediction": "0", "true_label": "0", "raw_text": "Question: int xen_be_send_notify(struct XenDevice *xendev)\n\n{\n\n    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1667, "prediction": "0", "true_label": "0", "raw_text": "Question: static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)\n\n{\n\n    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&\n\n        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {\n\n        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&\n\n            timestamp < st->pts_wrap_reference)\n\n            return timestamp + (1ULL<<st->pts_wrap_bits);\n\n        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&\n\n            timestamp >= st->pts_wrap_reference)\n\n            return timestamp - (1ULL<<st->pts_wrap_bits);\n\n    }\n\n    return timestamp;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1668, "prediction": "0", "true_label": "0", "raw_text": " s->elementary_transfer_size)\n\n                size = s->elementary_transfer_size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n        } else {\n\n            /* a new transfer is needed */\n\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n\n            byte_count_limit = s->lcyl | (s->hcyl << 8);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"byte_count_limit=%d\\n\", byte_count_limit);\n\n#endif\n\n            if (byte_count_limit == 0xffff)\n\n                byte_count_limit--;\n\n            size = s->packet_transfer_size;\n\n            if (size > byte_count_limit) {\n\n                /* byte count limit must be even if this case */\n\n                if (byte_count_limit & 1)\n\n                    byte_count_limit--;\n\n                size = byte_count_limit;\n\n            }\n\n            s->lcyl = size;\n\n            s->hcyl = size >> 8;\n\n            s->elementary_transfer_size = size;\n\n            /* we cannot transmit more than one sector at a time */\n\n            if (s->lba != -1) {\n\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n\n                    size = (s->cd_sector_size - s->io_buffer_index);\n\n            }\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1669, "prediction": "0", "true_label": "0", "raw_text": "Question: static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    MiscState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr & LED_MAXADDR;\n\n    MISC_DPRINTF(\"Write diagnostic LED reg 0x\" TARGET_FMT_plx \" =  %x\\n\", addr,\n\n                 val);\n\n    switch (saddr) {\n\n    case 0:\n\n        s->leds = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1670, "prediction": "0", "true_label": "0", "raw_text": "ENOMEDIUM;\n\n    } else if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n\n        return -EIO;\n\n    } else if (bs->read_only) {\n\n        return -EROFS;\n\n    }\n\n\n\n    bdrv_reset_dirty(bs, sector_num, nb_sectors);\n\n\n\n    /* Do nothing if disabled.  */\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {\n\n        return 0;\n\n    }\n\n\n\n    max_discard = bs->bl.max_discard ?  bs->bl.max_discard : MAX_DISCARD_DEFAULT;\n\n    while (nb_sectors > 0) {\n\n        int ret;\n\n        int num = nb_sectors;\n\n\n\n        /* align request */\n\n        if (bs->bl.discard_alignment &&\n\n            num >= bs->bl.discard_alignment &&\n\n            sector_num % bs->bl.discard_alignment) {\n\n            if (num > bs->bl.discard_alignment) {\n\n                num = bs->bl.discard_alignment;\n\n            }\n\n            num -= sector_num % bs->bl.discard_alignment;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_discard) {\n\n            num = max_discard;\n\n        }\n\n\n\n        if (bs->drv->bdrv_co_discard) {\n\n            ret = bs->drv->bdrv_co_discard(bs, sector_num, num);\n\n        } else {\n\n            BlockDriverAIOCB *acb;\n\n            CoroutineIOCompletion co = {\n\n                .coroutine = qemu_coroutine_self(),\n\n            };\n\n\n\n            acb = bs->drv->bdrv_aio_discard(bs, sector_num, nb_sectors,\n\n                                            bdrv_co_io_em_complete, &co);\n\n            if (acb == NULL) {\n\n                return -EIO;\n\n            } else {\n\n                qemu_coroutine_yield();\n\n                ret = co.ret;\n\n            }\n\n        }\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        sector_num += num;\n\n        nb_sectors -= num;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1671, "prediction": "0", "true_label": "0", "raw_text": "Question: static void xlnx_ep108_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"Xilinx ZynqMP EP108 board\";\n\n    mc->init = xlnx_ep108_init;\n\n    mc->block_default_type = IF_IDE;\n\n    mc->units_per_default_bus = 1;\n\n    mc->ignore_memory_transaction_failures = true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1672, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,\n\n                             TCGReg rd, TCGReg rn, uint64_t limm)\n\n{\n\n    unsigned h, l, r, c;\n\n\n\n    assert(is_limm(limm));\n\n\n\n    h = clz64(limm);\n\n    l = ctz64(limm);\n\n    if (l == 0) {\n\n        r = 0;                  /* form 0....01....1 */\n\n        c = ctz64(~limm) - 1;\n\n        if (h == 0) {\n\n            r = clz64(~limm);   /* form 1..10..01..1 */\n\n            c += r;\n\n        }\n\n    } else {\n\n        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */\n\n        c = r - h - 1;\n\n    }\n\n    if (ext == TCG_TYPE_I32) {\n\n        r &= 31;\n\n        c &= 31;\n\n    }\n\n\n\n    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1673, "prediction": "0", "true_label": "0", "raw_text": "->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,\n\n                      pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->smm_enabled = smm_enabled;\n\n\n\n    pm->enable_tco = true;\n\n    acpi_pm_tco_init(&pm->tco_regs, &pm->io);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    legacy_acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci),\n\n        OBJECT(lpc_pci), &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1674, "prediction": "0", "true_label": "0", "raw_text": "_env, tcg_rt);\n\n        return;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        gen_io_start();\n\n    }\n\n\n\n    tcg_rt = cpu_reg(s, rt);\n\n\n\n    if (isread) {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            tcg_gen_movi_i64(tcg_rt, ri->resetvalue);\n\n        } else if (ri->readfn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_get_cp_reg64(tcg_rt, cpu_env, tmpptr);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_ld_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    } else {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            /* If not forbidden by access permissions, treat as WI */\n\n            return;\n\n        } else if (ri->writefn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_set_cp_reg64(cpu_env, tmpptr, tcg_rt);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_st_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        /* I/O operations must end the TB here (whether read or write) */\n\n        gen_io_end();\n\n        s->is_jmp = DISAS_UPDATE;\n\n    } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n\n        /* We default to ending the TB on a coprocessor register write,\n\n         * but allow this to be suppressed by the register definition\n\n         * (usually only necessary to work around guest bugs).\n\n         */\n\n        s->is_jmp = DISAS_UPDATE;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1675, "prediction": "0", "true_label": "0", "raw_text": "Question: static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    return visitor_input_test_init_internal(data, json_string, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1676, "prediction": "0", "true_label": "0", "raw_text": "Question: static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1677, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1678, "prediction": "0", "true_label": "1", "raw_text": " /* no custom intra matrix */\n\n            put_bits(&s->pb, 1, 0); /* no custom non intra matrix */\n\n\n\n            put_header(s, GOP_START_CODE);\n\n            put_bits(&s->pb, 1, 0); /* do drop frame */\n\n            /* time code : we must convert from the real frame rate to a\n\n               fake mpeg frame rate in case of low frame rate */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            time_code = s->fake_picture_number * FRAME_RATE_BASE;\n\n            s->gop_picture_number = s->fake_picture_number;\n\n            put_bits(&s->pb, 5, (UINT32)((time_code / (fps * 3600)) % 24));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / (fps * 60)) % 60));\n\n            put_bits(&s->pb, 1, 1);\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / fps) % 60));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code % fps) / FRAME_RATE_BASE));\n\n            put_bits(&s->pb, 1, 1); /* closed gop */\n\n            put_bits(&s->pb, 1, 0); /* broken link */\n\n        }\n\n\n\n        if (s->frame_rate < (24 * FRAME_RATE_BASE) && s->picture_number > 0) {\n\n            /* insert empty P pictures to slow down to the desired\n\n               frame rate. Each fake pictures takes about 20 bytes */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            n = ((s->picture_number * fps) / s->frame_rate) - 1;\n\n            while (s->fake_picture_number < n) {\n\n                mpeg1_skip_picture(s, s->fake_picture_number - \n\n                                   s->gop_picture_number); \n\n                s->fake_picture_number++;\n\n            }\n\n\n\n        }\n\n        s->fake_picture_number++;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1679, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src + stride - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1680, "prediction": "0", "true_label": "0", "raw_text": "324 - 2294);\n\n\n\n        /* Add padding so that the full bitrate is 2324*75 bytes/sec */\n\n        s->vcd_padding_bitrate_num = (2324LL * 75 * 8 - bitrate) * 2279 * 2294 - overhead_rate;\n\n#define VCD_PADDING_BITRATE_DEN (2279 * 2294)\n\n    }\n\n\n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n        s->pack_header_freq = 1;\n\n\n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* the standard mandates that there are only two system headers\n\n         * in the whole file: one in the first packet of each stream.\n\n         * (see standard p. IV-7 and IV-8) */\n\n        s->system_header_freq = 0x7fffffff;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        stream                = ctx->streams[i]->priv_data;\n\n        stream->packet_number = 0;\n\n    }\n\n    s->system_header_size = get_system_header_size(ctx);\n\n    s->last_scr           = AV_NOPTS_VALUE;\n\n    return 0;\n\n\n\nfail:\n\n    for (i = 0; i < ctx->nb_streams; i++)\n\n        av_freep(&ctx->streams[i]->priv_data);\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1681, "prediction": "0", "true_label": "0", "raw_text": "a_mc8_mmx2_rnd;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;\n\n    }\n\n    if (bit_depth == 10 && CONFIG_H264CHROMA) {\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;\n\n        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;\n\n    }\n\n\n\n    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;\n\n\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;\n\n\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;\n\n    } else {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext;\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1682, "prediction": "0", "true_label": "0", "raw_text": "     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->CurrPic.picture_id = VA_INVALID_ID;\n\n        vpic->CurrPic.flags      = VA_PICTURE_H264_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) {\n\n            vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID;\n\n            vpic->ReferenceFrames[i].flags      = VA_PICTURE_H264_INVALID;\n\n        }\n\n\n\n        vpic->coded_buf = VA_INVALID_ID;\n\n\n\n        vpic->pic_parameter_set_id = 0;\n\n        vpic->seq_parameter_set_id = 0;\n\n\n\n        vpic->num_ref_idx_l0_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_active_minus1 = 0;\n\n\n\n        vpic->pic_fields.bits.entropy_coding_mode_flag =\n\n            ((avctx->profile & 0xff) != 66);\n\n        vpic->pic_fields.bits.weighted_pred_flag = 0;\n\n        vpic->pic_fields.bits.weighted_bipred_idc = 0;\n\n        vpic->pic_fields.bits.transform_8x8_mode_flag =\n\n            ((avctx->profile & 0xff) >= 100);\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n    }\n\n\n\n    {\n\n        mseq->profile_idc = avctx->profile & 0xff;\n\n\n\n        if (avctx->profile & FF_PROFILE_H264_CONSTRAINED)\n\n            mseq->constraint_set1_flag = 1;\n\n        if (avctx->profile & FF_PROFILE_H264_INTRA)\n\n            mseq->constraint_set3_flag = 1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1683, "prediction": "0", "true_label": "0", "raw_text": "_next;\n\n        if (ifm_next == &slirp->if_fastq) {\n\n            /* No more packets in fastq, switch to batchq */\n\n            ifm_next = slirp->next_m;\n\n            next_from_batchq = true;\n\n        }\n\n        if (ifm_next == &slirp->if_batchq) {\n\n            /* end of batchq */\n\n            ifm_next = NULL;\n\n        }\n\n\n\n        /* Try to send packet unless it already expired */\n\n        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {\n\n            /* Packet is delayed due to pending ARP resolution */\n\n            continue;\n\n        }\n\n\n\n        if (ifm == slirp->next_m) {\n\n            /* Set which packet to send on next iteration */\n\n            slirp->next_m = ifm->ifq_next;\n\n        }\n\n\n\n        /* Remove it from the queue */\n\n        ifqt = ifm->ifq_prev;\n\n        remque(ifm);\n\n\n\n        /* If there are more packets for this session, re-queue them */\n\n        if (ifm->ifs_next != ifm) {\n\n            struct mbuf *next = ifm->ifs_next;\n\n\n\n            insque(next, ifqt);\n\n            ifs_remque(ifm);\n\n\n\n            if (!from_batchq) {\n\n                /* Next packet in fastq is from the same session */\n\n                ifm_next = next;\n\n                next_from_batchq = false;\n\n            } else if (slirp->next_m == &slirp->if_batchq) {\n\n                /* Set next_m and ifm_next if the session packet is now the\n\n                 * only one on batchq */\n\n                slirp->next_m = ifm_next = next;\n\n            }\n\n        }\n\n\n\n        /* Update so_queued */\n\n        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {\n\n            /* If there's no more queued, reset nqueued */\n\n            ifm->ifq_so->so_nqueued = 0;\n\n        }\n\n\n\n        m_free(ifm);\n\n    }\n\n\n\n    slirp->if_start_busy = false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1684, "prediction": "0", "true_label": "0", "raw_text": "Question: static void handle_ti(ESPState *s)\n\n{\n\n    uint32_t dmalen, minlen;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_ti;\n\n        return;\n\n    }\n\n\n\n    dmalen = s->rregs[ESP_TCLO];\n\n    dmalen |= s->rregs[ESP_TCMID] << 8;\n\n    dmalen |= s->rregs[ESP_TCHI] << 16;\n\n    if (dmalen==0) {\n\n      dmalen=0x10000;\n\n    }\n\n    s->dma_counter = dmalen;\n\n\n\n    if (s->do_cmd)\n\n        minlen = (dmalen < 32) ? dmalen : 32;\n\n    else if (s->ti_size < 0)\n\n        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;\n\n    else\n\n        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;\n\n    trace_esp_handle_ti(minlen);\n\n    if (s->dma) {\n\n        s->dma_left = minlen;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        esp_do_dma(s);\n\n    }\n\n    if (s->do_cmd) {\n\n        trace_esp_handle_ti_cmd(s->cmdlen);\n\n        s->ti_size = 0;\n\n        s->cmdlen = 0;\n\n        s->do_cmd = 0;\n\n        do_cmd(s, s->cmdbuf);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1685, "prediction": "0", "true_label": "0", "raw_text": "Question: static void lsi53c895a_register_devices(void)\n\n{\n\n    type_register_static(&lsi_info);\n\n    type_register_static_alias(&lsi_info, \"lsi\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1686, "prediction": "0", "true_label": "1", "raw_text": "Question: static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1687, "prediction": "0", "true_label": "1", "raw_text": "Question: static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n\n\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1688, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)\n\n{\n\n    int ch, bw_code;\n\n\n\n    if (cutoff) {\n\n        /* calculate bandwidth based on user-specified cutoff frequency */\n\n        int fbw_coeffs;\n\n        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);\n\n        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;\n\n        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);\n\n    } else {\n\n        /* use default bandwidth setting */\n\n        /* XXX: should compute the bandwidth according to the frame\n\n           size, so that we avoid annoying high frequency artifacts */\n\n        bw_code = 50;\n\n    }\n\n\n\n    /* set number of coefficients for each channel */\n\n    for (ch = 0; ch < s->fbw_channels; ch++) {\n\n        s->bandwidth_code[ch] = bw_code;\n\n        s->nb_coefs[ch]       = bw_code * 3 + 73;\n\n    }\n\n    if (s->lfe_on)\n\n        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1689, "prediction": "0", "true_label": "0", "raw_text": "8_t *src2, long width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"movq \"MANGLE(bm01010101)\", %%mm4           \\n\\t\"\n\n        \"mov                    %0, %%\"REG_a\"       \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq    (%1, %%\"REG_a\",4), %%mm0           \\n\\t\"\n\n        \"movq   8(%1, %%\"REG_a\",4), %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"psrlw                  $8, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm0           \\n\\t\"\n\n        \"movq                %%mm0, %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"pand                %%mm4, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm0, %%mm0           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm1           \\n\\t\"\n\n        \"movd                %%mm0, (%3, %%\"REG_a\") \\n\\t\"\n\n        \"movd                %%mm1, (%2, %%\"REG_a\") \\n\\t\"\n\n        \"add                    $4, %%\"REG_a\"       \\n\\t\"\n\n        \" js                    1b                  \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        dstU[i]= src1[4*i + 1];\n\n        dstV[i]= src1[4*i + 3];\n\n    }\n\n#endif\n\n    assert(src1 == src2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1690, "prediction": "0", "true_label": "0", "raw_text": "Question: static void xtensa_kc705_init(MachineState *machine)\n\n{\n\n    static const LxBoardDesc kc705_board = {\n\n        .flash_base = 0xf0000000,\n\n        .flash_size = 0x08000000,\n\n        .flash_boot_base = 0x06000000,\n\n        .flash_sector_size = 0x20000,\n\n        .sram_size = 0x2000000,\n\n    };\n\n    lx_init(&kc705_board, machine);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1691, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,\n\n                               unsigned int len)\n\n{\n\n    unsigned int offset;\n\n    int i;\n\n\n\n    offset = 0;\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n\n                                  elem->in_sg[i].iov_len,\n\n                                  1, size);\n\n\n\n        offset += size;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++)\n\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n\n                                  elem->out_sg[i].iov_len,\n\n                                  0, elem->out_sg[i].iov_len);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1692, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1693, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void tcg_out_goto_label(TCGContext *s, int label_index)\n\n{\n\n    TCGLabel *l = &s->labels[label_index];\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);\n\n        tcg_out_goto_noaddr(s);\n\n    } else {\n\n        tcg_out_goto(s, l->u.value_ptr);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1694, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ac97_map (PCIDevice *pci_dev, int region_num,\n\n                      uint32_t addr, uint32_t size, int type)\n\n{\n\n    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;\n\n    AC97LinkState *s = &d->ac97;\n\n\n\n    if (!region_num) {\n\n        s->base[0] = addr;\n\n        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);\n\n        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);\n\n        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);\n\n        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);\n\n        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);\n\n        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);\n\n    }\n\n    else {\n\n        s->base[1] = addr;\n\n        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);\n\n        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);\n\n        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);\n\n        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);\n\n        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);\n\n        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1695, "prediction": "0", "true_label": "0", "raw_text": "Question: void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1696, "prediction": "0", "true_label": "0", "raw_text": "Question: static int xenfb_send_motion(struct XenInput *xenfb,\n\n\t\t\t     int rel_x, int rel_y, int rel_z)\n\n{\n\n    union xenkbd_in_event event;\n\n\n\n    memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n\n    event.type = XENKBD_TYPE_MOTION;\n\n    event.motion.rel_x = rel_x;\n\n    event.motion.rel_y = rel_y;\n\n#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207\n\n    event.motion.rel_z = rel_z;\n\n#endif\n\n\n\n    return xenfb_kbd_event(xenfb, &event);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1697, "prediction": "0", "true_label": "1", "raw_text": "\n\n    ast->codec->codec_tag   = 0; /* no fourcc */\n\n    ast->codec->sample_rate = avio_rl16(pb);\n\n    ast->codec->channels    = 1;\n\n    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);\n\n\n\n    avio_skip(pb, 10);\n\n\n\n    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));\n\n    if (!ast->index_entries)\n\n        return AVERROR(ENOMEM);\n\n\n\n    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));\n\n    if (!jv->frames)\n\n        return AVERROR(ENOMEM);\n\n\n\n    offset = 0x68 + ast->nb_index_entries * 16;\n\n    for(i = 0; i < ast->nb_index_entries; i++) {\n\n        AVIndexEntry *e   = ast->index_entries + i;\n\n        JVFrame      *jvf = jv->frames + i;\n\n\n\n        /* total frame size including audio, video, palette data and padding */\n\n        e->size         = avio_rl32(pb);\n\n        e->timestamp    = i;\n\n        e->pos          = offset;\n\n        offset         += e->size;\n\n\n\n        jvf->audio_size = avio_rl32(pb);\n\n        jvf->video_size = avio_rl32(pb);\n\n        jvf->palette_size = avio_r8(pb) ? 768 : 0;\n\n\n\n        if (avio_r8(pb))\n\n             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");\n\n        jvf->video_type = avio_r8(pb);\n\n        avio_skip(pb, 1);\n\n\n\n        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;\n\n        audio_pts += jvf->audio_size;\n\n\n\n        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;\n\n    }\n\n\n\n    jv->state = JV_AUDIO;\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1698, "prediction": "0", "true_label": "0", "raw_text": " (track->mode == MODE_MP4)\n\n        ffio_wfourcc(pb, \"nclx\");\n\n    else\n\n        ffio_wfourcc(pb, \"nclc\");\n\n    switch (track->enc->color_primaries) {\n\n    case AVCOL_PRI_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_PRI_SMPTE170M:\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_BT470BG:   avio_wb16(pb, 5); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->color_trc) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_TRC_SMPTE170M: avio_wb16(pb, 1); break; // remapped\n\n    case AVCOL_TRC_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->colorspace) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_SPC_BT470BG:\n\n    case AVCOL_PRI_SMPTE170M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n\n\n    if (track->mode == MODE_MP4) {\n\n        int full_range = track->enc->color_range == AVCOL_RANGE_JPEG;\n\n        avio_w8(pb, full_range << 7);\n\n        return 19;\n\n    } else {\n\n        return 18;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1699, "prediction": "0", "true_label": "0", "raw_text": "Question: static int slirp_socket_load(QEMUFile *f, struct socket *so)\n\n{\n\n    if (tcp_attach(so) < 0)\n\n        return -ENOMEM;\n\n\n\n    so->so_urgc = qemu_get_be32(f);\n\n    so->so_ffamily = qemu_get_be16(f);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        so->so_faddr.s_addr = qemu_get_be32(f);\n\n        so->so_fport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_faddr and so_lport\\n\");\n\n    }\n\n    so->so_lfamily = qemu_get_be16(f);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        so->so_laddr.s_addr = qemu_get_be32(f);\n\n        so->so_lport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_laddr and so_lport\\n\");\n\n    }\n\n    so->so_iptos = qemu_get_byte(f);\n\n    so->so_emu = qemu_get_byte(f);\n\n    so->so_type = qemu_get_byte(f);\n\n    so->so_state = qemu_get_be32(f);\n\n    if (slirp_sbuf_load(f, &so->so_rcv) < 0)\n\n        return -ENOMEM;\n\n    if (slirp_sbuf_load(f, &so->so_snd) < 0)\n\n        return -ENOMEM;\n\n    slirp_tcp_load(f, so->so_tcpcb);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1700, "prediction": "0", "true_label": "0", "raw_text": "Question: static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)\n\n{\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\",\n\n                    info->name, info->bus_info->name);\n\n    if (info->alias)\n\n        pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias);\n\n    if (info->desc)\n\n        pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc);\n\n    if (info->no_user)\n\n        pos += snprintf(dest+pos, len-pos, \", no-user\");\n\n    return pos;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1701, "prediction": "0", "true_label": "0", "raw_text": "->is_avc ? 0 : buf_size;\n\n    int nal_index   = 0;\n\n    int buf_index   = 0;\n\n    int nals_needed = 0;\n\n\n\n    while(1) {\n\n        int nalsize = 0;\n\n        int dst_length, bit_length, consumed;\n\n        const uint8_t *ptr;\n\n\n\n        if (buf_index >= next_avc) {\n\n            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);\n\n            if (nalsize < 0)\n\n                break;\n\n            next_avc = buf_index + nalsize;\n\n        } else {\n\n            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);\n\n            if (buf_index >= buf_size)\n\n                break;\n\n        }\n\n\n\n        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,\n\n                                 next_avc - buf_index);\n\n\n\n        if (ptr == NULL || dst_length < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        buf_index += consumed;\n\n\n\n        bit_length = get_bit_length(h, buf, ptr, dst_length,\n\n                                    buf_index, next_avc);\n\n        nal_index++;\n\n\n\n        /* packets can sometimes contain multiple PPS/SPS,\n\n         * e.g. two PAFF field pictures in one packet, or a demuxer\n\n         * which splits NALs strangely if so, when frame threading we\n\n         * can't start the next thread until we've read all of them */\n\n        switch (h->nal_unit_type) {\n\n        case NAL_SPS:\n\n        case NAL_PPS:\n\n            nals_needed = nal_index;\n\n            break;\n\n        case NAL_DPA:\n\n        case NAL_IDR_SLICE:\n\n        case NAL_SLICE:\n\n            init_get_bits(&h->gb, ptr, bit_length);\n\n            if (!get_ue_golomb(&h->gb))\n\n                nals_needed = nal_index;\n\n        }\n\n    }\n\n\n\n    return nals_needed;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1702, "prediction": "0", "true_label": "0", "raw_text": "5.1                      */\n\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                       NULL, 0);\n\n                    }\n\n                }\n\n\n\n                /* Copy packet payload */\n\n                while (copy_size) {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n\n\n                    copy_size -= iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                }\n\n\n\n                if (desc_offset + desc_size >= total_size) {\n\n                    /* Simulate FCS checksum presence in the last descriptor */\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n\n                }\n\n            }\n\n            desc_offset += desc_size;\n\n            if (desc_offset >= total_size) {\n\n                is_last = true;\n\n            }\n\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n\n            trace_e1000e_rx_null_descriptor();\n\n        }\n\n\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n\n\n        e1000e_ring_advance(core, rxi,\n\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n\n\n    } while (desc_offset < total_size);\n\n\n\n    e1000e_update_rx_stats(core, size, total_size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1703, "prediction": "0", "true_label": "0", "raw_text": "_blt_dstpitch)) / depth;\n\n        dy = (dst / ABS(s->cirrus_blt_dstpitch));\n\n\n\n        /* normalize width */\n\n        w /= depth;\n\n\n\n        /* if we're doing a backward copy, we have to adjust\n\n           our x/y to be the upper left corner (instead of the lower\n\n           right corner) */\n\n        if (s->cirrus_blt_dstpitch < 0) {\n\n            sx -= (s->cirrus_blt_width / depth) - 1;\n\n            dx -= (s->cirrus_blt_width / depth) - 1;\n\n            sy -= s->cirrus_blt_height - 1;\n\n            dy -= s->cirrus_blt_height - 1;\n\n        }\n\n\n\n        /* are we in the visible portion of memory? */\n\n        if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\n            (sx + w) <= width && (sy + h) <= height &&\n\n            (dx + w) <= width && (dy + h) <= height) {\n\n            notify = 1;\n\n        }\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n\n                      s->vga.vram_ptr + s->cirrus_blt_srcaddr,\n\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n\n\n    if (notify) {\n\n        dpy_gfx_update(s->vga.con, dx, dy,\n\n                       s->cirrus_blt_width / depth,\n\n                       s->cirrus_blt_height);\n\n    }\n\n\n\n    /* we don't have to notify the display that this portion has\n\n       changed since qemu_console_copy implies this */\n\n\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t\ts->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t\ts->cirrus_blt_height);\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1704, "prediction": "0", "true_label": "1", "raw_text": "Question: static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1705, "prediction": "0", "true_label": "1", "raw_text": " i);\n        if (r < 0) {\n            goto fail_vq;\n        }\n    }\n    hdev->features = features;\n    hdev->memory_listener = (MemoryListener) {\n        .begin = vhost_begin,\n        .commit = vhost_commit,\n        .region_add = vhost_region_add,\n        .region_del = vhost_region_del,\n        .region_nop = vhost_region_nop,\n        .log_start = vhost_log_start,\n        .log_stop = vhost_log_stop,\n        .log_sync = vhost_log_sync,\n        .log_global_start = vhost_log_global_start,\n        .log_global_stop = vhost_log_global_stop,\n        .eventfd_add = vhost_eventfd_add,\n        .eventfd_del = vhost_eventfd_del,\n        .priority = 10\n    };\n    hdev->migration_blocker = NULL;\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n        error_setg(&hdev->migration_blocker,\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n        migrate_add_blocker(hdev->migration_blocker);\n    }\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n    hdev->n_mem_sections = 0;\n    hdev->mem_sections = NULL;\n    hdev->log = NULL;\n    hdev->log_size = 0;\n    hdev->log_enabled = false;\n    hdev->started = false;\n    hdev->memory_changed = false;\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n    return 0;\nfail_vq:\n    while (--i >= 0) {\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n    }\nfail:\n    r = -errno;\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n    QLIST_REMOVE(hdev, entry);\n    return r;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1706, "prediction": "0", "true_label": "1", "raw_text": "Question: int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1707, "prediction": "0", "true_label": "1", "raw_text": "Question: static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1]<<16;\n\n    return (b+r) << 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1708, "prediction": "0", "true_label": "1", "raw_text": "eight[j];\n\n\n\n    s->min_mse = FFMIN(s->min_mse, mse);\n\n    s->max_mse = FFMAX(s->max_mse, mse);\n\n\n\n    s->mse += mse;\n\n    for (j = 0; j < s->nb_components; j++)\n\n        s->mse_comp[j] += comp_mse[j];\n\n    s->nb_frames++;\n\n\n\n    for (j = 0; j < s->nb_components; j++) {\n\n        c = s->is_rgb ? s->rgba_map[j] : j;\n\n        set_meta(metadata, \"lavfi.psnr.mse.\", s->comps[j], comp_mse[c]);\n\n        set_meta(metadata, \"lavfi.psnr.psnr.\", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));\n\n    }\n\n    set_meta(metadata, \"lavfi.psnr.mse_avg\", 0, mse);\n\n    set_meta(metadata, \"lavfi.psnr.psnr_avg\", 0, get_psnr(mse, 1, s->average_max));\n\n\n\n    if (s->stats_file) {\n\n        fprintf(s->stats_file, \"n:%\"PRId64\" mse_avg:%0.2f \", s->nb_frames, mse);\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"mse_%c:%0.2f \", s->comps[j], comp_mse[c]);\n\n        }\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"psnr_%c:%0.2f \", s->comps[j],\n\n                    get_psnr(comp_mse[c], 1, s->max[c]));\n\n        }\n\n        fprintf(s->stats_file, \"\\n\");\n\n    }\n\n\n\n    return main;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1709, "prediction": "0", "true_label": "1", "raw_text": "Question: static void matroska_add_index_entries(MatroskaDemuxContext *matroska)\n\n{\n\n    EbmlList *index_list;\n\n    MatroskaIndex *index;\n\n    int index_scale = 1;\n\n    int i, j;\n\n\n\n    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)\n\n        return;\n\n\n\n    index_list = &matroska->index;\n\n    index      = index_list->elem;\n\n    if (index_list->nb_elem &&\n\n        index[0].time > 1E14 / matroska->time_scale) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");\n\n        index_scale = matroska->time_scale;\n\n    }\n\n    for (i = 0; i < index_list->nb_elem; i++) {\n\n        EbmlList *pos_list    = &index[i].pos;\n\n        MatroskaIndexPos *pos = pos_list->elem;\n\n        for (j = 0; j < pos_list->nb_elem; j++) {\n\n            MatroskaTrack *track = matroska_find_track_by_num(matroska,\n\n                                                              pos[j].track);\n\n            if (track && track->stream)\n\n                av_add_index_entry(track->stream,\n\n                                   pos[j].pos + matroska->segment_start,\n\n                                   index[i].time / index_scale, 0, 0,\n\n                                   AVINDEX_KEYFRAME);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1710, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void downmix_3f_2r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1711, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */\n\n    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&\n\n        !kvm_irqchip_is_split()) {\n\n        error_setg(errp, \"Intel Interrupt Remapping cannot work with \"\n\n                         \"kernel-irqchip=on, please use 'split|off'.\");\n\n        return false;\n\n    }\n\n    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {\n\n        error_setg(errp, \"eim=on cannot be selected without intremap=on\");\n\n        return false;\n\n    }\n\n\n\n    if (s->intr_eim == ON_OFF_AUTO_AUTO) {\n\n        s->intr_eim = x86_iommu->intr_supported ?\n\n                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1712, "prediction": "0", "true_label": "1", "raw_text": "Question: static int no_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1713, "prediction": "0", "true_label": "1", "raw_text": ") {\n\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n\n                }\n\n                bps /= channels; // ???\n\n                if (bps == 8)\n\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n\n                samplerate /= 4;/* UGH ??? XXX */\n\n                channels = 1;\n\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                       bps, channels, samplerate);\n\n            }\n\n        }\n\n        av_get_packet(pb, pkt, asize);\n\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n\n            /* on a nsvs frame we have new information on a/v sync */\n\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n\n                   nsv->avsync, pkt->dts);\n\n        }\n\n        nst->frame_offset++;\n\n    }\n\n\n\n    nsv->state = NSV_UNSYNC;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1714, "prediction": "0", "true_label": "1", "raw_text": "Question: static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1715, "prediction": "0", "true_label": "1", "raw_text": "0};\n                        pkt_data = NULL;\n                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n                            continue;\n                        bzstream.next_in = data;\n                        bzstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n                            result = BZ2_bzDecompress(&bzstream);\n                        } while (result==BZ_OK && pkt_size<10000000);\n                        pkt_size = bzstream.total_out_lo32;\n                        BZ2_bzDecompressEnd(&bzstream);\n                        if (result != BZ_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n                    }\n                }\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, pkt_size+offset) < 0) {\n                    av_free(pkt);\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                if (offset)\n                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n                memcpy (pkt->data+offset, pkt_data, pkt_size);\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n                matroska_queue_packet(matroska, pkt);\n            }\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1716, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)\n\n{\n\n    c->high = 255;\n\n    c->bits = -16;\n\n    c->buffer = buf;\n\n    c->end = buf + buf_size;\n\n    c->code_word = bytestream_get_be24(&c->buffer);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1717, "prediction": "0", "true_label": "1", "raw_text": "VirtQueueElement);\n\n    elem->index = head;\n\n    elem->in_num = elem->out_num = 0;\n\n    \n\n    /* If their number is silly, that's an error. */\n\n    if (unlikely(head >= num)) {\n\n        error_report(\"Guest says index %u > %u is available\", head, num);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    if (vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\n        vring_avail_event(&vring->vr) = vring->vr.avail->idx;\n\n    }\n\n\n\n    i = head;\n\n    do {\n\n        if (unlikely(i >= num)) {\n\n            error_report(\"Desc index is %u > %u, head = %u\", i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        if (unlikely(++found > num)) {\n\n            error_report(\"Loop detected: last one at %u vq size %u head %u\",\n\n                         i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        desc = vring->vr.desc[i];\n\n\n\n        /* Ensure descriptor is loaded before accessing fields */\n\n        barrier();\n\n\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n\n            ret = get_indirect(vring, elem, &desc);\n\n            if (ret < 0) {\n\n                goto out;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        ret = get_desc(vring, elem, &desc);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        i = desc.next;\n\n    } while (desc.flags & VRING_DESC_F_NEXT);\n\n\n\n    /* On success, increment avail index. */\n\n    vring->last_avail_idx++;\n\n    *p_elem = elem;\n\n    return head;\n\n\n\nout:\n\n    assert(ret < 0);\n\n    if (ret == -EFAULT) {\n\n        vring->broken = true;\n\n    }\n\n    if (elem) {\n\n        vring_unmap_element(elem);\n\n        g_slice_free(VirtQueueElement, elem);\n\n    }\n\n    *p_elem = NULL;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1718, "prediction": "1", "true_label": "0", "raw_text": "Question: static int ftp_connect_control_connection(URLContext *h)\n\n{\n\n    char buf[CONTROL_BUFFER_SIZE], opts_format[20];\n\n    int err;\n\n    AVDictionary *opts = NULL;\n\n    FTPContext *s = h->priv_data;\n\n    const int connect_codes[] = {220, 0};\n\n\n\n    s->conn_control_block_flag = 0;\n\n\n\n    if (!s->conn_control) {\n\n        ff_url_join(buf, sizeof(buf), \"tcp\", NULL,\n\n                    s->hostname, s->server_control_port, NULL);\n\n        if (s->rw_timeout != -1) {\n\n            snprintf(opts_format, sizeof(opts_format), \"%d\", s->rw_timeout);\n\n            av_dict_set(&opts, \"timeout\", opts_format, 0);\n\n        } /* if option is not given, don't pass it and let tcp use its own default */\n\n        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,\n\n                         &s->conn_control_interrupt_cb, &opts);\n\n        av_dict_free(&opts);\n\n        if (err < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Cannot open control connection\\n\");\n\n            return err;\n\n        }\n\n\n\n        /* consume all messages from server */\n\n        if (!ftp_status(s, NULL, connect_codes)) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP server not ready for new users\\n\");\n\n            err = AVERROR(EACCES);\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_auth(s)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP authentication failed\\n\");\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_type(s)) < 0) {\n\n            av_dlog(h, \"Set content type failed\\n\");\n\n            return err;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1719, "prediction": "0", "true_label": "1", "raw_text": "Question: void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1720, "prediction": "0", "true_label": "0", "raw_text": "y < s->mb_height - 1; mb_y++) {\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int error;\n\n            const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n\n\n            error = s->error_status_table[mb_xy];\n\n            if ((error & ER_DC_ERROR) && (error & ER_MV_ERROR))\n\n                continue; // skip damaged\n\n\n\n            j++;\n\n            // skip a few to speed things up\n\n            if ((j % skip_amount) != 0)\n\n                continue;\n\n\n\n            if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I) {\n\n                int *linesize = s->cur_pic.f->linesize;\n\n                uint8_t *mb_ptr      = s->cur_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n                uint8_t *last_mb_ptr = s->last_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n\n\n                if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n\n                    // FIXME\n\n                } else {\n\n                    ff_thread_await_progress(s->last_pic.tf, mb_y, 0);\n\n                }\n\n                is_intra_likely += s->mecc->sad[0](NULL, last_mb_ptr, mb_ptr,\n\n                                                   linesize[0], 16);\n\n                is_intra_likely -= s->mecc->sad[0](NULL, last_mb_ptr,\n\n                                                   last_mb_ptr + linesize[0] * 16,\n\n                                                   linesize[0], 16);\n\n            } else {\n\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n\n                   is_intra_likely++;\n\n                else\n\n                   is_intra_likely--;\n\n            }\n\n        }\n\n    }\n\n    return is_intra_likely > 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1721, "prediction": "0", "true_label": "1", "raw_text": "Question: void Release(void *ctx)\n\n{\n\n    ContextInfo *ci;\n\n    ci = (ContextInfo *) ctx;\n\n\n\n    if (ci->cache) {\n\n        imlib_context_set_image(ci->cache->image);\n\n        imlib_free_image();\n\n        av_free(ci->cache);\n\n    }\n\n    if (ctx) {\n\n        if (ci->imageOverlaid) {\n\n            imlib_context_set_image(ci->imageOverlaid);\n\n            imlib_free_image();\n\n        }\n\n        ff_eval_free(ci->expr_x);\n\n        ff_eval_free(ci->expr_y);\n\n        ff_eval_free(ci->expr_R);\n\n        ff_eval_free(ci->expr_G);\n\n        ff_eval_free(ci->expr_B);\n\n        sws_freeContext(ci->toRGB_convert_ctx);\n\n        sws_freeContext(ci->fromRGB_convert_ctx);\n\n        av_free(ctx);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1722, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1723, "prediction": "0", "true_label": "1", "raw_text": "Question: static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1724, "prediction": "0", "true_label": "1", "raw_text": "Question: static int xen_platform_initfn(PCIDevice *dev)\n{\n    PCIXenPlatformState *d = XEN_PLATFORM(dev);\n    uint8_t *pci_conf;\n    pci_conf = dev->config;\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n    pci_config_set_prog_interface(pci_conf, 0);\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n    platform_ioport_bar_setup(d);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);\n    /* reserve 16MB mmio address for share memory*/\n    platform_mmio_setup(d);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &d->mmio_bar);\n    platform_fixed_ioport_init(d);\n    return 0;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1725, "prediction": "0", "true_label": "0", "raw_text": "Question: static void mmap_release_buffer(AVPacket *pkt)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res, fd;\n\n    struct buff_data *buf_descriptor = pkt->priv;\n\n\n\n    if (pkt->data == NULL)\n\n        return;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    buf.index = buf_descriptor->index;\n\n    fd = buf_descriptor->fd;\n\n    av_free(buf_descriptor);\n\n\n\n    res = ioctl(fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0)\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n               strerror(errno));\n\n\n\n    pkt->data = NULL;\n\n    pkt->size = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1726, "prediction": "0", "true_label": "1", "raw_text": "Question: static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1727, "prediction": "0", "true_label": "1", "raw_text": "Question: static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1728, "prediction": "0", "true_label": "1", "raw_text": "Question: static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1729, "prediction": "0", "true_label": "0", "raw_text": "Question: static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1730, "prediction": "0", "true_label": "0", "raw_text": " = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x14:\t/* IT_STATUS */\n\n        ret = s->ulpd_pm_regs[addr >> 2];\n\n        s->ulpd_pm_regs[addr >> 2] = 0;\n\n        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);\n\n        return ret;\n\n\n\n    case 0x18:\t/* Reserved */\n\n    case 0x1c:\t/* Reserved */\n\n    case 0x20:\t/* Reserved */\n\n    case 0x28:\t/* Reserved */\n\n    case 0x2c:\t/* Reserved */\n\n        OMAP_BAD_REG(addr);\n\n    case 0x00:\t/* COUNTER_32_LSB */\n\n    case 0x04:\t/* COUNTER_32_MSB */\n\n    case 0x08:\t/* COUNTER_HIGH_FREQ_LSB */\n\n    case 0x0c:\t/* COUNTER_HIGH_FREQ_MSB */\n\n    case 0x10:\t/* GAUGING_CTRL */\n\n    case 0x24:\t/* SETUP_ANALOG_CELL3_ULPD1 */\n\n    case 0x30:\t/* CLOCK_CTRL */\n\n    case 0x34:\t/* SOFT_REQ */\n\n    case 0x38:\t/* COUNTER_32_FIQ */\n\n    case 0x3c:\t/* DPLL_CTRL */\n\n    case 0x40:\t/* STATUS_REQ */\n\n        /* XXX: check clk::usecount state for every clock */\n\n    case 0x48:\t/* LOCL_TIME */\n\n    case 0x4c:\t/* APLL_CTRL */\n\n    case 0x50:\t/* POWER_CTRL */\n\n        return s->ulpd_pm_regs[addr >> 2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1731, "prediction": "0", "true_label": "0", "raw_text": "Question: static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1732, "prediction": "0", "true_label": "0", "raw_text": "Question: static void visitor_output_setup_internal(TestOutputVisitorData *data,\n\n                                          bool human)\n\n{\n\n    data->human = human;\n\n    data->sov = string_output_visitor_new(human);\n\n    g_assert(data->sov);\n\n    data->ov = string_output_get_visitor(data->sov);\n\n    g_assert(data->ov);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1733, "prediction": "0", "true_label": "0", "raw_text": "Question: static int get_riff(AVFormatContext *s, AVIOContext *pb)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    char header[8];\n\n    int i;\n\n\n\n    /* check RIFF header */\n\n    avio_read(pb, header, 4);\n\n    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */\n\n    avi->riff_end += avio_tell(pb); /* RIFF chunk end */\n\n    avio_read(pb, header+4, 4);\n\n\n\n    for(i=0; avi_headers[i][0]; i++)\n\n        if(!memcmp(header, avi_headers[i], 8))\n\n            break;\n\n    if(!avi_headers[i][0])\n\n        return -1;\n\n\n\n    if(header[7] == 0x19)\n\n        av_log(s, AV_LOG_INFO, \"This file has been generated by a totally broken muxer.\\n\");\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1734, "prediction": "0", "true_label": "1", "raw_text": "Question: _eth_get_rss_ex_src_addr(const struct iovec *pkt, int pkt_frags,\n\n                        size_t dsthdr_offset,\n\n                        struct ip6_ext_hdr *ext_hdr,\n\n                        struct in6_address *src_addr)\n\n{\n\n    size_t bytes_left = (ext_hdr->ip6r_len + 1) * 8 - sizeof(*ext_hdr);\n\n    struct ip6_option_hdr opthdr;\n\n    size_t opt_offset = dsthdr_offset + sizeof(*ext_hdr);\n\n\n\n    while (bytes_left > sizeof(opthdr)) {\n\n        size_t input_size = iov_size(pkt, pkt_frags);\n\n        size_t bytes_read, optlen;\n\n\n\n        if (input_size < opt_offset) {\n\n            return false;\n\n        }\n\n\n\n        bytes_read = iov_to_buf(pkt, pkt_frags, opt_offset,\n\n                                &opthdr, sizeof(opthdr));\n\n\n\n        if (bytes_read != sizeof(opthdr)) {\n\n            return false;\n\n        }\n\n\n\n        optlen = (opthdr.type == IP6_OPT_PAD1) ? 1\n\n                                               : (opthdr.len + sizeof(opthdr));\n\n\n\n        if (optlen > bytes_left) {\n\n            return false;\n\n        }\n\n\n\n        if (opthdr.type == IP6_OPT_HOME) {\n\n            size_t input_size = iov_size(pkt, pkt_frags);\n\n\n\n            if (input_size < opt_offset + sizeof(opthdr)) {\n\n                return false;\n\n            }\n\n\n\n            bytes_read = iov_to_buf(pkt, pkt_frags,\n\n                                    opt_offset + sizeof(opthdr),\n\n                                    src_addr, sizeof(*src_addr));\n\n\n\n            return bytes_read == sizeof(src_addr);\n\n        }\n\n\n\n        opt_offset += optlen;\n\n        bytes_left -= optlen;\n\n    }\n\n\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1735, "prediction": "0", "true_label": "0", "raw_text": ";\n\n  vector signed   short Y,U,V;\n\n  vector signed   short vx,ux,uvx;\n\n  vector signed   short R0,G0,B0,R1,G1,B1;\n\n  vector unsigned char  R,G,B;\n\n  vector unsigned char *out;\n\n  ubyte *img;\n\n\n\n  img = in[0];\n\n  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);\n\n\n\n  for (i=0;i<h;i++) {\n\n    for (j=0;j<w/16;j++) {\n\n      uyvy = vec_ld (0, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);\n\n\n\n      uyvy = vec_ld (16, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);\n\n\n\n      R  = vec_packclp (R0,R1);\n\n      G  = vec_packclp (G0,G1);\n\n      B  = vec_packclp (B0,B1);\n\n\n\n      //      vec_mstbgr24 (R,G,B, out);\n\n      out_rgba (R,G,B,out);\n\n\n\n      img += 32;\n\n    }\n\n  }\n\n  return srcSliceH;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1736, "prediction": "0", "true_label": "0", "raw_text": "Question: static void inc_refcounts(BlockDriverState *bs,\n\n                          BdrvCheckResult *res,\n\n                          uint16_t *refcount_table,\n\n                          int refcount_table_size,\n\n                          int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0)\n\n        return;\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1737, "prediction": "0", "true_label": "0", "raw_text": "Question: void stw_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t v = tswap16(val);\n\n    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1738, "prediction": "0", "true_label": "0", "raw_text": " MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                int l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1739, "prediction": "0", "true_label": "0", "raw_text": "Question: void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1740, "prediction": "0", "true_label": "0", "raw_text": "Question: void scsi_req_abort(SCSIRequest *req, int status)\n\n{\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->ops->cancel_io) {\n\n        req->ops->cancel_io(req);\n\n    }\n\n    scsi_req_complete(req, status);\n\n    scsi_req_unref(req);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1741, "prediction": "0", "true_label": "0", "raw_text": "Question: rdt_free_extradata (PayloadContext *rdt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_STREAMS; i++)\n\n        if (rdt->rmst[i]) {\n\n            ff_rm_free_rmstream(rdt->rmst[i]);\n\n            av_freep(&rdt->rmst[i]);\n\n        }\n\n    if (rdt->rmctx)\n\n        av_close_input_stream(rdt->rmctx);\n\n    av_freep(&rdt->mlti_data);\n\n    av_free(rdt);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1742, "prediction": "0", "true_label": "0", "raw_text": "pi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    /*\n\n                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                        Rewrite to take IRQ from TPM device model and\n\n                        fix default IRQ value there to use some unused IRQ\n\n                     */\n\n                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1743, "prediction": "0", "true_label": "0", "raw_text": "x80;\n\n        break;\n\n    case EXCP_FIQ:\n\n    case EXCP_VFIQ:\n\n        addr += 0x100;\n\n        break;\n\n    case EXCP_SEMIHOST:\n\n        qemu_log_mask(CPU_LOG_INT,\n\n                      \"...handling as semihosting call 0x%\" PRIx64 \"\\n\",\n\n                      env->xregs[0]);\n\n        env->xregs[0] = do_arm_semihosting(env);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n    }\n\n\n\n    if (is_a64(env)) {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);\n\n        aarch64_save_sp(env, arm_current_el(env));\n\n        env->elr_el[new_el] = env->pc;\n\n    } else {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);\n\n        if (!env->thumb) {\n\n            env->cp15.esr_el[new_el] |= 1 << 25;\n\n        }\n\n        env->elr_el[new_el] = env->regs[15];\n\n\n\n        aarch64_sync_32_to_64(env);\n\n\n\n        env->condexec_bits = 0;\n\n    }\n\n    qemu_log_mask(CPU_LOG_INT, \"...with ELR 0x%\" PRIx64 \"\\n\",\n\n                  env->elr_el[new_el]);\n\n\n\n    pstate_write(env, PSTATE_DAIF | new_mode);\n\n    env->aarch64 = 1;\n\n    aarch64_restore_sp(env, new_el);\n\n\n\n    env->pc = addr;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\",\n\n                  new_el, env->pc, pstate_read(env));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1744, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool pc_machine_get_nvdimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->nvdimm;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1745, "prediction": "1", "true_label": "0", "raw_text": "Question: build_header(GArray *linker, GArray *table_data,\n\n             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n\n             const char *oem_table_id)\n\n{\n\n    memcpy(&h->signature, sig, 4);\n\n    h->length = cpu_to_le32(len);\n\n    h->revision = rev;\n\n    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n\n\n\n    if (oem_table_id) {\n\n        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n\n    } else {\n\n        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n\n        memcpy(h->oem_table_id + 4, sig, 4);\n\n    }\n\n\n\n    h->oem_revision = cpu_to_le32(1);\n\n    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n\n    h->asl_compiler_revision = cpu_to_le32(1);\n\n    h->checksum = 0;\n\n    /* Checksum to be filled in by Guest linker */\n\n    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,\n\n                                    table_data->data, h, len, &h->checksum);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1746, "prediction": "0", "true_label": "0", "raw_text": "Question: static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n\n{\n\n    int v;\n\n    int i = 0;\n\n    uint8_t state[CONTEXT_SIZE];\n\n\n\n    memset(state, 128, sizeof(state));\n\n\n\n    for (v = 0; i < 128; v++) {\n\n        unsigned len = get_symbol(c, state, 0) + 1;\n\n\n\n        if (len > 128 - i)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        while (len--) {\n\n            quant_table[i] = scale * v;\n\n            i++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < 128; i++)\n\n        quant_table[256 - i] = -quant_table[i];\n\n    quant_table[128] = -quant_table[127];\n\n\n\n    return 2 * v - 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1747, "prediction": "1", "true_label": "0", "raw_text": "Question: static int tb_unreliable(AVCodecContext *c)\n\n{\n\n    if (c->time_base.den >= 101L * c->time_base.num ||\n\n        c->time_base.den <    5L * c->time_base.num ||\n\n        // c->codec_tag == AV_RL32(\"DIVX\") ||\n\n        // c->codec_tag == AV_RL32(\"XVID\") ||\n\n        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n        c->codec_id == AV_CODEC_ID_H264)\n\n        return 1;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1748, "prediction": "0", "true_label": "1", "raw_text": ";\n\n\n\n    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);\n\n    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);\n\n    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n    s->in_buffer= s->in;\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count=\n\n        s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;\n\n    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;\n\n\n\n\n\n    if(s->rematrix)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1749, "prediction": "0", "true_label": "1", "raw_text": "->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames\n\n    s->flags= avctx->flags;\n\n    if (MPV_common_init(s) < 0) return -1;\n\n\n\n    init_vlc(&svq1_block_type, 2, 4,\n\n        &svq1_block_type_vlc[0][1], 2, 1,\n\n        &svq1_block_type_vlc[0][0], 2, 1);\n\n\n\n    init_vlc(&svq1_motion_component, 7, 33,\n\n        &mvtab[0][1], 2, 1,\n\n        &mvtab[0][0], 2, 1);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        init_vlc(&svq1_intra_multistage[i], 3, 8,\n\n            &svq1_intra_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_intra_multistage_vlc[i][0][0], 2, 1);\n\n        init_vlc(&svq1_inter_multistage[i], 3, 8,\n\n            &svq1_inter_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_inter_multistage_vlc[i][0][0], 2, 1);\n\n    }\n\n\n\n    init_vlc(&svq1_intra_mean, 8, 256,\n\n        &svq1_intra_mean_vlc[0][1], 4, 2,\n\n        &svq1_intra_mean_vlc[0][0], 4, 2);\n\n\n\n    init_vlc(&svq1_inter_mean, 9, 512,\n\n        &svq1_inter_mean_vlc[0][1], 4, 2,\n\n        &svq1_inter_mean_vlc[0][0], 4, 2);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1750, "prediction": "0", "true_label": "1", "raw_text": "\n\n            }\n\n            break;\n\n        default:\n\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n\n        }\n\n        if (ast->deint_id == DEINT_ID_INT4 ||\n\n            ast->deint_id == DEINT_ID_GENR ||\n\n            ast->deint_id == DEINT_ID_SIPR) {\n\n            if (st->codec->block_align <= 0 ||\n\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n\n                ast->audio_framesize * sub_packet_h < st->codec->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n        switch (ast->deint_id) {\n\n        case DEINT_ID_INT4:\n\n            if (ast->coded_framesize > ast->audio_framesize ||\n\n                sub_packet_h <= 1 ||\n\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_GENR:\n\n            if (ast->sub_packet_size <= 0 ||\n\n                ast->sub_packet_size > ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_SIPR:\n\n        case DEINT_ID_INT0:\n\n        case DEINT_ID_VBRS:\n\n        case DEINT_ID_VBRF:\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown interleaver %X\\n\", ast->deint_id);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (read_all) {\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            rm_read_metadata(s, 0);\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1751, "prediction": "0", "true_label": "1", "raw_text": "\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_LGPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU Lesser General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#else\n\n    \"%s is free software; you can redistribute it and/or\\n\"\n\n    \"modify it under the terms of the GNU Lesser General Public\\n\"\n\n    \"License as published by the Free Software Foundation; either\\n\"\n\n    \"version 2.1 of the License, or (at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\"\n\n    \"Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public\\n\"\n\n    \"License along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#endif\n\n    );\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1752, "prediction": "0", "true_label": "1", "raw_text": " RTP/RTCP dummy packets are used for RDT, too.\n\n             */\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n\n                CONFIG_RTPDEC)\n\n                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);\n\n            break;\n\n        }\n\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n\n            char url[1024], namebuf[50], optbuf[20] = \"\";\n\n            struct sockaddr_storage addr;\n\n            int port, ttl;\n\n\n\n            if (reply->transports[0].destination.ss_family) {\n\n                addr      = reply->transports[0].destination;\n\n                port      = reply->transports[0].port_min;\n\n                ttl       = reply->transports[0].ttl;\n\n            } else {\n\n                addr      = rtsp_st->sdp_ip;\n\n                port      = rtsp_st->sdp_port;\n\n                ttl       = rtsp_st->sdp_ttl;\n\n            }\n\n            if (ttl > 0)\n\n                snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl);\n\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n\n                        port, \"%s\", optbuf);\n\n            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,\n\n                           &s->interrupt_callback, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            break;\n\n        }\n\n        }\n\n\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n\n            goto fail;\n\n    }\n\n\n\n    if (reply->timeout > 0)\n\n        rt->timeout = reply->timeout;\n\n\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n\n        rt->need_subscription = 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    ff_rtsp_undo_setup(s);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1753, "prediction": "0", "true_label": "0", "raw_text": "Question: static int parse_fmtp(AVFormatContext *s,\n\n                      AVStream *stream, PayloadContext *data,\n\n                      const char *attr, const char *value)\n\n{\n\n    AVCodecParameters *par = stream->codecpar;\n\n    int res, i;\n\n\n\n    if (!strcmp(attr, \"config\")) {\n\n        res = parse_fmtp_config(par, value);\n\n\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (par->codec_id == AV_CODEC_ID_AAC) {\n\n        /* Looking for a known attribute */\n\n        for (i = 0; attr_names[i].str; ++i) {\n\n            if (!av_strcasecmp(attr, attr_names[i].str)) {\n\n                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {\n\n                    *(int *)((char *)data+\n\n                        attr_names[i].offset) = atoi(value);\n\n                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)\n\n                    *(char **)((char *)data+\n\n                        attr_names[i].offset) = av_strdup(value);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1754, "prediction": "0", "true_label": "0", "raw_text": "Question: static int ffserver_set_int_param(int *dest, const char *value, int factor,\n\n                                  int min, int max, FFServerConfig *config,\n\n                                  const char *error_msg, ...)\n\n{\n\n    int tmp;\n\n    char *tailp;\n\n    if (!value || !value[0])\n\n        goto error;\n\n    errno = 0;\n\n    tmp = strtol(value, &tailp, 0);\n\n    if (tmp < min || tmp > max)\n\n        goto error;\n\n    if (factor) {\n\n        if (FFABS(tmp) > INT_MAX / FFABS(factor))\n\n            goto error;\n\n        tmp *= factor;\n\n    }\n\n    if (tailp[0] || errno)\n\n        goto error;\n\n    if (dest)\n\n        *dest = tmp;\n\n    return 0;\n\n  error:\n\n    if (config) {\n\n        va_list vl;\n\n        va_start(vl, error_msg);\n\n        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, error_msg, vl);\n\n        va_end(vl);\n\n    }\n\n    return AVERROR(EINVAL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1755, "prediction": "0", "true_label": "0", "raw_text": "Question: static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n\n{\n\n    unsigned int tag;\n\n    int64_t size;\n\n\n\n    for (;;) {\n\n        if (url_feof(pb))\n\n            return AVERROR_EOF;\n\n        size = next_tag(pb, &tag);\n\n        if (tag == tag1)\n\n            break;\n\n        wav_seek_tag(pb, size, SEEK_CUR);\n\n    }\n\n    return size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1756, "prediction": "0", "true_label": "0", "raw_text": "Question: av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_6REGS && HAVE_INLINE_ASM\n\n    if (INLINE_AMD3DNOWEXT(cpu_flags)) {\n\n        fdsp->vector_fmul_window  = vector_fmul_window_3dnowext;\n\n    }\n\n    if (INLINE_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul_window = vector_fmul_window_sse;\n\n    }\n\n#endif\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_sse;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;\n\n        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_sse;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;\n\n        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;\n\n        fdsp->butterflies_float   = ff_butterflies_float_sse;\n\n    }\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;\n\n    }\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_avx;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_avx;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1757, "prediction": "0", "true_label": "1", "raw_text": " 2) & 1;\n\n\n\n    case 0x14:\t/* INTC_SYSSTATUS */\n\n        return 1;\t\t\t\t\t\t/* RESETDONE */\n\n\n\n    case 0x40:\t/* INTC_SIR_IRQ */\n\n        return s->sir_intr[0];\n\n\n\n    case 0x44:\t/* INTC_SIR_FIQ */\n\n        return s->sir_intr[1];\n\n\n\n    case 0x48:\t/* INTC_CONTROL */\n\n        return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */\n\n\n\n    case 0x4c:\t/* INTC_PROTECTION */\n\n\n\n\n    case 0x50:\t/* INTC_IDLE */\n\n        return s->autoidle & 3;\n\n\n\n    /* Per-bank registers */\n\n    case 0x80:\t/* INTC_ITR */\n\n        return bank->inputs;\n\n\n\n    case 0x84:\t/* INTC_MIR */\n\n        return bank->mask;\n\n\n\n    case 0x88:\t/* INTC_MIR_CLEAR */\n\n    case 0x8c:\t/* INTC_MIR_SET */\n\n\n\n\n    case 0x90:\t/* INTC_ISR_SET */\n\n        return bank->swi;\n\n\n\n    case 0x94:\t/* INTC_ISR_CLEAR */\n\n\n\n\n    case 0x98:\t/* INTC_PENDING_IRQ */\n\n        return bank->irqs & ~bank->mask & ~bank->fiq;\n\n\n\n    case 0x9c:\t/* INTC_PENDING_FIQ */\n\n        return bank->irqs & ~bank->mask & bank->fiq;\n\n\n\n    /* Per-line registers */\n\n    case 0x100 ... 0x300:\t/* INTC_ILR */\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        return (bank->priority[line_no] << 2) |\n\n                ((bank->fiq >> line_no) & 1);\n\n    }\n\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1758, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)\n\n{\n\n    *range = 8 * (1 << (f_code - 1));\n\n    /* XXX: temporary kludge to avoid overflow for msmpeg4 */\n\n    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)\n\n\t*range *= 2;\n\n\n\n    if (s->unrestricted_mv) {\n\n        *xmin = -16;\n\n        *ymin = -16;\n\n        if (s->h263_plus)\n\n            *range *= 2;\n\n        if(s->avctx->codec->id!=CODEC_ID_MPEG4){\n\n            *xmax = s->mb_width*16;\n\n            *ymax = s->mb_height*16;\n\n        }else {\n\n            *xmax = s->width;\n\n            *ymax = s->height;\n\n        }\n\n    } else {\n\n        *xmin = 0;\n\n        *ymin = 0;\n\n        *xmax = s->mb_width*16 - 16;\n\n        *ymax = s->mb_height*16 - 16;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1759, "prediction": "0", "true_label": "0", "raw_text": " ret = device_init(ctx, width, height, *desired_format);\n\n        if (ret < 0) {\n\n            *desired_format = 0;\n\n            if (ret != AVERROR(EINVAL))\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    if (!*desired_format) {\n\n        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n\n            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||\n\n                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {\n\n                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",\n\n                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),\n\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));\n\n\n\n                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;\n\n                ret = device_init(ctx, width, height, *desired_format);\n\n                if (ret >= 0)\n\n                    break;\n\n                else if (ret != AVERROR(EINVAL))\n\n                    return ret;\n\n                *desired_format = 0;\n\n            }\n\n        }\n\n\n\n        if (*desired_format == 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"\n\n                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",\n\n                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,\n\n                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    *codec_id = avpriv_fmt_v4l2codec(*desired_format);\n\n    av_assert0(*codec_id != AV_CODEC_ID_NONE);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1760, "prediction": "0", "true_label": "1", "raw_text": "\n\n    s->ctest2 = LSI_CTEST2_DACK;\n\n    s->ctest3 = 0;\n\n    s->ctest4 = 0;\n\n    s->ctest5 = 0;\n\n    s->ccntl0 = 0;\n\n    s->ccntl1 = 0;\n\n    s->dsp = 0;\n\n    s->dsps = 0;\n\n    s->dmode = 0;\n\n    s->dcntl = 0;\n\n    s->scntl0 = 0xc0;\n\n    s->scntl1 = 0;\n\n    s->scntl2 = 0;\n\n    s->scntl3 = 0;\n\n    s->sstat0 = 0;\n\n    s->sstat1 = 0;\n\n    s->scid = 7;\n\n    s->sxfer = 0;\n\n    s->socl = 0;\n\n    s->sdid = 0;\n\n    s->ssid = 0;\n\n    s->stest1 = 0;\n\n    s->stest2 = 0;\n\n    s->stest3 = 0;\n\n    s->sidl = 0;\n\n    s->stime0 = 0;\n\n    s->respid0 = 0x80;\n\n    s->respid1 = 0;\n\n    s->mmrs = 0;\n\n    s->mmws = 0;\n\n    s->sfs = 0;\n\n    s->drs = 0;\n\n    s->sbms = 0;\n\n    s->dbms = 0;\n\n    s->dnad64 = 0;\n\n    s->pmjad1 = 0;\n\n    s->pmjad2 = 0;\n\n    s->rbc = 0;\n\n    s->ua = 0;\n\n    s->ia = 0;\n\n    s->sbc = 0;\n\n    s->csbc = 0;\n\n    s->sbr = 0;\n\n    while (!QTAILQ_EMPTY(&s->queue)) {\n\n        p = QTAILQ_FIRST(&s->queue);\n\n        QTAILQ_REMOVE(&s->queue, p, next);\n\n        g_free(p);\n\n    }\n\n    if (s->current) {\n\n        g_free(s->current);\n\n        s->current = NULL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1761, "prediction": "0", "true_label": "1", "raw_text": "Question: static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n\n{\n\n    int ich, i;\n\n    int order        = s->mclms_order;\n\n    int num_channels = s->num_channels;\n\n\n\n    for (ich = 0; ich < num_channels; ich++) {\n\n        pred[ich] = 0;\n\n        if (!s->is_channel_coded[ich])\n\n            continue;\n\n        for (i = 0; i < order * num_channels; i++)\n\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n\n                         s->mclms_coeffs[i + order * num_channels * ich];\n\n        for (i = 0; i < ich; i++)\n\n            pred[ich] += s->channel_residues[i][icoef] *\n\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n\n        pred[ich] += 1 << s->mclms_scaling - 1;\n\n        pred[ich] >>= s->mclms_scaling;\n\n        s->channel_residues[ich][icoef] += pred[ich];\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1762, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs = vd->clients;\n\n    while (vs != NULL) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        else /* TODO */\n\n            vnc_update(vs, dst_x, dst_y, w, h);\n\n        vs = vs->next;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1763, "prediction": "0", "true_label": "1", "raw_text": "Question: static int emulated_exitfn(CCIDCardState *base)\n\n{\n\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n\n\n\n    vevent_queue_vevent(vevent); /* stop vevent thread */\n\n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n\n    card->quit_apdu_thread = 1; /* stop handle_apdu thread */\n\n    qemu_cond_signal(&card->handle_apdu_cond);\n\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n\n                      &card->apdu_thread_quit_mutex);\n\n    /* handle_apdu thread stopped, can destroy all of it's mutexes */\n\n    qemu_cond_destroy(&card->handle_apdu_cond);\n\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n\n    qemu_mutex_destroy(&card->vreader_mutex);\n\n    qemu_mutex_destroy(&card->event_list_mutex);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1764, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1765, "prediction": "0", "true_label": "1", "raw_text": "\n\n        }\n\n        if (ps->enable_icc){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (ps->icc_par[ps->num_env][b] > 7U) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"icc_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        ps->num_env++;\n\n        ps->border_position[ps->num_env] = numQMFSlots - 1;\n\n    }\n\n\n\n\n\n    ps->is34bands_old = ps->is34bands;\n\n    if (!PS_BASELINE && (ps->enable_iid || ps->enable_icc))\n\n        ps->is34bands = (ps->enable_iid && ps->nr_iid_par == 34) ||\n\n                        (ps->enable_icc && ps->nr_icc_par == 34);\n\n\n\n    //Baseline\n\n    if (!ps->enable_ipdopd) {\n\n        memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n        memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    }\n\n\n\n    if (header)\n\n        ps->start = 1;\n\n\n\n    bits_consumed = get_bits_count(gb) - bit_count_start;\n\n    if (bits_consumed <= bits_left) {\n\n        skip_bits_long(gb_host, bits_consumed);\n\n        return bits_consumed;\n\n    }\n\n    av_log(avctx, AV_LOG_ERROR, \"Expected to read %d PS bits actually read %d.\\n\", bits_left, bits_consumed);\n\nerr:\n\n    ps->start = 0;\n\n    skip_bits_long(gb_host, bits_left);\n\n    memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n    memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n    memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n    memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    return bits_left;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1766, "prediction": "0", "true_label": "1", "raw_text": "6le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        size = pb->buf_end - pb->buf_ptr;\n\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n\n                             .buf_size = size };\n\n        if (!pd.buf)\n\n            goto error;\n\n        memcpy(pd.buf, pb->buf_ptr, size);\n\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n\n        av_freep(&pd.buf);\n\n        if (!sub_demuxer)\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n\n\n        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);\n\n        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1767, "prediction": "0", "true_label": "1", "raw_text": "Question: void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1768, "prediction": "0", "true_label": "0", "raw_text": "Question: static int movie_request_frame(AVFilterLink *outlink)\n\n{\n\n    AVFilterBufferRef *outpicref;\n\n    MovieContext *movie = outlink->src->priv;\n\n    int ret;\n\n\n\n    if (movie->is_done)\n\n        return AVERROR_EOF;\n\n    if ((ret = movie_get_frame(outlink)) < 0)\n\n        return ret;\n\n\n\n    outpicref = avfilter_ref_buffer(movie->picref, ~0);\n\n    ff_start_frame(outlink, outpicref);\n\n    ff_draw_slice(outlink, 0, outlink->h, 1);\n\n    ff_end_frame(outlink);\n\n    avfilter_unref_buffer(movie->picref);\n\n    movie->picref = NULL;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1769, "prediction": "-1", "true_label": "1", "raw_text": " AV_LOG_TRACE, \"resource=%p\\n\", resource);\n\n    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {\n\n        reply_code = 200;\n\n    } else {\n\n        reply_code = AVERROR_HTTP_NOT_FOUND;\n\n    }\n\n    if ((ret = av_opt_set_int(client, \"reply_code\", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        av_log(client, AV_LOG_ERROR, \"Failed to set reply_code: %s.\\n\", av_err2str(ret));\n\n        goto end;\n\n    }\n\n    av_log(client, AV_LOG_TRACE, \"Set reply code to %d\\n\", reply_code);\n\n\n\n    while ((ret = avio_handshake(client)) > 0);\n\n\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    fprintf(stderr, \"Handshake performed.\\n\");\n\n    if (reply_code != 200)\n\n        goto end;\n\n    fprintf(stderr, \"Opening input file.\\n\");\n\n    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {\n\n        av_log(input, AV_LOG_ERROR, \"Failed to open input: %s: %s.\\n\", in_uri,\n\n               av_err2str(ret));\n\n        goto end;\n\n    }\n\n    for(;;) {\n\n        n = avio_read(input, buf, sizeof(buf));\n\n        if (n < 0) {\n\n            if (n == AVERROR_EOF)\n\n                break;\n\n            av_log(input, AV_LOG_ERROR, \"Error reading from input: %s.\\n\",\n\n                   av_err2str(n));\n\n            break;\n\n        }\n\n        avio_write(client, buf, n);\n\n        avio_flush(client);\n\n    }\n\nend:\n\n    fprintf(stderr, \"Flushing client\\n\");\n\n    avio_flush(client);\n\n    fprintf(stderr, \"Closing client\\n\");\n\n    avio_close(client);\n\n    fprintf(stderr, \"Closing input\\n\");\n\n    avio_close(input);\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1770, "prediction": "0", "true_label": "1", "raw_text": "cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n\n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                if(ref0 >= 0)\n\n                    ref0 = h->map_col_to_list0[0][ref0];\n\n                else{\n\n                    ref0 = h->map_col_to_list0[1][l1ref1[x8 + y8*h->b8_stride]];\n\n                    l1mv= l1mv1;\n\n                }\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1771, "prediction": "0", "true_label": "0", "raw_text": " opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     */\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* From here on only known autoclear feature bits are valid */\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* If image was not closed cleanly, check consistency */\n\n    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {\n\n        /* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         */\n\n        if (!bdrv_is_read_only(bs->file) &&\n\n            !(flags & BDRV_O_INCOMING)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (ret) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1772, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_8w_msa(src - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 8);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1773, "prediction": "0", "true_label": "0", "raw_text": "Question: static CharDriverState *qemu_chr_open_pipe(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    ChardevHostdev *opts = backend->u.pipe;\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_new0(WinCharState, 1);\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename, errp) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1774, "prediction": "1", "true_label": "0", "raw_text": "Question: uint32_t HELPER(clz)(uint32_t x)\n\n{\n\n    int count;\n\n    for (count = 32; x; count--)\n\n        x >>= 1;\n\n    return count;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1775, "prediction": "0", "true_label": "0", "raw_text": ";\n\n        info->sps[1].enc[0].pte_enc = 0;\n\n    } else {\n\n        int i = 0;\n\n\n\n        /* HV KVM has backing store size restrictions */\n\n        info->flags = KVM_PPC_PAGE_SIZES_REAL;\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            info->flags |= KVM_PPC_1T_SEGMENTS;\n\n        }\n\n\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->slb_size = 32;\n\n        } else {\n\n            info->slb_size = 64;\n\n        }\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[i].page_shift = 12;\n\n        info->sps[i].slb_enc = 0;\n\n        info->sps[i].enc[0].page_shift = 12;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n        i++;\n\n\n\n        /* 64K on MMU 2.06 and later */\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->sps[i].page_shift = 16;\n\n            info->sps[i].slb_enc = 0x110;\n\n            info->sps[i].enc[0].page_shift = 16;\n\n            info->sps[i].enc[0].pte_enc = 1;\n\n            i++;\n\n        }\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[i].page_shift = 24;\n\n        info->sps[i].slb_enc = SLB_VSID_L;\n\n        info->sps[i].enc[0].page_shift = 24;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1776, "prediction": "0", "true_label": "0", "raw_text": "Question: void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1777, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* The memory barrier implicit in atomic_xchg makes sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    if (atomic_xchg(&bh->scheduled, 1) == 0) {\n\n        aio_notify(ctx);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1778, "prediction": "0", "true_label": "0", "raw_text": "Question: static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)\n\n{\n\n    SpiceTimer *timer;\n\n\n\n    timer = qemu_mallocz(sizeof(*timer));\n\n    timer->timer = qemu_new_timer(rt_clock, func, opaque);\n\n    QTAILQ_INSERT_TAIL(&timers, timer, next);\n\n    return timer;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1779, "prediction": "0", "true_label": "0", "raw_text": "Question: static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->users == 0) {\n\n        ret = kvm_irqchip_add_msi_route(kvm_state, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        irqfd->virq = ret;\n\n    }\n\n    irqfd->users++;\n\n\n\n    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);\n\n    if (ret < 0) {\n\n        if (--irqfd->users == 0) {\n\n            kvm_irqchip_release_virq(kvm_state, irqfd->virq);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1780, "prediction": "0", "true_label": "1", "raw_text": ":\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_ostreams; i++) {\n\n        OutputStream *ost = &ost_table[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1781, "prediction": "0", "true_label": "0", "raw_text": "\n\n                for (q = 0; q < q1 - q0; q++) {\n\n                    if (!isinf(paths[idx - 1][q].cost)) {\n\n                        paths[idx][q].cost = paths[idx - 1][q].cost + 1;\n\n                        paths[idx][q].prev = q;\n\n                        continue;\n\n                    }\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            sce->zeroes[w*16+g] = !nz;\n\n            start += sce->ics.swb_sizes[g];\n\n            idx++;\n\n        }\n\n    }\n\n    idx--;\n\n    mincost = paths[idx][0].cost;\n\n    minq    = 0;\n\n    for (i = 1; i < TRELLIS_STATES; i++) {\n\n        if (paths[idx][i].cost < mincost) {\n\n            mincost = paths[idx][i].cost;\n\n            minq = i;\n\n        }\n\n    }\n\n    while (idx) {\n\n        sce->sf_idx[bandaddr[idx]] = minq + q0;\n\n        minq = paths[idx][minq].prev;\n\n        idx--;\n\n    }\n\n    //set the same quantizers inside window groups\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])\n\n        for (g = 0;  g < sce->ics.num_swb; g++)\n\n            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)\n\n                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1782, "prediction": "0", "true_label": "0", "raw_text": "Question: static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)\n\n{\n\n    int ret = -EIO;\n\n\n\n    /* Add footer to total size */\n\n    total_size += 512;\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n    if (lseek(fd, -512, SEEK_END) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1783, "prediction": "0", "true_label": "0", "raw_text": "Question: static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1784, "prediction": "0", "true_label": "0", "raw_text": ") &&\n\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n\n\n\n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n\n                            vs->clientds.pf.gshift > 7 &&\n\n                            vs->clientds.pf.bshift > 7);\n\n\n\n        if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n\n            if (be) {\n\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n\n          }\n\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n\n            if (be) {\n\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n    }\n\n    break;\n\n    }\n\n\n\n    vnc_zrle_stop(vs);\n\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n\n    vnc_write_u32(vs, bytes);\n\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1785, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n    MMIOState *s= opaque;\n\n    return ide_status_read(&s->bus, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1786, "prediction": "0", "true_label": "0", "raw_text": "Question: void tlb_flush_page(CPUState *env, target_ulong addr)\n\n{\n\n    int i;\n\n\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_flush_page: \" TARGET_FMT_lx \"\\n\", addr);\n\n#endif\n\n    /* must reset current TB so that interrupts cannot modify the\n\n       links while we are modifying them */\n\n    env->current_tb = NULL;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    tlb_flush_entry(&env->tlb_table[0][i], addr);\n\n    tlb_flush_entry(&env->tlb_table[1][i], addr);\n\n#if (NB_MMU_MODES >= 3)\n\n    tlb_flush_entry(&env->tlb_table[2][i], addr);\n\n#if (NB_MMU_MODES == 4)\n\n    tlb_flush_entry(&env->tlb_table[3][i], addr);\n\n#endif\n\n#endif\n\n\n\n    tlb_flush_jmp_cache(env, addr);\n\n\n\n#ifdef USE_KQEMU\n\n    if (env->kqemu_enabled) {\n\n        kqemu_flush_page(env, addr);\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1787, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_slice_thread_free(AVCodecContext *avctx)\n\n{\n\n    ThreadContext *c = avctx->thread_opaque;\n\n    int i;\n\n\n\n    pthread_mutex_lock(&c->current_job_lock);\n\n    c->done = 1;\n\n    pthread_cond_broadcast(&c->current_job_cond);\n\n    pthread_mutex_unlock(&c->current_job_lock);\n\n\n\n    for (i=0; i<avctx->thread_count; i++)\n\n         pthread_join(c->workers[i], NULL);\n\n\n\n    pthread_mutex_destroy(&c->current_job_lock);\n\n    pthread_cond_destroy(&c->current_job_cond);\n\n    pthread_cond_destroy(&c->last_job_cond);\n\n    av_free(c->workers);\n\n    av_freep(&avctx->thread_opaque);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1788, "prediction": "0", "true_label": "1", "raw_text": "Question: static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1789, "prediction": "0", "true_label": "1", "raw_text": "mds = g_new0(BlkMigDevState, 1);\n\n        bmds->blk = blk_new(BLK_PERM_CONSISTENT_READ, BLK_PERM_ALL);\n\n        bmds->blk_name = g_strdup(bdrv_get_device_name(bs));\n\n        bmds->bulk_completed = 0;\n\n        bmds->total_sectors = sectors;\n\n        bmds->completed_sectors = 0;\n\n        bmds->shared_base = migrate_use_block_incremental();\n\n\n\n        assert(i < num_bs);\n\n        bmds_bs[i].bmds = bmds;\n\n        bmds_bs[i].bs = bs;\n\n\n\n        block_mig_state.total_sector_sum += sectors;\n\n\n\n        if (bmds->shared_base) {\n\n            DPRINTF(\"Start migration for %s with shared base image\\n\",\n\n                    bdrv_get_device_name(bs));\n\n        } else {\n\n            DPRINTF(\"Start full migration for %s\\n\", bdrv_get_device_name(bs));\n\n        }\n\n\n\n        QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n    }\n\n\n\n    /* Can only insert new BDSes now because doing so while iterating block\n\n     * devices may end up in a deadlock (iterating the new BDSes, too). */\n\n    for (i = 0; i < num_bs; i++) {\n\n        BlkMigDevState *bmds = bmds_bs[i].bmds;\n\n        BlockDriverState *bs = bmds_bs[i].bs;\n\n\n\n        if (bmds) {\n\n            ret = blk_insert_bs(bmds->blk, bs, &local_err);\n\n            if (ret < 0) {\n\n                error_report_err(local_err);\n\n                goto out;\n\n            }\n\n\n\n            alloc_aio_bitmap(bmds);\n\n            error_setg(&bmds->blocker, \"block device is in use by migration\");\n\n            bdrv_op_block_all(bs, bmds->blocker);\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    g_free(bmds_bs);\n\n    return ret;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1790, "prediction": "0", "true_label": "1", "raw_text": "Question: static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1791, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_dispatch_cmd_failure(void)\n\n{\n\n    QDict *req = qdict_new();\n\n\n    QObject *resp;\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n\n\n    /* check that with extra arguments it throws an error */\n\n    req = qdict_new();\n\n    qdict_put(args, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args);\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1792, "prediction": "0", "true_label": "0", "raw_text": "Question: static void add_index_entry(AVStream *st,\n\n                            int64_t pos, int64_t timestamp, int flags)\n\n{\n\n    AVIndexEntry *entries, *ie;\n\n    \n\n    entries = av_fast_realloc(st->index_entries,\n\n                              &st->index_entries_allocated_size,\n\n                              (st->nb_index_entries + 1) * \n\n                              sizeof(AVIndexEntry));\n\n    if (entries) {\n\n        st->index_entries = entries;\n\n        ie = &entries[st->nb_index_entries++];\n\n        ie->pos = pos;\n\n        ie->timestamp = timestamp;\n\n        ie->flags = flags;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1793, "prediction": "0", "true_label": "1", "raw_text": " get_slice_offset(avctx, slices_hdr, i);\n\n        int size, size2;\n\n\n\n        if (offset >= buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (i + 1 == slice_count)\n\n            size = buf_size - offset;\n\n        else\n\n            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;\n\n\n\n        if (i + 2 >= slice_count)\n\n            size2 = buf_size - offset;\n\n        else\n\n            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;\n\n\n\n        if (size <= 0 || size2 <= 0 ||\n\n            offset + FFMAX(size, size2) > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)\n\n            return ret;\n\n\n\n        if (ret > 8 * size)\n\n            i++;\n\n    }\n\n\n\n    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {\n\n        ff_er_frame_end(&s->er);\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            if ((ret = av_frame_ref(pict, &s->current_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            if ((ret = av_frame_ref(pict, &s->last_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->last_picture_ptr);\n\n        }\n\n\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *got_frame = 1;\n\n        }\n\n\n\n        // so we can detect if frame_end was not called (find some nicer solution...)\n\n        s->current_picture_ptr = NULL;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1794, "prediction": "0", "true_label": "1", "raw_text": "codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(st->codec, AV_LOG_ERROR, \"Unsupported video codec\\n\");\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n//        av_log(s, AV_LOG_DEBUG, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,\n\n                  0x10000, fps, (1 << 30) - 1);\n\n        st->avg_frame_rate = st->r_frame_rate;\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1795, "prediction": "0", "true_label": "1", "raw_text": "Question: static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1796, "prediction": "1", "true_label": "0", "raw_text": "Question: QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1797, "prediction": "0", "true_label": "0", "raw_text": "Question: void kqemu_record_dump(void)\n\n{\n\n    PCRecord **pr, *r;\n\n    int i, h;\n\n    FILE *f;\n\n    int64_t total, sum;\n\n\n\n    pr = malloc(sizeof(PCRecord *) * nb_pc_records);\n\n    i = 0;\n\n    total = 0;\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {\n\n            pr[i++] = r;\n\n            total += r->count;\n\n        }\n\n    }\n\n    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);\n\n\n\n    f = fopen(\"/tmp/kqemu.stats\", \"w\");\n\n    if (!f) {\n\n        perror(\"/tmp/kqemu.stats\");\n\n        exit(1);\n\n    }\n\n    fprintf(f, \"total: %\" PRId64 \"\\n\", total);\n\n    sum = 0;\n\n    for(i = 0; i < nb_pc_records; i++) {\n\n        r = pr[i];\n\n        sum += r->count;\n\n        fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\",\n\n                r->pc,\n\n                r->count,\n\n                (double)r->count / (double)total * 100.0,\n\n                (double)sum / (double)total * 100.0);\n\n    }\n\n    fclose(f);\n\n    free(pr);\n\n\n\n    kqemu_record_flush();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1798, "prediction": "0", "true_label": "0", "raw_text": " }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1799, "prediction": "-1", "true_label": "0", "raw_text": "Question: static void nbd_reply_ready(void *opaque)\n\n{\n\n    NbdClientSession *s = opaque;\n\n    uint64_t i;\n\n    int ret;\n\n\n\n    if (s->reply.handle == 0) {\n\n        /* No reply already in flight.  Fetch a header.  It is possible\n\n         * that another thread has done the same thing in parallel, so\n\n         * the socket is not readable anymore.\n\n         */\n\n        ret = nbd_receive_reply(s->sock, &s->reply);\n\n        if (ret == -EAGAIN) {\n\n            return;\n\n        }\n\n        if (ret < 0) {\n\n            s->reply.handle = 0;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* There's no need for a mutex on the receive side, because the\n\n     * handler acts as a synchronization point and ensures that only\n\n     * one coroutine is called until the reply finishes.  */\n\n    i = HANDLE_TO_INDEX(s, s->reply.handle);\n\n    if (i >= MAX_NBD_REQUESTS) {\n\n        goto fail;\n\n    }\n\n\n\n    if (s->recv_coroutine[i]) {\n\n        qemu_coroutine_enter(s->recv_coroutine[i], NULL);\n\n        return;\n\n    }\n\n\n\nfail:\n\n    nbd_teardown_connection(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1800, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ffm_write_data(AVFormatContext *s,\n\n                           const uint8_t *buf, int size,\n\n                           int64_t pts, int header)\n\n{\n\n    FFMContext *ffm = s->priv_data;\n\n    int len;\n\n\n\n    if (header && ffm->frame_offset == 0) {\n\n        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;\n\n        ffm->pts = pts;\n\n    }\n\n\n\n    /* write as many packets as needed */\n\n    while (size > 0) {\n\n        len = ffm->packet_end - ffm->packet_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(ffm->packet_ptr, buf, len);\n\n\n\n        ffm->packet_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        if (ffm->packet_ptr >= ffm->packet_end) {\n\n            /* special case : no pts in packet : we leave the current one */\n\n            if (ffm->pts == 0)\n\n                ffm->pts = pts;\n\n\n\n            flush_packet(s);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1801, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n\n                struct vmsvga_cursor_definition_s *c)\n\n{\n\n    QEMUCursor *qc;\n\n    int i, pixels;\n\n\n\n    qc = cursor_alloc(c->width, c->height);\n\n    qc->hot_x = c->hot_x;\n\n    qc->hot_y = c->hot_y;\n\n    switch (c->bpp) {\n\n    case 1:\n\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,\n\n                        1, (void*)c->mask);\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/mono\");\n\n#endif\n\n        break;\n\n    case 32:\n\n        /* fill alpha channel from mask, set color to zero */\n\n        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,\n\n                        1, (void*)c->mask);\n\n        /* add in rgb values */\n\n        pixels = c->width * c->height;\n\n        for (i = 0; i < pixels; i++) {\n\n            qc->data[i] |= c->image[i] & 0xffffff;\n\n        }\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/32bit\");\n\n#endif\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\",\n\n                __FUNCTION__, c->bpp);\n\n        cursor_put(qc);\n\n        qc = cursor_builtin_left_ptr();\n\n    }\n\n\n\n    dpy_cursor_define(s->vga.ds, qc);\n\n    cursor_put(qc);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1802, "prediction": "0", "true_label": "0", "raw_text": "Question: static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,\n\n                                          ptrdiff_t stride)\n\n{\n\n    int i;\n\n    pixel *pix = (pixel*)_pix;\n\n    const dctcoef *block = (const dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n    for(i=0; i<4; i++){\n\n        pixel v = pix[-1];\n\n        pix[0]= v += block[0];\n\n        pix[1]= v += block[1];\n\n        pix[2]= v += block[2];\n\n        pix[3]= v +  block[3];\n\n        pix+= stride;\n\n        block+= 4;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1803, "prediction": "0", "true_label": "0", "raw_text": "Question: static void set_proc_name(const char *s)\n\n{\n\n#ifdef __linux__\n\n    char name[16];\n\n    if (!s)\n\n        return;\n\n    name[sizeof(name) - 1] = 0;\n\n    strncpy(name, s, sizeof(name));\n\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n\n       This simple way is enough for `top'. */\n\n    prctl(PR_SET_NAME, name);\n\n#endif    \t\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1804, "prediction": "1", "true_label": "1", "raw_text": "Question: int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.type = NBD_CMD_FLUSH;\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1805, "prediction": "0", "true_label": "0", "raw_text": "Question: int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,\n\n                                      CL_TRUE,CL_MAP_READ, 0, buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(dst_buf, mapped, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1806, "prediction": "1", "true_label": "1", "raw_text": "Question: static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id > sc->stsd_count)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1807, "prediction": "0", "true_label": "0", "raw_text": "Question: static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,\n\n                        uint32_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    char key[5]     = { 0 };\n\n    char *value;\n\n\n\n    size += (size & 1);\n\n\n\n    if (size == UINT_MAX)\n\n        return AVERROR(EINVAL);\n\n    value = av_malloc(size + 1);\n\n    if (!value)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, value, size);\n\n    value[size] = 0;\n\n\n\n    AV_WL32(key, tag);\n\n\n\n    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,\n\n                       AV_DICT_DONT_STRDUP_VAL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1808, "prediction": "1", "true_label": "0", "raw_text": "\n\n            in[i][j+6][1] = L[1][j][i];\n\n        }\n\n    }\n\n    if (is34) {\n\n        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);\n\n        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);\n\n        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);\n\n        for (i = 0; i < 59; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+32][j][0] = L[0][j][i+5];\n\n                out[i+32][j][1] = L[1][j][i+5];\n\n            }\n\n        }\n\n    } else {\n\n        hybrid6_cx(in[0], out, f20_0_8, len);\n\n        hybrid2_re(in[1], out+6, g1_Q2, len, 1);\n\n        hybrid2_re(in[2], out+8, g1_Q2, len, 0);\n\n        for (i = 0; i < 61; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+10][j][0] = L[0][j][i+3];\n\n                out[i+10][j][1] = L[1][j][i+3];\n\n            }\n\n        }\n\n    }\n\n    //update in_buf\n\n    for (i = 0; i < 5; i++) {\n\n        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1809, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1810, "prediction": "1", "true_label": "1", "raw_text": "Question: static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes, it is a defect.\n"}], [{"ID": 1811, "prediction": "0", "true_label": "0", "raw_text": "psa = cs->kvm_run->s.regs.prefix;\n\n    }\n\n\n\n    /* One Regs */\n\n    reg.id = KVM_REG_S390_CPU_TIMER;\n\n    reg.addr = (__u64)&(env->cputm);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_CLOCK_COMP;\n\n    reg.addr = (__u64)&(env->ckc);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_TODPR;\n\n    reg.addr = (__u64)&(env->todpr);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    if (cap_async_pf) {\n\n        reg.id = KVM_REG_S390_PFTOKEN;\n\n        reg.addr = (__u64)&(env->pfault_token);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFCOMPARE;\n\n        reg.addr = (__u64)&(env->pfault_compare);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFSELECT;\n\n        reg.addr = (__u64)&(env->pfault_select);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1812, "prediction": "0", "true_label": "0", "raw_text": "Question: int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n    QemuOpts *opts;\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            /* add the device */\n\n            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n            qemu_opt_set(opts, \"driver\", p);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1813, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);\n\n    VirtQueueElement elem;\n\n    MemoryRegionSection section;\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t offset = 0;\n\n        uint32_t pfn;\n\n\n\n        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {\n\n            ram_addr_t pa;\n\n            ram_addr_t addr;\n\n            int p = virtio_ldl_p(vdev, &pfn);\n\n\n\n            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;\n\n            offset += 4;\n\n\n\n            /* FIXME: remove get_system_memory(), but how? */\n\n            section = memory_region_find(get_system_memory(), pa, 1);\n\n            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))\n\n                continue;\n\n\n\n            trace_virtio_balloon_handle_output(memory_region_name(section.mr),\n\n                                               pa);\n\n            /* Using memory_region_get_ram_ptr is bending the rules a bit, but\n\n               should be OK because we only want a single page.  */\n\n            addr = section.offset_within_region;\n\n            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,\n\n                         !!(vq == s->dvq));\n\n            memory_region_unref(section.mr);\n\n        }\n\n\n\n        virtqueue_push(vq, &elem, offset);\n\n        virtio_notify(vdev, vq);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1814, "prediction": "0", "true_label": "0", "raw_text": "_xiph_headers(headers, headers_len, 30, header_start, header_len)) < 0) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata corrupt.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[0], header_len[0]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 1) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"First header is not the id header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_id_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Id header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[2], header_len[2]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 5) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Third header is not the setup header.\\n\");\n\n        vorbis_free(vc);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_setup_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Setup header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    if (vc->audio_channels > 8)\n\n        avccontext->channel_layout = 0;\n\n    else\n\n        avccontext->channel_layout = ff_vorbis_channel_layouts[vc->audio_channels - 1];\n\n\n\n    avccontext->channels    = vc->audio_channels;\n\n    avccontext->sample_rate = vc->audio_samplerate;\n\n    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2;\n\n\n\n    avcodec_get_frame_defaults(&vc->frame);\n\n    avccontext->coded_frame = &vc->frame;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1815, "prediction": "0", "true_label": "1", "raw_text": "Question: static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n\n{\n\n    int len;\n\n    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;\n\n\n\n    if (block_mig_state.zero_blocks &&\n\n        buffer_is_zero(blk->buf, BLOCK_SIZE)) {\n\n        flags |= BLK_MIG_FLAG_ZERO_BLOCK;\n\n    }\n\n\n\n    /* sector number and flags */\n\n    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)\n\n                     | flags);\n\n\n\n    /* device name */\n\n    len = strlen(bdrv_get_device_name(blk->bmds->bs));\n\n    qemu_put_byte(f, len);\n\n    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);\n\n\n\n    /* if a block is zero we need to flush here since the network\n\n     * bandwidth is now a lot higher than the storage device bandwidth.\n\n     * thus if we queue zero blocks we slow down the migration */\n\n    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {\n\n        qemu_fflush(f);\n\n        return;\n\n    }\n\n\n\n    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1816, "prediction": "0", "true_label": "1", "raw_text": " mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1817, "prediction": "0", "true_label": "1", "raw_text": "Question: int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1818, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part     = (1 << porder);\n\n    all_bits = 4 * part;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for (i = 0; i < part; i++) {\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n        cnt = n >> porder;\n\n    }\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1819, "prediction": "0", "true_label": "1", "raw_text": "Question: static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1820, "prediction": "0", "true_label": "1", "raw_text": "Question: int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n\n                   int w, int h, enum PixelFormat pix_fmt, int align)\n\n{\n\n    int i, ret;\n\n    uint8_t *buf;\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        linesizes[i] = FFALIGN(linesizes[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n\n        return ret;\n\n    buf = av_malloc(ret + align);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n\n        av_free(buf);\n\n        return ret;\n\n    }\n\n    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)\n\n        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1821, "prediction": "0", "true_label": "1", "raw_text": "Question: static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1822, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1823, "prediction": "0", "true_label": "1", "raw_text": "ctlpath, PATH_MAX, \"/dev/%s.00\", bus_info.udi_devnames[0]);\n\n#endif\n\n\n\n    dfd  = open(ctlpath, O_RDWR);\n\n    if (dfd < 0) {\n\n        dfd = open(ctlpath, O_RDONLY);\n\n        if (dfd < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to open usb device %s - %s\\n\",\n\n                   ctlpath, strerror(errno));\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (dfd >= 0) {\n\n        if (ioctl(dfd, USB_GET_DEVICEINFO, &dev_info) < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to grab device info - %s\\n\",\n\n                   strerror(errno));\n\n#endif\n\n            goto fail;\n\n        }\n\n\n\n        d = usb_create(NULL /* FIXME */, \"usb-host\");\n\n        dev = DO_UPCAST(USBHostDevice, dev, d);\n\n\n\n        if (dev_info.udi_speed == 1)\n\n            dev->dev.speed = USB_SPEED_LOW - 1;\n\n        else\n\n            dev->dev.speed = USB_SPEED_FULL - 1;\n\n\n\n        if (strncmp(dev_info.udi_product, \"product\", 7) != 0)\n\n            pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                    dev_info.udi_product);\n\n        else\n\n            snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                     \"host:%s\", devname);\n\n\n\n        pstrcpy(dev->devpath, sizeof(dev->devpath), \"/dev/\");\n\n        pstrcat(dev->devpath, sizeof(dev->devpath), dev_info.udi_devnames[0]);\n\n\n\n        /* Mark the endpoints as not yet open */\n\n        for (i = 0; i < USB_MAX_ENDPOINTS; i++)\n\n           dev->ep_fd[i] = -1;\n\n\n\n        ioctl(dfd, USB_SETDEBUG, &ugendebug);\n\n\n\n        return (USBDevice *)dev;\n\n    }\n\n\n\nfail:\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1824, "prediction": "0", "true_label": "0", "raw_text": " &mode_08_08; break;\n\n    case (11<<8) +  8: tctx->mtab = &mode_11_08; break;\n\n    case (11<<8) + 10: tctx->mtab = &mode_11_10; break;\n\n    case (16<<8) + 16: tctx->mtab = &mode_16_16; break;\n\n    case (22<<8) + 20: tctx->mtab = &mode_22_20; break;\n\n    case (22<<8) + 24: tctx->mtab = &mode_22_24; break;\n\n    case (22<<8) + 32: tctx->mtab = &mode_22_32; break;\n\n    case (44<<8) + 40: tctx->mtab = &mode_44_40; break;\n\n    case (44<<8) + 48: tctx->mtab = &mode_44_48; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);\n\n        return -1;\n\n    }\n\n\n\n    ff_dsputil_init(&tctx->dsp, avctx);\n\n    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    if ((ret = init_mdct_win(tctx))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        twin_decode_close(avctx);\n\n        return ret;\n\n    }\n\n    init_bitstream_params(tctx);\n\n\n\n    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));\n\n\n\n    avcodec_get_frame_defaults(&tctx->frame);\n\n    avctx->coded_frame = &tctx->frame;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1825, "prediction": "0", "true_label": "1", "raw_text": "Question: static int copy_chapters(InputFile *ifile, OutputFile *ofile, int copy_metadata)\n\n{\n\n    AVFormatContext *is = ifile->ctx;\n\n    AVFormatContext *os = ofile->ctx;\n\n    int i;\n\n\n\n    for (i = 0; i < is->nb_chapters; i++) {\n\n        AVChapter *in_ch = is->chapters[i], *out_ch;\n\n        int64_t ts_off   = av_rescale_q(ofile->start_time - ifile->ts_offset,\n\n                                       AV_TIME_BASE_Q, in_ch->time_base);\n\n        int64_t rt       = (ofile->recording_time == INT64_MAX) ? INT64_MAX :\n\n                           av_rescale_q(ofile->recording_time, AV_TIME_BASE_Q, in_ch->time_base);\n\n\n\n\n\n        if (in_ch->end < ts_off)\n\n            continue;\n\n        if (rt != INT64_MAX && in_ch->start > rt + ts_off)\n\n            break;\n\n\n\n        out_ch = av_mallocz(sizeof(AVChapter));\n\n        if (!out_ch)\n\n            return AVERROR(ENOMEM);\n\n\n\n        out_ch->id        = in_ch->id;\n\n        out_ch->time_base = in_ch->time_base;\n\n        out_ch->start     = FFMAX(0,  in_ch->start - ts_off);\n\n        out_ch->end       = FFMIN(rt, in_ch->end   - ts_off);\n\n\n\n        if (copy_metadata)\n\n            av_dict_copy(&out_ch->metadata, in_ch->metadata, 0);\n\n\n\n        os->nb_chapters++;\n\n        os->chapters = av_realloc(os->chapters, sizeof(AVChapter) * os->nb_chapters);\n\n        if (!os->chapters)\n\n            return AVERROR(ENOMEM);\n\n        os->chapters[os->nb_chapters - 1] = out_ch;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1826, "prediction": "0", "true_label": "1", "raw_text": "Question: int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1827, "prediction": "0", "true_label": "1", "raw_text": " == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1828, "prediction": "0", "true_label": "1", "raw_text": "Question: static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1829, "prediction": "0", "true_label": "1", "raw_text": "Question: void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1830, "prediction": "0", "true_label": "0", "raw_text": "Question: static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)\n\n{\n\n    DynBuffer *d = opaque;\n\n    int new_size, new_allocated_size;\n\n    UINT8 *new_buffer;\n\n    \n\n    /* reallocate buffer if needed */\n\n    new_size = d->pos + buf_size;\n\n    new_allocated_size = d->allocated_size;\n\n    while (new_size > new_allocated_size) {\n\n        if (!new_allocated_size)\n\n            new_allocated_size = new_size;\n\n        else\n\n            new_allocated_size = (new_allocated_size * 3) / 2;\n\n    }\n\n    \n\n    if (new_allocated_size > d->allocated_size) {\n\n        new_buffer = av_malloc(new_allocated_size);\n\n        if (!new_buffer)\n\n            return;\n\n        memcpy(new_buffer, d->buffer, d->size);\n\n        av_free(d->buffer);\n\n        d->buffer = new_buffer;\n\n        d->allocated_size = new_allocated_size;\n\n    }\n\n    memcpy(d->buffer + d->pos, buf, buf_size);\n\n    d->pos = new_size;\n\n    if (d->pos > d->size)\n\n        d->size = d->pos;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1831, "prediction": "0", "true_label": "0", "raw_text": "2 u1 u0 */\n\n\n\n\t\t\t\"psrlq $24, %%mm6\t\t\\n\\t\" /* 0000RGBR 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"psllq $24, %%mm5\t\t\\n\\t\" /* BRGB0000 2 */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" /* BRGBRGBR 1 */\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\n\n\t\t\t\"psrlq $40, %%mm1\t\t\\n\\t\" /* 000000RG 2 */\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* RGBRGB00 3 */\n\n\t\t\t\"por %%mm3, %%mm1\t\t\\n\\t\" /* RGBRGBRG 2 */\n\n\t\t\tMOVNTQ\" %%mm1, 16(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n#endif\n\n\t\t     \n\n\t\t     \"add $24, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\t\t     \n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n    return srcSliceH;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1832, "prediction": "0", "true_label": "0", "raw_text": "Question: static int hex_to_data(uint8_t *data, const char *p)\n\n{\n\n    int c, len, v;\n\n\n\n    len = 0;\n\n    v = 1;\n\n    for(;;) {\n\n        skip_spaces(&p);\n\n        if (*p == '\\0')\n\n            break;\n\n        c = toupper((unsigned char)*p++);\n\n        if (c >= '0' && c <= '9')\n\n            c = c - '0';\n\n        else if (c >= 'A' && c <= 'F')\n\n            c = c - 'A' + 10;\n\n        else\n\n            break;\n\n        v = (v << 4) | c;\n\n        if (v & 0x100) {\n\n            if (data)\n\n                data[len] = v;\n\n            len++;\n\n            v = 1;\n\n        }\n\n    }\n\n    return len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1833, "prediction": "0", "true_label": "0", "raw_text": "_p1 <= 40) goto end;\n\n        block[0x1D] = temp_block[0x1D]; block[0x16] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1E] = temp_block[0x1E]; block[0x25] = temp_block[0x25];\n\n        block[0x2C] = temp_block[0x2C]; block[0x33] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x3A] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x34] = temp_block[0x34]; block[0x2D] = temp_block[0x2D];\n\n        block[0x26] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2E] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x35] = temp_block[0x35]; block[0x3C] = temp_block[0x3C];\n\n        block[0x3D] = temp_block[0x3D]; block[0x36] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3E] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }\n\n    end:\n\n    return last_non_zero_p1 - 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1834, "prediction": "0", "true_label": "1", "raw_text": "local_int_10 - 1)) {\n\n                offset += (1 - (local_int_10 - 1));\n\n                local_int_4  += local_int_10;\n\n                local_int_28 += (1 << local_int_8);\n\n            }\n\n        }\n\n\n\n        if (local_int_4 >= q->group_size)\n\n\n\n\n        local_int_14 = (offset >> local_int_8);\n\n\n\n\n\n        if (q->nb_channels > 1) {\n\n            channel = get_bits1(gb);\n\n            stereo = get_bits1(gb);\n\n        } else {\n\n            channel = 0;\n\n            stereo = 0;\n\n        }\n\n\n\n        exp = qdm2_get_vlc(gb, (b ? &fft_level_exp_vlc : &fft_level_exp_alt_vlc), 0, 2);\n\n        exp += q->fft_level_exp[fft_level_index_table[local_int_14]];\n\n        exp = (exp < 0) ? 0 : exp;\n\n\n\n        phase = get_bits(gb, 3);\n\n        stereo_exp = 0;\n\n        stereo_phase = 0;\n\n\n\n        if (stereo) {\n\n            stereo_exp = (exp - qdm2_get_vlc(gb, &fft_stereo_exp_vlc, 0, 1));\n\n            stereo_phase = (phase - qdm2_get_vlc(gb, &fft_stereo_phase_vlc, 0, 1));\n\n            if (stereo_phase < 0)\n\n                stereo_phase += 8;\n\n        }\n\n\n\n        if (q->frequency_range > (local_int_14 + 1)) {\n\n            int sub_packet = (local_int_20 + local_int_28);\n\n\n\n            qdm2_fft_init_coefficient(q, sub_packet, offset, duration, channel, exp, phase);\n\n            if (stereo)\n\n                qdm2_fft_init_coefficient(q, sub_packet, offset, duration, (1 - channel), stereo_exp, stereo_phase);\n\n        }\n\n\n\n        offset++;\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1835, "prediction": "0", "true_label": "1", "raw_text": "_ADDR:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_SET_TIME:\n\n        ti = (((uint32_t)data[1]) << 24) + (((uint32_t)data[2]) << 16) + (((uint32_t)data[3]) << 8) + data[4];\n\n        s->tick_offset = ti - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_TIME:\n\n        ti = s->tick_offset + (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        obuf[3] = ti >> 24;\n\n        obuf[4] = ti >> 16;\n\n        obuf[5] = ti >> 8;\n\n        obuf[6] = ti;\n\n        cuda_send_packet_to_host(s, obuf, 7);\n\n        break;\n\n    case CUDA_FILE_SERVER_FLAG:\n\n    case CUDA_SET_DEVICE_LIST:\n\n    case CUDA_SET_AUTO_RATE:\n\n    case CUDA_SET_POWER_MESSAGES:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_POWERDOWN:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_shutdown_request();\n\n        break;\n\n    case CUDA_RESET_SYSTEM:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_reset_request();\n\n        break;\n\n    case CUDA_COMBINED_FORMAT_IIC:\n\n\n        obuf[1] = 0x5;\n\n\n\n\n        break;\n\n    case CUDA_GET_SET_IIC:\n\n        if (len == 4) {\n\n            cuda_send_packet_to_host(s, obuf, 3);\n\n        } else {\n\n\n\n\n\n\n        }\n\n        break;\n\n    default:\n\n\n\n\n\n\n        break;\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1836, "prediction": "1", "true_label": "1", "raw_text": "Question: static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1837, "prediction": "0", "true_label": "1", "raw_text": "_coeff_bit_length[idx]; i>=0; i--)\n\n                            coeff += vp56_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;\n\n                    } else {\n\n                        if (vp56_rac_get_prob_branchy(c, model2[4]))\n\n                            coeff = 3 + vp56_rac_get_prob(c, model1[5]);\n\n                        else\n\n                            coeff = 2;\n\n                    }\n\n                    ct = 2;\n\n                } else {\n\n                    ct = 1;\n\n                    coeff = 1;\n\n                }\n\n                sign = vp56_rac_get(c);\n\n                coeff = (coeff ^ -sign) + sign;\n\n                if (coeff_idx)\n\n                    coeff *= s->dequant_ac;\n\n                idx = model->coeff_index_to_pos[coeff_idx];\n\n                s->block_coeff[b][permute[idx]] = coeff;\n\n                run = 1;\n\n            } else {\n\n                /* parse a run */\n\n                ct = 0;\n\n                if (coeff_idx > 0) {\n\n                    if (!vp56_rac_get_prob_branchy(c, model2[1]))\n\n                        break;\n\n\n\n                    model3 = model->coeff_runv[coeff_idx >= 6];\n\n                    run = vp56_rac_get_tree(c, vp6_pcr_tree, model3);\n\n                    if (!run)\n\n                        for (run=9, i=0; i<6; i++)\n\n                            run += vp56_rac_get_prob(c, model3[i+8]) << i;\n\n                }\n\n            }\n\n            coeff_idx += run;\n\n            if (coeff_idx >= 64)\n\n                break;\n\n            cg = vp6_coeff_groups[coeff_idx];\n\n            model1 = model2 = model->coeff_ract[pt][ct][cg];\n\n        }\n\n\n\n        s->left_block[ff_vp56_b6to4[b]].not_null_dc =\n\n        s->above_blocks[s->above_block_idx[b]].not_null_dc = !!s->block_coeff[b][0];\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1838, "prediction": "1", "true_label": "0", "raw_text": "Question: static int ftp_passive_mode_epsv(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    static const char d = '|';\n\n    static const char *command = \"EPSV\\r\\n\";\n\n    static const int epsv_codes[] = {229, 0};\n\n\n\n    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '(') {\n\n            start = res + i + 1;\n\n        } else if (res[i] == ')') {\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n    if (!start || !end)\n\n        goto fail;\n\n\n\n    *end = '\\0';\n\n    if (strlen(start) < 5)\n\n        goto fail;\n\n    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n\n        goto fail;\n\n    start += 3;\n\n    end[-1] = '\\0';\n\n\n\n    s->server_data_port = atoi(start);\n\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    s->server_data_port = -1;\n\n    return AVERROR(ENOSYS);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1839, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qemu_enqueue_packet(VLANClientState *sender,\n\n                                const uint8_t *buf, int size,\n\n                                NetPacketSent *sent_cb)\n\n{\n\n    VLANPacket *packet;\n\n\n\n    packet = qemu_malloc(sizeof(VLANPacket) + size);\n\n    packet->sender = sender;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1840, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)\n\n{\n\n    /* TO FIX */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1841, "prediction": "0", "true_label": "0", "raw_text": "Question: uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1842, "prediction": "0", "true_label": "0", "raw_text": "Question: void cpu_loop_exit(CPUState *env1)\n\n{\n\n    env1->current_tb = NULL;\n\n    longjmp(env1->jmp_env, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1843, "prediction": "0", "true_label": "0", "raw_text": " (1 << PPC_INTERRUPT_PIT)) {\n\n            env->exception_index = EXCP_40x_PIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            raised = 1;\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->exception_index = EXCP_40x_FIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            raised = 1;\n\n        /* Watchdog timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->exception_index = EXCP_40x_WATCHDOG;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            raised = 1;\n\n        /* External interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            env->exception_index = EXCP_EXTERNAL;\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            raised = 1;\n\n#if 0 // TODO\n\n        /* Thermal interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->exception_index = EXCP_970_THRM;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            raised = 1;\n\n#endif\n\n        }\n\n#if 0 // TODO\n\n    /* External debug exception */\n\n    } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->exception_index = EXCP_xxx;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        raised = 1;\n\n#endif\n\n    }\n\n    if (raised != 0) {\n\n        env->error_code = 0;\n\n        do_interrupt(env);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1844, "prediction": "0", "true_label": "0", "raw_text": "dc->cpustate_changed || org_flags != dc->tb_flags)) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    }\n\n    t_sync_flags(dc);\n\n\n\n    if (unlikely(env->singlestep_enabled)) {\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n        if (dc->is_jmp == DISAS_NEXT)\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n            case DISAS_NEXT:\n\n                gen_goto_tb(dc, 1, npc);\n\n                break;\n\n            default:\n\n            case DISAS_JUMP:\n\n            case DISAS_UPDATE:\n\n                /* indicate that the hash table must be used\n\n                   to find the next TB */\n\n                tcg_gen_exit_tb(0);\n\n                break;\n\n            case DISAS_TB_JUMP:\n\n                /* nothing more to generate */\n\n                break;\n\n        }\n\n    }\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n                tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n#if !SIM_COMPAT\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n#if DISAS_GNU\n\n        log_target_disas(pc_start, dc->pc - pc_start, 0);\n\n#endif\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, gen_opc_ptr - gen_opc_buf);\n\n    }\n\n#endif\n\n#endif\n\n    assert(!dc->abort_at_next_insn);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1845, "prediction": "0", "true_label": "1", "raw_text": "Question: static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n\n{\n\n    long i;\n\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n\n        long a = *(long *)(src1 + i);\n\n        long b = *(long *)(src2 + i);\n\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n\n    }\n\n    for (; i < w; i++)\n\n        dst[i] = src1[i] + src2[i];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1846, "prediction": "0", "true_label": "1", "raw_text": "6_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1847, "prediction": "0", "true_label": "1", "raw_text": " = addr | (page << 4);\n\n        switch(offset) {\n\n        case EN0_STARTPG:\n\n            s->start = val << 8;\n\n            break;\n\n        case EN0_STOPPG:\n\n            s->stop = val << 8;\n\n            break;\n\n        case EN0_BOUNDARY:\n\n            s->boundary = val;\n\n            break;\n\n        case EN0_IMR:\n\n            s->imr = val;\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN0_TPSR:\n\n            s->tpsr = val;\n\n            break;\n\n        case EN0_TCNTLO:\n\n            s->tcnt = (s->tcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_TCNTHI:\n\n            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RSARLO:\n\n            s->rsar = (s->rsar & 0xff00) | val;\n\n            break;\n\n        case EN0_RSARHI:\n\n            s->rsar = (s->rsar & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RCNTLO:\n\n            s->rcnt = (s->rcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_RCNTHI:\n\n            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_DCFG:\n\n            s->dcfg = val;\n\n            break;\n\n        case EN0_ISR:\n\n            s->isr &= ~(val & 0x7f);\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN1_PHYS ... EN1_PHYS + 5:\n\n            s->phys[offset - EN1_PHYS] = val;\n\n            break;\n\n        case EN1_CURPAG:\n\n            s->curpag = val;\n\n            break;\n\n        case EN1_MULT ... EN1_MULT + 7:\n\n            s->mult[offset - EN1_MULT] = val;\n\n            break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1848, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vc1_filter_line(uint8_t* src, int stride, int pq){\n\n    int a0, a1, a2, a3, d, clip, filt3 = 0;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;\n\n    if(FFABS(a0) < pq){\n\n        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;\n\n        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3;\n\n        a3 = FFMIN(FFABS(a1), FFABS(a2));\n\n        if(a3 < FFABS(a0)){\n\n            d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8;\n\n            clip = (src[-1*stride] - src[ 0*stride])/2;\n\n            if(clip){\n\n                filt3 = 1;\n\n                if(clip > 0)\n\n                    d = av_clip(d, 0, clip);\n\n                else\n\n                    d = av_clip(d, clip, 0);\n\n                src[-1*stride] = cm[src[-1*stride] - d];\n\n                src[ 0*stride] = cm[src[ 0*stride] + d];\n\n            }\n\n        }\n\n    }\n\n    return filt3;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1849, "prediction": "0", "true_label": "0", "raw_text": "Question: static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n                      int src_count, int src_size, int dest_len)\n\n{\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            return 0;\n\n        *pd++ = bytestream2_get_byteu(&gb);\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            break;\n\n        l = bytestream2_get_byteu(&gb);\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)\n\n                return bytestream2_tell(&gb);\n\n            bytestream2_get_bufferu(&gb, pd, l);\n\n            pd += l;\n\n        } else {\n\n            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)\n\n                return bytestream2_tell(&gb);\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n            }\n\n            bytestream2_skip(&gb, 2);\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return bytestream2_tell(&gb);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1850, "prediction": "0", "true_label": "0", "raw_text": "Question: static int recheck_discard_flags(AVFormatContext *s, int first)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i, changed = 0;\n\n\n\n    /* Check if any new streams are needed */\n\n    for (i = 0; i < c->n_playlists; i++)\n\n        c->playlists[i]->cur_needed = 0;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n\n        if (st->discard < AVDISCARD_ALL)\n\n            pls->cur_needed = 1;\n\n    }\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->cur_needed && !pls->needed) {\n\n            pls->needed = 1;\n\n            changed = 1;\n\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n            pls->pb.eof_reached = 0;\n\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n\n                /* catch up */\n\n                pls->seek_timestamp = c->cur_timestamp;\n\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n\n                pls->seek_stream_index = -1;\n\n            }\n\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n\n        } else if (first && !pls->cur_needed && pls->needed) {\n\n            if (pls->input)\n\n                ff_format_io_close(pls->parent, &pls->input);\n\n            pls->needed = 0;\n\n            changed = 1;\n\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n\n        }\n\n    }\n\n    return changed;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1851, "prediction": "0", "true_label": "0", "raw_text": "Question: static int tpm_passthrough_unix_transfer(int tpm_fd,\n\n                                         const TPMLocality *locty_data)\n\n{\n\n    return tpm_passthrough_unix_tx_bufs(tpm_fd,\n\n                                        locty_data->w_buffer.buffer,\n\n                                        locty_data->w_offset,\n\n                                        locty_data->r_buffer.buffer,\n\n                                        locty_data->r_buffer.size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1852, "prediction": "0", "true_label": "0", "raw_text": "Question: void do_tw (int flags)\n\n{\n\n    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||\n\n                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||\n\n                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||\n\n                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||\n\n                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1853, "prediction": "0", "true_label": "1", "raw_text": "mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, sgr), \"SGR\");\n\n    cpu_dbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, dbr), \"DBR\");\n\n    cpu_mach = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, mach), \"MACH\");\n\n    cpu_macl = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, macl), \"MACL\");\n\n    cpu_pr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pr), \"PR\");\n\n    cpu_fpscr = tcg_global_mem_new_i32(cpu_env,\n\n                                       offsetof(CPUSH4State, fpscr), \"FPSCR\");\n\n    cpu_fpul = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, fpul), \"FPUL\");\n\n\n\n    cpu_flags = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t       offsetof(CPUSH4State, flags), \"_flags_\");\n\n    cpu_delayed_pc = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t\t    offsetof(CPUSH4State, delayed_pc),\n\n\t\t\t\t\t    \"_delayed_pc_\");\n\n    cpu_delayed_cond = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State,\n\n                                                       delayed_cond),\n\n                                              \"_delayed_cond_\");\n\n    cpu_ldst = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t      offsetof(CPUSH4State, ldst), \"_ldst_\");\n\n\n\n    for (i = 0; i < 32; i++)\n\n        cpu_fregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, fregs[i]),\n\n                                              fregnames[i]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1854, "prediction": "0", "true_label": "1", "raw_text": "_stream(AVFormatContext *oc, int codec_id)\n\n{\n\n    AVCodec *codec;\n\n    AVCodecContext *c;\n\n    AVStream *st;\n\n\n\n    st = av_new_stream(oc, 1);\n\n    if (!st) {\n\n        fprintf(stderr, \"Could not alloc stream\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* find the MP2 encoder */\n\n    codec = avcodec_find_encoder(codec_id);\n\n    if (!codec) {\n\n        fprintf(stderr, \"codec not found\\n\");\n\n        exit(1);\n\n    }\n\n    c = &st->codec;\n\n    c->codec_type = CODEC_TYPE_AUDIO;\n\n\n\n    /* put sample parameters */\n\n    c->bit_rate = 64000;\n\n    c->sample_rate = 44100;\n\n    c->channels = 2;\n\n\n\n    /* open it */\n\n    if (avcodec_open(c, codec) < 0) {\n\n        fprintf(stderr, \"could not open codec\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* init signal generator */\n\n    t = 0;\n\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n\n\n\n    audio_outbuf_size = 10000;\n\n    audio_outbuf = malloc(audio_outbuf_size);\n\n\n\n    /* ugly hack for PCM codecs (will be removed ASAP with new PCM\n\n       support to compute the input frame size in samples */\n\n    if (c->frame_size <= 1) {\n\n        audio_input_frame_size = audio_outbuf_size / c->channels;\n\n        switch(st->codec.codec_id) {\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            audio_input_frame_size >>= 1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    } else {\n\n        audio_input_frame_size = c->frame_size;\n\n    }\n\n    samples = malloc(audio_input_frame_size * 2 * c->channels);\n\n\n\n    return st;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1855, "prediction": "0", "true_label": "1", "raw_text": "resolution = ctx->numresolution;\n\n    ctx->enc_params.cp_disto_alloc = ctx->disto_alloc;\n\n    ctx->enc_params.cp_fixed_alloc = ctx->fixed_alloc;\n\n    ctx->enc_params.cp_fixed_quality = ctx->fixed_quality;\n\n    ctx->enc_params.tcp_numlayers = ctx->numlayers;\n\n    ctx->enc_params.tcp_rates[0] = FFMAX(avctx->compression_level, 0) * 2;\n\n\n\n    if (ctx->cinema_mode > 0) {\n\n        cinema_parameters(&ctx->enc_params);\n\n    }\n\n\n\n    ctx->compress = opj_create_compress(ctx->format);\n\n    if (!ctx->compress) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the compressor\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    ctx->image = mj2_create_image(avctx, &ctx->enc_params);\n\n    if (!ctx->image) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the mj2 image\\n\");\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error allocating coded frame\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    memset(&ctx->event_mgr, 0, sizeof(opj_event_mgr_t));\n\n    ctx->event_mgr.info_handler    = info_callback;\n\n    ctx->event_mgr.error_handler = error_callback;\n\n    ctx->event_mgr.warning_handler = warning_callback;\n\n    opj_set_event_mgr((opj_common_ptr) ctx->compress, &ctx->event_mgr, avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opj_destroy_compress(ctx->compress);\n\n    ctx->compress = NULL;\n\n    opj_image_destroy(ctx->image);\n\n    ctx->image = NULL;\n\n    av_freep(&avctx->coded_frame);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1856, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline unsigned int msi_nr_vectors(uint16_t flags)\n\n{\n\n    return 1U <<\n\n        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1857, "prediction": "0", "true_label": "0", "raw_text": "Question: static void openrisc_sim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    OpenRISCCPU *cpu = NULL;\n\n    MemoryRegion *ram;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"or1200\";\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n        main_cpu_reset(cpu);\n\n    }\n\n\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"openrisc.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram);\n\n\n\n    cpu_openrisc_pic_init(cpu);\n\n    cpu_openrisc_clock_init(cpu);\n\n\n\n    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],\n\n                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n\n\n    if (nd_table[0].used) {\n\n        openrisc_sim_net_init(get_system_memory(), 0x92000000,\n\n                              0x92000400, cpu->env.irq[4], nd_table);\n\n    }\n\n\n\n    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1858, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ohci_reset(void *opaque)\n\n{\n\n    OHCIState *ohci = opaque;\n\n    OHCIPort *port;\n\n    int i;\n\n\n\n    ohci_bus_stop(ohci);\n\n    ohci->ctl = 0;\n\n    ohci->old_ctl = 0;\n\n    ohci->status = 0;\n\n    ohci->intr_status = 0;\n\n    ohci->intr = OHCI_INTR_MIE;\n\n\n\n    ohci->hcca = 0;\n\n    ohci->ctrl_head = ohci->ctrl_cur = 0;\n\n    ohci->bulk_head = ohci->bulk_cur = 0;\n\n    ohci->per_cur = 0;\n\n    ohci->done = 0;\n\n    ohci->done_count = 7;\n\n\n\n    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?\n\n     * I took the value linux sets ...\n\n     */\n\n    ohci->fsmps = 0x2778;\n\n    ohci->fi = 0x2edf;\n\n    ohci->fit = 0;\n\n    ohci->frt = 0;\n\n    ohci->frame_number = 0;\n\n    ohci->pstart = 0;\n\n    ohci->lst = OHCI_LS_THRESH;\n\n\n\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n\n    ohci->rhstatus = 0;\n\n\n\n    for (i = 0; i < ohci->num_ports; i++)\n\n      {\n\n        port = &ohci->rhport[i];\n\n        port->ctrl = 0;\n\n        if (port->port.dev) {\n\n            usb_attach(&port->port, port->port.dev);\n\n        }\n\n      }\n\n    if (ohci->async_td) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n    DPRINTF(\"usb-ohci: Reset %s\\n\", ohci->name);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1859, "prediction": "0", "true_label": "0", "raw_text": "Question: uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&\n\n                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {\n\n        /* Magnitude subtraction of infinities */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN subtraction */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1860, "prediction": "0", "true_label": "1", "raw_text": "Question: static int net_socket_connect_init(NetClientState *peer,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            if (errno == EINTR || errno == EWOULDBLOCK) {\n\n                /* continue */\n\n            } else if (errno == EINPROGRESS ||\n\n                       errno == EALREADY ||\n\n                       errno == EINVAL) {\n\n                break;\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(peer, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1861, "prediction": "0", "true_label": "1", "raw_text": "MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1862, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_validate_fail_union_anon(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1863, "prediction": "0", "true_label": "0", "raw_text": "Question: static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1864, "prediction": "0", "true_label": "1", "raw_text": "Question: static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)\n\n{\n\n    AVFilterContext  *ctx = inlink->dst;\n\n    ATempoContext *atempo = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n\n\n    int ret = 0;\n\n    int n_in = src_buffer->nb_samples;\n\n    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);\n\n\n\n    const uint8_t *src = src_buffer->data[0];\n\n    const uint8_t *src_end = src + n_in * atempo->stride;\n\n\n\n    while (src < src_end) {\n\n        if (!atempo->dst_buffer) {\n\n            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);\n\n            if (!atempo->dst_buffer)\n\n                return AVERROR(ENOMEM);\n\n            av_frame_copy_props(atempo->dst_buffer, src_buffer);\n\n\n\n            atempo->dst = atempo->dst_buffer->data[0];\n\n            atempo->dst_end = atempo->dst + n_out * atempo->stride;\n\n        }\n\n\n\n        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);\n\n\n\n        if (atempo->dst == atempo->dst_end) {\n\n            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /\n\n                             atempo->stride);\n\n            ret = push_samples(atempo, outlink, n_samples);\n\n            if (ret < 0)\n\n                goto end;\n\n        }\n\n    }\n\n\n\n    atempo->nsamples_in += n_in;\n\nend:\n\n    av_frame_free(&src_buffer);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1865, "prediction": "0", "true_label": "1", "raw_text": "TYPE_KERNEL;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n\n\n    if (!options->net_backend) {\n\n        fprintf(stderr, \"vhost-net requires net backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (backend_kernel) {\n\n        r = vhost_net_get_fd(options->net_backend);\n\n        if (r < 0) {\n\n            goto fail;\n\n        }\n\n        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)\n\n            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);\n\n        net->backend = r;\n\n    } else {\n\n        net->dev.backend_features = 0;\n\n        net->backend = -1;\n\n    }\n\n    net->nc = options->net_backend;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = net->nc->queue_index;\n\n\n\n    r = vhost_dev_init(&net->dev, options->opaque,\n\n                       options->backend_type, options->force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (backend_kernel) {\n\n        if (!qemu_has_vnet_hdr_len(options->net_backend,\n\n                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);\n\n        }\n\n        if (~net->dev.features & net->dev.backend_features) {\n\n            fprintf(stderr, \"vhost lacks feature mask %\" PRIu64\n\n                   \" for backend\\n\",\n\n                   (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n            vhost_dev_cleanup(&net->dev);\n\n            goto fail;\n\n        }\n\n    }\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1866, "prediction": "1", "true_label": "1", "raw_text": "Question: static USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n\n\n        filename = p1;\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"usb-storage\");\n\n\n\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    if (qdev_init(&dev->qdev) < 0)\n\n\n\n\n    return dev;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1867, "prediction": "0", "true_label": "1", "raw_text": ";\n\n    }\n\n    if(!weighted){\n\n        Y = s->dest[0] + xoff      + yoff     *s->linesize;\n\n        U = s->dest[1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = s->dest[2] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }else{\n\n        Y = r->tmp_b_block_y [dir]     +  xoff     +  yoff    *s->linesize;\n\n        U = r->tmp_b_block_uv[dir*2]   + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = r->tmp_b_block_uv[dir*2+1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }\n\n\n\n    if(block_type == RV34_MB_P_16x8){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8;\n\n        srcY += 8;\n\n    }else if(block_type == RV34_MB_P_8x16){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8 * s->linesize;\n\n        srcY += 8 * s->linesize;\n\n    }\n\n    is16x16 = (block_type != RV34_MB_P_8x8) && (block_type != RV34_MB_P_16x8) && (block_type != RV34_MB_P_8x16);\n\n    qpel_mc[!is16x16][dxy](Y, srcY, s->linesize);\n\n    chroma_mc[2-width]   (U, srcU, s->uvlinesize, height*4, uvmx, uvmy);\n\n    chroma_mc[2-width]   (V, srcV, s->uvlinesize, height*4, uvmx, uvmy);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1868, "prediction": "0", "true_label": "1", "raw_text": "Question: void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1869, "prediction": "0", "true_label": "1", "raw_text": "_out = VCO_out / D2;\n\n    } else {\n\n        /* Bypass PLL */\n\n    bypass_pll:\n\n        M = D0;\n\n        PLL_out = cpc->sysclk * M;\n\n    }\n\n    CPU_clk = PLL_out;\n\n    if (cpc->cr1 & 0x00800000)\n\n        TMR_clk = cpc->sysclk; /* Should have a separate clock */\n\n    else\n\n        TMR_clk = CPU_clk;\n\n    PLB_clk = CPU_clk / D0;\n\n    SDRAM_clk = PLB_clk;\n\n    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;\n\n    OPB_clk = PLB_clk / D0;\n\n    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;\n\n    EXT_clk = PLB_clk / D0;\n\n    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;\n\n    UART_clk = CPU_clk / D0;\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);\n\n    /* Setup time-base clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);\n\n    /* Setup SDRAM clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);\n\n    /* Setup UART clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1870, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (addr != 2 || size != 1) {\n\n        return ((uint64_t)1 << (size * 8)) - 1;\n\n    }\n\n    return ide_status_read(cmd646bar->bus, addr + 2);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1871, "prediction": "0", "true_label": "0", "raw_text": " id out of range\\n\");\n\n            return 0;\n\n        }\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            return timer->config;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            return timer->config >> 32;\n\n        case HPET_TN_CMP: // comparator register\n\n            return timer->cmp;\n\n        case HPET_TN_CMP + 4:\n\n            return timer->cmp >> 32;\n\n        case HPET_TN_ROUTE:\n\n            return timer->fsb;\n\n        case HPET_TN_ROUTE + 4:\n\n            return timer->fsb >> 32;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return s->capability;\n\n        case HPET_PERIOD:\n\n            return s->capability >> 32;\n\n        case HPET_CFG:\n\n            return s->config;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl\\n\");\n\n            return 0;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick >> 32;\n\n        case HPET_STATUS:\n\n            return s->isr;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1872, "prediction": "0", "true_label": "0", "raw_text": "\n\n    pci_config_set_device_id(config, device);\n\n\n\n    config[0x08] = VIRTIO_PCI_ABI_VERSION;\n\n\n\n    config[0x09] = pif;\n\n    pci_config_set_class(config, class_code);\n\n\n\n    config[0x2c] = vendor & 0xFF;\n\n    config[0x2d] = (vendor >> 8) & 0xFF;\n\n    config[0x2e] = vdev->device_id & 0xFF;\n\n    config[0x2f] = (vdev->device_id >> 8) & 0xFF;\n\n\n\n    config[0x3d] = 1;\n\n\n\n    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {\n\n        pci_register_bar(&proxy->pci_dev, 1,\n\n                         msix_bar_size(&proxy->pci_dev),\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                         msix_mmio_map);\n\n    } else\n\n        vdev->nvectors = 0;\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n\n\n    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;\n\n    if (size & (size-1))\n\n        size = 1 << qemu_fls(size);\n\n\n\n    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,\n\n                           virtio_map);\n\n\n\n    if (!kvm_has_many_ioeventfds()) {\n\n        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;\n\n    }\n\n\n\n    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);\n\n    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;\n\n    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;\n\n    proxy->host_features = vdev->get_features(vdev, proxy->host_features);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1873, "prediction": "0", "true_label": "0", "raw_text": "1;\n\n\n\n    if (strstart(devname, \"host:\", &p)) {\n\n        dev = usb_host_device_open(p);\n\n    } else if (!strcmp(devname, \"mouse\")) {\n\n        dev = usb_mouse_init();\n\n    } else if (!strcmp(devname, \"tablet\")) {\n\n        dev = usb_tablet_init();\n\n    } else if (!strcmp(devname, \"keyboard\")) {\n\n        dev = usb_keyboard_init();\n\n    } else if (strstart(devname, \"disk:\", &p)) {\n\n        BlockDriverState *bs;\n\n\n\n        dev = usb_msd_init(p, &bs);\n\n        if (!dev)\n\n            return -1;\n\n        if (bdrv_key_required(bs)) {\n\n            autostart = 0;\n\n            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {\n\n                dev->handle_destroy(dev);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (!strcmp(devname, \"wacom-tablet\")) {\n\n        dev = usb_wacom_init();\n\n    } else if (strstart(devname, \"serial:\", &p)) {\n\n        dev = usb_serial_init(p);\n\n#ifdef CONFIG_BRLAPI\n\n    } else if (!strcmp(devname, \"braille\")) {\n\n        dev = usb_baum_init();\n\n#endif\n\n    } else if (strstart(devname, \"net:\", &p)) {\n\n        int nic = nb_nics;\n\n\n\n        if (net_client_init(\"nic\", p) < 0)\n\n            return -1;\n\n        nd_table[nic].model = \"usb\";\n\n        dev = usb_net_init(&nd_table[nic]);\n\n    } else if (!strcmp(devname, \"bt\") || strstart(devname, \"bt:\", &p)) {\n\n        dev = usb_bt_init(devname[2] ? hci_init(p) :\n\n                        bt_new_hci(qemu_find_bt_vlan(0)));\n\n    } else {\n\n        return -1;\n\n    }\n\n    if (!dev)\n\n        return -1;\n\n\n\n    return usb_device_add_dev(dev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1874, "prediction": "0", "true_label": "0", "raw_text": "Question: void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    SCHIB schib;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {\n\n        return;\n\n    }\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_schib_valid(&schib)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"msch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_msch(sch, &schib);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1875, "prediction": "0", "true_label": "1", "raw_text": " Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto out;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1876, "prediction": "0", "true_label": "1", "raw_text": " url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);\n\n        c->curbits = c->frames[c->curframe].skip;\n\n    }\n\n    c->lastframe = c->curframe;\n\n    c->curframe++;\n\n    curbits = c->curbits;\n\n    pos = url_ftell(s->pb);\n\n    tmp = get_le32(s->pb);\n\n    if(curbits <= 12){\n\n        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;\n\n    }else{\n\n        tmp = (tmp << 32) | get_le32(s->pb);\n\n        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;\n\n    }\n\n    curbits += 20;\n\n    url_fseek(s->pb, pos, SEEK_SET);\n\n\n\n    size = ((size2 + curbits + 31) & ~31) >> 3;\n\n    if(cur == c->frames_noted){\n\n        c->frames[cur].pos = pos;\n\n        c->frames[cur].size = size;\n\n        c->frames[cur].skip = curbits - 20;\n\n        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);\n\n        c->frames_noted++;\n\n    }\n\n    c->curbits = (curbits + size2) & 0x1F;\n\n\n\n    if (av_new_packet(pkt, size) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->data[0] = curbits;\n\n    pkt->data[1] = (c->curframe > c->fcount);\n\n\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pts = cur;\n\n    ret = get_buffer(s->pb, pkt->data + 4, size);\n\n    if(c->curbits)\n\n        url_fseek(s->pb, -4, SEEK_CUR);\n\n    if(ret < size){\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n    pkt->size = ret + 4;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1877, "prediction": "0", "true_label": "1", "raw_text": "s->timer[i]);\n\n                }\n\n                else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Halt main counter and disable interrupt generation. */\n\n                    s->hpet_counter = hpet_get_ticks();\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        hpet_del_timer(&s->timer[i]);\n\n                }\n\n                /* i8254 and RTC are disabled when HPET is in legacy mode */\n\n                if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_disable();\n\n                } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_enable();\n\n                }\n\n                break;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG+4 write \\n\");\n\n                break;\n\n            case HPET_STATUS:\n\n                /* FIXME: need to handle level-triggered interrupts */\n\n                break;\n\n            case HPET_COUNTER:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffff00000000ULL)\n\n                                  | value;\n\n               DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            case HPET_COUNTER + 4:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffffULL)\n\n                                  | (((uint64_t)value) << 32);\n\n               DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            default:\n\n               DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n               break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1878, "prediction": "0", "true_label": "0", "raw_text": "Question: void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n        int flags)\n\n{\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"PC=%08x\\n\", env->pc);\n\n\n\n    for (i = 0; i < 16; ++i) {\n\n        cpu_fprintf(f, \"A%02d=%08x%c\", i, env->regs[i],\n\n                (i % 4) == 3 ? '\\n' : ' ');\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1879, "prediction": "0", "true_label": "0", "raw_text": "has_connect + sock->has_mcast +\n\n        sock->has_udp != 1) {\n\n        error_report(\"exactly one of fd=, listen=, connect=, mcast= or udp=\"\n\n                     \" is required\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {\n\n        error_report(\"localaddr= is only valid with mcast= or udp=\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_fd) {\n\n        int fd;\n\n\n\n        fd = monitor_fd_param(cur_mon, sock->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n        qemu_set_nonblock(fd);\n\n        if (!net_socket_fd_init(peer, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_listen) {\n\n        if (net_socket_listen_init(peer, \"socket\", name, sock->listen) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_connect) {\n\n        if (net_socket_connect_init(peer, \"socket\", name, sock->connect) ==\n\n            -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_mcast) {\n\n        /* if sock->localaddr is missing, it has been initialized to \"all bits\n\n         * zero\" */\n\n        if (net_socket_mcast_init(peer, \"socket\", name, sock->mcast,\n\n            sock->localaddr) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    assert(sock->has_udp);\n\n    if (!sock->has_localaddr) {\n\n        error_report(\"localaddr= is mandatory with udp=\");\n\n        return -1;\n\n    }\n\n    if (net_socket_udp_init(peer, \"socket\", name, sock->udp, sock->localaddr) ==\n\n        -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1880, "prediction": "0", "true_label": "1", "raw_text": "Question: void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1881, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)\n\n{\n\n    int d;\n\n    for( d = 0; d < 8; d++ ) {\n\n        const int p0 = pix[-1*xstride];\n\n        const int p1 = pix[-2*xstride];\n\n        const int q0 = pix[0];\n\n        const int q1 = pix[1*xstride];\n\n\n\n        if( FFABS( p0 - q0 ) < alpha &&\n\n            FFABS( p1 - p0 ) < beta &&\n\n            FFABS( q1 - q0 ) < beta ) {\n\n\n\n            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */\n\n            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */\n\n        }\n\n        pix += ystride;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1882, "prediction": "1", "true_label": "1", "raw_text": " VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n\n    if (vs->major != 3 ||\n\n        (vs->minor != 3 &&\n\n         vs->minor != 4 &&\n\n         vs->minor != 5 &&\n\n         vs->minor != 7 &&\n\n         vs->minor != 8)) {\n\n        VNC_DEBUG(\"Unsupported client version\\n\");\n\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n        vnc_flush(vs);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n\n     * as equivalent to v3.3 by servers\n\n     */\n\n    if (vs->minor == 4 || vs->minor == 5)\n\n        vs->minor = 3;\n\n\n\n    if (vs->minor == 3) {\n\n        if (vs->auth == VNC_AUTH_NONE) {\n\n            VNC_DEBUG(\"Tell client auth none\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_client_init(vs);\n\n       } else if (vs->auth == VNC_AUTH_VNC) {\n\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_auth_vnc(vs);\n\n       } else {\n\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n            vnc_flush(vs);\n\n            vnc_client_error(vs);\n\n       }\n\n    } else {\n\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n\n        vnc_write_u8(vs, 1); /* num auth */\n\n        vnc_write_u8(vs, vs->auth);\n\n        vnc_read_when(vs, protocol_client_auth, 1);\n\n        vnc_flush(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1883, "prediction": "0", "true_label": "1", "raw_text": "Question: qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    struct pxa2xx_pic_state_s *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (struct pxa2xx_pic_state_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n    s->base = base;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x000fffff, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(\"pxa2xx_pic\", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1884, "prediction": "0", "true_label": "1", "raw_text": " 0) {\n\n            if (i < 0)\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid new backstep %d\\n\", i);\n\n            i = FFMIN(BACKSTEP_SIZE, buf_size - HEADER_SIZE);\n\n        }\n\n        assert(i <= buf_size - HEADER_SIZE && i >= 0);\n\n        memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);\n\n        s->last_buf_size += i;\n\n    }\n\n\n\n    /* get output buffer */\n\n    if (!samples) {\n\n        av_assert0(s->frame != NULL);\n\n        s->frame->nb_samples = s->avctx->frame_size;\n\n        if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n        samples = (OUT_INT **)s->frame->extended_data;\n\n    }\n\n\n\n    /* apply the synthesis filter */\n\n    for (ch = 0; ch < s->nb_channels; ch++) {\n\n        int sample_stride;\n\n        if (s->avctx->sample_fmt == OUT_FMT_P) {\n\n            samples_ptr   = samples[ch];\n\n            sample_stride = 1;\n\n        } else {\n\n            samples_ptr   = samples[0] + ch;\n\n            sample_stride = s->nb_channels;\n\n        }\n\n        for (i = 0; i < nb_frames; i++) {\n\n            RENAME(ff_mpa_synth_filter)(&s->mpadsp, s->synth_buf[ch],\n\n                                        &(s->synth_buf_offset[ch]),\n\n                                        RENAME(ff_mpa_synth_window),\n\n                                        &s->dither_state, samples_ptr,\n\n                                        sample_stride, s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * sample_stride;\n\n        }\n\n    }\n\n\n\n    return nb_frames * 32 * sizeof(OUT_INT) * s->nb_channels;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1885, "prediction": "0", "true_label": "1", "raw_text": "Question: static InetSocketAddress *ssh_config(QDict *options, Error **errp)\n\n{\n\n    InetSocketAddress *inet = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"SSH server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return inet;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1886, "prediction": "1", "true_label": "1", "raw_text": "Question: sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n\n{\n\n    if ((s->data_count & 0x3) != byte_num) {\n\n        ERRPRINT(\"Non-sequential access to Buffer Data Port register\"\n\n                \"is prohibited\\n\");\n\n        return false;\n\n    }\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1887, "prediction": "-1", "true_label": "0", "raw_text": "Question: static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n\n{\n\n    ssize_t ret;\n\n    guint watch;\n\n\n\n    assert(qemu_in_coroutine());\n\n    /* Negotiation are always in main loop. */\n\n    watch = qio_channel_add_watch(ioc,\n\n                                  G_IO_OUT,\n\n                                  nbd_negotiate_continue,\n\n                                  qemu_coroutine_self(),\n\n                                  NULL);\n\n    ret = write_sync(ioc, buffer, size, NULL);\n\n    g_source_remove(watch);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1888, "prediction": "0", "true_label": "0", "raw_text": "Question: static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n    free(ctx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1889, "prediction": "0", "true_label": "0", "raw_text": "Question: static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1890, "prediction": "0", "true_label": "0", "raw_text": " = 0 /* No function Supported */;\n\n    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(unpatched, ifctx);\n\n\n\n    /* No function is supported yet. */\n\n    byte_list[0] = 1 /* Not Supported */;\n\n    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(method, unpatched);\n\n\n\n    /*\n\n     * The HDLE indicates the DSM function is issued from which device,\n\n     * it is not used at this time as no function is supported yet.\n\n     * Currently we make it always be 0 for all the devices and will set\n\n     * the appropriate value once real function is implemented.\n\n     */\n\n    aml_append(method, aml_store(aml_int(0x0), aml_name(\"HDLE\")));\n\n    aml_append(method, aml_store(aml_arg(1), aml_name(\"REVS\")));\n\n    aml_append(method, aml_store(aml_arg(2), aml_name(\"FUNC\")));\n\n\n\n    /*\n\n     * tell QEMU about the real address of DSM memory, then QEMU\n\n     * gets the control and fills the result in DSM memory.\n\n     */\n\n    aml_append(method, aml_store(dsm_mem, aml_name(\"NTFI\")));\n\n\n\n    result_size = aml_local(1);\n\n    aml_append(method, aml_store(aml_name(\"RLEN\"), result_size));\n\n    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),\n\n                                 result_size));\n\n    aml_append(method, aml_create_field(aml_name(\"ODAT\"), aml_int(0),\n\n                                        result_size, \"OBUF\"));\n\n    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(\"OBUF\"),\n\n                                       aml_arg(6)));\n\n    aml_append(method, aml_return(aml_arg(6)));\n\n    aml_append(dev, method);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1891, "prediction": "1", "true_label": "0", "raw_text": "Question: static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n\tVNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n\treturn NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1892, "prediction": "0", "true_label": "0", "raw_text": "Question: static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1893, "prediction": "0", "true_label": "0", "raw_text": "Question: static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    S390pciState *s = opaque;\n\n\n\n    return &s->pbdev[PCI_SLOT(devfn)].as;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1894, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_info_commands(void)\n\n{\n\n    char *resp, *info, *info_buf, *endp;\n\n\n\n    info_buf = info = hmp(\"help info\");\n\n\n\n    while (*info) {\n\n        /* Extract the info command, ignore parameters and description */\n\n        g_assert(strncmp(info, \"info \", 5) == 0);\n\n        endp = strchr(&info[5], ' ');\n\n        g_assert(endp != NULL);\n\n        *endp = '\\0';\n\n        /* Now run the info command */\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", info);\n\n        }\n\n        resp = hmp(info);\n\n        g_free(resp);\n\n        /* And move forward to the next line */\n\n        info = strchr(endp + 1, '\\n');\n\n        if (!info) {\n\n            break;\n\n        }\n\n        info += 1;\n\n    }\n\n\n\n    g_free(info_buf);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1895, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1896, "prediction": "0", "true_label": "0", "raw_text": "Question: static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1897, "prediction": "0", "true_label": "0", "raw_text": ", job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,\n\n                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = blk_co_pwrite_zeroes(job->target, start,\n\n                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = blk_co_pwritev(job->target, start,\n\n                                 bounce_qiov.size, &bounce_qiov,\n\n                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        set_bit(start / job->cluster_size, job->done_bitmap);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->bytes_read += n;\n\n        job->common.offset += n;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, offset, bytes, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1898, "prediction": "1", "true_label": "0", "raw_text": "Question: static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1899, "prediction": "0", "true_label": "0", "raw_text": "\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    /* Flush the entire write buffer onto backing storage.  */\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; /* Programming error */\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: /* Confirm mode */\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen */\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1900, "prediction": "0", "true_label": "0", "raw_text": "Question: int kvm_init_vcpu(CPUState *cpu)\n\n{\n\n    KVMState *s = kvm_state;\n\n    long mmap_size;\n\n    int ret;\n\n\n\n    DPRINTF(\"kvm_init_vcpu\\n\");\n\n\n\n    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));\n\n    if (ret < 0) {\n\n        DPRINTF(\"kvm_create_vcpu failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_fd = ret;\n\n    cpu->kvm_state = s;\n\n    cpu->kvm_vcpu_dirty = true;\n\n\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (mmap_size < 0) {\n\n        ret = mmap_size;\n\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\n                        cpu->kvm_fd, 0);\n\n    if (cpu->kvm_run == MAP_FAILED) {\n\n        ret = -errno;\n\n        DPRINTF(\"mmap'ing vcpu state failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {\n\n        s->coalesced_mmio_ring =\n\n            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;\n\n    }\n\n\n\n    ret = kvm_arch_init_vcpu(cpu);\n\nerr:\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1901, "prediction": "0", "true_label": "1", "raw_text": "Question: void arm_cpu_do_interrupt(CPUState *cs)\n{\n    ARMCPU *cpu = ARM_CPU(cs);\n    CPUARMState *env = &cpu->env;\n    unsigned int new_el = env->exception.target_el;\n    assert(!arm_feature(env, ARM_FEATURE_M));\n    arm_log_exception(cs->exception_index);\n    qemu_log_mask(CPU_LOG_INT, \"...from EL%d to EL%d\\n\", arm_current_el(env),\n                  new_el);\n    if (qemu_loglevel_mask(CPU_LOG_INT)\n        && !excp_is_internal(cs->exception_index)) {\n        qemu_log_mask(CPU_LOG_INT, \"...with ESR %x/0x%\" PRIx32 \"\\n\",\n                      env->exception.syndrome >> ARM_EL_EC_SHIFT,\n                      env->exception.syndrome);\n    }\n    if (arm_is_psci_call(cpu, cs->exception_index)) {\n        arm_handle_psci_call(cpu);\n        qemu_log_mask(CPU_LOG_INT, \"...handled as PSCI call\\n\");\n        return;\n    }\n    /* Semihosting semantics depend on the register width of the\n     * code that caused the exception, not the target exception level,\n     * so must be handled here.\n    if (check_for_semihosting(cs)) {\n        return;\n    }\n    assert(!excp_is_internal(cs->exception_index));\n    if (arm_el_is_aa64(env, new_el)) {\n        arm_cpu_do_interrupt_aarch64(cs);\n    } else {\n        arm_cpu_do_interrupt_aarch32(cs);\n    }\n    arm_call_el_change_hook(cpu);\n    if (!kvm_enabled()) {\n        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n    }\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1902, "prediction": "0", "true_label": "1", "raw_text": " *n, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))\n\n        return;\n\n\n\n    if (n->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(n->tx_vq, 0);\n\n        return;\n\n    }\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        ssize_t ret, len = 0;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        unsigned hdr_len;\n\n\n\n        /* hdr_len refers to the header received from the guest */\n\n        hdr_len = n->mergeable_rx_bufs ?\n\n            sizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\n            sizeof(struct virtio_net_hdr);\n\n\n\n        if (out_num < 1 || out_sg->iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* ignore the header if GSO is not supported */\n\n        if (!n->has_vnet_hdr) {\n\n            out_num--;\n\n            out_sg++;\n\n            len += hdr_len;\n\n        } else if (n->mergeable_rx_bufs) {\n\n            /* tapfd expects a struct virtio_net_hdr */\n\n            hdr_len -= sizeof(struct virtio_net_hdr);\n\n            out_sg->iov_len -= hdr_len;\n\n            len += hdr_len;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,\n\n                                      virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(n->tx_vq, 0);\n\n            n->async_tx.elem = elem;\n\n            n->async_tx.len  = len;\n\n            return;\n\n        }\n\n\n\n        len += ret;\n\n\n\n        virtqueue_push(vq, &elem, len);\n\n        virtio_notify(&n->vdev, vq);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1903, "prediction": "0", "true_label": "1", "raw_text": "Question: static void flush_queued_data(VirtIOSerialPort *port, bool discard)\n\n{\n\n    assert(port || discard);\n\n\n\n    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1904, "prediction": "-1", "true_label": "1", "raw_text": "\n\n        if (bsd_path[0] == '\\0') {\n\n            error_setg(errp, \"Failed to obtain bsd path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If using a cdrom disc and finding a partition on the disc failed */\n\n        if (strncmp(mediaType, kIOCDMediaClass, 9) == 0 &&\n\n            setup_cdrom(bsd_path, errp) == false) {\n\n            print_unmounting_directions(bsd_path);\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        qdict_put(options, \"filename\", qstring_from_str(bsd_path));\n\n\n\nhdev_open_Mac_error:\n\n        g_free(mediaType);\n\n        if (mediaIterator) {\n\n            IOObjectRelease(mediaIterator);\n\n        }\n\n        if (error_occurred) {\n\n            return -ENOENT;\n\n        }\n\n    }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n\n    s->type = FTYPE_FILE;\n\n\n\n    ret = raw_open_common(bs, options, flags, 0, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n        if (*bsd_path) {\n\n            filename = bsd_path;\n\n        }\n\n        /* if a physical device experienced an error while being opened */\n\n        if (strncmp(filename, \"/dev/\", 5) == 0) {\n\n            print_unmounting_directions(filename);\n\n        }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n        return ret;\n\n    }\n\n\n\n    /* Since this does ioctl the device must be already opened */\n\n    bs->sg = hdev_is_sg(bs);\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        ret = check_hdev_writable(s);\n\n        if (ret < 0) {\n\n            raw_close(bs);\n\n            error_setg_errno(errp, -ret, \"The device is not writable\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1905, "prediction": "0", "true_label": "1", "raw_text": "Question: int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1906, "prediction": "0", "true_label": "1", "raw_text": "Question: static int link_filter_inouts(AVFilterContext *filt_ctx,\n\n                              AVFilterInOut **curr_inputs,\n\n                              AVFilterInOut **open_inputs, AVClass *log_ctx)\n\n{\n\n    int pad = filt_ctx->input_count, ret;\n\n\n\n    while (pad--) {\n\n        AVFilterInOut *p = *curr_inputs;\n\n        if (!p) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Not enough inputs specified for the \\\"%s\\\" filter.\\n\",\n\n                   filt_ctx->filter->name);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        *curr_inputs = (*curr_inputs)->next;\n\n\n\n        if (p->filter) {\n\n            if ((ret = link_filter(p->filter, p->pad_idx, filt_ctx, pad, log_ctx)) < 0)\n\n                return ret;\n\n            av_free(p->name);\n\n            av_free(p);\n\n        } else {\n\n            p->filter = filt_ctx;\n\n            p->pad_idx = pad;\n\n            insert_inout(open_inputs, p);\n\n        }\n\n    }\n\n\n\n    if (*curr_inputs) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Too many inputs specified for the \\\"%s\\\" filter.\\n\",\n\n               filt_ctx->filter->name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    pad = filt_ctx->output_count;\n\n    while (pad--) {\n\n        AVFilterInOut *currlinkn = av_mallocz(sizeof(AVFilterInOut));\n\n\n\n        currlinkn->filter  = filt_ctx;\n\n        currlinkn->pad_idx = pad;\n\n        insert_inout(curr_inputs, currlinkn);\n\n    }\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1907, "prediction": "0", "true_label": "0", "raw_text": "6_cpu_has_work;\n\n    cc->do_interrupt = x86_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;\n\n    cc->dump_state = x86_cpu_dump_state;\n\n    cc->set_pc = x86_cpu_set_pc;\n\n    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = x86_cpu_gdb_read_register;\n\n    cc->gdb_write_register = x86_cpu_gdb_write_register;\n\n    cc->get_arch_id = x86_cpu_get_arch_id;\n\n    cc->get_paging_enabled = x86_cpu_get_paging_enabled;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = x86_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_memory_mapping = x86_cpu_get_memory_mapping;\n\n    cc->get_phys_page_debug = x86_cpu_get_phys_page_debug;\n\n    cc->write_elf64_note = x86_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = x86_cpu_write_elf64_qemunote;\n\n    cc->write_elf32_note = x86_cpu_write_elf32_note;\n\n    cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;\n\n    cc->vmsd = &vmstate_x86_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->debug_excp_handler = breakpoint_handler;\n\n#endif\n\n    cc->cpu_exec_enter = x86_cpu_exec_enter;\n\n    cc->cpu_exec_exit = x86_cpu_exec_exit;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1908, "prediction": "0", "true_label": "0", "raw_text": "Question: static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    audsettings_t obt_as = *as;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_RECORD,\n\n        conf.source,\n\n        \"pcm.capture\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        NULL,                   /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for capture failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1909, "prediction": "0", "true_label": "0", "raw_text": "Question: uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)\n\n{\n\n    CPU_DoubleU farg;\n\n    int isneg;\n\n    int ret;\n\n    farg.ll = arg;\n\n    isneg = float64_is_neg(farg.d);\n\n    if (unlikely(float64_is_nan(farg.d))) {\n\n        if (float64_is_signaling_nan(farg.d)) {\n\n            /* Signaling NaN: flags are undefined */\n\n            ret = 0x00;\n\n        } else {\n\n            /* Quiet NaN */\n\n            ret = 0x11;\n\n        }\n\n    } else if (unlikely(float64_is_infinity(farg.d))) {\n\n        /* +/- infinity */\n\n        if (isneg)\n\n            ret = 0x09;\n\n        else\n\n            ret = 0x05;\n\n    } else {\n\n        if (float64_is_zero(farg.d)) {\n\n            /* +/- zero */\n\n            if (isneg)\n\n                ret = 0x12;\n\n            else\n\n                ret = 0x02;\n\n        } else {\n\n            if (isden(farg.d)) {\n\n                /* Denormalized numbers */\n\n                ret = 0x10;\n\n            } else {\n\n                /* Normalized numbers */\n\n                ret = 0x00;\n\n            }\n\n            if (isneg) {\n\n                ret |= 0x08;\n\n            } else {\n\n                ret |= 0x04;\n\n            }\n\n        }\n\n    }\n\n    if (set_fprf) {\n\n        /* We update FPSCR_FPRF */\n\n        env->fpscr &= ~(0x1F << FPSCR_FPRF);\n\n        env->fpscr |= ret << FPSCR_FPRF;\n\n    }\n\n    /* We just need fpcc to update Rc1 */\n\n    return ret & 0xF;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1910, "prediction": "0", "true_label": "0", "raw_text": ") {\n\n                    s->cr[VGA_CRTC_OVERFLOW] =\n\n                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);\n\n                }\n\n                return;\n\n            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&\n\n                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n                /* extra CGA compatibility hacks (not in standard VGA) */\n\n                if (s->cr_index == VGA_CRTC_MAX_SCAN &&\n\n                    val == 7 &&\n\n                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    return;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&\n\n                           val == 6 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xd;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&\n\n                           val == 7 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xe;\n\n                }\n\n            }\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1911, "prediction": "0", "true_label": "0", "raw_text": "Question: static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1912, "prediction": "0", "true_label": "0", "raw_text": "Question: static void dhcp_decode(const uint8_t *buf, int size,\n\n                        int *pmsg_type)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n\n\n    p = buf;\n\n    p_end = buf + size;\n\n    if (size < 5)\n\n        return;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1913, "prediction": "0", "true_label": "0", "raw_text": " = &xfer->trbs[xfer->trb_count-1];\n\n\n\n    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,\n\n                              xfer->epctx->epid, xfer->streamid);\n\n\n\n    /* at most one Event Data TRB allowed after STATUS */\n\n    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {\n\n        trb_status--;\n\n    }\n\n\n\n    /* do some sanity checks */\n\n    if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n\n        DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\",\n\n                TRB_TYPE(*trb_setup));\n\n        return -1;\n\n    }\n\n    if (TRB_TYPE(*trb_status) != TR_STATUS) {\n\n        DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\",\n\n                TRB_TYPE(*trb_status));\n\n        return -1;\n\n    }\n\n    if (!(trb_setup->control & TRB_TR_IDT)) {\n\n        DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\");\n\n        return -1;\n\n    }\n\n    if ((trb_setup->status & 0x1ffff) != 8) {\n\n        DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\",\n\n                (trb_setup->status & 0x1ffff));\n\n        return -1;\n\n    }\n\n\n\n    bmRequestType = trb_setup->parameter;\n\n\n\n    xfer->in_xfer = bmRequestType & USB_DIR_IN;\n\n    xfer->iso_xfer = false;\n\n    xfer->timed_xfer = false;\n\n\n\n    if (xhci_setup_packet(xfer) < 0) {\n\n        return -1;\n\n    }\n\n    xfer->packet.parameter = trb_setup->parameter;\n\n\n\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n\n\n    xhci_try_complete_packet(xfer);\n\n    if (!xfer->running_async && !xfer->running_retry) {\n\n        xhci_kick_epctx(xfer->epctx, 0);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1914, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_free_timer(QEMUTimer *ts)\n\n{\n\n    g_free(ts);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1915, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int dvdsub_close(AVCodecContext *avctx)\n\n{\n\n    DVDSubContext *ctx = avctx->priv_data;\n\n    av_freep(&ctx->buf);\n\n    ctx->buf_size = 0;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1916, "prediction": "0", "true_label": "0", "raw_text": "Question: static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return toclen;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1917, "prediction": "0", "true_label": "0", "raw_text": "Question: void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n    } else if (bs->file) {\n\n        bdrv_invalidate_cache(bs->file->bs, &local_err);\n\n    }\n\n    if (local_err) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1918, "prediction": "0", "true_label": "0", "raw_text": "Question: static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);\n\n\n\n    /* USB misc control 1/2 */\n\n    pci_set_long(pci_conf + 0x40,0x00001000);\n\n    /* PM capability */\n\n    pci_set_long(pci_conf + 0x80,0x00020001);\n\n    /* USB legacy support  */\n\n    pci_set_long(pci_conf + 0xc0,0x00002000);\n\n\n\n    return usb_uhci_common_initfn(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1919, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1920, "prediction": "0", "true_label": "1", "raw_text": "Question: static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIONvidia3d0Quirk *data;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vdev->bars[1].region.size) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->data = data = g_malloc0(sizeof(*data));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);\n\n    quirk->nr_mem = 2;\n\n    data->vdev = vdev;\n\n\n\n    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,\n\n                          data, \"vfio-nvidia-3d4-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);\n\n\n\n    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,\n\n                          data, \"vfio-nvidia-3d0-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,\n\n                      quirk, next);\n\n\n\n    trace_vfio_quirk_nvidia_3d0_probe(vdev->vbasedev.name);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1921, "prediction": "0", "true_label": "0", "raw_text": "Question: static int cookie_string(AVDictionary *dict, char **cookies)\n\n{\n\n    AVDictionaryEntry *e = NULL;\n\n    int len = 1;\n\n\n\n    // determine how much memory is needed for the cookies string\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n\n\n    // reallocate the cookies\n\n    e = NULL;\n\n    if (*cookies) av_free(*cookies);\n\n    *cookies = av_malloc(len);\n\n    if (!cookies) return AVERROR(ENOMEM);\n\n    *cookies[0] = '\\0';\n\n\n\n    // write out the cookies\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1922, "prediction": "0", "true_label": "1", "raw_text": "0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {\n\n            *physical = address & env->PAMask;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xFFFFFFFF80000000ULL) {\n\n        /* xkseg */\n\n        if (kernel_mode && KX &&\n\n            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n#endif\n\n    } else if (address < (int32_t)KSEG1_BASE) {\n\n        /* kseg0 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG0_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG2_BASE) {\n\n        /* kseg1 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG1_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG3_BASE) {\n\n        /* sseg (kseg2) */\n\n        if (supervisor_mode || kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else {\n\n        /* kseg3 */\n\n        /* XXX: debug segment is not emulated */\n\n        if (kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1923, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1924, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1925, "prediction": "0", "true_label": "0", "raw_text": "\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, \"\");\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* seek to 0 */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-seek',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \", \"\n\n                          \" 'offset': %d, 'whence': %d } }\",\n\n                          id, 0, SEEK_SET);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    qmp_assert_no_error(ret);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"position\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(!eof);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, enc);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n    g_free(enc);\n\n\n\n    /* close */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-close',\"\n\n                          \" 'arguments': {'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1926, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1927, "prediction": "0", "true_label": "0", "raw_text": "pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1928, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1929, "prediction": "0", "true_label": "0", "raw_text": "\n\n\n\n      c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;\n\n      c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;\n\n      c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;\n\n      c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;\n\n\n\n      c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;\n\n      c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;\n\n      c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;\n\n      c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;\n\n      }\n\n  }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1930, "prediction": "0", "true_label": "0", "raw_text": " height, int linesize,\n\n            vp8_mc_func mc_func[3][3])\n\n{\n\n    if (AV_RN32A(mv)) {\n\n        static const uint8_t idx[3][8] = {\n\n            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,\n\n                                        // also function pointer index\n\n            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required\n\n            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels\n\n        };\n\n        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];\n\n        int my = (mv->y << luma)&7, my_idx = idx[0][my];\n\n\n\n        x_off += mv->x >> (3 - luma);\n\n        y_off += mv->y >> (3 - luma);\n\n\n\n        // edge emulation\n\n        src += y_off * linesize + x_off;\n\n        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - idx[2][my]) {\n\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n\n                                block_w + idx[1][mx], block_h + idx[1][my],\n\n                                x_off - mx_idx, y_off - my_idx, width, height);\n\n            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n        }\n\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n\n    } else\n\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1931, "prediction": "0", "true_label": "1", "raw_text": "Question: static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1932, "prediction": "0", "true_label": "1", "raw_text": "v_loop_filter_simple_ssse3;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_ssse3;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_ssse3;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_ssse3;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_ssse3;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_ssse3;\n\n    }\n\n\n\n    if (EXTERNAL_SSE4(cpu_flags)) {\n\n        c->vp8_idct_dc_add                  = ff_vp8_idct_dc_add_sse4;\n\n\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_sse4;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse4;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse4;\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1933, "prediction": "0", "true_label": "0", "raw_text": "l & 0x0FFE0000)) |\n\n                    (virtual & 0x0001F000);\n\n                if (*BATl & 0x00000001)\n\n                    ctx->prot = PAGE_READ;\n\n                if (*BATl & 0x00000002)\n\n                    ctx->prot = PAGE_WRITE | PAGE_READ;\n\n#if defined (DEBUG_BATS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"BAT %d match: r 0x\" PADDRX\n\n                            \" prot=%c%c\\n\",\n\n                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                            ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n#endif\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & 0xF0000000;\n\n                BEPIl = *BATu & 0x0FFE0000;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                        \" BATl 0x\" ADDRX \" \\n\\t\"\n\n                        \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\",\n\n                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                        *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1934, "prediction": "0", "true_label": "0", "raw_text": "s->dirty_bytes_rate && transferred_bytes > 10000) {\n\n                s->expected_downtime = s->dirty_bytes_rate / bandwidth;\n\n            }\n\n\n\n            qemu_file_reset_rate_limit(s->to_dst_file);\n\n            initial_time = current_time;\n\n            initial_bytes = qemu_ftell(s->to_dst_file);\n\n        }\n\n        if (qemu_file_rate_limit(s->to_dst_file)) {\n\n            /* usleep expects microseconds */\n\n            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);\n\n        }\n\n    }\n\n\n\n    trace_migration_thread_after_loop();\n\n    /* If we enabled cpu throttling for auto-converge, turn it off. */\n\n    cpu_throttle_stop();\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_cleanup();\n\n    if (s->state == MIGRATION_STATUS_COMPLETED) {\n\n        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);\n\n        s->total_time = end_time - s->total_time;\n\n        if (!entered_postcopy) {\n\n            s->downtime = end_time - start_time;\n\n        }\n\n        if (s->total_time) {\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                       ((double) s->total_time)) / 1000;\n\n        }\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    } else {\n\n        if (old_vm_running && !entered_postcopy) {\n\n            vm_start();\n\n        } else {\n\n            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {\n\n                runstate_set(RUN_STATE_POSTMIGRATE);\n\n            }\n\n        }\n\n    }\n\n    qemu_bh_schedule(s->cleanup_bh);\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1935, "prediction": "0", "true_label": "0", "raw_text": "Question: void replay_input_event(QemuConsole *src, InputEvent *evt)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        /* Nothing */\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_add_input_event(qapi_clone_InputEvent(evt));\n\n    } else {\n\n        qemu_input_event_send_impl(src, evt);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1936, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline unsigned int get_uint(ShortenContext *s, int k)\n\n{\n\n    if (s->version != 0)\n\n        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);\n\n    return get_ur_golomb_shorten(&s->gb, k);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1937, "prediction": "1", "true_label": "1", "raw_text": " = src[i+2] * mul;\n\n\n\n          temp1 = temp1 + round;\n\n          dst[i] = temp >> shift;\n\n          temp3 = src[i+3] * mul;\n\n          temp2 = temp2 + round;\n\n\n\n          dst[i+1] = temp1 >> shift;\n\n          temp4 = src[i + 4] * mul;\n\n          temp3 = temp3 + round;\n\n          dst[i+2] = temp2 >> shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          temp4 = temp4 + round;\n\n          dst[i+3] = temp3 >> shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 >> shift;\n\n          temp5 = temp5 + round;\n\n          temp7 = src[i+7] * mul;\n\n          temp6 = temp6 + round;\n\n\n\n          dst[i+5] = temp5 >> shift;\n\n          temp7 = temp7 + round;\n\n          dst[i+6] = temp6 >> shift;\n\n          dst[i+7] = temp7 >> shift;\n\n\n\n      }\n\n    } else {\n\n      shift = -shift;\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          dst[i] = temp << shift;\n\n          temp3 = src[i+3] * mul;\n\n\n\n          dst[i+1] = temp1 << shift;\n\n          temp4 = src[i + 4] * mul;\n\n          dst[i+2] = temp2 << shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          dst[i+3] = temp3 << shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 << shift;\n\n          temp7 = src[i+7] * mul;\n\n\n\n          dst[i+5] = temp5 << shift;\n\n          dst[i+6] = temp6 << shift;\n\n          dst[i+7] = temp7 << shift;\n\n\n\n      }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1938, "prediction": "0", "true_label": "1", "raw_text": "Question: static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)\n{\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n    const char *path = qemu_opt_get(opts, \"path\");\n    if (sec_model) {\n        error_report(\"Invalid argument security_model specified with handle fsdriver\");\n        return -1;\n    }\n    if (!path) {\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n    fse->path = g_strdup(path);\n    return 0;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1939, "prediction": "0", "true_label": "1", "raw_text": "Question: void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1940, "prediction": "0", "true_label": "1", "raw_text": "cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (s->memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (s->memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (s->memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (s->memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,\n\n                                   1000);\n\n    memory_region_init_ram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->flash);\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,\n\n                          \"integratorcm\", 0x00800000);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    integratorcm_do_remap(s);\n\n    /* ??? Save/restore.  */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1941, "prediction": "0", "true_label": "1", "raw_text": "Question: static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1942, "prediction": "0", "true_label": "0", "raw_text": "\",\n\n                    (csum == 0) ? \"correct\" : \"incorrect\", csum);\n\n        }\n\n\n\n        if ((s->f_code ^ 0x10) >= 0x50) {\n\n            uint8_t msg[256];\n\n\n\n            svq1_parse_string(bitbuf, msg);\n\n\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"embedded message: \\\"%s\\\"\\n\", (char *)msg);\n\n        }\n\n\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits1(bitbuf);\n\n\n\n        /* load frame size */\n\n        frame_size_code = get_bits(bitbuf, 3);\n\n\n\n        if (frame_size_code == 7) {\n\n            /* load width, height (12 bits each) */\n\n            s->width  = get_bits(bitbuf, 12);\n\n            s->height = get_bits(bitbuf, 12);\n\n\n\n            if (!s->width || !s->height)\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            /* get width, height from table */\n\n            s->width  = ff_svq1_frame_size_table[frame_size_code].width;\n\n            s->height = ff_svq1_frame_size_table[frame_size_code].height;\n\n        }\n\n    }\n\n\n\n    /* unknown fields */\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);    /* use packet checksum if (1) */\n\n        skip_bits1(bitbuf);    /* component checksums after image data if (1) */\n\n\n\n        if (get_bits(bitbuf, 2) != 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 4);\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 2);\n\n\n\n        while (get_bits1(bitbuf) == 1)\n\n            skip_bits(bitbuf, 8);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1943, "prediction": "0", "true_label": "1", "raw_text": "Question: void prepare_grab(void)\n\n{\n\n    fprintf(stderr, \"Must supply at least one input file\\n\");\n\n    exit(1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1944, "prediction": "0", "true_label": "1", "raw_text": "Question: static int compare_codec_desc(const void *a, const void *b)\n\n{\n\n    const AVCodecDescriptor * const *da = a;\n\n    const AVCodecDescriptor * const *db = b;\n\n\n\n    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n\n           strcmp((*da)->name, (*db)->name);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1945, "prediction": "-1", "true_label": "1", "raw_text": "_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, NULL, s);\n\n    set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = do_write(s->fd, &hdr, sizeof(hdr));\n\n    if (ret) {\n\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -EIO;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = do_writev(s->fd, iov, wlen, aio_req->iov_offset);\n\n        if (ret) {\n\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -EIO;\n\n        }\n\n    }\n\n\n\n    set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, NULL, s);\n\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1946, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO.\n"}], [{"ID": 1947, "prediction": "0", "true_label": "1", "raw_text": "ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"lwp\";\n\n        break;\n\n    case SWP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sw(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sw(t1, t0, ctx);\n\n        opn = \"swp\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case LDP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"ldp\";\n\n        break;\n\n    case SDP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sd(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sd(t1, t0, ctx);\n\n        opn = \"sdp\";\n\n        break;\n\n#endif\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s, %s, %d(%s)\", opn, regnames[rd], offset, regnames[base]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1948, "prediction": "0", "true_label": "1", "raw_text": "Question: static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1949, "prediction": "0", "true_label": "0", "raw_text": "         ][0];\n\n                P[3][1] = mv_table[mot_xy - mot_stride + 1         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            pred_x= P[1][0];\n\n            pred_y= P[1][1];\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    /* intra / predictive decision */\n\n//    xx = mb_x * 16;\n\n//    yy = mb_y * 16;\n\n\n\n//    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n//    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    dmin= halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n\n\n//    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    mv_table[mot_xy][0]= mx;\n\n    mv_table[mot_xy][1]= my;\n\n    return dmin;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1950, "prediction": "0", "true_label": "0", "raw_text": "_index + consumed));\n\n                ff_h264_decode_seq_parameter_set(h);\n\n            }\n\n\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n\n                s->low_delay=1;\n\n\n\n            if(avctx->has_b_frames < 2)\n\n                avctx->has_b_frames= !s->low_delay;\n\n            break;\n\n        case NAL_PPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n\n\n            break;\n\n        case NAL_AUD:\n\n        case NAL_END_SEQUENCE:\n\n        case NAL_END_STREAM:\n\n        case NAL_FILLER_DATA:\n\n        case NAL_SPS_EXT:\n\n        case NAL_AUXILIARY_SLICE:\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n\n        }\n\n\n\n        if(context_count == h->max_contexts) {\n\n            execute_decode_slices(h, context_count);\n\n            context_count = 0;\n\n        }\n\n\n\n        if (err < 0)\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n\n        else if(err == 1) {\n\n            /* Slice could not be decoded in parallel mode, copy down\n\n             * NAL unit stuff to context 0 and restart. Note that\n\n             * rbsp_buffer is not transferred, but since we no longer\n\n             * run in parallel mode this should not be an issue. */\n\n            h->nal_unit_type = hx->nal_unit_type;\n\n            h->nal_ref_idc   = hx->nal_ref_idc;\n\n            hx = h;\n\n            goto again;\n\n        }\n\n    }\n\n    }\n\n    if(context_count)\n\n        execute_decode_slices(h, context_count);\n\n    return buf_index;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1951, "prediction": "0", "true_label": "1", "raw_text": " (pic_found && !dctx->remaining) {\n\n        if (!buf_size) /* EOF considered as end of frame */\n\n            return 0;\n\n        for (; i < buf_size; i++) {\n\n            dctx->cur_byte++;\n\n            state = (state << 8) | buf[i];\n\n\n\n            if (dctx->cur_byte == 24) {\n\n                dctx->h = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 26) {\n\n                dctx->w = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 42) {\n\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n\n\n                if (cid <= 0)\n\n                    continue;\n\n\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n\n                if (dctx->remaining <= 0) {\n\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n\n                    if (dctx->remaining <= 0)\n\n                        return dctx->remaining;\n\n                }\n\n                if (buf_size - i + 47 >= dctx->remaining) {\n\n                    int remaining = dctx->remaining;\n\n\n\n                    pc->frame_start_found = 0;\n\n                    pc->state64 = -1;\n\n                    dctx->cur_byte = 0;\n\n                    dctx->remaining = 0;\n\n                    return remaining;\n\n                } else {\n\n                    dctx->remaining -= buf_size;\n\n                }\n\n            }\n\n        }\n\n    } else if (pic_found) {\n\n        if (dctx->remaining > buf_size) {\n\n            dctx->remaining -= buf_size;\n\n        } else {\n\n            int remaining = dctx->remaining;\n\n\n\n            pc->frame_start_found = 0;\n\n            pc->state64 = -1;\n\n            dctx->cur_byte = 0;\n\n            dctx->remaining = 0;\n\n            return remaining;\n\n        }\n\n    }\n\n    pc->frame_start_found = pic_found;\n\n    pc->state64 = state;\n\n    return END_NOT_FOUND;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1952, "prediction": "0", "true_label": "0", "raw_text": "buffer_occupancy)\n\n        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;\n\n    else\n\n        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;\n\n\n\n    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;\n\n    priv->rc_params.rc = (VAEncMiscParameterRateControl) {\n\n        .bits_per_second   = avctx->bit_rate,\n\n        .target_percentage = 66,\n\n        .window_size       = 1000,\n\n        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),\n\n        .min_qp            = (avctx->qmin >= 0 ? avctx->qmin : 18),\n\n        .basic_unit_size   = 0,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->rc_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->rc_params);\n\n\n\n    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;\n\n    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {\n\n        .initial_buffer_fullness = hrd_initial_buffer_fullness,\n\n        .buffer_size             = hrd_buffer_size,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->hrd_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->hrd_params);\n\n\n\n    // These still need to be  set for pic_init_qp/slice_qp_delta.\n\n    priv->fixed_qp_idr = 26;\n\n    priv->fixed_qp_p   = 26;\n\n    priv->fixed_qp_b   = 26;\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\"PRId64\" bps.\\n\",\n\n           avctx->bit_rate);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1953, "prediction": "0", "true_label": "1", "raw_text": "  src[0] + 3*src[srcStride])>>2;\n\n\n\n\t\tfor(x=mmxSize-1; x<srcWidth-1; x++){\n\n\t\t\tdst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;\n\n\t\t\tdst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;\n\n\t\t}\n\n\t\tdst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;\n\n\t\tdst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;\n\n\n\n\t\tdst+=dstStride*2;\n\n\t\tsrc+=srcStride;\n\n\t}\n\n\n\n\t// last line\n\n#if 1\n\n\tdst[0]= src[0];\n\n\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n#else\n\n\tfor(x=0; x<srcWidth; x++){\n\n\t\tdst[2*x+0]=\n\n\t\tdst[2*x+1]= src[x];\n\n\t}\n\n#endif\n\n\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1954, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_mtmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        TCGv msr = tcg_temp_new();\n\n\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);\n\n#else\n\n        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n        gen_helper_store_msr(cpu_env, msr);\n\n        tcg_temp_free(msr);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1955, "prediction": "-1", "true_label": "1", "raw_text": "Question: static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 1956, "prediction": "0", "true_label": "1", "raw_text": "Question: static int huff_build10(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[1024];\n\n    uint32_t codes[1024];\n\n    uint8_t bits[1024];\n\n    uint16_t syms[1024];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        he[i].sym = 1023 - i;\n\n        he[i].len = len[i];\n\n\n\n    }\n\n    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);\n\n\n\n    code = 1;\n\n    for (i = 1023; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1957, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1958, "prediction": "0", "true_label": "0", "raw_text": "_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    ByteIOContext *bc = &s->pb;\n\n    int64_t pos;\n\n    int inited_stream_count;\n\n\n\n    nut->avf= s;\n\n    \n\n    av_set_pts_info(s, 60, 1, AV_TIME_BASE);\n\n\n\n    /* main header */\n\n    pos=0;\n\n    for(;;){\n\n        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"no main startcode found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_main_header(nut) >= 0)\n\n            break;\n\n    }\n\n    \n\n    \n\n    s->bit_rate = 0;\n\n\n\n    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);\n\n\n\n    /* stream headers */\n\n    pos=0;\n\n    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){\n\n        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"not all stream headers found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_stream_header(nut) >= 0)\n\n            inited_stream_count++;\n\n    }\n\n\n\n    /* info headers */\n\n    pos=0;\n\n    for(;;){\n\n        uint64_t startcode= find_any_startcode(bc, pos);\n\n        pos= url_ftell(bc);\n\n\n\n        if(startcode==0){\n\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n\n            return -1;\n\n        }else if(startcode == KEYFRAME_STARTCODE){\n\n            url_fseek(bc, -8, SEEK_CUR); //FIXME\n\n            break;\n\n        }else if(startcode != INFO_STARTCODE){\n\n            continue;\n\n        }\n\n\n\n        decode_info_header(nut);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1959, "prediction": "0", "true_label": "1", "raw_text": "Question: int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)\n\n{\n\n    int ret;\n\n\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"reinit context\\n\");\n\n\n\n    /* 1. streamoff */\n\n    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);\n\n    if (ret)\n\n        av_log(s->avctx, AV_LOG_ERROR, \"capture VIDIOC_STREAMOFF\\n\");\n\n\n\n    /* 2. unmap the capture buffers (v4l2 and ffmpeg):\n\n     *    we must wait for all references to be released before being allowed\n\n     *    to queue new buffers.\n\n     */\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"waiting for user to release AVBufferRefs\\n\");\n\n    if (atomic_load(&s->refcount))\n\n        while(sem_wait(&s->refsync) == -1 && errno == EINTR);\n\n\n\n    ff_v4l2_context_release(&s->capture);\n\n\n\n    /* 3. get the new capture format */\n\n    ret = ff_v4l2_context_get_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"query the new capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 4. set the capture format */\n\n    ret = ff_v4l2_context_set_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"setting capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 5. complete reinit */\n\n    sem_destroy(&s->refsync);\n\n    sem_init(&s->refsync, 0, 0);\n\n    s->draining = 0;\n\n    s->reinit = 0;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1960, "prediction": "0", "true_label": "1", "raw_text": "sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1961, "prediction": "1", "true_label": "1", "raw_text": " i];\n\n\n\n\n    s->reset_block_lengths = 1;\n\n\n\n    if (s->use_noise_coding) {\n\n\n\n        /* init the noise generator */\n\n        if (s->use_exp_vlc) {\n\n            s->noise_mult = 0.02;\n\n        } else {\n\n            s->noise_mult = 0.04;\n\n\n\n\n#ifdef TRACE\n\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n\n            s->noise_table[i] = 1.0 * s->noise_mult;\n\n#else\n\n        {\n\n            unsigned int seed;\n\n            float norm;\n\n            seed = 1;\n\n            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n\n                seed = seed * 314159 + 1;\n\n                s->noise_table[i] = (float)((int)seed) * norm;\n\n\n\n#endif\n\n\n\n\n    /* choose the VLC tables for the coefficients */\n\n    coef_vlc_table = 2;\n\n    if (avctx->sample_rate >= 32000) {\n\n        if (bps1 < 0.72) {\n\n            coef_vlc_table = 0;\n\n        } else if (bps1 < 1.16) {\n\n            coef_vlc_table = 1;\n\n\n\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n\n                  s->coef_vlcs[0]);\n\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n\n                  s->coef_vlcs[1]);\n\n\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1962, "prediction": "1", "true_label": "1", "raw_text": "Question: av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n{\n    IVI45DecContext *ctx = avctx->priv_data;\n    ivi_free_buffers(&ctx->planes[0]);\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n    av_frame_free(&ctx->p_frame);\n    return 0;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1963, "prediction": "0", "true_label": "1", "raw_text": "Question: int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1964, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_s390_notify(void *opaque, uint16_t vector)\n\n{\n\n    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;\n\n    uint64_t token = s390_virtio_device_vq_token(dev, vector);\n\n\n\n    /* XXX kvm dependency! */\n\n    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1965, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)\n\n{\n\n    if (throttle_conflicting(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (!throttle_is_valid(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (throttle_max_is_missing_limit(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1966, "prediction": "0", "true_label": "1", "raw_text": " 8;\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            width = get_bits(gb, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    coeff = get_bits(gb, width);\n\n                    if (coeff) {\n\n                        if (get_bits1(gb))\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n            s->dsp.vector_fmul_scalar(coeffs, coeffs, s->frame_len / 2, s->frame_len);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    s->fmt_conv.float_to_int16_interleave(out, (const float **)s->coeffs_ptr,\n\n                                          s->frame_len, s->channels);\n\n\n\n    if (!s->first) {\n\n        int count = s->overlap_len * s->channels;\n\n        int shift = av_log2(count);\n\n        for (i = 0; i < count; i++) {\n\n            out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift;\n\n        }\n\n    }\n\n\n\n    memcpy(s->previous, out + s->block_size,\n\n           s->overlap_len * s->channels * sizeof(*out));\n\n\n\n    s->first = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1967, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_main_loop_start(void)\n\n{\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1968, "prediction": "0", "true_label": "1", "raw_text": "Question: static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n\n                                 const uint8_t *buf, int size, int64_t pts)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    AVStream *st = ctx->streams[stream_index];\n\n    StreamInfo *stream = st->priv_data;\n\n    int64_t dts;\n\n    int len;\n\n\n\n    /* XXX: system clock should be computed precisely, especially for\n\n       CBR case. The current mode gives at least something coherent */\n\n    if (stream_index == s->scr_stream_index)\n\n        s->last_scr = pts;\n\n    \n\n#if 0\n\n    printf(\"%d: pts=%0.3f scr=%0.3f\\n\", \n\n           stream_index, pts / 90000.0, s->last_scr / 90000.0);\n\n#endif\n\n    \n\n    /* XXX: currently no way to pass dts, will change soon */\n\n    dts = AV_NOPTS_VALUE;\n\n\n\n    /* we assume here that pts != AV_NOPTS_VALUE */\n\n    if (stream->start_pts == AV_NOPTS_VALUE) {\n\n        stream->start_pts = pts;\n\n        stream->start_dts = dts;\n\n    }\n\n    while (size > 0) {\n\n        len = s->packet_data_max_size - stream->buffer_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n\n        stream->buffer_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        while (stream->buffer_ptr >= s->packet_data_max_size) {\n\n            /* output the packet */\n\n            flush_packet(ctx, stream_index,\n\n                         stream->start_pts, stream->start_dts, s->last_scr);\n\n            /* Make sure only the FIRST pes packet for this frame has\n\n               a timestamp */\n\n            stream->start_pts = AV_NOPTS_VALUE;\n\n            stream->start_dts = AV_NOPTS_VALUE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1969, "prediction": "0", "true_label": "1", "raw_text": "Question: static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1970, "prediction": "1", "true_label": "0", "raw_text": "Question: av_cold void avcodec_register(AVCodec *codec)\n\n{\n\n    AVCodec **p;\n\n    avcodec_init();\n\n    p = &first_avcodec;\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n    *p          = codec;\n\n    codec->next = NULL;\n\n\n\n    if (codec->init_static_data)\n\n        codec->init_static_data(codec);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1971, "prediction": "0", "true_label": "1", "raw_text": "Question: static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n\n{\n\n    int i;\n\n\n\n    if ((p[1] & 0xF) == 3) {\n\n        /* NAA designator type */\n\n        if (p[3] != 8) {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = ldq_be_p(p + 4);\n\n        return 0;\n\n    }\n\n\n\n    if ((p[1] & 0xF) == 8) {\n\n        /* SCSI name string designator type */\n\n        if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) {\n\n            return -EINVAL;\n\n        }\n\n        if (p[3] > 20 && p[24] != ',') {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = 0;\n\n        for (i = 8; i < 24; i++) {\n\n            char c = toupper(p[i]);\n\n            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);\n\n            *p_wwn = (*p_wwn << 4) | c;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -EINVAL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1972, "prediction": "0", "true_label": "1", "raw_text": "quant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n#if HAS_ADVANCED_PROFILE\n\n    if (v->profile <= PROFILE_MAIN)\n\n#endif\n\n    {\n\n        if (v->extended_mv) v->mvrange = get_prefix(gb, 0, 3);\n\n        if (v->multires) v->respic = get_bits(gb, 2);\n\n    }\n\n#if HAS_ADVANCED_PROFILE\n\n    else\n\n    {\n\n        v->s.ac_pred = get_bits(gb, 1);\n\n        if (v->postprocflag) v->postproc = get_bits(gb, 1);\n\n        /* 7.1.1.34 + 8.5.2 */\n\n        if (v->overlap && v->pq<9)\n\n        {\n\n            v->condover = get_bits(gb, 1);\n\n            if (v->condover)\n\n            {\n\n                v->condover = 2+get_bits(gb, 1);\n\n                if (v->condover == 3)\n\n                {\n\n                    status = bitplane_decoding(&v->over_flags_plane, v);\n\n                    if (status < 0) return -1;\n\n#if TRACE\n\n                    av_log(v->s.avctx, AV_LOG_DEBUG, \"Overflags plane encoding: \"\n\n                           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n                }\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return status;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1973, "prediction": "0", "true_label": "0", "raw_text": "\\n\",\n\n                   dec_ctx->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[dec_ctx->pix_fmt].name\n\n                                                    : \"unknown\");\n\n            printf(\"level=%d\\n\", dec_ctx->level);\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            printf(\"sample_rate=%s\\n\", value_string(val_str, sizeof(val_str),\n\n                                                    dec_ctx->sample_rate,\n\n                                                    unit_hertz_str));\n\n            printf(\"channels=%d\\n\", dec_ctx->channels);\n\n            printf(\"bits_per_sample=%d\\n\",\n\n                   av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n        }\n\n    } else {\n\n        printf(\"codec_type=unknown\\n\");\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n\n        printf(\"id=0x%x\\n\", stream->id);\n\n    printf(\"r_frame_rate=%d/%d\\n\",\n\n           stream->r_frame_rate.num, stream->r_frame_rate.den);\n\n    printf(\"avg_frame_rate=%d/%d\\n\",\n\n           stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n\n    printf(\"time_base=%d/%d\\n\",\n\n           stream->time_base.num, stream->time_base.den);\n\n    printf(\"start_time=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->start_time, &stream->time_base));\n\n    printf(\"duration=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->duration, &stream->time_base));\n\n    if (stream->nb_frames)\n\n        printf(\"nb_frames=%\"PRId64\"\\n\", stream->nb_frames);\n\n\n\n    while ((tag = av_dict_get(stream->metadata, \"\", tag,\n\n                              AV_DICT_IGNORE_SUFFIX)))\n\n        printf(\"TAG:%s=%s\\n\", tag->key, tag->value);\n\n\n\n    printf(\"[/STREAM]\\n\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1974, "prediction": "0", "true_label": "0", "raw_text": "Question: static void encode_block(MpegEncContext *s, int16_t *block, int n)\n\n{\n\n    int i, j, table_id;\n\n    int component, dc, last_index, val, run;\n\n    MJpegContext *m = s->mjpeg_ctx;\n\n\n\n    /* DC coef */\n\n    component = (n <= 3 ? 0 : (n&1) + 1);\n\n    table_id = (n <= 3 ? 0 : 1);\n\n    dc = block[0]; /* overflow is impossible */\n\n    val = dc - s->last_dc[component];\n\n\n\n    ff_mjpeg_encode_coef(m, table_id, val, 0);\n\n\n\n    s->last_dc[component] = dc;\n\n\n\n    /* AC coefs */\n\n\n\n    run = 0;\n\n    last_index = s->block_last_index[n];\n\n    table_id |= 2;\n\n\n\n    for(i=1;i<=last_index;i++) {\n\n        j = s->intra_scantable.permutated[i];\n\n        val = block[j];\n\n\n\n        if (val == 0) {\n\n            run++;\n\n        } else {\n\n            while (run >= 16) {\n\n                ff_mjpeg_encode_code(m, table_id, 0xf0);\n\n                run -= 16;\n\n            }\n\n            ff_mjpeg_encode_coef(m, table_id, val, run);\n\n            run = 0;\n\n        }\n\n    }\n\n\n\n    /* output EOB only if not already 64 values */\n\n    if (last_index < 63 || run != 0)\n\n        ff_mjpeg_encode_code(m, table_id, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1975, "prediction": "0", "true_label": "0", "raw_text": "\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we cant use MMX here without overwriting this arrays tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2rgbXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstFormat);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1976, "prediction": "1", "true_label": "1", "raw_text": "srp;\n\n    SCSIDevice *sdev;\n\n    int n, id, lun;\n\n\n\n    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);\n\n\n\n    /* Qemu vs. linux issue with LUNs to be sorted out ... */\n\n    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;\n\n    if (!sdev) {\n\n        dprintf(\"VSCSI: Command for id %d with no drive\\n\", id);\n\n        if (srp->cmd.cdb[0] == INQUIRY) {\n\n            vscsi_inquiry_no_target(s, req);\n\n        } else {\n\n            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        } return 1;\n\n    }\n\n\n\n    req->sdev = sdev;\n\n    req->lun = lun;\n\n    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);\n\n\n\n    dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\",\n\n            req->qtag, srp->cmd.cdb[0], id, lun, n);\n\n\n\n    if (n) {\n\n        /* Transfer direction must be set before preprocessing the\n\n         * descriptors\n\n         */\n\n        req->writing = (n < 1);\n\n\n\n        /* Preprocess RDMA descriptors */\n\n        vscsi_preprocess_desc(req);\n\n    }\n\n\n\n    /* Get transfer direction and initiate transfer */\n\n    if (n > 0) {\n\n        req->data_len = n;\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    } else if (n < 0) {\n\n        req->data_len = -n;\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    }\n\n    /* Don't touch req here, it may have been recycled already */\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes"}], [{"ID": 1977, "prediction": "0", "true_label": "1", "raw_text": "1;\n\n    last_iov = iov;\n\n    len += offset;\n\n\n\n    while (last_iov->iov_len < len) {\n\n        len -= last_iov->iov_len;\n\n\n\n        last_iov++;\n\n        iovlen++;\n\n    }\n\n\n\n    diff = last_iov->iov_len - len;\n\n    last_iov->iov_len -= diff;\n\n\n\n    while (iov->iov_len <= offset) {\n\n        offset -= iov->iov_len;\n\n\n\n        iov++;\n\n        iovlen--;\n\n    }\n\n\n\n    iov->iov_base = (char *) iov->iov_base + offset;\n\n    iov->iov_len -= offset;\n\n\n\n    {\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n        struct msghdr msg;\n\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_iov = iov;\n\n        msg.msg_iovlen = iovlen;\n\n\n\n        do {\n\n            if (do_sendv) {\n\n                ret = sendmsg(sockfd, &msg, 0);\n\n            } else {\n\n                ret = recvmsg(sockfd, &msg, 0);\n\n            }\n\n        } while (ret == -1 && errno == EINTR);\n\n#else\n\n        struct iovec *p = iov;\n\n        ret = 0;\n\n        while (iovlen > 0) {\n\n            int rc;\n\n            if (do_sendv) {\n\n                rc = send(sockfd, p->iov_base, p->iov_len, 0);\n\n            } else {\n\n                rc = qemu_recv(sockfd, p->iov_base, p->iov_len, 0);\n\n            }\n\n            if (rc == -1) {\n\n                if (errno == EINTR) {\n\n                    continue;\n\n                }\n\n                if (ret == 0) {\n\n                    ret = -1;\n\n                }\n\n                break;\n\n            }\n\n            if (rc == 0) {\n\n                break;\n\n            }\n\n            ret += rc;\n\n            iovlen--, p++;\n\n        }\n\n#endif\n\n    }\n\n\n\n    /* Undo the changes above */\n\n    iov->iov_base = (char *) iov->iov_base - offset;\n\n    iov->iov_len += offset;\n\n    last_iov->iov_len += diff;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1978, "prediction": "0", "true_label": "1", "raw_text": "\n\n\n\n                // loopfilter one row\n\n                if (s->s.h.filter.level) {\n\n                    yoff2 = yoff;\n\n                    uvoff2 = uvoff;\n\n                    lflvl_ptr = s->lflvl;\n\n                    for (col = 0; col < s->cols;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);\n\n                    }\n\n                }\n\n\n\n                // FIXME maybe we can make this more finegrained by running the\n\n                // loopfilter per-block instead of after each sbrow\n\n                // In fact that would also make intra pred left preparation easier?\n\n                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);\n\n            }\n\n        }\n\n\n\n        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {\n\n            adapt_probs(s);\n\n            ff_thread_finish_setup(ctx);\n\n        }\n\n    } while (s->pass++ == 1);\n\n    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n\n\nfinish:\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->s.refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->s.refs[i]);\n\n        if (s->next_refs[i].f->buf[0] &&\n\n            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)\n\n            return res;\n\n    }\n\n\n\n    if (!s->s.h.invisible) {\n\n        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)\n\n            return res;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    return pkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1979, "prediction": "0", "true_label": "0", "raw_text": "32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    default:\n\n        val = s->regs[saddr];\n\n        DPRINTF (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    if (!(s->regs[GT_CPU] & 0x00001000))\n\n        val = bswap32(val);\n\n\n\n    return val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1980, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    opt = qemu_opt_find(opts, name);\n\n    if (!opt) {\n\n        QemuOptDesc *desc = opts->list->desc;\n\n        int i;\n\n\n\n        for (i = 0; desc[i].name != NULL; i++) {\n\n            if (strcmp(desc[i].name, name) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (desc[i].name == NULL) {\n\n            if (i == 0) {\n\n                /* empty list -> allow any */;\n\n            } else {\n\n                fprintf(stderr, \"option \\\"%s\\\" is not valid for %s\\n\",\n\n                        name, opts->list->name);\n\n                return -1;\n\n            }\n\n        }\n\n        opt = qemu_mallocz(sizeof(*opt));\n\n        opt->name = qemu_strdup(name);\n\n        opt->opts = opts;\n\n        TAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n        if (desc[i].name != NULL) {\n\n            opt->desc = desc+i;\n\n        }\n\n    }\n\n    qemu_free((/* !const */ char*)opt->str);\n\n    opt->str = NULL;\n\n    if (value) {\n\n        opt->str = qemu_strdup(value);\n\n    }\n\n    if (qemu_opt_parse(opt) < 0) {\n\n        fprintf(stderr, \"Failed to parse \\\"%s\\\" for \\\"%s.%s\\\"\\n\", opt->str,\n\n                opts->list->name, opt->name);\n\n        qemu_opt_del(opt);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1981, "prediction": "1", "true_label": "0", "raw_text": "REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_report(\"unwanted /dev/sg*\");\n\n        return -1;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1982, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ehci_update_frindex(EHCIState *ehci, int frames)\n\n{\n\n    int i;\n\n\n\n    if (!ehci_enabled(ehci)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < frames; i++) {\n\n        ehci->frindex += 8;\n\n\n\n        if (ehci->frindex == 0x00002000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n        }\n\n\n\n        if (ehci->frindex == 0x00004000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n            ehci->frindex = 0;\n\n            if (ehci->usbsts_frindex >= 0x00004000) {\n\n                ehci->usbsts_frindex -= 0x00004000;\n\n            } else {\n\n                ehci->usbsts_frindex = 0;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1983, "prediction": "0", "true_label": "0", "raw_text": "Question: static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)\n\n{\n\n    while (uls->id != CODEC_ID_NONE) {\n\n        if(mxf_match_uid(uls->uid, *uid, 16))\n\n            break;\n\n        uls++;\n\n    }\n\n    return uls;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1984, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            g_source_remove(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        s->polling = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (!s->connected)\n\n            qemu_chr_be_generic_open(chr);\n\n        s->connected = 1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1985, "prediction": "0", "true_label": "1", "raw_text": "_bits(&s->gb, 3) != 1) /* Update Full Extended PTYPE */\n\n            return -1;\n\n        format = get_bits(&s->gb, 3);\n\n                \n\n        skip_bits(&s->gb,1); /* Custom PCF */\n\n        umvplus_dec = get_bits(&s->gb, 1); /* Unrestricted Motion Vector */\n\n        skip_bits(&s->gb, 10);\n\n        skip_bits(&s->gb, 3); /* Reserved */\n\n        \n\n        /* MPPTYPE */\n\n        s->pict_type = get_bits(&s->gb, 3) + 1;\n\n        if (s->pict_type != I_TYPE &&\n\n            s->pict_type != P_TYPE)\n\n            return -1;\n\n        skip_bits(&s->gb, 7);\n\n        \n\n        /* Get the picture dimensions */\n\n        if (format == 6) {\n\n            /* Custom Picture Format (CPFMT) */\n\n            skip_bits(&s->gb, 4); /* aspect ratio */\n\n            width = (get_bits(&s->gb, 9) + 1) * 4;\n\n            skip_bits1(&s->gb);\n\n            height = get_bits(&s->gb, 9) * 4;\n\n#ifdef DEBUG \n\n            fprintf(stderr,\"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n\n#endif            \n\n        }\n\n        else {\n\n            width = h263_format[format][0];\n\n            height = h263_format[format][1];\n\n        }\n\n        \n\n        if ((width == 0) || (height == 0))\n\n            return -1;\n\n            \n\n        if (umvplus_dec) {\n\n            skip_bits1(&s->gb); /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n\n        }\n\n            \n\n        s->qscale = get_bits(&s->gb, 5);\n\n    }\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n    s->width = width;\n\n    s->height = height;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1986, "prediction": "0", "true_label": "1", "raw_text": "_get_index(IF_SD, 0, 0);\n\n            sd = ssi_sd_init(drives_table[index].bdrv);\n\n\n\n            ssi_bus = stellaris_ssi_bus_init(&gpio_out[GPIO_D][0],\n\n                                             ssi_sd_xfer, sd,\n\n                                             ssd0323_xfer_ssi, oled);\n\n\n\n            pl022_init(0x40008000, pic[7], stellaris_ssi_bus_xfer, ssi_bus);\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        } else {\n\n            pl022_init(0x40008000, pic[7], NULL, NULL);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        /* FIXME: Obey network model.  */\n\n        stellaris_enet_init(&nd_table[0], 0x40048000, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1987, "prediction": "0", "true_label": "1", "raw_text": "ost->forced_kf_index]) {\n\n                big_picture.pict_type = AV_PICTURE_TYPE_I;\n\n                ost->forced_kf_index++;\n\n            }\n\n            ret = avcodec_encode_video(enc,\n\n                                       bit_buffer, bit_buffer_size,\n\n                                       &big_picture);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Video encoding failed\\n\");\n\n                exit_program(1);\n\n            }\n\n\n\n            if(ret>0){\n\n                pkt.data= bit_buffer;\n\n                pkt.size= ret;\n\n                if(enc->coded_frame->pts != AV_NOPTS_VALUE)\n\n                    pkt.pts= av_rescale_q(enc->coded_frame->pts, enc->time_base, ost->st->time_base);\n\n/*av_log(NULL, AV_LOG_DEBUG, \"encoder -> %\"PRId64\"/%\"PRId64\"\\n\",\n\n   pkt.pts != AV_NOPTS_VALUE ? av_rescale(pkt.pts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1,\n\n   pkt.dts != AV_NOPTS_VALUE ? av_rescale(pkt.dts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1);*/\n\n\n\n                if(enc->coded_frame->key_frame)\n\n                    pkt.flags |= AV_PKT_FLAG_KEY;\n\n                write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n                *frame_size = ret;\n\n                video_size += ret;\n\n                //fprintf(stderr,\"\\nFrame: %3d size: %5d type: %d\",\n\n                //        enc->frame_number-1, ret, enc->pict_type);\n\n                /* if two pass, output log */\n\n                if (ost->logfile && enc->stats_out) {\n\n                    fprintf(ost->logfile, \"%s\", enc->stats_out);\n\n                }\n\n            }\n\n        }\n\n        ost->sync_opts++;\n\n        ost->frame_number++;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1988, "prediction": "0", "true_label": "1", "raw_text": "Question: static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1989, "prediction": "0", "true_label": "0", "raw_text": "->usbcmd)) {\n\n            if (!ehci_enabled(s)) {\n\n                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            ehci_update_halt(s);\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_set_interrupt(s, 0);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1990, "prediction": "1", "true_label": "0", "raw_text": "Question: sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 1991, "prediction": "0", "true_label": "0", "raw_text": " ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) + farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1992, "prediction": "0", "true_label": "0", "raw_text": "Question: static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    const struct cow_header_v2 *cow_header = (const void *)buf;\n\n\n\n    if (buf_size >= sizeof(struct cow_header_v2) &&\n\n        be32_to_cpu(cow_header->magic) == COW_MAGIC &&\n\n        be32_to_cpu(cow_header->version) == COW_VERSION)\n\n        return 100;\n\n    else\n\n        return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1993, "prediction": "0", "true_label": "0", "raw_text": "Question: uint64_t ram_bytes_remaining(void)\n\n{\n\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1994, "prediction": "0", "true_label": "0", "raw_text": " scale_flag) {\n\n    Pulse pulse;\n\n    TemporalNoiseShaping * tns = &sce->tns;\n\n    IndividualChannelStream * ics = &sce->ics;\n\n    float * out = sce->coeffs;\n\n    int global_gain, pulse_present = 0;\n\n\n\n    /* This assignment is to silence a GCC warning about the variable being used\n\n     * uninitialized when in fact it always is.\n\n     */\n\n    pulse.num_pulse = 0;\n\n\n\n    global_gain = get_bits(gb, 8);\n\n\n\n    if (!common_window && !scale_flag) {\n\n        if (decode_ics_info(ac, ics, gb, 0) < 0)\n\n            return -1;\n\n    }\n\n\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n\n        return -1;\n\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n\n        return -1;\n\n\n\n    pulse_present = 0;\n\n    if (!scale_flag) {\n\n        if ((pulse_present = get_bits1(gb))) {\n\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n                av_log(ac->avccontext, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n\n                return -1;\n\n            }\n\n            decode_pulses(&pulse, gb, ics->swb_offset);\n\n        }\n\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n\n            return -1;\n\n        if (get_bits1(gb)) {\n\n            av_log_missing_feature(ac->avccontext, \"SSR\", 1);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n\n        return -1;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 1995, "prediction": "0", "true_label": "0", "raw_text": "Question: static ssize_t buffered_flush(QEMUFileBuffered *s)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t ret = 0;\n\n\n\n    DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffer_size);\n\n\n\n    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {\n\n        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);\n\n        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,\n\n                                    to_send);\n\n        if (ret <= 0) {\n\n            DPRINTF(\"error flushing data, %zd\\n\", ret);\n\n            break;\n\n        } else {\n\n            DPRINTF(\"flushed %zd byte(s)\\n\", ret);\n\n            offset += ret;\n\n            s->bytes_xfer += ret;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffer_size);\n\n    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);\n\n    s->buffer_size -= offset;\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1996, "prediction": "0", "true_label": "0", "raw_text": "Question: void pci_qdev_register(PCIDeviceInfo *info)\n\n{\n\n    info->qdev.init = pci_qdev_init;\n\n    info->qdev.bus_type = BUS_TYPE_PCI;\n\n    qdev_register(&info->qdev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1997, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vhost_net_stop_one(struct vhost_net *net,\n\n                               VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { .fd = -1 };\n\n\n\n    if (!net->dev.started) {\n\n        return;\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 1998, "prediction": "1", "true_label": "0", "raw_text": "(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", \n\n                         host, \n\n                         reply->transports[0].server_port_min,\n\n                         ttl);\n\n                if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* use callback if available to extend setup */\n\n    if (ff_rtsp_callback) {\n\n        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, \n\n                             NULL, 0, rt->last_reply) < 0) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n                         \n\n    /* start playing */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"PLAY %s RTSP/1.0\\r\\n\"\n\n             \"Range: npt=0-\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, NULL);\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n#if 0\n\n    /* open TCP with bufferized input */\n\n    if (rt->protocol == RTSP_PROTOCOL_RTP_TCP) {\n\n        if (url_fdopen(&rt->rtsp_gb, rt->rtsp_hd) < 0) {\n\n            err = AVERROR_NOMEM;\n\n            goto fail;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n fail:\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n        if (rtsp_st) {\n\n            if (rtsp_st->ic)\n\n                av_close_input_file(rtsp_st->ic);\n\n        }\n\n        av_free(rtsp_st);\n\n    }\n\n    av_freep(&content);\n\n    url_close(rt->rtsp_hd);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 1999, "prediction": "0", "true_label": "0", "raw_text": "Question: int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                                int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong phys;\n\n    int prot;\n\n\n\n    /* XXX: implement mmu */\n\n\n\n    phys = address;\n\n    prot = PAGE_READ | PAGE_WRITE;\n\n\n\n    return tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                        phys & TARGET_PAGE_MASK, prot,\n\n                        mmu_idx, is_softmmu);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2000, "prediction": "0", "true_label": "0", "raw_text": "Question: static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         void **refcount_table,\n\n                         int64_t *refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k, refcount;\n\n    int ret;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= *refcount_table_size) {\n\n            ret = realloc_refcount_array(s, refcount_table,\n\n                                         refcount_table_size, k + 1);\n\n            if (ret < 0) {\n\n                res->check_errors++;\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        refcount = s->get_refcount(*refcount_table, k);\n\n        if (refcount == s->refcount_max) {\n\n            fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n            fprintf(stderr, \"Use qemu-img amend to increase the refcount entry \"\n\n                    \"width or qemu-img convert to create a clean copy if the \"\n\n                    \"image cannot be opened for writing\\n\");\n\n            res->corruptions++;\n\n            continue;\n\n        }\n\n        s->set_refcount(*refcount_table, k, refcount + 1);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2001, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,\n\n                             uint64_t value, unsigned size)\n\n{\n\n    GICState **backref = (GICState **)opaque;\n\n    GICState *s = *backref;\n\n    int id = (backref - s->backref);\n\n    gic_cpu_write(s, id, addr, value);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2002, "prediction": "0", "true_label": "0", "raw_text": "Question: void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2003, "prediction": "0", "true_label": "0", "raw_text": "Question: static int fb_initialise(struct XenDevice *xendev)\n\n{\n\n    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);\n\n    struct xenfb_page *fb_page;\n\n    int videoram;\n\n    int rc;\n\n\n\n    if (xenstore_read_fe_int(xendev, \"videoram\", &videoram) == -1)\n\n\tvideoram = 0;\n\n\n\n    rc = common_bind(&fb->c);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    fb_page = fb->c.page;\n\n    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,\n\n\t\t\t    fb_page->width, fb_page->height, fb_page->depth,\n\n\t\t\t    fb_page->mem_length, 0, fb_page->line_length);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n    rc = xenfb_map_fb(fb);\n\n    if (rc != 0)\n\n\treturn rc;\n\n\n\n#if 0  /* handled in xen_init_display() for now */\n\n    if (!fb->have_console) {\n\n        fb->c.ds = graphic_console_init(xenfb_update,\n\n                                        xenfb_invalidate,\n\n                                        NULL,\n\n                                        NULL,\n\n                                        fb);\n\n        fb->have_console = 1;\n\n    }\n\n#endif\n\n\n\n    if (xenstore_read_fe_int(xendev, \"feature-update\", &fb->feature_update) == -1)\n\n\tfb->feature_update = 0;\n\n    if (fb->feature_update)\n\n\txenstore_write_be_int(xendev, \"request-update\", 1);\n\n\n\n    xen_pv_printf(xendev, 1, \"feature-update=%d, videoram=%d\\n\",\n\n\t\t  fb->feature_update, videoram);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2004, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_exts(int ot, TCGv reg)\n\n{\n\n    switch(ot) {\n\n    case OT_BYTE:\n\n        tcg_gen_ext8s_tl(reg, reg);\n\n        break;\n\n    case OT_WORD:\n\n        tcg_gen_ext16s_tl(reg, reg);\n\n        break;\n\n    case OT_LONG:\n\n        tcg_gen_ext32s_tl(reg, reg);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2005, "prediction": "0", "true_label": "0", "raw_text": "Question: bool is_valid_option_list(const char *param)\n\n{\n\n    size_t buflen = strlen(param) + 1;\n\n    char *buf = g_malloc(buflen);\n\n    const char *p = param;\n\n    bool result = true;\n\n\n\n    while (*p) {\n\n        p = get_opt_value(buf, buflen, p);\n\n        if (*p && !*++p) {\n\n            result = false;\n\n            goto out;\n\n        }\n\n\n\n        if (!*buf || *buf == ',') {\n\n            result = false;\n\n            goto out;\n\n        }\n\n    }\n\n\n\nout:\n\n    free(buf);\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2006, "prediction": "0", "true_label": "1", "raw_text": "_table[0], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->list_counts, big_mb_num * sizeof(uint8_t), fail)\n\n\n\n    memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(*h->slice_table_base));\n\n    h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n\n\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2b_xy  , big_mb_num * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mb2br_xy , big_mb_num * sizeof(uint32_t), fail);\n\n    for(y=0; y<s->mb_height; y++){\n\n        for(x=0; x<s->mb_width; x++){\n\n            const int mb_xy= x + y*s->mb_stride;\n\n            const int b_xy = 4*x + 4*y*h->b_stride;\n\n\n\n            h->mb2b_xy [mb_xy]= b_xy;\n\n            h->mb2br_xy[mb_xy]= 8*(FMO ? mb_xy : (mb_xy % (2*s->mb_stride)));\n\n        }\n\n    }\n\n\n\n    s->obmc_scratchpad = NULL;\n\n\n\n    if(!h->dequant4_coeff[0])\n\n        init_dequant_tables(h);\n\n\n\n    return 0;\n\nfail:\n\n    free_tables(h, 1);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2007, "prediction": "0", "true_label": "0", "raw_text": "\n\n        sStride = bwidth;\n\n    }\n\n\n\n    dStride = priv->pic.linesize[0];\n\n    dst     = priv->pic.data[0];\n\n\n\n    av_log(priv->avctx, AV_LOG_VERBOSE, \"CrystalHD: Copying out frame\\n\");\n\n\n\n    if (interlaced) {\n\n        int dY = 0;\n\n        int sY = 0;\n\n\n\n        height /= 2;\n\n        if (bottom_field) {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: bottom field\\n\");\n\n            dY = 1;\n\n        } else {\n\n            av_log(priv->avctx, AV_LOG_VERBOSE, \"Interlaced: top field\\n\");\n\n            dY = 0;\n\n        }\n\n\n\n        for (sY = 0; sY < height; dY++, sY++) {\n\n            memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);\n\n            if (interlaced)\n\n                dY++;\n\n        }\n\n    } else {\n\n        av_image_copy_plane(dst, dStride, src, sStride, bwidth, height);\n\n    }\n\n\n\n    priv->pic.interlaced_frame = interlaced;\n\n    if (interlaced)\n\n        priv->pic.top_field_first = !bottom_first;\n\n\n\n    if (output->PicInfo.timeStamp != 0) {\n\n        priv->pic.pkt_pts = opaque_list_pop(priv, output->PicInfo.timeStamp);\n\n        av_log(avctx, AV_LOG_VERBOSE, \"output \\\"pts\\\": %\"PRIu64\"\\n\",\n\n               priv->pic.pkt_pts);\n\n    }\n\n\n\n    if (!priv->need_second_field) {\n\n        *data_size       = sizeof(AVFrame);\n\n        *(AVFrame *)data = priv->pic;\n\n    }\n\n\n\n    if (ASSUME_TWO_INPUTS_ONE_OUTPUT &&\n\n        output->PicInfo.flags & VDEC_FLAG_UNKNOWN_SRC) {\n\n        av_log(priv->avctx, AV_LOG_VERBOSE, \"Fieldpair from two packets.\\n\");\n\n        return RET_SKIP_NEXT_COPY;\n\n    }\n\n\n\n    return RET_OK;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2008, "prediction": "0", "true_label": "1", "raw_text": "Question: static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2009, "prediction": "0", "true_label": "1", "raw_text": "Question: static AioHandler *find_aio_handler(int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    LIST_FOREACH(node, &aio_handlers, node) {\n\n        if (node->fd == fd)\n\n            return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2010, "prediction": "0", "true_label": "0", "raw_text": "6_reg counter[4]= {dstW, dstW, chrDstW, chrDstW};\n\n\n\n        if (c->flags & SWS_ACCURATE_RND) {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121_ACCURATE\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        } else {\n\n            while(p--) {\n\n                if (dst[p]) {\n\n                    __asm__ volatile(\n\n                        YSCALEYUV2YV121\n\n                        :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]),\n\n                        \"g\" (-counter[p])\n\n                        : \"%\"REG_a\n\n                    );\n\n                }\n\n            }\n\n        }\n\n        return;\n\n    }\n\n#endif\n\n    for (i=0; i<dstW; i++) {\n\n        int val= (lumSrc[i]+64)>>7;\n\n\n\n        if (val&256) {\n\n            if (val<0) val=0;\n\n            else       val=255;\n\n        }\n\n\n\n        dest[i]= val;\n\n    }\n\n\n\n    if (uDest)\n\n        for (i=0; i<chrDstW; i++) {\n\n            int u=(chrSrc[i       ]+64)>>7;\n\n            int v=(chrSrc[i + VOFW]+64)>>7;\n\n\n\n            if ((u|v)&256) {\n\n                if (u<0)        u=0;\n\n                else if (u>255) u=255;\n\n                if (v<0)        v=0;\n\n                else if (v>255) v=255;\n\n            }\n\n\n\n            uDest[i]= u;\n\n            vDest[i]= v;\n\n        }\n\n\n\n    if (CONFIG_SWSCALE_ALPHA && aDest)\n\n        for (i=0; i<dstW; i++) {\n\n            int val= (alpSrc[i]+64)>>7;\n\n            aDest[i]= av_clip_uint8(val);\n\n        }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2011, "prediction": "0", "true_label": "1", "raw_text": "p(mem_buf);\n\n            return 4;\n\n\n\n        case IDX_SEG_REGS:\n\n            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);\n\n        case IDX_SEG_REGS + 1:\n\n            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);\n\n        case IDX_SEG_REGS + 2:\n\n            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);\n\n        case IDX_SEG_REGS + 3:\n\n            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);\n\n        case IDX_SEG_REGS + 4:\n\n            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);\n\n        case IDX_SEG_REGS + 5:\n\n            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */\n\n            return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */\n\n            return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */\n\n            return 4;\n\n        case IDX_FP_REGS + 15: /* fop */\n\n            return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2012, "prediction": "0", "true_label": "0", "raw_text": " char csp[4][5] = { \"Gray\", \"420\", \"422\", \"444\" };\n\n        av_log(avctx, AV_LOG_DEBUG,\n\n               \"sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %\"PRId32\"/%\"PRId32\"\\n\",\n\n               sps_id, sps->profile_idc, sps->level_idc,\n\n               sps->poc_type,\n\n               sps->ref_frame_count,\n\n               sps->mb_width, sps->mb_height,\n\n               sps->frame_mbs_only_flag ? \"FRM\" : (sps->mb_aff ? \"MB-AFF\" : \"PIC-AFF\"),\n\n               sps->direct_8x8_inference_flag ? \"8B8\" : \"\",\n\n               sps->crop_left, sps->crop_right,\n\n               sps->crop_top, sps->crop_bottom,\n\n               sps->vui_parameters_present_flag ? \"VUI\" : \"\",\n\n               csp[sps->chroma_format_idc],\n\n               sps->timing_info_present_flag ? sps->num_units_in_tick : 0,\n\n               sps->timing_info_present_flag ? sps->time_scale : 0);\n\n    }\n\n\n\n    /* check if this is a repeat of an already parsed SPS, then keep the\n\n     * original one.\n\n     * otherwise drop all PPSes that depend on it */\n\n    if (ps->sps_list[sps_id] &&\n\n        !memcmp(ps->sps_list[sps_id]->data, sps_buf->data, sps_buf->size)) {\n\n        av_buffer_unref(&sps_buf);\n\n    } else {\n\n        remove_sps(ps, sps_id);\n\n        ps->sps_list[sps_id] = sps_buf;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&sps_buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2013, "prediction": "0", "true_label": "0", "raw_text": "0: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2014, "prediction": "0", "true_label": "0", "raw_text": "210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n        /* IIECR */\n\n    case 1:\n\n        DPRINTF(\"%s disable IRQ for groups %d, %d, %d, %d\\n\",\n\n                s->external ? \"EXT\" : \"INT\",\n\n                grp_quad_base_n,\n\n                grp_quad_base_n + 1,\n\n                grp_quad_base_n + 2,\n\n                grp_quad_base_n + 3);\n\n\n\n        /* Disable interrupt sources */\n\n        s->group[grp_quad_base_n].src_mask &= ~(val & 0xFF);\n\n        s->group[grp_quad_base_n + 1].src_mask &= ~((val & 0xFF00) >> 8);\n\n        s->group[grp_quad_base_n + 2].src_mask &= ~((val & 0xFF0000) >> 16);\n\n        s->group[grp_quad_base_n + 3].src_mask &= ~((val & 0xFF000000) >> 24);\n\n\n\n        exynos4210_combiner_update(s, grp_quad_base_n);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 1);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 2);\n\n        exynos4210_combiner_update(s, grp_quad_base_n + 3);\n\n        break;\n\n    default:\n\n        hw_error(\"exynos4210.combiner: unallowed write access at offset 0x\"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2015, "prediction": "0", "true_label": "0", "raw_text": " flags = acl_flags((data[1] << 8) | data[0]);\n\n    datalen = (data[3] << 8) | data[2];\n\n    data += HCI_ACL_HDR_SIZE;\n\n    length -= HCI_ACL_HDR_SIZE;\n\n\n\n    if (bt_hci_handle_bad(hci, handle)) {\n\n        fprintf(stderr, \"%s: invalid ACL handle %03x\\n\",\n\n                        __FUNCTION__, handle);\n\n        /* TODO: signal an error */\n\n        return;\n\n    }\n\n    handle &= ~HCI_HANDLE_OFFSET;\n\n\n\n    if (datalen > length) {\n\n        fprintf(stderr, \"%s: ACL packet too short (%iB < %iB)\\n\",\n\n                        __FUNCTION__, length, datalen);\n\n        return;\n\n    }\n\n\n\n    link = hci->lm.handle[handle].link;\n\n\n\n    if ((flags & ~3) == ACL_ACTIVE_BCAST) {\n\n        if (!hci->asb_handle)\n\n            hci->asb_handle = handle;\n\n        else if (handle != hci->asb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Active Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    if ((flags & ~3) == ACL_PICO_BCAST) {\n\n        if (!hci->psb_handle)\n\n            hci->psb_handle = handle;\n\n        else if (handle != hci->psb_handle) {\n\n            fprintf(stderr, \"%s: Bad handle %03x in Parked Slave Broadcast\\n\",\n\n                            __FUNCTION__, handle);\n\n            /* TODO: signal an error */\n\n            return;\n\n        }\n\n\n\n        /* TODO */\n\n    }\n\n\n\n    /* TODO: increase counter and send EVT_NUM_COMP_PKTS */\n\n    bt_hci_event_num_comp_pkts(hci, handle | HCI_HANDLE_OFFSET, 1);\n\n\n\n    /* Do this last as it can trigger further events even in this HCI */\n\n    hci->lm.handle[handle].lmp_acl_data(link, data,\n\n                    (flags & 3) == ACL_START, length);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2016, "prediction": "0", "true_label": "0", "raw_text": "Question: static int nbd_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    return nbd_client_session_co_flush(&s->client);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2017, "prediction": "0", "true_label": "0", "raw_text": "Question: static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2018, "prediction": "0", "true_label": "1", "raw_text": "Question: static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2019, "prediction": "0", "true_label": "1", "raw_text": "\n\n             * save the remainder for when more RX buffers are\n\n             * available, or flag an error.\n\n             */\n\n            qemu_log_mask(LOG_GUEST_ERROR, \"[%s]%s: Lost end of frame\\n\",\n\n                          TYPE_IMX_FEC, __func__);\n\n            break;\n\n        }\n\n        buf_len = (size <= s->regs[ENET_MRBR]) ? size : s->regs[ENET_MRBR];\n\n        bd.length = buf_len;\n\n        size -= buf_len;\n\n\n\n        FEC_PRINTF(\"rx_bd 0x%x length %d\\n\", addr, bd.length);\n\n\n\n        /* The last 4 bytes are the CRC.  */\n\n        if (size < 4) {\n\n            buf_len += size - 4;\n\n        }\n\n        buf_addr = bd.data;\n\n        dma_memory_write(&address_space_memory, buf_addr, buf, buf_len);\n\n        buf += buf_len;\n\n        if (size < 4) {\n\n            dma_memory_write(&address_space_memory, buf_addr + buf_len,\n\n                             crc_ptr, 4 - size);\n\n            crc_ptr += 4 - size;\n\n        }\n\n        bd.flags &= ~ENET_BD_E;\n\n        if (size == 0) {\n\n            /* Last buffer in frame.  */\n\n            bd.flags |= flags | ENET_BD_L;\n\n            FEC_PRINTF(\"rx frame flags %04x\\n\", bd.flags);\n\n            s->regs[ENET_EIR] |= ENET_INT_RXF;\n\n        } else {\n\n            s->regs[ENET_EIR] |= ENET_INT_RXB;\n\n        }\n\n        imx_fec_write_bd(&bd, addr);\n\n        /* Advance to the next descriptor.  */\n\n        if ((bd.flags & ENET_BD_W) != 0) {\n\n            addr = s->regs[ENET_RDSR];\n\n        } else {\n\n            addr += sizeof(bd);\n\n        }\n\n    }\n\n    s->rx_descriptor = addr;\n\n    imx_eth_enable_rx(s);\n\n    imx_eth_update(s);\n\n    return len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2020, "prediction": "0", "true_label": "0", "raw_text": "Question: static void breakpoint_handler(CPUState *env)\n\n{\n\n    CPUBreakpoint *bp;\n\n\n\n    if (env->watchpoint_hit) {\n\n        if (env->watchpoint_hit->flags & BP_CPU) {\n\n            env->watchpoint_hit = NULL;\n\n            if (check_hw_breakpoints(env, 0))\n\n                raise_exception(EXCP01_DB);\n\n            else\n\n                cpu_resume_from_signal(env, NULL);\n\n        }\n\n    } else {\n\n        TAILQ_FOREACH(bp, &env->breakpoints, entry)\n\n            if (bp->pc == env->eip) {\n\n                if (bp->flags & BP_CPU) {\n\n                    check_hw_breakpoints(env, 1);\n\n                    raise_exception(EXCP01_DB);\n\n                }\n\n                break;\n\n            }\n\n    }\n\n    if (prev_debug_excp_handler)\n\n        prev_debug_excp_handler(env);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2021, "prediction": "1", "true_label": "0", "raw_text": "Question: static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 2022, "prediction": "0", "true_label": "1", "raw_text": " avctx->internal->frame_thread_encoder;\n\n    AVPacket *pkt = NULL;\n\n\n\n    while(!c->exit){\n\n        int got_packet, ret;\n\n        AVFrame *frame;\n\n        Task task;\n\n\n\n        if(!pkt) pkt= av_mallocz(sizeof(*pkt));\n\n        if(!pkt) continue;\n\n        av_init_packet(pkt);\n\n\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {\n\n            if(c->exit){\n\n                pthread_mutex_unlock(&c->task_fifo_mutex);\n\n                goto end;\n\n            }\n\n            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);\n\n        }\n\n        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n        frame = task.indata;\n\n\n\n        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);\n\n        pthread_mutex_lock(&c->buffer_mutex);\n\n        av_frame_unref(frame);\n\n        pthread_mutex_unlock(&c->buffer_mutex);\n\n        av_frame_free(&frame);\n\n        if(got_packet) {\n\n            int ret2 = av_dup_packet(pkt);\n\n            if (ret >= 0 && ret2 < 0)\n\n                ret = ret2;\n\n        } else {\n\n            pkt->data = NULL;\n\n            pkt->size = 0;\n\n        }\n\n        pthread_mutex_lock(&c->finished_task_mutex);\n\n        c->finished_tasks[task.index].outdata = pkt; pkt = NULL;\n\n        c->finished_tasks[task.index].return_code = ret;\n\n        pthread_cond_signal(&c->finished_task_cond);\n\n        pthread_mutex_unlock(&c->finished_task_mutex);\n\n    }\n\nend:\n\n    av_free(pkt);\n\n    pthread_mutex_lock(&c->buffer_mutex);\n\n    avcodec_close(avctx);\n\n    pthread_mutex_unlock(&c->buffer_mutex);\n\n    av_freep(&avctx);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2023, "prediction": "0", "true_label": "1", "raw_text": "CHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2024, "prediction": "0", "true_label": "1", "raw_text": "Question: void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2025, "prediction": "0", "true_label": "1", "raw_text": " io->addr, io->len);\n\n    MACIO_DPRINTF(\"xxx remainder: %x\\n\", remainder);\n\n    MACIO_DPRINTF(\"xxx sector_num: %\"PRIx64\"   nsector: %x\\n\",\n\n                  sector_num, nsector);\n\n\n\n    dma_addr = io->addr;\n\n    dma_len = io->len;\n\n    mem = dma_memory_map(&address_space_memory, dma_addr, &dma_len,\n\n                         DMA_DIRECTION_TO_DEVICE);\n\n\n\n    if (!remainder) {\n\n        MACIO_DPRINTF(\"--- DMA write aligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, io->len);\n\n        qemu_iovec_add(&io->iov, mem, io->len);\n\n    } else {\n\n        /* Write up to last complete sector */\n\n        MACIO_DPRINTF(\"--- DMA write unaligned - addr: %\" HWADDR_PRIx\n\n                      \" len: %x\\n\", io->addr, (nsector << 9));\n\n        qemu_iovec_add(&io->iov, mem, (nsector << 9));\n\n\n\n        MACIO_DPRINTF(\"--- DMA write read    - bounce addr: %p \"\n\n                      \"remainder_len: %x\\n\", &io->remainder, remainder);\n\n        cpu_physical_memory_read(io->addr + (nsector << 9), &io->remainder,\n\n                                 remainder);\n\n\n\n        io->remainder_len = 0x200 - remainder;\n\n\n\n        MACIO_DPRINTF(\"xxx remainder_len: %x\\n\", io->remainder_len);\n\n    }\n\n\n\n    s->io_buffer_size -= ((nsector + extra) << 9);\n\n    s->io_buffer_index += ((nsector + extra) << 9);\n\n\n\n    io->len = 0;\n\n\n\n    MACIO_DPRINTF(\"--- Block write transfer   - sector_num: %\"PRIx64\"  \"\n\n                  \"nsector: %x\\n\", sector_num, nsector + extra);\n\n\n\n    m->aiocb = blk_aio_writev(blk, sector_num, &io->iov, nsector + extra, cb,\n\n                              io);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2026, "prediction": "0", "true_label": "0", "raw_text": "Question: static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2027, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2028, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2029, "prediction": "0", "true_label": "0", "raw_text": "_attrib.bold = 0;\n\n                break;\n\n            case 24:\n\n                s->t_attrib.uline = 0;\n\n                break;\n\n            case 25:\n\n                s->t_attrib.blink = 0;\n\n                break;\n\n            case 27:\n\n                s->t_attrib.invers = 0;\n\n                break;\n\n            case 28:\n\n                s->t_attrib.unvisible = 0;\n\n                break;\n\n            /* set foreground color */\n\n            case 30:\n\n                s->t_attrib.fgcol=COLOR_BLACK;\n\n                break;\n\n            case 31:\n\n                s->t_attrib.fgcol=COLOR_RED;\n\n                break;\n\n            case 32:\n\n                s->t_attrib.fgcol=COLOR_GREEN;\n\n                break;\n\n            case 33:\n\n                s->t_attrib.fgcol=COLOR_YELLOW;\n\n                break;\n\n            case 34:\n\n                s->t_attrib.fgcol=COLOR_BLUE;\n\n                break;\n\n            case 35:\n\n                s->t_attrib.fgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 36:\n\n                s->t_attrib.fgcol=COLOR_CYAN;\n\n                break;\n\n            case 37:\n\n                s->t_attrib.fgcol=COLOR_WHITE;\n\n                break;\n\n            /* set background color */\n\n            case 40:\n\n                s->t_attrib.bgcol=COLOR_BLACK;\n\n                break;\n\n            case 41:\n\n                s->t_attrib.bgcol=COLOR_RED;\n\n                break;\n\n            case 42:\n\n                s->t_attrib.bgcol=COLOR_GREEN;\n\n                break;\n\n            case 43:\n\n                s->t_attrib.bgcol=COLOR_YELLOW;\n\n                break;\n\n            case 44:\n\n                s->t_attrib.bgcol=COLOR_BLUE;\n\n                break;\n\n            case 45:\n\n                s->t_attrib.bgcol=COLOR_MAGENTA;\n\n                break;\n\n            case 46:\n\n                s->t_attrib.bgcol=COLOR_CYAN;\n\n                break;\n\n            case 47:\n\n                s->t_attrib.bgcol=COLOR_WHITE;\n\n                break;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2030, "prediction": "0", "true_label": "0", "raw_text": "Question: static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,\n\n                              int element, TCGMemOp memop)\n\n{\n\n    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);\n\n    switch (memop) {\n\n    case MO_8:\n\n        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_16:\n\n        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_32:\n\n        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    case MO_64:\n\n        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2031, "prediction": "0", "true_label": "0", "raw_text": "Question: static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),\n\n                                    int ra, int rb, int rc,\n\n                                    int islit, uint8_t lit)\n\n{\n\n    if (unlikely(rc == 31))\n\n        return;\n\n\n\n    if (ra != 31) {\n\n        if (islit) {\n\n            if (lit != 0)\n\n                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));\n\n            else\n\n                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);\n\n        } else {\n\n            TCGv tmp1, tmp2;\n\n            tmp1 = tcg_temp_new(TCG_TYPE_I64);\n\n            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);\n\n            tcg_gen_shli_i64(tmp1, tmp1, 3);\n\n            tmp2 = tcg_const_i64(64);\n\n            tcg_gen_sub_i64(tmp1, tmp2, tmp1);\n\n            tcg_temp_free(tmp2);\n\n            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);\n\n            tcg_temp_free(tmp1);\n\n        }\n\n        if (tcg_gen_ext_i64)\n\n            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);\n\n    } else\n\n        tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2032, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_h264_init_dequant_tables(H264Context *h)\n\n{\n\n    int i, x;\n\n    init_dequant4_coeff_table(h);\n\n    if (h->pps.transform_8x8_mode)\n\n        init_dequant8_coeff_table(h);\n\n    if (h->sps.transform_bypass) {\n\n        for (i = 0; i < 6; i++)\n\n            for (x = 0; x < 16; x++)\n\n                h->dequant4_coeff[i][0][x] = 1 << 6;\n\n        if (h->pps.transform_8x8_mode)\n\n            for (i = 0; i < 6; i++)\n\n                for (x = 0; x < 64; x++)\n\n                    h->dequant8_coeff[i][0][x] = 1 << 6;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2033, "prediction": "0", "true_label": "0", "raw_text": "buf));\n\n            if (!c->paths[i] || !c->node_buf[i] || !c->nodep_buf[i]) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (avctx->frame_size) {\n\n        /* validate frame size */\n\n        if (avctx->frame_size & 1 || avctx->frame_size > MAX_FRAME_SIZE) {\n\n            int new_frame_size;\n\n\n\n            if (avctx->frame_size == 1)\n\n                new_frame_size = 2;\n\n            else if (avctx->frame_size > MAX_FRAME_SIZE)\n\n                new_frame_size = MAX_FRAME_SIZE;\n\n            else\n\n                new_frame_size = avctx->frame_size - 1;\n\n\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested frame size is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_frame_size,\n\n                   avctx->frame_size);\n\n            avctx->frame_size = new_frame_size;\n\n        }\n\n    } else {\n\n        /* This is arbitrary. We use 320 because it's 20ms @ 16kHz, which is\n\n           a common packet size for VoIP applications */\n\n        avctx->frame_size = 320;\n\n    }\n\n    avctx->delay = 22;\n\n\n\n    if (avctx->trellis) {\n\n        /* validate trellis */\n\n        if (avctx->trellis < MIN_TRELLIS || avctx->trellis > MAX_TRELLIS) {\n\n            int new_trellis = av_clip(avctx->trellis, MIN_TRELLIS, MAX_TRELLIS);\n\n            av_log(avctx, AV_LOG_WARNING, \"Requested trellis value is not \"\n\n                   \"allowed. Using %d instead of %d\\n\", new_trellis,\n\n                   avctx->trellis);\n\n            avctx->trellis = new_trellis;\n\n        }\n\n    }\n\n\n\n    return 0;\n\nerror:\n\n    g722_encode_close(avctx);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2034, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n\n\n    return lsi_reg_readb(s, addr & 0xff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2035, "prediction": "1", "true_label": "0", "raw_text": "unused_session_index(builtin);\n\n    if (index < 0) {\n\n        error_setg(errp, \"Total number of sessions created exceeds %u\",\n\n                  MAX_NUM_SESSIONS);\n\n        return -1;\n\n    }\n\n\n\n    switch (sess_info->cipher_alg) {\n\n    case VIRTIO_CRYPTO_CIPHER_AES_ECB:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CBC:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CBC;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_AES_CTR:\n\n        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,\n\n                                                          errp);\n\n        if (algo < 0)  {\n\n            return -1;\n\n        }\n\n        mode = QCRYPTO_CIPHER_MODE_CTR;\n\n        break;\n\n    case VIRTIO_CRYPTO_CIPHER_DES_ECB:\n\n        algo = QCRYPTO_CIPHER_ALG_DES_RFB;\n\n        mode = QCRYPTO_CIPHER_MODE_ECB;\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Unsupported cipher alg :%u\",\n\n                   sess_info->cipher_alg);\n\n        return -1;\n\n    }\n\n\n\n    cipher = qcrypto_cipher_new(algo, mode,\n\n                               sess_info->cipher_key,\n\n                               sess_info->key_len,\n\n                               errp);\n\n    if (!cipher) {\n\n        return -1;\n\n    }\n\n\n\n    sess = g_new0(CryptoDevBackendBuiltinSession, 1);\n\n    sess->cipher = cipher;\n\n    sess->direction = sess_info->direction;\n\n    sess->type = sess_info->op_type;\n\n\n\n    builtin->sessions[index] = sess;\n\n\n\n    return index;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2036, "prediction": "0", "true_label": "0", "raw_text": "Question: envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2037, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2038, "prediction": "-1", "true_label": "1", "raw_text": " char *buf;\n\n    int64_t offset;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int nr_iov;\n\n    int pattern = 0xcd;\n\n    QEMUIOVector qiov;\n\n\n\n    while ((c = getopt(argc, argv, \"CqP:\")) != EOF) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        default:\n\n            return command_usage(&writev_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind > argc - 2) {\n\n        return command_usage(&writev_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n    optind++;\n\n\n\n    if (offset & 0x1ff) {\n\n        printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n               offset);\n\n        return 0;\n\n    }\n\n\n\n    nr_iov = argc - optind;\n\n    buf = create_iovec(&qiov, &argv[optind], nr_iov, pattern);\n\n    if (buf == NULL) {\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    cnt = do_aio_writev(&qiov, offset, &total);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"writev failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n\n\n    qemu_io_free(buf);\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2039, "prediction": "0", "true_label": "0", "raw_text": "Question: static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)\n\n{\n\n    int i;\n\n    for (i = 0; i < width; i++) {\n\n        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264\n\n        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2040, "prediction": "0", "true_label": "1", "raw_text": " match the sample rate index configured by the container.\\n\");\n\n\n\n    num_front       = get_bits(gb, 4);\n\n    num_side        = get_bits(gb, 4);\n\n    num_back        = get_bits(gb, 4);\n\n    num_lfe         = get_bits(gb, 2);\n\n    num_assoc_data  = get_bits(gb, 3);\n\n    num_cc          = get_bits(gb, 4);\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // mono_mixdown_tag\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // stereo_mixdown_tag\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround\n\n\n\n\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );\n\n    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );\n\n\n\n    skip_bits_long(gb, 4 * num_assoc_data);\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );\n\n\n\n    align_get_bits(gb);\n\n\n\n    /* comment field, first byte is length */\n\n    comment_len = get_bits(gb, 8) * 8;\n\n    if (get_bits_left(gb) < comment_len) {\n\n\n\n\n    skip_bits_long(gb, comment_len);\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2041, "prediction": "0", "true_label": "1", "raw_text": "_size)\n\n            break;\n\n\n\n        switch (code) {\n\n        case 0: /* ADPCM 2-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ( code       & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 2) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ((code >> 4) & 0x3) - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample +=  (code >> 6)        - 2;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 1: /* ADPCM 4-bit */\n\n            for (count++; count > 0; count--) {\n\n                code = *buf++;\n\n                sample += ws_adpcm_4bit[code & 0xF];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n                sample += ws_adpcm_4bit[code >> 4];\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            }\n\n            break;\n\n        case 2: /* no compression */\n\n            if (count & 0x20) { /* big delta */\n\n                int8_t t;\n\n                t = count;\n\n                t <<= 3;\n\n                sample += t >> 3;\n\n                sample = av_clip_uint8(sample);\n\n                *samples++ = sample;\n\n            } else { /* copy */\n\n                memcpy(samples, buf, smp);\n\n                samples += smp;\n\n                buf     += smp;\n\n                sample = buf[-1];\n\n            }\n\n            break;\n\n        default: /* run */\n\n            memset(samples, sample, smp);\n\n            samples += smp;\n\n        }\n\n    }\n\n\n\n    s->frame.nb_samples = samples - s->frame.data[0];\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = s->frame;\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2042, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                     const uint8_t *src_in[4], int srcW, int xInc,\n\n                                     const int16_t *hLumFilter,\n\n                                     const int16_t *hLumFilterPos, int hLumFilterSize,\n\n                                     uint8_t *formatConvBuffer,\n\n                                     uint32_t *pal, int isAlpha)\n\n{\n\n    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;\n\n    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;\n\n    const uint8_t *src = src_in[isAlpha ? 3 : 0];\n\n\n\n    if (toYV12) {\n\n        toYV12(formatConvBuffer, src, srcW, pal);\n\n        src= formatConvBuffer;\n\n    } else if (c->readLumPlanar && !isAlpha) {\n\n        c->readLumPlanar(formatConvBuffer, src_in, srcW);\n\n        src = formatConvBuffer;\n\n    }\n\n\n\n    if (!c->hyscale_fast) {\n\n        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);\n\n    }\n\n\n\n    if (convertRange)\n\n        convertRange(dst, dstWidth);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2043, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)\n\n{\n\n    int i, d;\n\n    for( i = 0; i < 4; i++ ) {\n\n        const int tc = tc0[i];\n\n        if( tc <= 0 ) {\n\n            pix += 2*ystride;\n\n            continue;\n\n        }\n\n        for( d = 0; d < 2; d++ ) {\n\n            const int p0 = pix[-1*xstride];\n\n            const int p1 = pix[-2*xstride];\n\n            const int q0 = pix[0];\n\n            const int q1 = pix[1*xstride];\n\n\n\n            if( FFABS( p0 - q0 ) < alpha &&\n\n                FFABS( p1 - p0 ) < beta &&\n\n                FFABS( q1 - q0 ) < beta ) {\n\n\n\n                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );\n\n\n\n                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */\n\n                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */\n\n            }\n\n            pix += ystride;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2044, "prediction": "0", "true_label": "0", "raw_text": "0x1B4) printf(\"Video Session Error\");\n\n            else if(startcode==0x1B5) printf(\"Visual Object Start\");\n\n            else if(startcode==0x1B6) printf(\"Video Object Plane start\");\n\n            else if(startcode==0x1B7) printf(\"slice start\");\n\n            else if(startcode==0x1B8) printf(\"extension start\");\n\n            else if(startcode==0x1B9) printf(\"fgs start\");\n\n            else if(startcode==0x1BA) printf(\"FBA Object start\");\n\n            else if(startcode==0x1BB) printf(\"FBA Object Plane start\");\n\n            else if(startcode==0x1BC) printf(\"Mesh Object start\");\n\n            else if(startcode==0x1BD) printf(\"Mesh Object Plane start\");\n\n            else if(startcode==0x1BE) printf(\"Still Textutre Object start\");\n\n            else if(startcode==0x1BF) printf(\"Textutre Spatial Layer start\");\n\n            else if(startcode==0x1C0) printf(\"Textutre SNR Layer start\");\n\n            else if(startcode==0x1C1) printf(\"Textutre Tile start\");\n\n            else if(startcode==0x1C2) printf(\"Textutre Shape Layer start\");\n\n            else if(startcode==0x1C3) printf(\"stuffing start\");\n\n            else if(startcode<=0x1C5) printf(\"reserved\");\n\n            else if(startcode<=0x1FF) printf(\"System start\");\n\n            printf(\" at %d\\n\", get_bits_count(gb));\n\n        }\n\n\n\n        switch(startcode){\n\n        case 0x120:\n\n            decode_vol_header(s, gb);\n\n            break;\n\n        case USER_DATA_STARTCODE:\n\n            decode_user_data(s, gb);\n\n            break;\n\n        case GOP_STARTCODE:\n\n            mpeg4_decode_gop_header(s, gb);\n\n            break;\n\n        case VOP_STARTCODE:\n\n            return decode_vop_header(s, gb);\n\n        default:\n\n            break;\n\n        }\n\n\n\n        align_get_bits(gb);\n\n        startcode = 0xff;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2045, "prediction": "0", "true_label": "0", "raw_text": " avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1) * 2;\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        s->repeat_pict = 1;\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 5;\n\n                                else\n\n                                    s->repeat_pict = 3;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 2;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2046, "prediction": "0", "true_label": "1", "raw_text": "Question: static int set_chroma_format(AVCodecContext *avctx)\n\n{\n\n    int num_formats = sizeof(schro_pixel_format_map) /\n\n                      sizeof(schro_pixel_format_map[0]);\n\n    int idx;\n\n\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    for (idx = 0; idx < num_formats; ++idx) {\n\n        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {\n\n            p_schro_params->format->chroma_format =\n\n                            schro_pixel_format_map[idx].schro_pix_fmt;\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR,\n\n           \"This codec currently only supports planar YUV 4:2:0, 4:2:2\"\n\n           \" and 4:4:4 formats.\\n\");\n\n\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2047, "prediction": "0", "true_label": "1", "raw_text": "Question: IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2048, "prediction": "0", "true_label": "1", "raw_text": "Question: static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2049, "prediction": "1", "true_label": "1", "raw_text": "Question: int kvm_arch_init_vcpu(CPUState *cenv)\n\n{\n\n    int ret = 0;\n\n    struct kvm_sregs sregs;\n\n\n\n    sregs.pvr = cenv->spr[SPR_PVR];\n\n    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);\n\n\n\n    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2050, "prediction": "-1", "true_label": "1", "raw_text": "Question: static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2051, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int mp_decode_init(AVCodecContext *avctx)\n\n{\n\n    MotionPixelsContext *mp = avctx->priv_data;\n\n    int w4 = (avctx->width  + 3) & ~3;\n\n    int h4 = (avctx->height + 3) & ~3;\n\n\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"extradata too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    motionpixels_tableinit();\n\n    mp->avctx = avctx;\n\n    ff_dsputil_init(&mp->dsp, avctx);\n\n    mp->changes_map = av_mallocz(avctx->width * h4);\n\n    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;\n\n    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));\n\n    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&mp->frame);\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2052, "prediction": "1", "true_label": "0", "raw_text": "Question: static void put_payload_header(\n\n                                AVFormatContext *s,\n\n                                ASFStream       *stream,\n\n                                int             presentation_time,\n\n                                int             m_obj_size,\n\n                                int             m_obj_offset,\n\n                                int             payload_len\n\n            )\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    ByteIOContext *pb = &asf->pb;\n\n    int val;\n\n    \n\n    val = stream->num;\n\n    if (s->streams[val - 1]->codec.coded_frame->key_frame)\n\n        val |= ASF_PL_FLAG_KEY_FRAME;\n\n    put_byte(pb, val);\n\n        \n\n    put_byte(pb, stream->seq);  //Media object number\n\n    put_le32(pb, m_obj_offset); //Offset Into Media Object\n\n         \n\n    // Replicated Data shall be at least 8 bytes long.\n\n    // The first 4 bytes of data shall contain the \n\n    // Size of the Media Object that the payload belongs to.\n\n    // The next 4 bytes of data shall contain the \n\n    // Presentation Time for the media object that the payload belongs to.\n\n    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);\n\n\n\n    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size\n\n    put_le32(pb, presentation_time);//Replicated Data - Presentation Time\n\n    \n\n    if (asf->multi_payloads_present){\n\n        put_le16(pb, payload_len);   //payload length\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2053, "prediction": "0", "true_label": "1", "raw_text": "S16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16LE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v & 0xff;\n\n            dst[1] = v >> 8;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U16BE:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            v += 0x8000;\n\n            dst[0] = v >> 8;\n\n            dst[1] = v;\n\n            dst += 2;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_S8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = (v + 128) >> 8;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_U8:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = ((v + 128) >> 8) + 128;\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_ALAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_alaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    case CODEC_ID_PCM_MULAW:\n\n        for(;n>0;n--) {\n\n            v = *samples++;\n\n            dst[0] = linear_to_ulaw[(v + 32768) >> 2];\n\n            dst++;\n\n        }\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    avctx->key_frame = 1;\n\n    //avctx->frame_size = (dst - frame) / (sample_size * avctx->channels);\n\n\n\n    return dst - frame;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2054, "prediction": "0", "true_label": "1", "raw_text": "1R, permF);\n\n          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);\n\n\n\n          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);\n\n          val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n          filter_v0R = filter_v2R;\n\n          src_v0 = src_v1;\n\n        }\n\n\n\n        if (j < (filterSize-7)) {\n\n          // loading src_v0 is useless, it's already done above\n\n          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);\n\n          vector unsigned char src_v1, src_vF;\n\n          vector signed short src_v, filter_v1R, filter_v;\n\n          if ((((int)src + srcPos)% 16) > 8) {\n\n            src_v1 = vec_ld(srcPos + j + 16, src);\n\n          }\n\n          src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          src_v = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          // loading filter_v0R is useless, it's already done above\n\n          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);\n\n          filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          filter_v = vec_perm(filter_v0R, filter_v1R, permF);\n\n\n\n          val_v = vec_msums(src_v, filter_v, val_v);\n\n        }\n\n\n\n        val_s = vec_sums(val_v, vzero);\n\n\n\n        vec_st(val_s, 0, tempo);\n\n        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n\n\n    }\n\n  }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2055, "prediction": "1", "true_label": "1", "raw_text": "Question: void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2056, "prediction": "0", "true_label": "1", "raw_text": "Question: static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2057, "prediction": "0", "true_label": "0", "raw_text": "Question: static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2058, "prediction": "0", "true_label": "0", "raw_text": "\n\n\n\n    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,\n\n                       mch->pci_hole64_size);\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             mch->pci_info.w64.begin,\n\n                             mch->pci_hole64_size);\n\n    if (mch->pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    mch->pci_info.w64.begin,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2059, "prediction": "0", "true_label": "0", "raw_text": ", i, j, bits_left, last_bits;\n\n    uint32_t state;\n\n\n\n    H261Context *h = avctx->priv_data;\n\n\n\n    if(h){\n\n        bits_left = h->bits_left;\n\n        last_bits = h->last_bits;\n\n    }\n\n    else{\n\n        bits_left = 0;\n\n        last_bits = 0;\n\n    }\n\n\n\n    vop_found= pc->frame_start_found;\n\n    state= pc->state;\n\n    if(bits_left!=0 && !vop_found)\n\n        state = state << (8-bits_left) | last_bits;\n\n    i=0;\n\n    if(!vop_found){\n\n        for(i=0; i<buf_size; i++){\n\n            state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    i++;\n\n                    vop_found=1;\n\n                    break;\n\n                }\n\n            }\n\n            if(vop_found)\n\n                    break;    \n\n        }\n\n    }\n\n    if(vop_found){\n\n        for(; i<buf_size; i++){\n\n            if(avctx->flags & CODEC_FLAG_TRUNCATED)//XXX ffplay workaround, someone a better solution?\n\n                state= (state<<8) | buf[i];\n\n            for(j=0; j<8; j++){\n\n                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pc->frame_start_found= vop_found;\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2060, "prediction": "0", "true_label": "0", "raw_text": "Question: void address_space_write(AddressSpace *as, target_phys_addr_t addr,\n\n                         const uint8_t *buf, int len)\n\n{\n\n    address_space_rw(as, addr, (uint8_t *)buf, len, true);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2061, "prediction": "0", "true_label": "0", "raw_text": "Question: static void audio_run_capture (AudioState *s)\n\n{\n\n    CaptureVoiceOut *cap;\n\n\n\n    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {\n\n        int live, rpos, captured;\n\n        HWVoiceOut *hw = &cap->hw;\n\n        SWVoiceOut *sw;\n\n\n\n        captured = live = audio_pcm_hw_get_live_out (hw);\n\n        rpos = hw->rpos;\n\n        while (live) {\n\n            int left = hw->samples - rpos;\n\n            int to_capture = audio_MIN (live, left);\n\n            st_sample_t *src;\n\n            struct capture_callback *cb;\n\n\n\n            src = hw->mix_buf + rpos;\n\n            hw->clip (cap->buf, src, to_capture);\n\n            mixeng_clear (src, to_capture);\n\n\n\n            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {\n\n                cb->ops.capture (cb->opaque, cap->buf,\n\n                                 to_capture << hw->info.shift);\n\n            }\n\n            rpos = (rpos + to_capture) % hw->samples;\n\n            live -= to_capture;\n\n        }\n\n        hw->rpos = rpos;\n\n\n\n        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {\n\n            if (!sw->active && sw->empty) {\n\n                continue;\n\n            }\n\n\n\n            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {\n\n                dolog (\"captured=%d sw->total_hw_samples_mixed=%d\\n\",\n\n                       captured, sw->total_hw_samples_mixed);\n\n                captured = sw->total_hw_samples_mixed;\n\n            }\n\n\n\n            sw->total_hw_samples_mixed -= captured;\n\n            sw->empty = sw->total_hw_samples_mixed == 0;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2062, "prediction": "1", "true_label": "1", "raw_text": "Question: CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2063, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2064, "prediction": "0", "true_label": "0", "raw_text": "0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len / 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2065, "prediction": "0", "true_label": "0", "raw_text": "Question: static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,\n\n                                  void *opaque)\n\n{\n\n    monitor_flush(opaque);\n\n    return FALSE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2066, "prediction": "0", "true_label": "0", "raw_text": "Question: static always_inline void gen_store_spr(int reg, TCGv t)\n\n{\n\n    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2067, "prediction": "1", "true_label": "0", "raw_text": "Question: int bdrv_is_read_only(BlockDriverState *bs)\n\n{\n\n    return bs->read_only;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2068, "prediction": "0", "true_label": "0", "raw_text": "Question: static void bw_conf1_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t val, unsigned size)\n\n{\n\n    PCIBus *b = opaque;\n\n    pci_data_write(b, addr, val, size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2069, "prediction": "0", "true_label": "0", "raw_text": "Question: void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)\n\n{\n\n    TranslationBlock *tb;\n\n    int ret;\n\n    unsigned long pc;\n\n    CPUX86State *saved_env;\n\n\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n\n\n    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);\n\n    if (ret) {\n\n        if (retaddr) {\n\n            /* now we have a real cpu fault */\n\n            pc = (unsigned long)retaddr;\n\n            tb = tb_find_pc(pc);\n\n            if (tb) {\n\n                /* the PC is inside the translated code. It means that we have\n\n                   a virtual CPU fault */\n\n                cpu_restore_state(tb, env, pc, NULL);\n\n            }\n\n        }\n\n        if (retaddr)\n\n            raise_exception_err(EXCP0E_PAGE, env->error_code);\n\n        else\n\n            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);\n\n    }\n\n    env = saved_env;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2070, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2071, "prediction": "0", "true_label": "1", "raw_text": "Question: block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2072, "prediction": "0", "true_label": "0", "raw_text": "Question: static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,\n\n                             const int16_t **lumSrc, int lumFilterSize,\n\n                             const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                             const int16_t **chrVSrc,\n\n                             int chrFilterSize, const int16_t **alpSrc,\n\n                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                             uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    if (uDest) {\n\n        x86_reg uv_off = c->uv_off;\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2073, "prediction": "0", "true_label": "0", "raw_text": "Question: static void add_cpreg_to_list(gpointer key, gpointer opaque)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    uint64_t regidx;\n\n    const ARMCPRegInfo *ri;\n\n\n\n    regidx = *(uint32_t *)key;\n\n    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);\n\n\n\n    if (!(ri->type & ARM_CP_NO_MIGRATE)) {\n\n        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);\n\n        /* The value array need not be initialized at this point */\n\n        cpu->cpreg_array_len++;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2074, "prediction": "0", "true_label": "0", "raw_text": "Question: static int xan_huffman_decode(unsigned char *dest, unsigned char *src)\n\n{\n\n    unsigned char byte = *src++;\n\n    unsigned char ival = byte + 0x16;\n\n    unsigned char * ptr = src + byte*2;\n\n    unsigned char val = ival;\n\n    int counter = 0;\n\n\n\n    unsigned char bits = *ptr++;\n\n\n\n    while ( val != 0x16 ) {\n\n        if ( (1 << counter) & bits )\n\n            val = src[byte + val - 0x17];\n\n        else\n\n            val = src[val - 0x17];\n\n\n\n        if ( val < 0x16 ) {\n\n            *dest++ = val;\n\n            val = ival;\n\n        }\n\n\n\n        if (counter++ == 7) {\n\n            counter = 0;\n\n            bits = *ptr++;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2075, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)\n\n{\n\n    return t && t->rearm;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2076, "prediction": "0", "true_label": "1", "raw_text": "_bits_per_sample(st->codec->codec_id);\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        iff->bpp          = st->codec->bits_per_coded_sample;\n\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n\n            st->codec->bits_per_coded_sample = 24;\n\n        }\n\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n\n        iff->masking      = masking;\n\n        iff->transparency = transparency;\n\n\n\n        if (!st->codec->extradata) {\n\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n\n        buf = st->codec->extradata;\n\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n\n        bytestream_put_byte(&buf, iff->bpp);\n\n        bytestream_put_byte(&buf, iff->ham);\n\n        bytestream_put_byte(&buf, iff->flags);\n\n        bytestream_put_be16(&buf, iff->transparency);\n\n        bytestream_put_byte(&buf, iff->masking);\n\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2077, "prediction": "1", "true_label": "1", "raw_text": "Question: static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n\n{\n\n    int err, i, dash = 0, result = 0, code_found = 0;\n\n    char buf[CONTROL_BUFFER_SIZE];\n\n    AVBPrint line_buffer;\n\n\n\n    if (line)\n\n        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    while (!code_found || dash) {\n\n        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {\n\n            av_bprint_finalize(&line_buffer, NULL);\n\n            return err;\n\n        }\n\n\n\n        av_log(s, AV_LOG_DEBUG, \"%s\\n\", buf);\n\n\n\n        if (strlen(buf) < 4)\n\n            continue;\n\n\n\n        err = 0;\n\n        for (i = 0; i < 3; ++i) {\n\n            if (buf[i] < '0' || buf[i] > '9')\n\n                continue;\n\n            err *= 10;\n\n            err += buf[i] - '0';\n\n        }\n\n        dash = !!(buf[3] == '-');\n\n\n\n        for (i = 0; response_codes[i]; ++i) {\n\n            if (err == response_codes[i]) {\n\n                if (line)\n\n                    av_bprintf(&line_buffer, \"%s\", buf);\n\n                code_found = 1;\n\n                result = err;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (line)\n\n        av_bprint_finalize(&line_buffer, line);\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2078, "prediction": "0", "true_label": "0", "raw_text": "8: /* MCI */\n\n        return 0;\n\n    case 0x4c: /* FLASH */\n\n        return 0;\n\n    case 0x50: /* CLCD */\n\n        return 0x1000;\n\n    case 0x54: /* CLCDSER */\n\n        return 0;\n\n    case 0x58: /* BOOTCS */\n\n        return 0;\n\n    case 0x5c: /* 24MHz */\n\n        return muldiv64(qemu_get_clock(vm_clock), 24000000, get_ticks_per_sec());\n\n    case 0x60: /* MISC */\n\n        return 0;\n\n    case 0x84: /* PROCID0 */\n\n        /* ??? Don't know what the proper value for the core tile ID is.  */\n\n        return 0x02000000;\n\n    case 0x88: /* PROCID1 */\n\n        return 0xff000000;\n\n    case 0x64: /* DMAPSR0 */\n\n    case 0x68: /* DMAPSR1 */\n\n    case 0x6c: /* DMAPSR2 */\n\n    case 0x70: /* IOSEL */\n\n    case 0x74: /* PLDCTL */\n\n    case 0x80: /* BUSID */\n\n    case 0x8c: /* OSCRESET0 */\n\n    case 0x90: /* OSCRESET1 */\n\n    case 0x94: /* OSCRESET2 */\n\n    case 0x98: /* OSCRESET3 */\n\n    case 0x9c: /* OSCRESET4 */\n\n    case 0xc0: /* SYS_TEST_OSC0 */\n\n    case 0xc4: /* SYS_TEST_OSC1 */\n\n    case 0xc8: /* SYS_TEST_OSC2 */\n\n    case 0xcc: /* SYS_TEST_OSC3 */\n\n    case 0xd0: /* SYS_TEST_OSC4 */\n\n        return 0;\n\n    default:\n\n        printf (\"arm_sysctl_read: Bad register offset 0x%x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2079, "prediction": "0", "true_label": "0", "raw_text": "Question: void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)\n\n{\n\n    struct qemu_work_item wi;\n\n\n\n    if (qemu_cpu_is_self(cpu)) {\n\n        func(data);\n\n        return;\n\n    }\n\n\n\n    wi.func = func;\n\n    wi.data = data;\n\n    wi.free = false;\n\n    if (cpu->queued_work_first == NULL) {\n\n        cpu->queued_work_first = &wi;\n\n    } else {\n\n        cpu->queued_work_last->next = &wi;\n\n    }\n\n    cpu->queued_work_last = &wi;\n\n    wi.next = NULL;\n\n    wi.done = false;\n\n\n\n    qemu_cpu_kick(cpu);\n\n    while (!wi.done) {\n\n        CPUState *self_cpu = current_cpu;\n\n\n\n        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);\n\n        current_cpu = self_cpu;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2080, "prediction": "0", "true_label": "0", "raw_text": "ptr, char **restrict endptr)\n\n{\n\n    char *end;\n\n    double res;\n\n\n\n    /* Skip leading spaces */\n\n    while (isspace(*nptr))\n\n        nptr++;\n\n\n\n    if (!av_strncasecmp(nptr, \"infinity\", 8)) {\n\n        end = nptr + 8;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"inf\", 3)) {\n\n        end = nptr + 3;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"+inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-infinity\", 9)) {\n\n        end = nptr + 9;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"-inf\", 4)) {\n\n        end = nptr + 4;\n\n        res = -INFINITY;\n\n    } else if (!av_strncasecmp(nptr, \"nan\", 3)) {\n\n        end = check_nan_suffix(nptr + 3);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"+nan\", 4) ||\n\n               !av_strncasecmp(nptr, \"-nan\", 4)) {\n\n        end = check_nan_suffix(nptr + 4);\n\n        res = NAN;\n\n    } else if (!av_strncasecmp(nptr, \"0x\", 2) ||\n\n               !av_strncasecmp(nptr, \"-0x\", 3) ||\n\n               !av_strncasecmp(nptr, \"+0x\", 3)) {\n\n        /* FIXME this doesn't handle exponents, non-integers (float/double)\n\n         * and numbers too large for long long */\n\n        res = strtoll(nptr, &end, 16);\n\n    } else {\n\n        res = strtod(nptr, &end);\n\n    }\n\n\n\n    if (endptr)\n\n        *endptr = end;\n\n\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2081, "prediction": "0", "true_label": "0", "raw_text": "Question: static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {\n\n    double time = av_gettime() / 1000000.0;\n\n    /* update current video pts */\n\n    is->video_current_pts = pts;\n\n    is->video_current_pts_drift = is->video_current_pts - time;\n\n    is->video_current_pos = pos;\n\n    is->frame_last_pts = pts;\n\n    check_external_clock_sync(is, is->video_current_pts);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2082, "prediction": "1", "true_label": "0", "raw_text": "Question: open_f(int argc, char **argv)\n\n{\n\n\tint flags = 0;\n\n\tint readonly = 0;\n\n\tint growable = 0;\n\n\tint c;\n\n\n\n\twhile ((c = getopt(argc, argv, \"snrg\")) != EOF) {\n\n\t\tswitch (c) {\n\n\t\tcase 's':\n\n\t\t\tflags |= BDRV_O_SNAPSHOT;\n\n\t\t\tbreak;\n\n\t\tcase 'n':\n\n\t\t\tflags |= BDRV_O_NOCACHE;\n\n\t\t\tbreak;\n\n\t\tcase 'r':\n\n\t\t\treadonly = 1;\n\n\t\t\tbreak;\n\n\t\tcase 'g':\n\n\t\t\tgrowable = 1;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\treturn command_usage(&open_cmd);\n\n\t\t}\n\n\t}\n\n\n\n\tif (!readonly) {\n\n            flags |= BDRV_O_RDWR;\n\n        }\n\n\n\n\tif (optind != argc - 1)\n\n\t\treturn command_usage(&open_cmd);\n\n\n\n\treturn openfile(argv[optind], flags, growable);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2083, "prediction": "1", "true_label": "0", "raw_text": "Question: static unsigned int event_status_media(IDEState *s,\n\n                                       uint8_t *buf)\n\n{\n\n    uint8_t event_code, media_status;\n\n\n\n    media_status = 0;\n\n    if (s->tray_open) {\n\n        media_status = MS_TRAY_OPEN;\n\n    } else if (bdrv_is_inserted(s->bs)) {\n\n        media_status = MS_MEDIA_PRESENT;\n\n    }\n\n\n\n    /* Event notification descriptor */\n\n    event_code = MEC_NO_CHANGE;\n\n    if (media_status != MS_TRAY_OPEN) {\n\n        if (s->events.new_media) {\n\n            event_code = MEC_NEW_MEDIA;\n\n            s->events.new_media = false;\n\n        } else if (s->events.eject_request) {\n\n            event_code = MEC_EJECT_REQUESTED;\n\n            s->events.eject_request = false;\n\n        }\n\n    }\n\n\n\n    buf[4] = event_code;\n\n    buf[5] = media_status;\n\n\n\n    /* These fields are reserved, just clear them. */\n\n    buf[6] = 0;\n\n    buf[7] = 0;\n\n\n\n    return 8; /* We wrote to 4 extra bytes from the header */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 2084, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,\n\n                                  Error **errp)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);\n\n    VirtIOSCSI *s = VIRTIO_SCSI(vdev);\n\n    SCSIDevice *sd = SCSI_DEVICE(dev);\n\n\n\n    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {\n\n        virtio_scsi_push_event(s, sd,\n\n                               VIRTIO_SCSI_T_TRANSPORT_RESET,\n\n                               VIRTIO_SCSI_EVT_RESET_REMOVED);\n\n    }\n\n\n\n    if (s->ctx) {\n\n        blk_op_unblock_all(sd->conf.blk, s->blocker);\n\n    }\n\n    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2085, "prediction": "0", "true_label": "0", "raw_text": "Question: int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,\n\n                                    SocketAddress *addr,\n\n                                    Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_connect_sync(ioc, addr);\n\n    fd = socket_connect(addr, NULL, NULL, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_connect_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_connect_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2086, "prediction": "0", "true_label": "1", "raw_text": "Question: static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,\n                      int append)\n{\n    int buflen;\n    /** when the frame data does not need to be concatenated, the input buffer\n        is resetted and additional bits from the previous frame are copyed\n        and skipped later so that a fast byte copy is possible */\n    if (!append) {\n        s->frame_offset = get_bits_count(gb) & 7;\n        s->num_saved_bits = s->frame_offset;\n        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n    buflen = (s->num_saved_bits + len + 8) >> 3;\n    if (len <= 0 || buflen > MAX_FRAMESIZE) {\n        avpriv_request_sample(s->avctx, \"Too small input buffer\");\n    s->num_saved_bits += len;\n    if (!append) {\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),\n                     s->num_saved_bits);\n    } else {\n        int align = 8 - (get_bits_count(gb) & 7);\n        align = FFMIN(align, len);\n        put_bits(&s->pb, align, get_bits(gb, align));\n        len -= align;\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);\n    skip_bits_long(gb, len);\n    {\n        PutBitContext tmp = s->pb;\n        flush_put_bits(&tmp);\n    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);\n    skip_bits(&s->gb, s->frame_offset);\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2087, "prediction": "-1", "true_label": "1", "raw_text": ", &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2088, "prediction": "0", "true_label": "1", "raw_text": "8 /\n                         (av_get_bits_per_sample(avctx->codec_id) *\n                          avctx->channels);\n            if (nb_samples >= INT_MAX) {\n                av_frame_free(&frame);\n                return AVERROR(EINVAL);\n            }\n            frame->nb_samples = nb_samples;\n        }\n        /* it is assumed that the samples buffer is large enough based on the\n         * relevant parameters */\n        samples_size = av_samples_get_buffer_size(NULL, avctx->channels,\n                                                  frame->nb_samples,\n                                                  avctx->sample_fmt, 1);\n        if ((ret = avcodec_fill_audio_frame(frame, avctx->channels,\n                                            avctx->sample_fmt,\n                                            (const uint8_t *)samples,\n                                            samples_size, 1)) < 0) {\n            av_frame_free(&frame);\n            return ret;\n        }\n        /* fabricate frame pts from sample count.\n         * this is needed because the avcodec_encode_audio() API does not have\n         * a way for the user to provide pts */\n        if (avctx->sample_rate && avctx->time_base.num)\n            frame->pts = ff_samples_to_time_base(avctx,\n                                                 avctx->internal->sample_count);\n        else\n            frame->pts = AV_NOPTS_VALUE;\n        avctx->internal->sample_count += frame->nb_samples;\n    } else {\n        frame = NULL;\n    }\n    got_packet = 0;\n    ret = avcodec_encode_audio2(avctx, &pkt, frame, &got_packet);\n    if (!ret && got_packet && avctx->coded_frame) {\n        avctx->coded_frame->pts       = pkt.pts;\n        avctx->coded_frame->key_frame = !!(pkt.flags & AV_PKT_FLAG_KEY);\n    }\n    /* free any side data since we cannot return it */\n    av_packet_free_side_data(&pkt);\n    if (frame && frame->extended_data != frame->data)\n        av_freep(&frame->extended_data);\n    av_frame_free(&frame);\n    return ret ? ret : pkt.size;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2089, "prediction": "0", "true_label": "1", "raw_text": "Question: static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2090, "prediction": "0", "true_label": "1", "raw_text": "urface9 *surface = (IDirect3DSurface9*)src->data[3];\n\n    DXVA2Mapping      *map;\n\n    D3DSURFACE_DESC    surfaceDesc;\n\n    D3DLOCKED_RECT     LockedRect;\n\n    HRESULT            hr;\n\n    int i, err, nb_planes;\n\n    int lock_flags = 0;\n\n\n\n    nb_planes = av_pix_fmt_count_planes(dst->format);\n\n\n\n    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error getting a surface description\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (!(flags & AV_HWFRAME_MAP_WRITE))\n\n        lock_flags |= D3DLOCK_READONLY;\n\n    if (flags & AV_HWFRAME_MAP_OVERWRITE)\n\n        lock_flags |= D3DLOCK_DISCARD;\n\n\n\n    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unable to lock DXVA2 surface\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    map = av_mallocz(sizeof(*map));\n\n    if (!map)\n\n        goto fail;\n\n\n\n    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,\n\n                                dxva2_unmap_frame, map);\n\n    if (err < 0) {\n\n        av_freep(&map);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < nb_planes; i++)\n\n        dst->linesize[i] = LockedRect.Pitch;\n\n\n\n    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,\n\n                           (uint8_t*)LockedRect.pBits, dst->linesize);\n\n\n\n    if (dst->format == AV_PIX_FMT_PAL8)\n\n        dst->data[1] = (uint8_t*)map->palette_dummy;\n\n\n\n    return 0;\n\nfail:\n\n    IDirect3DSurface9_UnlockRect(surface);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2091, "prediction": "0", "true_label": "1", "raw_text": "Question: void show_help(void)\n\n{\n\n    const char *prog;\n\n    const OptionDef *po;\n\n    int i, expert;\n\n    \n\n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n\n\n\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n\n           prog);\n\n    \n\n    if (!do_play) {\n\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n\n               \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\");\n\n    } else {\n\n        printf(\"usage: ffplay [options] input_file...\\n\"\n\n               \"Simple audio player\\n\");\n\n    }\n\n           \n\n    printf(\"\\n\"\n\n           \"Main options are:\\n\");\n\n    for(i=0;i<2;i++) {\n\n        if (i == 1)\n\n            printf(\"\\nAdvanced options are:\\n\");\n\n        for(po = options; po->name != NULL; po++) {\n\n            char buf[64];\n\n            expert = (po->flags & OPT_EXPERT) != 0;\n\n            if (expert == i) {\n\n                strcpy(buf, po->name);\n\n                if (po->flags & HAS_ARG) {\n\n                    strcat(buf, \" \");\n\n                    strcat(buf, po->argname);\n\n                }\n\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n\n            }\n\n        }\n\n    }\n\n\n\n    exit(1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2092, "prediction": "1", "true_label": "1", "raw_text": "Question: av_cold int ffv1_common_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n\n\n    if (!avctx->width || !avctx->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    s->avctx = avctx;\n\n    s->flags = avctx->flags;\n\n\n\n    s->picture.f = avcodec_alloc_frame();\n\n    s->last_picture.f = av_frame_alloc();\n\n\n\n    ff_dsputil_init(&s->dsp, avctx);\n\n\n\n    s->width  = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    // defaults\n\n    s->num_h_slices = 1;\n\n    s->num_v_slices = 1;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2093, "prediction": "0", "true_label": "0", "raw_text": " (cbp0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n\n\n            /* time to replace codebook */\n\n            memcpy(s->codebook, s->next_codebook_buffer,\n\n                s->next_codebook_buffer_index);\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    if (cbpz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n            GetByteContext gb;\n\n\n\n            bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n\n            /* decompress codebook */\n\n            if ((res = decode_format80(&gb, s->next_codebook_buffer_index,\n\n                                       s->codebook, s->codebook_size, 0)) < 0)\n\n                return res;\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2094, "prediction": "0", "true_label": "0", "raw_text": "Question: static void platform_mmio_map(PCIDevice *d, int region_num,\n\n                              pcibus_t addr, pcibus_t size, int type)\n\n{\n\n    int mmio_io_addr;\n\n\n\n    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,\n\n                                                 DEVICE_NATIVE_ENDIAN);\n\n\n\n    cpu_register_physical_memory(addr, size, mmio_io_addr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2095, "prediction": "-1", "true_label": "0", "raw_text": ";\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2096, "prediction": "0", "true_label": "0", "raw_text": "Question: static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,\n\n                                        uint8_t isc, bool swap,\n\n                                        bool is_maskable)\n\n{\n\n    struct kvm_s390_io_adapter adapter = {\n\n        .id = id,\n\n        .isc = isc,\n\n        .maskable = is_maskable,\n\n        .swap = swap,\n\n    };\n\n    KVMS390FLICState *flic = KVM_S390_FLIC(fs);\n\n    int r, ret;\n\n    struct kvm_device_attr attr = {\n\n        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,\n\n        .addr = (uint64_t)&adapter,\n\n    };\n\n\n\n    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {\n\n        /* nothing to do */\n\n        return 0;\n\n    }\n\n\n\n    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);\n\n\n\n    ret = r ? -errno : 0;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2097, "prediction": "0", "true_label": "0", "raw_text": "ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2098, "prediction": "1", "true_label": "0", "raw_text": "Question: QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2099, "prediction": "0", "true_label": "1", "raw_text": "Question: void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2100, "prediction": "0", "true_label": "1", "raw_text": "Question: static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2101, "prediction": "0", "true_label": "1", "raw_text": "\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n\n                                              pkt->size - 7,\n\n                                              0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb      = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2102, "prediction": "0", "true_label": "0", "raw_text": "_named->type == FF_OPT_TYPE_CONST)\n\n                    d= o_named->default_val.dbl;\n\n                else if (!strcmp(buf, \"default\")) d= o->default_val.dbl;\n\n                else if (!strcmp(buf, \"max\"    )) d= o->max;\n\n                else if (!strcmp(buf, \"min\"    )) d= o->min;\n\n                else if (!strcmp(buf, \"none\"   )) d= 0;\n\n                else if (!strcmp(buf, \"all\"    )) d= ~0;\n\n                else {\n\n                    int res = av_expr_parse_and_eval(&d, buf, const_names, const_values, NULL, NULL, NULL, NULL, NULL, 0, obj);\n\n                    if (res < 0) {\n\n                        av_log(obj, AV_LOG_ERROR, \"Unable to parse option value \\\"%s\\\"\\n\", val);\n\n                        return res;\n\n                    }\n\n                }\n\n            }\n\n            if (o->type == FF_OPT_TYPE_FLAGS) {\n\n                if      (cmd=='+') d= av_get_int(obj, name, NULL) | (int64_t)d;\n\n                else if (cmd=='-') d= av_get_int(obj, name, NULL) &~(int64_t)d;\n\n            } else {\n\n                if      (cmd=='+') d= notfirst*av_get_double(obj, name, NULL) + d;\n\n                else if (cmd=='-') d= notfirst*av_get_double(obj, name, NULL) - d;\n\n            }\n\n\n\n            if ((ret = av_set_number2(obj, name, d, 1, 1, o_out)) < 0)\n\n                return ret;\n\n            val+= i;\n\n            if (!*val)\n\n                return 0;\n\n            notfirst=1;\n\n        }\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (alloc) {\n\n        av_free(*(void**)(((uint8_t*)obj) + o->offset));\n\n        val= av_strdup(val);\n\n    }\n\n\n\n    memcpy(((uint8_t*)obj) + o->offset, &val, sizeof(val));\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2103, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,\n\n                                    int alpha, int beta, int8_t *tc)\n\n{\n\n    uint8_t bs0 = 1;\n\n    uint8_t bs1 = 1;\n\n    uint8_t bs2 = 1;\n\n    uint8_t bs3 = 1;\n\n\n\n    if (tc[0] < 0)\n\n        bs0 = 0;\n\n    if (tc[1] < 0)\n\n        bs1 = 0;\n\n    if (tc[2] < 0)\n\n        bs2 = 0;\n\n    if (tc[3] < 0)\n\n        bs3 = 0;\n\n\n\n    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,\n\n                                               bs0, bs1, bs2, bs3,\n\n                                               tc[0], tc[1], tc[2], tc[3],\n\n                                               alpha, beta,\n\n                                               img_width);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2104, "prediction": "0", "true_label": "0", "raw_text": ", 0,0);\n\n\t\t\t    if (ret < 0) {\n\n\t\t\t      /* XXX */\n\n\t\t\t      if (errno == EAGAIN || errno == EWOULDBLOCK ||\n\n\t\t\t\t  errno == EINPROGRESS || errno == ENOTCONN)\n\n\t\t\t\tcontinue;\n\n\t\t\t      /* else failed */\n\n\t\t\t      so->so_state &= SS_PERSISTENT_MASK;\n\n\t\t\t      so->so_state |= SS_NOFDREF;\n\n\t\t\t    } else\n\n\t\t\t      so->so_state &= ~SS_ISFCONNECTING;\n\n\n\n\t\t\t  }\n\n\t\t\t  tcp_input((struct mbuf *)NULL, sizeof(struct ip),so);\n\n\t\t\t} /* SS_ISFCONNECTING */\n\n#endif\n\n\t\t}\n\n\n\n\t\t/*\n\n\t\t * Now UDP sockets.\n\n\t\t * Incoming packets are sent straight away, they're not buffered.\n\n\t\t * Incoming UDP data isn't buffered either.\n\n\t\t */\n\n\t\tfor (so = slirp->udb.so_next; so != &slirp->udb;\n\n\t\t     so = so_next) {\n\n\t\t\tso_next = so->so_next;\n\n\n\n\t\t\tif (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                            sorecvfrom(so);\n\n                        }\n\n\t\t}\n\n\n\n                /*\n\n                 * Check incoming ICMP relies.\n\n                 */\n\n                for (so = slirp->icmp.so_next; so != &slirp->icmp;\n\n                     so = so_next) {\n\n                     so_next = so->so_next;\n\n\n\n                    if (so->s != -1 && FD_ISSET(so->s, readfds)) {\n\n                        icmp_receive(so);\n\n                    }\n\n                }\n\n\t}\n\n\n\n\t/*\n\n\t * See if we can start outputting\n\n\t */\n\n\tif (slirp->if_queued) {\n\n\t    if_start(slirp);\n\n\t}\n\n    }\n\n\n\n\t/* clear global file descriptor sets.\n\n\t * these reside on the stack in vl.c\n\n\t * so they're unusable if we're not in\n\n\t * slirp_select_fill or slirp_select_poll.\n\n\t */\n\n\t global_readfds = NULL;\n\n\t global_writefds = NULL;\n\n\t global_xfds = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2105, "prediction": "0", "true_label": "0", "raw_text": "Question: uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)\n\n{\n\n    uint8_t opa, opb, res;\n\n    int i;\n\n\n\n    res = 0;\n\n    for (i = 0; i < 7; i++) {\n\n        opa = op1 >> (i * 8);\n\n        opb = op2 >> (i * 8);\n\n        if (opa >= opb)\n\n            res |= 1 << i;\n\n    }\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2106, "prediction": "0", "true_label": "0", "raw_text": "->kernel, 0, ram_size);\n\n        }\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"could not load kernel '%s'\\n\", ipl->kernel);\n\n            return -1;\n\n        }\n\n        /*\n\n         * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the\n\n         * kernel parameters here as well. Note: For old kernels (up to 3.2)\n\n         * we can not rely on the ELF entry point - it was 0x800 (the SALIPL\n\n         * loader) and it won't work. For this case we force it to 0x10000, too.\n\n         */\n\n        if (pentry == KERN_IMAGE_START || pentry == 0x800) {\n\n            ipl->start_addr = KERN_IMAGE_START;\n\n            /* Overwrite parameters in the kernel image, which are \"rom\" */\n\n            strcpy(rom_ptr(KERN_PARM_AREA), ipl->cmdline);\n\n        } else {\n\n            ipl->start_addr = pentry;\n\n        }\n\n\n\n        if (ipl->initrd) {\n\n            ram_addr_t initrd_offset;\n\n            int initrd_size;\n\n\n\n            initrd_offset = INITRD_START;\n\n            while (kernel_size + 0x100000 > initrd_offset) {\n\n                initrd_offset += 0x100000;\n\n            }\n\n            initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n            if (initrd_size == -1) {\n\n                fprintf(stderr, \"qemu: could not load initrd '%s'\\n\",\n\n                        ipl->initrd);\n\n                exit(1);\n\n            }\n\n\n\n            /*\n\n             * we have to overwrite values in the kernel image,\n\n             * which are \"rom\"\n\n             */\n\n            stq_p(rom_ptr(INITRD_PARM_START), initrd_offset);\n\n            stq_p(rom_ptr(INITRD_PARM_SIZE), initrd_size);\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2107, "prediction": "0", "true_label": "1", "raw_text": "Question: static int virtcon_parse(const char *devname)\n\n{\n\n    QemuOptsList *device = qemu_find_opts(\"device\");\n\n    static int index = 0;\n\n    char label[32];\n\n    QemuOpts *bus_opts, *dev_opts;\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_VIRTIO_CONSOLES) {\n\n        fprintf(stderr, \"qemu: too many virtio consoles\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    bus_opts = qemu_opts_create(device, NULL, 0);\n\n    if (arch_type == QEMU_ARCH_S390X) {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-s390\");\n\n    } else {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-pci\");\n\n    } \n\n\n\n    dev_opts = qemu_opts_create(device, NULL, 0);\n\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\");\n\n\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n\n    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!virtcon_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\",\n\n                devname, strerror(errno));\n\n        return -1;\n\n    }\n\n    qemu_opt_set(dev_opts, \"chardev\", label);\n\n\n\n    index++;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2108, "prediction": "0", "true_label": "0", "raw_text": "Question: static void monitor_puts(Monitor *mon, const char *str)\n\n{\n\n    char c;\n\n\n\n    for(;;) {\n\n        c = *str++;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '\\n') {\n\n            qstring_append_chr(mon->outbuf, '\\r');\n\n        }\n\n        qstring_append_chr(mon->outbuf, c);\n\n        if (c == '\\n') {\n\n            monitor_flush(mon);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2109, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_movl_seg_T0(DisasContext *s, int seg_reg)\n\n{\n\n    if (s->pe && !s->vm86) {\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);\n\n        /* abort translation because the addseg value may change or\n\n           because ss32 may change. For R_SS, translation must always\n\n           stop as a special handling must be done to disable hardware\n\n           interrupts for the next instruction */\n\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_op_movl_seg_T0_vm(seg_reg);\n\n        if (seg_reg == R_SS)\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2110, "prediction": "0", "true_label": "0", "raw_text": " } else {\n\n        switch (dc->is_jmp) {\n\n        case DISAS_NEXT:\n\n            gen_goto_tb(dc, 1, dc->pc);\n\n            break;\n\n        default:\n\n        case DISAS_UPDATE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            /* fall through */\n\n        case DISAS_JUMP:\n\n            /* indicate that the hash table must be used to find the next TB */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        case DISAS_TB_JUMP:\n\n        case DISAS_EXC:\n\n        case DISAS_SWI:\n\n            break;\n\n        case DISAS_WFE:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfe(cpu_env);\n\n            break;\n\n        case DISAS_YIELD:\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_yield(cpu_env);\n\n            break;\n\n        case DISAS_WFI:\n\n            /* This is a special case because we don't want to just halt the CPU\n\n             * if trying to debug across a WFI.\n\n             */\n\n            gen_a64_set_pc_im(dc->pc);\n\n            gen_helper_wfi(cpu_env);\n\n            /* The helper doesn't necessarily throw an exception, but we\n\n             * must go back to the main loop to check for interrupts anyway.\n\n             */\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        }\n\n    }\n\n\n\ndone_generating:\n\n    gen_tb_end(tb, num_insns);\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"----------------\\n\");\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(cs, pc_start, dc->pc - pc_start,\n\n                         4 | (dc->bswap_code << 1));\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n    tb->size = dc->pc - pc_start;\n\n    tb->icount = num_insns;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2111, "prediction": "1", "true_label": "0", "raw_text": "Question: static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {\n\n            sc->stsc_data[i].id = 0;\n\n            if (c->fc->error_recognition & AV_EF_EXPLODE) {\n\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid stsc index.\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2112, "prediction": "0", "true_label": "1", "raw_text": "Question: static int decode_copy(uint8_t *frame, int width, int height,\n\n                       const uint8_t *src, const uint8_t *src_end)\n\n{\n\n    const int size = width * height;\n\n\n\n    if (src_end - src < size)\n\n        return -1;\n\n    bytestream_get_buffer(&src, frame, size);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2113, "prediction": "1", "true_label": "1", "raw_text": "Question: static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2114, "prediction": "0", "true_label": "1", "raw_text": "Question: void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2115, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t pl110_read(void *opaque, hwaddr offset,\n\n                           unsigned size)\n\n{\n\n    pl110_state *s = (pl110_state *)opaque;\n\n\n\n    if (offset >= 0xfe0 && offset < 0x1000) {\n\n        return idregs[s->version][(offset - 0xfe0) >> 2];\n\n    }\n\n    if (offset >= 0x200 && offset < 0x400) {\n\n        return s->raw_palette[(offset - 0x200) >> 2];\n\n    }\n\n    switch (offset >> 2) {\n\n    case 0: /* LCDTiming0 */\n\n        return s->timing[0];\n\n    case 1: /* LCDTiming1 */\n\n        return s->timing[1];\n\n    case 2: /* LCDTiming2 */\n\n        return s->timing[2];\n\n    case 3: /* LCDTiming3 */\n\n        return s->timing[3];\n\n    case 4: /* LCDUPBASE */\n\n        return s->upbase;\n\n    case 5: /* LCDLPBASE */\n\n        return s->lpbase;\n\n    case 6: /* LCDIMSC */\n\n        if (s->version != PL110) {\n\n            return s->cr;\n\n        }\n\n        return s->int_mask;\n\n    case 7: /* LCDControl */\n\n        if (s->version != PL110) {\n\n            return s->int_mask;\n\n        }\n\n        return s->cr;\n\n    case 8: /* LCDRIS */\n\n        return s->int_status;\n\n    case 9: /* LCDMIS */\n\n        return s->int_status & s->int_mask;\n\n    case 11: /* LCDUPCURR */\n\n        /* TODO: Implement vertical refresh.  */\n\n        return s->upbase;\n\n    case 12: /* LCDLPCURR */\n\n        return s->lpbase;\n\n    default:\n\n        hw_error(\"pl110_read: Bad offset %x\\n\", (int)offset);\n\n        return 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2116, "prediction": "0", "true_label": "0", "raw_text": "\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n\n\n    return;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2117, "prediction": "0", "true_label": "0", "raw_text": "t psr = cpsr_read(env);\n\n        const char *ns_status = \"\";\n\n\n\n        if (arm_feature(env, ARM_FEATURE_EL3) &&\n\n            (psr & CPSR_M) != ARM_CPU_MODE_MON) {\n\n            ns_status = env->cp15.scr_el3 & SCR_NS ? \"NS \" : \"S \";\n\n        }\n\n\n\n        cpu_fprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\",\n\n                    psr,\n\n                    psr & CPSR_N ? 'N' : '-',\n\n                    psr & CPSR_Z ? 'Z' : '-',\n\n                    psr & CPSR_C ? 'C' : '-',\n\n                    psr & CPSR_V ? 'V' : '-',\n\n                    psr & CPSR_T ? 'T' : 'A',\n\n                    ns_status,\n\n                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);\n\n    }\n\n\n\n    if (flags & CPU_DUMP_FPU) {\n\n        int numvfpregs = 0;\n\n        if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n            numvfpregs += 16;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n            numvfpregs += 16;\n\n        }\n\n        for (i = 0; i < numvfpregs; i++) {\n\n            uint64_t v = float64_val(env->vfp.regs[i]);\n\n            cpu_fprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\",\n\n                        i * 2, (uint32_t)v,\n\n                        i * 2 + 1, (uint32_t)(v >> 32),\n\n                        i, v);\n\n        }\n\n        cpu_fprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARM_VFP_FPSCR]);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2118, "prediction": "0", "true_label": "1", "raw_text": "version_id <= version_id)) {\n\n            void *first_elem = opaque + field->offset;\n\n            int i, n_elems = vmstate_n_elems(opaque, field);\n\n            int size = vmstate_size(opaque, field);\n\n\n\n            vmstate_handle_alloc(first_elem, field, opaque);\n\n            if (field->flags & VMS_POINTER) {\n\n                first_elem = *(void **)first_elem;\n\n                assert(first_elem  || !n_elems);\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *curr_elem = first_elem + size * i;\n\n\n\n                if (field->flags & VMS_ARRAY_OF_POINTER) {\n\n                    curr_elem = *(void **)curr_elem;\n\n                }\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, curr_elem,\n\n                                             field->vmsd->version_id);\n\n                } else {\n\n                    ret = field->info->get(f, curr_elem, size, field);\n\n                }\n\n                if (ret >= 0) {\n\n                    ret = qemu_file_get_error(f);\n\n                }\n\n                if (ret < 0) {\n\n                    qemu_file_set_error(f, ret);\n\n                    error_report(\"Failed to load %s:%s\", vmsd->name,\n\n                                 field->name);\n\n                    trace_vmstate_load_field_error(field->name, ret);\n\n                    return ret;\n\n                }\n\n            }\n\n        } else if (field->flags & VMS_MUST_EXIST) {\n\n            error_report(\"Input validation failed: %s/%s\",\n\n                         vmsd->name, field->name);\n\n            return -1;\n\n        }\n\n        field++;\n\n    }\n\n    ret = vmstate_subsection_load(f, vmsd, opaque);\n\n    if (ret != 0) {\n\n        return ret;\n\n    }\n\n    if (vmsd->post_load) {\n\n        ret = vmsd->post_load(opaque, version_id);\n\n    }\n\n    trace_vmstate_load_state_end(vmsd->name, \"end\", ret);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2119, "prediction": "0", "true_label": "0", "raw_text": "Question: static void xen_log_start(MemoryListener *listener,\n\n                          MemoryRegionSection *section)\n\n{\n\n    XenIOState *state = container_of(listener, XenIOState, memory_listener);\n\n\n\n    xen_sync_dirty_bitmap(state, section->offset_within_address_space,\n\n                          int128_get64(section->size));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2120, "prediction": "0", "true_label": "1", "raw_text": "_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 4;\n\n                                else\n\n                                    s->repeat_pict = 2;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2121, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_smbios_ep_address(test_data *data)\n\n{\n\n    uint32_t off;\n\n\n\n    /* find smbios entry point structure */\n\n    for (off = 0xf0000; off < 0x100000; off += 0x10) {\n\n        uint8_t sig[] = \"_SM_\";\n\n        int i;\n\n\n\n        for (i = 0; i < sizeof sig - 1; ++i) {\n\n            sig[i] = readb(off + i);\n\n        }\n\n\n\n        if (!memcmp(sig, \"_SM_\", sizeof sig)) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    g_assert_cmphex(off, <, 0x100000);\n\n    data->smbios_ep_addr = off;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2122, "prediction": "1", "true_label": "1", "raw_text": "Question: static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2123, "prediction": "1", "true_label": "1", "raw_text": ";\n\n                accu -= (int64_t)w_im*tmpz[ n2+i].re;\n\n                tmp2 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].re;\n\n                accu -= (int64_t)w_im*tmpz[n34+i].im;\n\n                tmp3 = (int32_t)((accu + 0x40000000) >> 31);\n\n                accu  = (int64_t)w_re*tmpz[n34+i].im;\n\n                accu += (int64_t)w_im*tmpz[n34+i].re;\n\n                tmp4 = (int32_t)((accu + 0x40000000) >> 31);\n\n\n\n                tmp5 = tmp1 + tmp3;\n\n                tmp1 = tmp1 - tmp3;\n\n                tmp6 = tmp2 + tmp4;\n\n                tmp2 = tmp2 - tmp4;\n\n\n\n                tmpz[ n2+i].re = tmpz[   i].re - tmp5;\n\n                tmpz[    i].re = tmpz[   i].re + tmp5;\n\n                tmpz[ n2+i].im = tmpz[   i].im - tmp6;\n\n                tmpz[    i].im = tmpz[   i].im + tmp6;\n\n                tmpz[n34+i].re = tmpz[n4+i].re - tmp2;\n\n                tmpz[ n4+i].re = tmpz[n4+i].re + tmp2;\n\n                tmpz[n34+i].im = tmpz[n4+i].im + tmp1;\n\n                tmpz[ n4+i].im = tmpz[n4+i].im - tmp1;\n\n\n\n                w_re_ptr += step;\n\n                w_im_ptr -= step;\n\n            }\n\n        }\n\n        step >>= 1;\n\n        n4   <<= 1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2124, "prediction": "0", "true_label": "1", "raw_text": "ISR] = 0x04000000;\n\n                    }\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x06100000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x04100000;\n\n                    }\n\n                    break;\n\n                default:\n\n                    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    env->exception_index = POWERPC_EXCP_PROGRAM;\n\n                    env->error_code =\n\n                        POWERPC_EXCP_INVAL | POWERPC_EXCP_INVAL_INVAL;\n\n                    env->spr[SPR_DAR] = address;\n\n                    break;\n\n                }\n\n                break;\n\n#if defined(TARGET_PPC64)\n\n            case -5:\n\n                /* No match in segment table */\n\n                if (env->mmu_model == POWERPC_MMU_620) {\n\n                    env->exception_index = POWERPC_EXCP_DSI;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                    /* XXX: this might be incorrect */\n\n                    if (rw == 1) {\n\n                        env->spr[SPR_DSISR] = 0x42000000;\n\n                    } else {\n\n                        env->spr[SPR_DSISR] = 0x40000000;\n\n                    }\n\n                } else {\n\n                    env->exception_index = POWERPC_EXCP_DSEG;\n\n                    env->error_code = 0;\n\n                    env->spr[SPR_DAR] = address;\n\n                }\n\n                break;\n\n#endif\n\n            }\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\", __func__,\n\n               env->exception, env->error_code);\n\n#endif\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2125, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2126, "prediction": "0", "true_label": "0", "raw_text": "Question: static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,\n\n                              int nb_sectors, int *pnum)\n\n{\n\n    uint64_t cluster_offset;\n\n    int ret;\n\n\n\n    *pnum = nb_sectors;\n\n    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't\n\n     * pass them on today */\n\n    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);\n\n    if (ret < 0) {\n\n        *pnum = 0;\n\n    }\n\n\n\n    return (cluster_offset != 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2127, "prediction": "0", "true_label": "0", "raw_text": "Question: static void migrate_params_test_apply(MigrateSetParameters *params,\n\n                                      MigrationParameters *dest)\n\n{\n\n    *dest = migrate_get_current()->parameters;\n\n\n\n    /* TODO use QAPI_CLONE() instead of duplicating it inline */\n\n\n\n    if (params->has_compress_level) {\n\n        dest->compress_level = params->compress_level;\n\n    }\n\n\n\n    if (params->has_compress_threads) {\n\n        dest->compress_threads = params->compress_threads;\n\n    }\n\n\n\n    if (params->has_decompress_threads) {\n\n        dest->decompress_threads = params->decompress_threads;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_initial) {\n\n        dest->cpu_throttle_initial = params->cpu_throttle_initial;\n\n    }\n\n\n\n    if (params->has_cpu_throttle_increment) {\n\n        dest->cpu_throttle_increment = params->cpu_throttle_increment;\n\n    }\n\n\n\n    if (params->has_tls_creds) {\n\n        dest->tls_creds = g_strdup(params->tls_creds);\n\n    }\n\n\n\n    if (params->has_tls_hostname) {\n\n        dest->tls_hostname = g_strdup(params->tls_hostname);\n\n    }\n\n\n\n    if (params->has_max_bandwidth) {\n\n        dest->max_bandwidth = params->max_bandwidth;\n\n    }\n\n\n\n    if (params->has_downtime_limit) {\n\n        dest->downtime_limit = params->downtime_limit;\n\n    }\n\n\n\n    if (params->has_x_checkpoint_delay) {\n\n        dest->x_checkpoint_delay = params->x_checkpoint_delay;\n\n    }\n\n\n\n    if (params->has_block_incremental) {\n\n        dest->block_incremental = params->block_incremental;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2128, "prediction": "0", "true_label": "0", "raw_text": "7] = 0;\n\n        env->CP0_WatchHi[7] = 0;\n\n    }\n\n    /* Count register increments in debug mode, EJTAG version 1 */\n\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n\n    env->hflags = MIPS_HFLAG_CP0;\n\n\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        int i;\n\n\n\n        /* Only TC0 on VPE 0 starts as active.  */\n\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n\n            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;\n\n            env->tcs[i].CP0_TCHalt = 1;\n\n        }\n\n        env->active_tc.CP0_TCHalt = 1;\n\n        env->halted = 1;\n\n\n\n        if (!env->cpu_index) {\n\n            /* VPE0 starts up enabled.  */\n\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n\n\n\n            /* TC0 starts up unhalted.  */\n\n            env->halted = 0;\n\n            env->active_tc.CP0_TCHalt = 0;\n\n            env->tcs[0].CP0_TCHalt = 0;\n\n            /* With thread 0 active.  */\n\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n\n        }\n\n    }\n\n#endif\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n#endif\n\n    env->exception_index = EXCP_NONE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2129, "prediction": "1", "true_label": "0", "raw_text": "Question: bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n\n        if (errp) {\n\n            *errp = error_copy(blocker->reason);\n\n            error_prepend(errp, \"Node '%s' is busy: \",\n\n                          bdrv_get_device_or_node_name(bs));\n\n        }\n\n        return true;\n\n    }\n\n    return false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2130, "prediction": "1", "true_label": "0", "raw_text": "Question: static BlockJob *find_block_job(const char *device, AioContext **aio_context,\n\n                                Error **errp)\n\n{\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs;\n\n\n\n    *aio_context = NULL;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        goto notfound;\n\n    }\n\n\n\n    *aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(*aio_context);\n\n\n\n    if (!blk_is_available(blk)) {\n\n        goto notfound;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (!bs->job) {\n\n        goto notfound;\n\n    }\n\n\n\n    return bs->job;\n\n\n\nnotfound:\n\n    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n\n              \"No active block job on device '%s'\", device);\n\n    if (*aio_context) {\n\n        aio_context_release(*aio_context);\n\n        *aio_context = NULL;\n\n    }\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2131, "prediction": "1", "true_label": "0", "raw_text": "Question: static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2132, "prediction": "0", "true_label": "0", "raw_text": ", mmu));\n\n\t} else {\n\n\t\t/* If refill, provide a randomized set.  */\n\n\t\tset = env->mmu_rand_lfsr & 3;\n\n\t}\n\n\n\n\tif (!match && !debug) {\n\n\t\tcris_mmu_update_rand_lfsr(env);\n\n\n\n\t\t/* Compute index.  */\n\n\t\tidx = vpage & 15;\n\n\n\n\t\t/* Update RW_MM_TLB_SEL.  */\n\n\t\tenv->sregs[SFR_RW_MM_TLB_SEL] = 0;\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], idx, 0, 4);\n\n\t\tset_field(&env->sregs[SFR_RW_MM_TLB_SEL], set, 4, 2);\n\n\n\n\t\t/* Update RW_MM_CAUSE.  */\n\n\t\tset_field(&r_cause, rwcause, 8, 2);\n\n\t\tset_field(&r_cause, vpage, 13, 19);\n\n\t\tset_field(&r_cause, pid, 0, 8);\n\n\t\tenv->sregs[SFR_R_MM_CAUSE] = r_cause;\n\n\t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc));\n\n\t}\n\n\n\n\tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\n\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\n\n\t\t  __func__, rw, match, env->pc,\n\n\t\t  vaddr, vpage,\n\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \n\n\t\t  pid,\n\n\t\t  r_cause,\n\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\n\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));\n\n\n\n\tres->phy = tlb_pfn << TARGET_PAGE_BITS;\n\n\treturn !match;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2133, "prediction": "0", "true_label": "1", "raw_text": "Question: static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2134, "prediction": "0", "true_label": "0", "raw_text": "Question: static void x86_cpu_enable_xsave_components(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    int i;\n\n\n\n    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n        return;\n\n    }\n\n\n\n    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n        const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n        if (env->features[esa->feature] & esa->bits) {\n\n            env->xsave_components |= (1ULL << i);\n\n        }\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        KVMState *s = kvm_state;\n\n        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n        kvm_mask <<= 32;\n\n        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        env->xsave_components &= kvm_mask;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2135, "prediction": "0", "true_label": "0", "raw_text": "Question: int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,\n\n                       target_ulong *addr, int *flags)\n\n{\n\n    /* TODO: low address protection once we flush the tlb on cr changes */\n\n    *flags = PAGE_READ | PAGE_WRITE;\n\n    *addr = mmu_real2abs(env, raddr);\n\n\n\n    /* TODO: storage key handling */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2136, "prediction": "0", "true_label": "0", "raw_text": "Question: static void nic_selective_reset(EEPRO100State * s)\n\n{\n\n    size_t i;\n\n    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);\n\n    //~ eeprom93xx_reset(s->eeprom);\n\n    memcpy(eeprom_contents, s->conf.macaddr.a, 6);\n\n    eeprom_contents[0xa] = 0x4000;\n\n    if (s->device == i82557B || s->device == i82557C)\n\n        eeprom_contents[5] = 0x0100;\n\n    uint16_t sum = 0;\n\n    for (i = 0; i < EEPROM_SIZE - 1; i++) {\n\n        sum += eeprom_contents[i];\n\n    }\n\n    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;\n\n    TRACE(EEPROM, logout(\"checksum=0x%04x\\n\", eeprom_contents[EEPROM_SIZE - 1]));\n\n\n\n    memset(s->mem, 0, sizeof(s->mem));\n\n    uint32_t val = BIT(21);\n\n    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));\n\n\n\n    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));\n\n    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2137, "prediction": "0", "true_label": "1", "raw_text": "Question: void pci_bridge_reset_reg(PCIDevice *dev)\n\n{\n\n    uint8_t *conf = dev->config;\n\n\n\n    conf[PCI_PRIMARY_BUS] = 0;\n\n    conf[PCI_SECONDARY_BUS] = 0;\n\n    conf[PCI_SUBORDINATE_BUS] = 0;\n\n    conf[PCI_SEC_LATENCY_TIMER] = 0;\n\n\n\n    conf[PCI_IO_BASE] = 0;\n\n    conf[PCI_IO_LIMIT] = 0;\n\n    pci_set_word(conf + PCI_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);\n\n    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);\n\n    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);\n\n    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);\n\n\n\n    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2138, "prediction": "0", "true_label": "1", "raw_text": "Question: static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,\n\n                                        target_phys_addr_t start_addr,\n\n                                        target_phys_addr_t end_addr)\n\n{\n\n    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2139, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2140, "prediction": "0", "true_label": "0", "raw_text": "fb7000,\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3TX),\n\n                                qdev_get_gpio_in(s->ih[1], OMAP_INT_McBSP3RX),\n\n                    &s->drq[OMAP_DMA_MCBSP3_TX], omap_findclk(s, \"dspxor_ck\"));\n\n\n\n    s->led[0] = omap_lpg_init(system_memory,\n\n                              0xfffbd000, omap_findclk(s, \"clk32-kHz\"));\n\n    s->led[1] = omap_lpg_init(system_memory,\n\n                              0xfffbd800, omap_findclk(s, \"clk32-kHz\"));\n\n\n\n    /* Register mappings not currenlty implemented:\n\n     * MCSI2 Comm\tfffb2000 - fffb27ff (not mapped on OMAP310)\n\n     * MCSI1 Bluetooth\tfffb2800 - fffb2fff (not mapped on OMAP310)\n\n     * USB W2FC\t\tfffb4000 - fffb47ff\n\n     * Camera Interface\tfffb6800 - fffb6fff\n\n     * USB Host\t\tfffba000 - fffba7ff\n\n     * FAC\t\tfffba800 - fffbafff\n\n     * HDQ/1-Wire\tfffbc000 - fffbc7ff\n\n     * TIPB switches\tfffbc800 - fffbcfff\n\n     * Mailbox\t\tfffcf000 - fffcf7ff\n\n     * Local bus IF\tfffec100 - fffec1ff\n\n     * Local bus MMU\tfffec200 - fffec2ff\n\n     * DSP MMU\t\tfffed200 - fffed2ff\n\n     */\n\n\n\n    omap_setup_dsp_mapping(system_memory, omap15xx_dsp_mm);\n\n    omap_setup_mpui_io(system_memory, s);\n\n\n\n    qemu_register_reset(omap1_mpu_reset, s);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2141, "prediction": "0", "true_label": "0", "raw_text": "Question: void nbd_client_close(NBDClient *client)\n\n{\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    client->closing = true;\n\n\n\n    /* Force requests to finish.  They will drop their own references,\n\n     * then we'll close the socket and free the NBDClient.\n\n     */\n\n    shutdown(client->sock, 2);\n\n\n\n    /* Also tell the client, so that they release their reference.  */\n\n    if (client->close) {\n\n        client->close(client);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2142, "prediction": "0", "true_label": "1", "raw_text": "Question: static bool find_dirty_block(RAMState *rs, PageSearchStatus *pss,\n\n                             bool *again, ram_addr_t *ram_addr_abs)\n\n{\n\n    pss->offset = migration_bitmap_find_dirty(rs, pss->block, pss->offset,\n\n                                              ram_addr_abs);\n\n    if (pss->complete_round && pss->block == rs->last_seen_block &&\n\n        pss->offset >= rs->last_offset) {\n\n        /*\n\n         * We've been once around the RAM and haven't found anything.\n\n         * Give up.\n\n         */\n\n        *again = false;\n\n        return false;\n\n    }\n\n    if (pss->offset >= pss->block->used_length) {\n\n        /* Didn't find anything in this RAM Block */\n\n        pss->offset = 0;\n\n        pss->block = QLIST_NEXT_RCU(pss->block, next);\n\n        if (!pss->block) {\n\n            /* Hit the end of the list */\n\n            pss->block = QLIST_FIRST_RCU(&ram_list.blocks);\n\n            /* Flag that we've looped */\n\n            pss->complete_round = true;\n\n            rs->ram_bulk_stage = false;\n\n            if (migrate_use_xbzrle()) {\n\n                /* If xbzrle is on, stop using the data compression at this\n\n                 * point. In theory, xbzrle can do better than compression.\n\n                 */\n\n                flush_compressed_data(rs);\n\n            }\n\n        }\n\n        /* Didn't find anything this time, but try again on the new block */\n\n        *again = true;\n\n        return false;\n\n    } else {\n\n        /* Can go around again, but... */\n\n        *again = true;\n\n        /* We've found something so probably don't need to */\n\n        return true;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2143, "prediction": "0", "true_label": "1", "raw_text": "Question: void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2144, "prediction": "0", "true_label": "0", "raw_text": "table) {\n\n            s->rl_table_index        = decode012(&s->gb);\n\n            s->rl_chroma_table_index = s->rl_table_index;\n\n        }\n\n\n\n        s->dc_table_index   = get_bits1(&s->gb);\n\n        s->mv_table_index   = get_bits1(&s->gb);\n\n\n\n        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);\n\n        s->no_rounding     ^= 1;\n\n\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \"\n\n                   \"per_mb_abt:%d abt_type:%d cbp:%d ii:%d\\n\",\n\n                   s->rl_table_index, s->rl_chroma_table_index,\n\n                   s->dc_table_index, s->mv_table_index,\n\n                   s->per_mb_rl_table, s->qscale, s->mspel,\n\n                   w->per_mb_abt, w->abt_type, w->cbp_table_index,\n\n                   s->inter_intra_pred);\n\n        }\n\n    }\n\n    s->esc3_level_length = 0;\n\n    s->esc3_run_length   = 0;\n\n    s->picture_number++; // FIXME ?\n\n\n\n    if (w->j_type) {\n\n        ff_intrax8_decode_picture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1);\n\n\n\n        ff_er_add_slice(&w->s.er, 0, 0,\n\n                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2145, "prediction": "0", "true_label": "1", "raw_text": "Question: static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,\n\n                       const int inc, void *y_tab)\n\n{\n\n    int i;\n\n    uint8_t *y_table = y_tab;\n\n\n\n    y_table -= elemsize * (inc >> 9);\n\n\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n\n        table[i] = y_table + elemsize * (cb >> 16);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2146, "prediction": "0", "true_label": "0", "raw_text": "Question: static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        if (alac->sample_size == 16) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2147, "prediction": "0", "true_label": "0", "raw_text": "Question: static int put_cod(Jpeg2000EncoderContext *s)\n\n{\n\n    Jpeg2000CodingStyle *codsty = &s->codsty;\n\n\n\n    if (s->buf_end - s->buf < 14)\n\n        return -1;\n\n\n\n    bytestream_put_be16(&s->buf, JPEG2000_COD);\n\n    bytestream_put_be16(&s->buf, 12); // Lcod\n\n    bytestream_put_byte(&s->buf, 0);  // Scod\n\n    // SGcod\n\n    bytestream_put_byte(&s->buf, 0); // progression level\n\n    bytestream_put_be16(&s->buf, 1); // num of layers\n\n    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){\n\n        bytestream_put_byte(&s->buf, 2); // ICT\n\n    }else{\n\n        bytestream_put_byte(&s->buf, 0); // unspecified\n\n    }\n\n    // SPcod\n\n    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width\n\n    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height\n\n    bytestream_put_byte(&s->buf, 0); // cblk style\n\n    bytestream_put_byte(&s->buf, codsty->transform); // transformation\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2148, "prediction": "0", "true_label": "0", "raw_text": "Question: bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2149, "prediction": "0", "true_label": "0", "raw_text": "Question: static int bdrv_get_cluster_size(BlockDriverState *bs)\n\n{\n\n    BlockDriverInfo bdi;\n\n    int ret;\n\n\n\n    ret = bdrv_get_info(bs, &bdi);\n\n    if (ret < 0 || bdi.cluster_size == 0) {\n\n        return bs->request_alignment;\n\n    } else {\n\n        return bdi.cluster_size;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2150, "prediction": "0", "true_label": "0", "raw_text": "schro_params->enc_frame_queue);\n\n\n\n    if (!p_frame_output)\n\n        return 0;\n\n\n\n    pkt_size = p_frame_output->size;\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n\n        pkt_size += p_schro_params->enc_buf_size;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", pkt_size);\n\n        goto error;\n\n    }\n\n\n\n    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n\n    avctx->coded_frame->key_frame = p_frame_output->key_frame;\n\n    /* Use the frame number of the encoded frame as the pts. It is OK to\n\n     * do so since Dirac is a constant frame rate codec. It expects input\n\n     * to be of constant frame rate. */\n\n    pkt->pts =\n\n    avctx->coded_frame->pts = p_frame_output->frame_num;\n\n    pkt->dts = p_schro_params->dts++;\n\n    enc_size = p_frame_output->size;\n\n\n\n    /* Append the end of sequence information to the last frame in the\n\n     * sequence. */\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n\n        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n\n               p_schro_params->enc_buf_size);\n\n        enc_size += p_schro_params->enc_buf_size;\n\n        av_freep(&p_schro_params->enc_buf);\n\n        p_schro_params->enc_buf_size = 0;\n\n    }\n\n\n\n    if (p_frame_output->key_frame)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\nerror:\n\n    /* free frame */\n\n    libschroedinger_free_frame(p_frame_output);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2151, "prediction": "0", "true_label": "0", "raw_text": "[0][index++].pic_id= h->short_ref[i]->frame_num;\n\n        }\n\n        short_len = index;\n\n        for(i = 0; i < 16; i++){\n\n            int sel;\n\n            if(h->long_ref[i] == NULL) continue;\n\n            sel = h->long_ref[i]->reference | structure_sel;\n\n            if(sel != PICT_FRAME) continue;\n\n            frame_list[0][index  ]= *h->long_ref[i];\n\n            frame_list[0][index++].pic_id= i;\n\n        }\n\n\n\n        if (FIELD_PICTURE)\n\n            index = split_field_ref_list(h->default_ref_list[0],\n\n                                         h->ref_count[0], frame_list[0],\n\n                                         index, s->picture_structure,\n\n                                         short_len);\n\n\n\n        if(index < h->ref_count[0])\n\n            memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));\n\n    }\n\n#ifdef TRACE\n\n    for (i=0; i<h->ref_count[0]; i++) {\n\n        tprintf(h->s.avctx, \"List0: %s fn:%d 0x%p\\n\", (h->default_ref_list[0][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[0][i].pic_id, h->default_ref_list[0][i].data[0]);\n\n    }\n\n    if(h->slice_type_nos==FF_B_TYPE){\n\n        for (i=0; i<h->ref_count[1]; i++) {\n\n            tprintf(h->s.avctx, \"List1: %s fn:%d 0x%p\\n\", (h->default_ref_list[1][i].long_ref ? \"LT\" : \"ST\"), h->default_ref_list[1][i].pic_id, h->default_ref_list[1][i].data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2152, "prediction": "-1", "true_label": "1", "raw_text": " se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2153, "prediction": "0", "true_label": "1", "raw_text": "Question: static void mvp_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));\n\n\n\n    /* MVPConf1 implemented, TLB sharable, no gating storage support,\n\n       programmable cache partitioning implemented, number of allocatable\n\n       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs\n\n       implemented, 5 TCs implemented. */\n\n    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |\n\n                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |\n\n// TODO: actually do 2 VPEs.\n\n//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |\n\n//                             (0x04 << CP0MVPC0_PTC);\n\n                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |\n\n                             (0x00 << CP0MVPC0_PTC);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    /* Usermode has no TLB support */\n\n    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);\n\n#endif\n\n\n\n    /* Allocatable CP1 have media extensions, allocatable CP1 have FP support,\n\n       no UDI implemented, no CP2 implemented, 1 CP1 implemented. */\n\n    env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |\n\n                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |\n\n                             (0x1 << CP0MVPC1_PCP1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2154, "prediction": "0", "true_label": "1", "raw_text": "));\n\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n            if (!tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted tile data encountered!\\n\");\n\n                break;\n\n            }\n\n\n\n            pos += tile->data_size << 3; // skip to next tile\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#ifdef DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2155, "prediction": "0", "true_label": "0", "raw_text": "Question: static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2156, "prediction": "1", "true_label": "0", "raw_text": "Question: RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,\n\n                                  void (*resized)(const char*,\n\n                                                  uint64_t length,\n\n                                                  void *host),\n\n                                  void *host, bool resizeable,\n\n                                  MemoryRegion *mr, Error **errp)\n\n{\n\n    RAMBlock *new_block;\n\n    Error *local_err = NULL;\n\n\n\n    size = HOST_PAGE_ALIGN(size);\n\n    max_size = HOST_PAGE_ALIGN(max_size);\n\n    new_block = g_malloc0(sizeof(*new_block));\n\n    new_block->mr = mr;\n\n    new_block->resized = resized;\n\n    new_block->used_length = size;\n\n    new_block->max_length = max_size;\n\n    assert(max_size >= size);\n\n    new_block->fd = -1;\n\n    new_block->host = host;\n\n    if (host) {\n\n        new_block->flags |= RAM_PREALLOC;\n\n    }\n\n    if (resizeable) {\n\n        new_block->flags |= RAM_RESIZEABLE;\n\n    }\n\n    ram_block_add(new_block, &local_err);\n\n    if (local_err) {\n\n        g_free(new_block);\n\n        error_propagate(errp, local_err);\n\n        return NULL;\n\n    }\n\n    mr->ram_block = new_block;\n\n    return new_block;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2157, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void tcg_out_movi(TCGContext *s, TCGType type,\n\n                                int ret, tcg_target_long arg)\n\n{\n\n#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)\n\n    if (arg != (arg & 0xffffffff))\n\n        fprintf(stderr, \"unimplemented %s with constant %ld\\n\", __func__, arg);\n\n#endif\n\n    if (arg == (arg & 0xfff))\n\n        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |\n\n                  INSN_IMM13(arg));\n\n    else {\n\n        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));\n\n        if (arg & 0x3ff)\n\n            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |\n\n                      INSN_IMM13(arg & 0x3ff));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2158, "prediction": "0", "true_label": "0", "raw_text": ");\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2159, "prediction": "0", "true_label": "1", "raw_text": "Question: static int swf_write_trailer(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int file_size, i;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = &s->streams[i]->codec;\n\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    put_swf_tag(s, TAG_END);\n\n    put_swf_end_tag(s);\n\n    \n\n    put_flush_packet(&s->pb);\n\n\n\n    /* patch file size and number of frames if not streamed */\n\n    if (!url_is_streamed(&s->pb) && video_enc) {\n\n        file_size = url_ftell(pb);\n\n        url_fseek(pb, 4, SEEK_SET);\n\n        put_le32(pb, file_size);\n\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n\n        put_le16(pb, video_enc->frame_number);\n\n    }\n\n    av_free(swf);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2160, "prediction": "0", "true_label": "1", "raw_text": " || ncolors > size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size *= 4;\n\n\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n\n    if (!x->pixels)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n\n    for (i = 0; i < ncolors; i++) {\n\n        const uint8_t *index;\n\n        int len;\n\n\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        if (ptr + cpp > end)\n\n            return AVERROR_INVALIDDATA;\n\n        index = ptr;\n\n        ptr += cpp;\n\n\n\n        ptr = strstr(ptr, \"c \");\n\n        if (ptr) {\n\n            ptr += 2;\n\n        } else {\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        len = strcspn(ptr, \"\\\" \");\n\n\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n\n            return ret;\n\n\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    for (i = 0; i < avctx->height; i++) {\n\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n\n\n        for (j = 0; j < avctx->width; j++) {\n\n            if (ptr + cpp > end)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n\n                return ret;\n\n\n\n            *dst++ = x->pixels[ret];\n\n            ptr += cpp;\n\n        }\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    p->key_frame = 1;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2161, "prediction": "1", "true_label": "0", "raw_text": ",b,c,d,j,f,g,h,i);\n\n        ROUND160_48_TO_63(d,e,a,b,c,i,j,f,g,h);\n\n    }\n\n    ROUND160_48_TO_63(c,d,e,a,b,h,i,j,f,g);\n\n    SWAP(d,i)\n\n\n\n    for (; n < 75;) {\n\n        ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n        ROUND160_64_TO_79(a,b,c,d,e,f,g,h,i,j);\n\n        ROUND160_64_TO_79(e,a,b,c,d,j,f,g,h,i);\n\n        ROUND160_64_TO_79(d,e,a,b,c,i,j,f,g,h);\n\n        ROUND160_64_TO_79(c,d,e,a,b,h,i,j,f,g);\n\n    }\n\n    ROUND160_64_TO_79(b,c,d,e,a,g,h,i,j,f);\n\n    SWAP(e,j)\n\n\n\n    if (ext) {\n\n        state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e;\n\n        state[5] += f; state[6] += g; state[7] += h; state[8] += i; state[9] += j;\n\n    } else {\n\n        i += c + state[1];\n\n        state[1] = state[2] + d + j;\n\n        state[2] = state[3] + e + f;\n\n        state[3] = state[4] + a + g;\n\n        state[4] = state[0] + b + h;\n\n        state[0] = i;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2162, "prediction": "0", "true_label": "0", "raw_text": "Question: static void opt_frame_size(const char *arg)\n\n{\n\n    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {\n\n        fprintf(stderr, \"Incorrect frame size\\n\");\n\n        av_exit(1);\n\n    }\n\n    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {\n\n        fprintf(stderr, \"Frame size must be a multiple of 2\\n\");\n\n        av_exit(1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2163, "prediction": "0", "true_label": "1", "raw_text": "Question: static int sdl_write_trailer(AVFormatContext *s)\n\n{\n\n    SDLContext *sdl = s->priv_data;\n\n\n\n    sdl->quit = 1;\n\n\n\n    if (sdl->overlay)\n\n        SDL_FreeYUVOverlay(sdl->overlay);\n\n\n    if (sdl->event_thread)\n\n        SDL_WaitThread(sdl->event_thread, NULL);\n\n\n    if (sdl->mutex)\n\n        SDL_DestroyMutex(sdl->mutex);\n\n\n    if (sdl->init_cond)\n\n        SDL_DestroyCond(sdl->init_cond);\n\n\n\n\n    if (!sdl->sdl_was_already_inited)\n\n        SDL_Quit();\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2164, "prediction": "0", "true_label": "0", "raw_text": "_pix, op_qpix);\n\n                    if ((!s->no_rounding) || s->pict_type==B_TYPE)\n\n                        op_pix = avg_pixels_tab;\n\n                    else\n\n                        op_pix = avg_no_rnd_pixels_tab;\n\n                }\n\n                if (s->mv_dir & MV_DIR_BACKWARD) {\n\n                    MPV_motion(s, dest_y, dest_cb, dest_cr, 1, s->next_picture, op_pix, op_qpix);\n\n                }\n\n            }\n\n\n\n            /* add dct residue */\n\n            add_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            add_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            add_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            add_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            add_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            add_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        } else {\n\n            /* dct only in intra block */\n\n            put_dct(s, block[0], 0, dest_y, dct_linesize);\n\n            put_dct(s, block[1], 1, dest_y + 8, dct_linesize);\n\n            put_dct(s, block[2], 2, dest_y + dct_offset, dct_linesize);\n\n            put_dct(s, block[3], 3, dest_y + dct_offset + 8, dct_linesize);\n\n\n\n            put_dct(s, block[4], 4, dest_cb, s->linesize >> 1);\n\n            put_dct(s, block[5], 5, dest_cr, s->linesize >> 1);\n\n        }\n\n    }\n\n the_end:\n\n    emms_c(); //FIXME remove\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2165, "prediction": "0", "true_label": "1", "raw_text": "Question: static void kvm_hwpoison_page_add(ram_addr_t ram_addr)\n\n{\n\n    HWPoisonPage *page;\n\n\n\n    QLIST_FOREACH(page, &hwpoison_page_list, list) {\n\n        if (page->ram_addr == ram_addr) {\n\n            return;\n\n        }\n\n    }\n\n    page = g_malloc(sizeof(HWPoisonPage));\n\n    page->ram_addr = ram_addr;\n\n    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2166, "prediction": "0", "true_label": "1", "raw_text": "Question: static int decode_i_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2167, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pcie_mmcfg_data_write(PCIBus *s,\n\n                                  uint32_t mmcfg_addr, uint32_t val, int len)\n\n{\n\n    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);\n\n\n\n    if (!pci_dev) {\n\n        return;\n\n    }\n\n    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),\n\n                                 pci_config_size(pci_dev), val, len);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2168, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_bits(Jpeg2000DecoderContext *s, int n)\n\n{\n\n    int res = 0;\n\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n\n        return AVERROR_INVALIDDATA;\n\n    while (--n >= 0) {\n\n        res <<= 1;\n\n        if (s->bit_index == 0) {\n\n            s->bit_index = 7 + (*s->buf != 0xff);\n\n            s->buf++;\n\n        }\n\n        s->bit_index--;\n\n        res |= (*s->buf >> s->bit_index) & 1;\n\n    }\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2169, "prediction": "1", "true_label": "0", "raw_text": "Question: static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)\n\n{\n\n    char *str = NULL;\n\n    int size;\n\n    uint16_t str_size;\n\n\n\n    if (c->itunes_metadata) {\n\n        int data_size = get_be32(pb);\n\n        int tag = get_le32(pb);\n\n        if (tag == MKTAG('d','a','t','a')) {\n\n            get_be32(pb); // type\n\n            get_be32(pb); // unknown\n\n            str_size = data_size - 16;\n\n        } else return 0;\n\n    } else {\n\n        str_size = get_be16(pb); // string length\n\n        get_be16(pb); // language\n\n    }\n\n    switch (atom.type) {\n\n    case MKTAG(0xa9,'n','a','m'):\n\n        str = c->fc->title; size = sizeof(c->fc->title); break;\n\n    case MKTAG(0xa9,'A','R','T'):\n\n    case MKTAG(0xa9,'w','r','t'):\n\n        str = c->fc->author; size = sizeof(c->fc->author); break;\n\n    case MKTAG(0xa9,'c','p','y'):\n\n        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;\n\n    case MKTAG(0xa9,'c','m','t'):\n\n    case MKTAG(0xa9,'i','n','f'):\n\n        str = c->fc->comment; size = sizeof(c->fc->comment); break;\n\n    case MKTAG(0xa9,'a','l','b'):\n\n        str = c->fc->album; size = sizeof(c->fc->album); break;\n\n    }\n\n    if (!str)\n\n        return 0;\n\n    get_buffer(pb, str, FFMIN(size, str_size));\n\n    dprintf(c->fc, \"%.4s %s\\n\", (char*)&atom.type, str);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2170, "prediction": "0", "true_label": "1", "raw_text": "Question: void aio_context_setup(AioContext *ctx, Error **errp)\n\n{\n\n#ifdef CONFIG_EPOLL\n\n    assert(!ctx->epollfd);\n\n    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);\n\n    if (ctx->epollfd == -1) {\n\n        ctx->epoll_available = false;\n\n    } else {\n\n        ctx->epoll_available = true;\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2171, "prediction": "0", "true_label": "0", "raw_text": "(*sub->rects));\n\n    if (!sub->rects)\n\n        return AVERROR(ENOMEM);\n\n\n\n    i = 0;\n\n\n\n    for (display = ctx->display_list; display; display = display->next) {\n\n        region = get_region(ctx, display->region_id);\n\n        rect = sub->rects[i];\n\n\n\n        if (!region)\n\n            continue;\n\n\n\n        rect->x = display->x_pos + offset_x;\n\n        rect->y = display->y_pos + offset_y;\n\n        rect->w = region->width;\n\n        rect->h = region->height;\n\n        rect->nb_colors = 16;\n\n        rect->type      = SUBTITLE_BITMAP;\n\n        rect->pict.linesize[0] = region->width;\n\n\n\n        clut = get_clut(ctx, region->clut);\n\n\n\n        if (!clut)\n\n            clut = &default_clut;\n\n\n\n        switch (region->depth) {\n\n        case 2:\n\n            clut_table = clut->clut4;\n\n            break;\n\n        case 8:\n\n            clut_table = clut->clut256;\n\n            break;\n\n        case 4:\n\n        default:\n\n            clut_table = clut->clut16;\n\n            break;\n\n        }\n\n\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n        if (!rect->pict.data[1]) {\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n\n        if (!rect->pict.data[0]) {\n\n            av_free(rect->pict.data[1]);\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n\n\n        i++;\n\n    }\n\n\n\n    sub->num_rects = i;\n\n\n\n#ifdef DEBUG\n\n    save_display_set(ctx);\n\n#endif\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2172, "prediction": "0", "true_label": "0", "raw_text": "Question: static QUANT_FN(pvq_encode_band)\n\n{\n\n    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,\n\n                               lowband_out, level, gain, lowband_scratch, fill, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2173, "prediction": "0", "true_label": "0", "raw_text": "\n\n            continue;\n\n        }\n\n\n\n        /* register prefix slot */\n\n        if (old.start_addr < start_addr) {\n\n            mem = kvm_alloc_slot(s);\n\n            mem->memory_size = start_addr - old.start_addr;\n\n            mem->start_addr = old.start_addr;\n\n            mem->phys_offset = old.phys_offset;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering prefix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n\n\n        /* register suffix slot */\n\n        if (old.start_addr + old.memory_size > start_addr + size) {\n\n            ram_addr_t size_delta;\n\n\n\n            mem = kvm_alloc_slot(s);\n\n            mem->start_addr = start_addr + size;\n\n            size_delta = mem->start_addr - old.start_addr;\n\n            mem->memory_size = old.memory_size - size_delta;\n\n            mem->phys_offset = old.phys_offset + size_delta;\n\n            mem->flags = 0;\n\n\n\n            err = kvm_set_user_memory_region(s, mem);\n\n            if (err) {\n\n                fprintf(stderr, \"%s: error registering suffix slot: %s\\n\",\n\n                        __func__, strerror(-err));\n\n                abort();\n\n            }\n\n        }\n\n    }\n\n\n\n    /* in case the KVM bug workaround already \"consumed\" the new slot */\n\n    if (!size)\n\n        return;\n\n\n\n    /* KVM does not need to know about this memory */\n\n    if (flags >= IO_MEM_UNASSIGNED)\n\n        return;\n\n\n\n    mem = kvm_alloc_slot(s);\n\n    mem->memory_size = size;\n\n    mem->start_addr = start_addr;\n\n    mem->phys_offset = phys_offset;\n\n    mem->flags = 0;\n\n\n\n    err = kvm_set_user_memory_region(s, mem);\n\n    if (err) {\n\n        fprintf(stderr, \"%s: error registering slot: %s\\n\", __func__,\n\n                strerror(-err));\n\n        abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2174, "prediction": "0", "true_label": "1", "raw_text": "Question: static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2175, "prediction": "0", "true_label": "1", "raw_text": " case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = ALIGN(*width , w_align);\n\n    *height= ALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2176, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2177, "prediction": "0", "true_label": "1", "raw_text": "->segments[0]->url, in_fmt, NULL);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n\n            avformat_queue_attached_pictures(pls->ctx);\n\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n\n            pls->id3_deferred_extra = NULL;\n\n        }\n\n\n\n        if (pls->is_id3_timestamped == -1)\n\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n\n\n        /*\n\n         * For ID3 timestamped raw audio streams we need to detect the packet\n\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n\n         * on us if they want to.\n\n         */\n\n        if (pls->is_id3_timestamped) {\n\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n\n\n        /* Create new AVStreams for each stream in this playlist */\n\n        ret = update_streams_from_subdemuxer(s, pls);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n\n    }\n\n\n\n    update_noheader_flag(s);\n\n\n\n    return 0;\n\nfail:\n\n    free_playlist_list(c);\n\n    free_variant_list(c);\n\n    free_rendition_list(c);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2178, "prediction": "1", "true_label": "0", "raw_text": "Question: AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)\n\n{\n\n    AVBitStreamFilter *bsf = first_bitstream_filter;\n\n\n\n    while (bsf) {\n\n        if (!strcmp(name, bsf->name)) {\n\n            AVBitStreamFilterContext *bsfc =\n\n                av_mallocz(sizeof(AVBitStreamFilterContext));\n\n            bsfc->filter    = bsf;\n\n            bsfc->priv_data =\n\n                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;\n\n            return bsfc;\n\n        }\n\n        bsf = bsf->next;\n\n    }\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2179, "prediction": "0", "true_label": "1", "raw_text": "Question: PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2180, "prediction": "0", "true_label": "1", "raw_text": "Question: BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)\n\n{\n\n    int index;\n\n\n\n    for (index = 0; index < nb_drives; index++)\n\n        if (drives_table[index].bdrv == bdrv)\n\n            return drives_table[index].onerror;\n\n\n\n    return BLOCK_ERR_REPORT;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2181, "prediction": "0", "true_label": "1", "raw_text": "Question: static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2182, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pc_compat_1_4(QEMUMachineInitArgs *args)\n\n{\n\n    pc_compat_1_5(args);\n\n    has_pvpanic = false;\n\n    x86_cpu_compat_set_features(\"n270\", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);\n\n    x86_cpu_compat_set_features(\"Westmere\", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2183, "prediction": "0", "true_label": "1", "raw_text": "DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2184, "prediction": "0", "true_label": "1", "raw_text": "Question: int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)\n\n{\n\n    DynBuffer *d = s->opaque;\n\n    int size;\n\n    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};\n\n    int padding = 0;\n\n\n\n    if (!s) {\n\n        *pbuffer = NULL;\n\n        return 0;\n\n    }\n\n\n\n    /* don't attempt to pad fixed-size packet buffers */\n\n    if (!s->max_packet_size) {\n\n        avio_write(s, padbuf, sizeof(padbuf));\n\n        padding = FF_INPUT_BUFFER_PADDING_SIZE;\n\n    }\n\n\n\n    avio_flush(s);\n\n\n\n    *pbuffer = d->buffer;\n\n    size = d->size;\n\n    av_free(d);\n\n    av_free(s);\n\n    return size - padding;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2185, "prediction": "1", "true_label": "1", "raw_text": "Question: static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes, the defect is in the code.\n"}], [{"ID": 2186, "prediction": "0", "true_label": "1", "raw_text": "Question: static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n\n{\n\n    int sum, i, j;\n\n    int coeffs[pred_order];\n\n\n\n    for (i=0; i<pred_order; i++)\n\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n\n\n    for (i=0; i < s->blocksize; i++) {\n\n        sum = s->lpcqoffset;\n\n        for (j=0; j<pred_order; j++)\n\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2187, "prediction": "0", "true_label": "1", "raw_text": "Question: bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2188, "prediction": "0", "true_label": "1", "raw_text": "t *ptr[4];\n\n            uint32_t pixel = 0;\n\n\n\n            switch (channel->pixel_type) {\n\n            case EXR_FLOAT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                ptr[2] = ptr[1] + td->xsize;\n\n                in     = ptr[2] + td->xsize;\n\n\n\n                for (j = 0; j < td->xsize; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                                    (*(ptr[1]++) << 16) |\n\n                                    (*(ptr[2]++) << 8);\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_HALF:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                in     = ptr[1] + td->xsize;\n\n                for (j = 0; j < td->xsize; j++) {\n\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n\n\n                    pixel += diff;\n\n                    bytestream_put_le16(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_UINT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + s->xdelta;\n\n                ptr[2] = ptr[1] + s->xdelta;\n\n                ptr[3] = ptr[2] + s->xdelta;\n\n                in     = ptr[3] + s->xdelta;\n\n\n\n                for (j = 0; j < s->xdelta; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                    (*(ptr[1]++) << 16) |\n\n                    (*(ptr[2]++) << 8 ) |\n\n                    (*(ptr[3]++));\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            default:\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2189, "prediction": "0", "true_label": "1", "raw_text": "size, atom.size - total_size);\n\n\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n\n            if (mov_default_parse_table[i].type == a.type) {\n\n                parse = mov_default_parse_table[i].parse;\n\n                break;\n\n            }\n\n\n\n        // container is user data\n\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n\n                       atom.type == MKTAG('i','l','s','t')))\n\n            parse = mov_read_udta_string;\n\n\n\n        if (!parse) { /* skip leaf atoms data */\n\n            avio_skip(pb, a.size);\n\n        } else {\n\n            int64_t start_pos = avio_tell(pb);\n\n            int64_t left;\n\n            int err = parse(c, pb, a);\n\n            if (err < 0)\n\n                return err;\n\n            if (c->found_moov && c->found_mdat &&\n\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n\n                 start_pos + a.size == avio_size(pb))) {\n\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n\n                    c->next_root_atom = start_pos + a.size;\n\n                return 0;\n\n            }\n\n            left = a.size - avio_tell(pb) + start_pos;\n\n            if (left > 0) /* skip garbage at atom end */\n\n                avio_skip(pb, left);\n\n            else if (left < 0) {\n\n                av_log(c->fc, AV_LOG_WARNING,\n\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n\n                       (char*)&a.type, -left);\n\n                avio_seek(pb, left, SEEK_CUR);\n\n            }\n\n        }\n\n\n\n        total_size += a.size;\n\n    }\n\n\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n\n        avio_skip(pb, atom.size - total_size);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2190, "prediction": "0", "true_label": "1", "raw_text": " {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < prdtl; i++) {\n\n            tbl_entry_size = prdt_tbl_entry_size(&tbl[i]);\n\n            if (offset < (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (prdtl - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr) + off_pos,\n\n                        MIN(prdt_tbl_entry_size(&tbl[off_idx]) - off_pos,\n\n                            limit));\n\n\n\n        for (i = off_idx + 1; i < prdtl && sglist->size < limit; i++) {\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            MIN(prdt_tbl_entry_size(&tbl[i]),\n\n                                limit - sglist->size));\n\n            if (sglist->size > INT32_MAX) {\n\n                error_report(\"AHCI Physical Region Descriptor Table describes \"\n\n                             \"more than 2 GiB.\");\n\n                qemu_sglist_destroy(sglist);\n\n                r = -1;\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2191, "prediction": "1", "true_label": "1", "raw_text": "1; lev >= 0; lev--){\n\n        int lh = s->linelen[lev][0],\n\n            lv = s->linelen[lev][1],\n\n            mh = s->mod[lev][0],\n\n            mv = s->mod[lev][1],\n\n            lp;\n\n        int *l;\n\n\n\n        // VER_SD\n\n        l = line + mv;\n\n        for (lp = 0; lp < lh; lp++) {\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lv; i++)\n\n                l[i] = t[w*i + lp];\n\n\n\n            sd_1d97_int(line, mv, mv + lv);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n        // HOR_SD\n\n        l = line + mh;\n\n        for (lp = 0; lp < lv; lp++){\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lh; i++)\n\n                l[i] = t[w*lp + i];\n\n\n\n            sd_1d97_int(line, mh, mh + lh);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2192, "prediction": "0", "true_label": "1", "raw_text": "0]->mmco_reset))\n\n        h->next_outputed_poc= INT_MIN;\n\n    out_of_order = out->poc < h->next_outputed_poc;\n\n\n\n    if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)\n\n        { }\n\n    else if((out_of_order && pics-1 == s->avctx->has_b_frames && s->avctx->has_b_frames < MAX_DELAYED_PIC_COUNT)\n\n       || (s->low_delay &&\n\n        ((h->next_outputed_poc != INT_MIN && out->poc > h->next_outputed_poc + 2)\n\n         || cur->pict_type == AV_PICTURE_TYPE_B)))\n\n    {\n\n        s->low_delay = 0;\n\n        s->avctx->has_b_frames++;\n\n    }\n\n\n\n    if(out_of_order || pics > s->avctx->has_b_frames){\n\n        out->reference &= ~DELAYED_PIC_REF;\n\n        out->owner2 = s; // for frame threading, the owner must be the second field's thread\n\n                         // or else the first thread can release the picture and reuse it unsafely\n\n        for(i=out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i+1];\n\n    }\n\n    if(!out_of_order && pics > s->avctx->has_b_frames){\n\n        h->next_output_pic = out;\n\n        if(out_idx==0 && h->delayed_pic[0] && (h->delayed_pic[0]->key_frame || h->delayed_pic[0]->mmco_reset)) {\n\n            h->next_outputed_poc = INT_MIN;\n\n        } else\n\n            h->next_outputed_poc = out->poc;\n\n    }else{\n\n        av_log(s->avctx, AV_LOG_DEBUG, \"no picture\\n\");\n\n    }\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2193, "prediction": "0", "true_label": "1", "raw_text": "Question: void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2194, "prediction": "0", "true_label": "1", "raw_text": "_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2195, "prediction": "0", "true_label": "1", "raw_text": "Question: int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )\n\n{\n\n    flag aSign;\n\n    int16 aExp, shiftCount;\n\n    uint64_t aSig, savedASig;\n\n    int32 z;\n\n    a = float64_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat64Frac( a );\n\n    aExp = extractFloat64Exp( a );\n\n    aSign = extractFloat64Sign( a );\n\n    if ( 0x41E < aExp ) {\n\n        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;\n\n        goto invalid;\n\n    }\n\n    else if ( aExp < 0x3FF ) {\n\n        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n        return 0;\n\n    }\n\n    aSig |= LIT64( 0x0010000000000000 );\n\n    shiftCount = 0x433 - aExp;\n\n    savedASig = aSig;\n\n    aSig >>= shiftCount;\n\n    z = aSig;\n\n    if ( aSign ) z = - z;\n\n    if ( ( z < 0 ) ^ aSign ) {\n\n invalid:\n\n        float_raise( float_flag_invalid STATUS_VAR);\n\n        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;\n\n    }\n\n    if ( ( aSig<<shiftCount ) != savedASig ) {\n\n        STATUS(float_exception_flags) |= float_flag_inexact;\n\n    }\n\n    return z;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2196, "prediction": "1", "true_label": "0", "raw_text": "Question: BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n\n                                    BlockDriverState *bs, int flags)\n\n{\n\n    assert(bs != NULL);\n\n\n\n    BlockReopenQueueEntry *bs_entry;\n\n    if (bs_queue == NULL) {\n\n        bs_queue = g_new0(BlockReopenQueue, 1);\n\n        QSIMPLEQ_INIT(bs_queue);\n\n    }\n\n\n\n    /* bdrv_open() masks this flag out */\n\n    flags &= ~BDRV_O_PROTOCOL;\n\n\n\n    if (bs->file) {\n\n        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));\n\n    }\n\n\n\n    bs_entry = g_new0(BlockReopenQueueEntry, 1);\n\n    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n\n\n\n    bs_entry->state.bs = bs;\n\n    bs_entry->state.flags = flags;\n\n\n\n    return bs_queue;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2197, "prediction": "0", "true_label": "0", "raw_text": "Question: static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n\n                        AVBPrint part[3], int *print_prefix, int type[2])\n\n{\n\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n\n    av_bprint_init(part+0, 0, 1);\n\n    av_bprint_init(part+1, 0, 1);\n\n    av_bprint_init(part+2, 0, 65536);\n\n\n\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n\n    if (*print_prefix && avc) {\n\n        if (avc->parent_log_context_offset) {\n\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n\n                                   avc->parent_log_context_offset);\n\n            if (parent && *parent) {\n\n                av_bprintf(part+0, \"[%s @ %p] \",\n\n                         (*parent)->item_name(parent), parent);\n\n                if(type) type[0] = get_category(parent);\n\n            }\n\n        }\n\n        av_bprintf(part+1, \"[%s @ %p] \",\n\n                 avc->item_name(ptr), ptr);\n\n        if(type) type[1] = get_category(ptr);\n\n    }\n\n\n\n    av_vbprintf(part+2, fmt, vl);\n\n\n\n    if(*part[0].str || *part[1].str || *part[2].str) {\n\n        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;\n\n        *print_prefix = lastc == '\\n' || lastc == '\\r';\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2198, "prediction": "1", "true_label": "0", "raw_text": "_init_vlc(DNXHDContext *ctx, uint32_t cid)\n\n{\n\n    if (cid != ctx->cid) {\n\n        int index;\n\n\n\n        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %d\\n\", cid);\n\n            return AVERROR(ENOSYS);\n\n        }\n\n        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %d.\\n\", cid);\n\n\n\n        ff_free_vlc(&ctx->ac_vlc);\n\n        ff_free_vlc(&ctx->dc_vlc);\n\n        ff_free_vlc(&ctx->run_vlc);\n\n\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n\n                 ctx->cid_table->ac_bits, 1, 1,\n\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,\n\n                 ctx->cid_table->dc_bits, 1, 1,\n\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n\n                 ctx->cid_table->run_bits, 1, 1,\n\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n\n\n        ctx->cid = cid;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2199, "prediction": "0", "true_label": "0", "raw_text": "Question: static void check_default_settings(AVCodecContext *avctx)\n\n{\n\n    X264Context *x4 = avctx->priv_data;\n\n\n\n    int score = 0;\n\n    score += x4->params.analyse.i_me_range == 0;\n\n    score += x4->params.rc.i_qp_step == 3;\n\n    score += x4->params.i_keyint_max == 12;\n\n    score += x4->params.rc.i_qp_min == 2;\n\n    score += x4->params.rc.i_qp_max == 31;\n\n    score += x4->params.rc.f_qcompress == 0.5;\n\n    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;\n\n    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;\n\n    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;\n\n    if (score >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Default settings detected, using medium profile\\n\");\n\n        x4->preset = av_strdup(\"medium\");\n\n        if (avctx->bit_rate == 200*1000)\n\n            avctx->crf = 23;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2200, "prediction": "1", "true_label": "0", "raw_text": "Question: int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)\n\n{\n\n    struct kvm_signal_mask *sigmask;\n\n    int r;\n\n\n\n    if (!sigset)\n\n        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);\n\n\n\n    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));\n\n\n\n    sigmask->len = 8;\n\n    memcpy(sigmask->sigset, sigset, sizeof(*sigset));\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);\n\n    free(sigmask);\n\n\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2201, "prediction": "0", "true_label": "1", "raw_text": "Question: static int unix_close(void *opaque)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    close(s->fd);\n\n    g_free(s);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2202, "prediction": "0", "true_label": "0", "raw_text": " AVFrame *picture = data;\n\n    MpegEncContext *s2 = &s->mpeg_enc_ctx;\n\n    av_dlog(avctx, \"fill_buffer\\n\");\n\n\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE)) {\n\n        /* special case for last picture */\n\n        if (s2->low_delay == 0 && s2->next_picture_ptr) {\n\n            *picture = s2->next_picture_ptr->f;\n\n            s2->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return buf_size;\n\n    }\n\n\n\n    if (s2->flags & CODEC_FLAG_TRUNCATED) {\n\n        int next = ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);\n\n\n\n        if (ff_combine_frame(&s2->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0)\n\n            return buf_size;\n\n    }\n\n\n\n    s2->codec_tag = avpriv_toupper4(avctx->codec_tag);\n\n    if (s->mpeg_enc_ctx_allocated == 0 && (   s2->codec_tag == AV_RL32(\"VCR2\")\n\n                                           || s2->codec_tag == AV_RL32(\"BW10\")\n\n                                          ))\n\n        vcr2_init_sequence(avctx);\n\n\n\n    s->slice_count = 0;\n\n\n\n    if (avctx->extradata && !avctx->frame_number) {\n\n        int ret = decode_chunks(avctx, picture, data_size, avctx->extradata, avctx->extradata_size);\n\n        if(*data_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"picture in extradata\\n\");\n\n            *data_size = 0;\n\n        }\n\n        if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n\n            return ret;\n\n    }\n\n\n\n    return decode_chunks(avctx, picture, data_size, buf, buf_size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2203, "prediction": "0", "true_label": "0", "raw_text": "Question: static void fd_chr_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    FDCharDriver *s = chr->opaque;\n\n    int size, len;\n\n    uint8_t buf[1024];\n\n\n\n    len = sizeof(buf);\n\n    if (len > s->max_size)\n\n        len = s->max_size;\n\n    if (len == 0)\n\n        return;\n\n    size = read(s->fd_in, buf, len);\n\n    if (size == 0) {\n\n        /* FD has been closed. Remove it from the active list.  */\n\n        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);\n\n        qemu_chr_event(chr, CHR_EVENT_CLOSED);\n\n        return;\n\n    }\n\n    if (size > 0) {\n\n        qemu_chr_read(chr, buf, size);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2204, "prediction": "0", "true_label": "0", "raw_text": "Question: static void smbios_build_type_1_fields(QemuOpts *opts)\n\n{\n\n    const char *val;\n\n\n\n    val = qemu_opt_get(opts, \"manufacturer\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"product\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"version\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"serial\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"uuid\");\n\n    if (val) {\n\n        if (qemu_uuid_parse(val, qemu_uuid) != 0) {\n\n            error_report(\"Invalid UUID\");\n\n            exit(1);\n\n        }\n\n    }\n\n    val = qemu_opt_get(opts, \"sku\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n    val = qemu_opt_get(opts, \"family\");\n\n    if (val) {\n\n        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),\n\n                         val, strlen(val) + 1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2205, "prediction": "0", "true_label": "0", "raw_text": ".\n\n         */\n\n        case SVGA_CMD_DEFINE_ALPHA_CURSOR:\n\n            len -= 6;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            x = vmsvga_fifo_read(s);\n\n            y = vmsvga_fifo_read(s);\n\n            args = x * y;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_FILL:\n\n            args = 6;\n\n            goto badcmd;\n\n        case SVGA_CMD_RECT_ROP_COPY:\n\n            args = 7;\n\n            goto badcmd;\n\n        case SVGA_CMD_DRAW_GLYPH_CLIPPED:\n\n            len -= 4;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            vmsvga_fifo_read(s);\n\n            vmsvga_fifo_read(s);\n\n            args = 7 + (vmsvga_fifo_read(s) >> 2);\n\n            goto badcmd;\n\n        case SVGA_CMD_SURFACE_ALPHA_BLEND:\n\n            args = 12;\n\n            goto badcmd;\n\n\n\n        /*\n\n         * Other commands that are not listed as depending on any\n\n         * CAPABILITIES bits, but are not described in the README either.\n\n         */\n\n        case SVGA_CMD_SURFACE_FILL:\n\n        case SVGA_CMD_SURFACE_COPY:\n\n        case SVGA_CMD_FRONT_ROP_FILL:\n\n        case SVGA_CMD_FENCE:\n\n        case SVGA_CMD_INVALID_CMD:\n\n            break; /* Nop */\n\n\n\n        default:\n\n            args = 0;\n\n        badcmd:\n\n            len -= args;\n\n            if (len < 0) {\n\n                goto rewind;\n\n            }\n\n            while (args--) {\n\n                vmsvga_fifo_read(s);\n\n            }\n\n            printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\",\n\n                   __func__, cmd);\n\n            break;\n\n\n\n        rewind:\n\n            s->cmd->stop = cmd_start;\n\n            break;\n\n        }\n\n    }\n\n\n\n    s->syncing = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2206, "prediction": "0", "true_label": "1", "raw_text": "Question: static int hdev_get_max_segments(const struct stat *st)\n\n{\n\n#ifdef CONFIG_LINUX\n\n    char buf[32];\n\n    const char *end;\n\n    char *sysfspath;\n\n    int ret;\n\n    int fd = -1;\n\n    long max_segments;\n\n\n\n    sysfspath = g_strdup_printf(\"/sys/dev/block/%u:%u/queue/max_segments\",\n\n                                major(st->st_rdev), minor(st->st_rdev));\n\n    fd = open(sysfspath, O_RDONLY);\n\n    if (fd == -1) {\n\n        ret = -errno;\n\n        goto out;\n\n    }\n\n    do {\n\n        ret = read(fd, buf, sizeof(buf));\n\n    } while (ret == -1 && errno == EINTR);\n\n    if (ret < 0) {\n\n        ret = -errno;\n\n        goto out;\n\n    } else if (ret == 0) {\n\n        ret = -EIO;\n\n        goto out;\n\n    }\n\n    buf[ret] = 0;\n\n    /* The file is ended with '\\n', pass 'end' to accept that. */\n\n    ret = qemu_strtol(buf, &end, 10, &max_segments);\n\n    if (ret == 0 && end && *end == '\\n') {\n\n        ret = max_segments;\n\n    }\n\n\n\nout:\n\n    g_free(sysfspath);\n\n    return ret;\n\n#else\n\n    return -ENOTSUP;\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2207, "prediction": "0", "true_label": "0", "raw_text": "Question: static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2208, "prediction": "1", "true_label": "1", "raw_text": "Question: PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2209, "prediction": "0", "true_label": "1", "raw_text": "Question: static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp) {\n\n    NFSClient *client = bs->opaque;\n\n    int64_t ret;\n\n\n\n    client->aio_context = bdrv_get_aio_context(bs);\n\n\n\n    ret = nfs_client_open(client, options,\n\n                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,\n\n                          bs->open_flags, errp);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qemu_mutex_init(&client->mutex);\n\n    bs->total_sectors = ret;\n\n    ret = 0;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2210, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)\n\n{\n\n    uint8_t retval;\n\n    MACIOIDEState *d = opaque;\n\n\n\n    addr = (addr & 0xFFF) >> 4;\n\n    switch (addr) {\n\n    case 1 ... 7:\n\n        retval = ide_ioport_read(&d->bus, addr);\n\n        break;\n\n    case 8:\n\n    case 22:\n\n        retval = ide_status_read(&d->bus, 0);\n\n        break;\n\n    default:\n\n        retval = 0xFF;\n\n        break;\n\n    }\n\n    return retval;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2211, "prediction": "0", "true_label": "0", "raw_text": "Question: target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2212, "prediction": "0", "true_label": "0", "raw_text": "Question: static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)\n\n{\n\n    usb_packet_setup(&xfer->packet,\n\n                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,\n\n                     xfer->xhci->slots[xfer->slotid-1].devaddr,\n\n                     ep & 0x7f);\n\n    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);\n\n    DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\",\n\n            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2213, "prediction": "0", "true_label": "0", "raw_text": "Question: static void thread_pool_cancel(BlockAIOCB *acb)\n\n{\n\n    ThreadPoolElement *elem = (ThreadPoolElement *)acb;\n\n    ThreadPool *pool = elem->pool;\n\n\n\n    trace_thread_pool_cancel(elem, elem->common.opaque);\n\n\n\n    qemu_mutex_lock(&pool->lock);\n\n    if (elem->state == THREAD_QUEUED &&\n\n        /* No thread has yet started working on elem. we can try to \"steal\"\n\n         * the item from the worker if we can get a signal from the\n\n         * semaphore.  Because this is non-blocking, we can do it with\n\n         * the lock taken and ensure that elem will remain THREAD_QUEUED.\n\n         */\n\n        qemu_sem_timedwait(&pool->sem, 0) == 0) {\n\n        QTAILQ_REMOVE(&pool->request_list, elem, reqs);\n\n        qemu_bh_schedule(pool->completion_bh);\n\n\n\n        elem->state = THREAD_DONE;\n\n        elem->ret = -ECANCELED;\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool->lock);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2214, "prediction": "0", "true_label": "1", "raw_text": "Question: static void monitor_protocol_event_init(void)\n\n{\n\n    qemu_mutex_init(&monitor_event_state_lock);\n\n    /* Limit RTC & BALLOON events to 1 per second */\n\n    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);\n\n    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2215, "prediction": "0", "true_label": "1", "raw_text": "Can't find video stream in input file\\n\");\n\n      return -1;\n\n    }\n\n\n\n    origin_par = fmt_ctx->streams[video_stream]->codecpar;\n\n\n\n    codec = avcodec_find_decoder(origin_par->codec_id);\n\n    if (!codec) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't find decoder\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx = avcodec_alloc_context3(codec);\n\n    if (!ctx) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate decoder context\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = avcodec_parameters_to_context(ctx, origin_par);\n\n    if (result) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't copy decoder context\\n\");\n\n        return result;\n\n    }\n\n\n\n    result = avcodec_open2(ctx, codec, NULL);\n\n    if (result < 0) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Can't open decoder\\n\");\n\n        return result;\n\n    }\n\n\n\n    fr = av_frame_alloc();\n\n    if (!fr) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Can't allocate frame\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);\n\n    if (result != 0)\n\n        return -1;\n\n\n\n    for (i = start_ts; i < end_ts; i += 100) {\n\n        for (j = i + 100; j < end_ts; j += 100)\n\n        result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 0);\n\n        if (result != 0)\n\n            return -1;\n\n    }\n\n\n\n    av_freep(&crc_array);\n\n    av_freep(&pts_array);\n\n    av_frame_free(&fr);\n\n    avcodec_close(ctx);\n\n    avformat_close_input(&fmt_ctx);\n\n    avcodec_free_context(&ctx);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2216, "prediction": "0", "true_label": "0", "raw_text": " (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2217, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,\n\n                                       const int16_t **lumSrc, int lumFilterSize,\n\n                                       const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                                       const int16_t **chrVSrc,\n\n                                       int chrFilterSize, const int16_t **alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    if (uDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2218, "prediction": "0", "true_label": "1", "raw_text": "pages_rate;\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n\n\n        if (blk_mig_active()) {\n\n            info->has_disk = true;\n\n            info->disk = g_malloc0(sizeof(*info->disk));\n\n            info->disk->transferred = blk_mig_bytes_transferred();\n\n            info->disk->remaining = blk_mig_bytes_remaining();\n\n            info->disk->total = blk_mig_bytes_total();\n\n        }\n\n\n\n        get_xbzrle_cache_stats(info);\n\n        break;\n\n    case MIG_STATE_COMPLETED:\n\n        get_xbzrle_cache_stats(info);\n\n\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"completed\");\n\n        info->has_total_time = true;\n\n        info->total_time = s->total_time;\n\n        info->has_downtime = true;\n\n        info->downtime = s->downtime;\n\n        info->has_setup_time = true;\n\n        info->setup_time = s->setup_time;\n\n\n\n        info->has_ram = true;\n\n        info->ram = g_malloc0(sizeof(*info->ram));\n\n        info->ram->transferred = ram_bytes_transferred();\n\n        info->ram->remaining = 0;\n\n        info->ram->total = ram_bytes_total();\n\n        info->ram->duplicate = dup_mig_pages_transferred();\n\n        info->ram->skipped = skipped_mig_pages_transferred();\n\n        info->ram->normal = norm_mig_pages_transferred();\n\n        info->ram->normal_bytes = norm_mig_bytes_transferred();\n\n        info->ram->mbps = s->mbps;\n\n        info->ram->dirty_sync_count = s->dirty_sync_count;\n\n        break;\n\n    case MIG_STATE_ERROR:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"failed\");\n\n        break;\n\n    case MIG_STATE_CANCELLED:\n\n        info->has_status = true;\n\n        info->status = g_strdup(\"cancelled\");\n\n        break;\n\n    }\n\n\n\n    return info;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2219, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2220, "prediction": "1", "true_label": "1", "raw_text": "Question: PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2221, "prediction": "0", "true_label": "0", "raw_text": "Question: static int voc_probe(AVProbeData *p)\n\n{\n\n    int version, check;\n\n\n\n    if (p->buf_size < 26)\n\n        return 0;\n\n    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))\n\n        return 0;\n\n    version = p->buf[22] | (p->buf[23] << 8);\n\n    check = p->buf[24] | (p->buf[25] << 8);\n\n    if (~version + 0x1234 != check)\n\n        return 10;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2222, "prediction": "0", "true_label": "1", "raw_text": "_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2223, "prediction": "1", "true_label": "1", "raw_text": "Question: static void drive_backup_prepare(BlkActionState *common, Error **errp)\n\n{\n\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    BlockDriverState *bs;\n\n    DriveBackup *backup;\n\n    Error *local_err = NULL;\n\n\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n\n    backup = common->action->u.drive_backup.data;\n\n\n\n    bs = qmp_get_root_bs(backup->device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    /* AioContext is released in .clean() */\n\n    state->aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(state->aio_context);\n\n    bdrv_drained_begin(bs);\n\n    state->bs = bs;\n\n\n\n    do_drive_backup(backup, common->block_job_txn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    state->job = state->bs->job;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2224, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void RET_STOP (DisasContext *ctx)\n\n{\n\n    gen_op_update_nip((ctx)->nip);\n\n    ctx->exception = EXCP_MTMSR;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2225, "prediction": "0", "true_label": "0", "raw_text": "Question: static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2226, "prediction": "0", "true_label": "0", "raw_text": " & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2227, "prediction": "0", "true_label": "0", "raw_text": "Question: static int v9fs_receivefd(int sockfd, int *status)\n\n{\n\n    struct iovec iov;\n\n    struct msghdr msg;\n\n    struct cmsghdr *cmsg;\n\n    int retval, data, fd;\n\n    union MsgControl msg_control;\n\n\n\n    iov.iov_base = &data;\n\n    iov.iov_len = sizeof(data);\n\n\n\n    memset(&msg, 0, sizeof(msg));\n\n    msg.msg_iov = &iov;\n\n    msg.msg_iovlen = 1;\n\n    msg.msg_control = &msg_control;\n\n    msg.msg_controllen = sizeof(msg_control);\n\n\n\n    do {\n\n        retval = recvmsg(sockfd, &msg, 0);\n\n    } while (retval < 0 && errno == EINTR);\n\n    if (retval <= 0) {\n\n        return retval;\n\n    }\n\n    /*\n\n     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this\n\n     * request doesn't need ancillary data (fd) or an error occurred,\n\n     * data is set to negative errno value.\n\n     */\n\n    if (data != V9FS_FD_VALID) {\n\n        *status = data;\n\n        return 0;\n\n    }\n\n    /*\n\n     * File descriptor (fd) is sent in the ancillary data. Check if we\n\n     * indeed received it. One of the reasons to fail to receive it is if\n\n     * we exceeded the maximum number of file descriptors!\n\n     */\n\n    for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\n        if (cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||\n\n            cmsg->cmsg_level != SOL_SOCKET ||\n\n            cmsg->cmsg_type != SCM_RIGHTS) {\n\n            continue;\n\n        }\n\n        fd = *((int *)CMSG_DATA(cmsg));\n\n        *status = fd;\n\n        return 0;\n\n    }\n\n    *status = -ENFILE;  /* Ancillary data sent but not received */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2228, "prediction": "0", "true_label": "0", "raw_text": "Question: static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,\n\n                                  int flag)\n\n{\n\n    struct kvm_x86_mce_data data = {\n\n        .env = env,\n\n        .mce = mce,\n\n        .abort_on_error = (flag & ABORT_ON_ERROR),\n\n    };\n\n\n\n    if (!env->mcg_cap) {\n\n        fprintf(stderr, \"MCE support is not enabled!\\n\");\n\n        return;\n\n    }\n\n\n\n    run_on_cpu(env, kvm_do_inject_x86_mce, &data);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2229, "prediction": "0", "true_label": "0", "raw_text": "Question: static AioHandler *find_aio_handler(AioContext *ctx, int fd)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.fd == fd)\n\n            if (!node->deleted)\n\n                return node;\n\n    }\n\n\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2230, "prediction": "0", "true_label": "0", "raw_text": " 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2231, "prediction": "0", "true_label": "0", "raw_text": "1) {\n\n        /* drop the frame and everything buffered except the first */\n\n        AVFilterBufferRef *tmp;\n\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n\n        s->drop += drop;\n\n\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n\n        flush_fifo(s->fifo);\n\n        ret = write_to_fifo(s->fifo, tmp);\n\n\n\n        avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n\n\n    /* can output >= 1 frames */\n\n    for (i = 0; i < delta; i++) {\n\n        AVFilterBufferRef *buf_out;\n\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n\n\n        /* duplicate the frame if needed */\n\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n\n            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\n\n            s->dup++;\n\n        }\n\n\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n\n                                    outlink->time_base) + s->frames_out;\n\n\n\n        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||\n\n            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||\n\n            (ret = ff_end_frame(outlink)) < 0) {\n\n            avfilter_unref_bufferp(&buf);\n\n            return ret;\n\n        }\n\n\n\n        s->frames_out++;\n\n    }\n\n    flush_fifo(s->fifo);\n\n\n\n    ret = write_to_fifo(s->fifo, buf);\n\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2232, "prediction": "0", "true_label": "1", "raw_text": "->channel_layout = AV_CH_LAYOUT_MONO;\n\n                }\n\n                roq->audio_channels    = st->codecpar->channels;\n\n                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;\n\n                st->codecpar->bits_per_coded_sample = 16;\n\n                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n\n                    st->codecpar->bits_per_coded_sample;\n\n                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;\n\n            }\n\n        case RoQ_QUAD_VQ:\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                if (roq->video_stream_index < 0)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* load up the packet */\n\n            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n\n                return AVERROR(EIO);\n\n            /* copy over preamble */\n\n            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n\n\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                pkt->stream_index = roq->video_stream_index;\n\n                pkt->pts = roq->video_pts++;\n\n            } else {\n\n                pkt->stream_index = roq->audio_stream_index;\n\n                pkt->pts = roq->audio_frame_count;\n\n                roq->audio_frame_count += (chunk_size / roq->audio_channels);\n\n            }\n\n\n\n            pkt->pos= avio_tell(pb);\n\n            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,\n\n                chunk_size);\n\n            if (ret != chunk_size)\n\n                ret = AVERROR(EIO);\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unknown RoQ chunk (%04X)\\n\", chunk_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2233, "prediction": "0", "true_label": "1", "raw_text": "psrad $8, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm5, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"mov %3, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm4, (%%\"REG_a\", %0)\t\\n\\t\"\n\n\t\t\t\"add $4, %0\t\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t: \"+r\" (counter), \"+r\" (filter)\n\n\t\t\t: \"m\" (filterPos), \"m\" (dst), \"m\"(offset),\n\n\t\t\t  \"m\" (src), \"r\" ((long)filterSize*2)\n\n\t\t\t: \"%\"REG_b, \"%\"REG_a, \"%\"REG_c\n\n\t\t);\n\n\t}\n\n#else\n\n#ifdef HAVE_ALTIVEC\n\n\thScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<dstW; i++)\n\n\t{\n\n\t\tint j;\n\n\t\tint srcPos= filterPos[i];\n\n\t\tint val=0;\n\n//\t\tprintf(\"filterPos: %d\\n\", filterPos[i]);\n\n\t\tfor(j=0; j<filterSize; j++)\n\n\t\t{\n\n//\t\t\tprintf(\"filter: %d, src: %d\\n\", filter[i], src[srcPos + j]);\n\n\t\t\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n\t\t}\n\n//\t\tfilter += hFilterSize;\n\n\t\tdst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...\n\n//\t\tdst[i] = val>>7;\n\n\t}\n\n#endif\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2234, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2235, "prediction": "0", "true_label": "0", "raw_text": "->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }else{\n\n                    for(i=0;i<3;i++) {\n\n                        uint8_t *ptr;\n\n                        int x, y, h, v, linesize;\n\n                        h = s->mjpeg_hsample[i];\n\n                        v = s->mjpeg_vsample[i];\n\n                        linesize= p->linesize[i];\n\n\n\n                        for(y=0; y<v; y++){\n\n                            for(x=0; x<h; x++){\n\n                                int pred;\n\n\n\n                                ptr = p->data[i] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap\n\n//printf(\"%d %d %d %d %8X\\n\", mb_x, mb_y, x, y, ptr);\n\n                                PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);\n\n\n\n                                if(i==0)\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_luminance, m->huff_code_dc_luminance); //FIXME ugly\n\n                                else\n\n                                    ff_mjpeg_encode_dc(s, (int8_t)(*ptr - pred), m->huff_size_dc_chrominance, m->huff_code_dc_chrominance);\n\n                            }\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    emms_c();\n\n\n\n    ff_mjpeg_encode_picture_trailer(s);\n\n    s->picture_number++;\n\n\n\n    flush_put_bits(&s->pb);\n\n    return pbBufPtr(&s->pb) - s->pb.buf;\n\n//    return (put_bits_count(&f->pb)+7)/8;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2236, "prediction": "0", "true_label": "0", "raw_text": " if seeking requested, we execute it */\n\n    if (o->start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                   filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    add_input_streams(o, ic);\n\n\n\n    /* dump the file content */\n\n    av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;\n\n    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;\n\n\n\n    for (i = 0; i < o->nb_dump_attachment; i++) {\n\n        int j;\n\n\n\n        for (j = 0; j < ic->nb_streams; j++) {\n\n            AVStream *st = ic->streams[j];\n\n\n\n            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)\n\n                dump_attachment(st, o->dump_attachment[i].u.str);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    reset_options(o, 1);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2237, "prediction": "0", "true_label": "0", "raw_text": "Question: uint64_t helper_efdctuidz (uint64_t val)\n\n{\n\n    CPU_DoubleU u;\n\n\n\n    u.ll = val;\n\n    /* NaN are not treated the same way IEEE 754 does */\n\n    if (unlikely(float64_is_nan(u.d)))\n\n        return 0;\n\n\n\n    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2238, "prediction": "1", "true_label": "0", "raw_text": "Question: void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,\n\n                                     void *start, unsigned size,\n\n                                     uint8_t *checksum)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);\n\n    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;\n\n    ptrdiff_t start_offset = (gchar *)start - file->blob->data;\n\n\n\n    assert(checksum_offset >= 0);\n\n    assert(start_offset >= 0);\n\n    assert(checksum_offset + 1 <= file->blob->len);\n\n    assert(start_offset + size <= file->blob->len);\n\n    assert(*checksum == 0x0);\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);\n\n    entry.cksum.offset = cpu_to_le32(checksum_offset);\n\n    entry.cksum.start = cpu_to_le32(start_offset);\n\n    entry.cksum.length = cpu_to_le32(size);\n\n\n\n    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2239, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->internal->thread_ctx;\n\n    FrameThreadContext *fctx;\n\n    AVFrame *dst, *tmp;\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                          avctx->thread_safe_callbacks                   ||\n\n                          (\n\n#if FF_API_GET_BUFFER\n\n                           !avctx->get_buffer &&\n\n#endif\n\n                           avctx->get_buffer2 == avcodec_default_get_buffer2);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    if (!f->f->buf[0])\n\n        return;\n\n\n\n    if (avctx->debug & FF_DEBUG_BUFFERS)\n\n        av_log(avctx, AV_LOG_DEBUG, \"thread_release_buffer called on pic %p\\n\", f);\n\n\n\n    av_buffer_unref(&f->progress);\n\n    f->owner    = NULL;\n\n\n\n    if (can_direct_free) {\n\n        av_frame_unref(f->f);\n\n        return;\n\n    }\n\n\n\n    fctx = p->parent;\n\n    pthread_mutex_lock(&fctx->buffer_mutex);\n\n\n\n    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))\n\n        goto fail;\n\n    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,\n\n                          (p->num_released_buffers + 1) *\n\n                          sizeof(*p->released_buffers));\n\n    if (!tmp)\n\n        goto fail;\n\n    p->released_buffers = tmp;\n\n\n\n    dst = &p->released_buffers[p->num_released_buffers];\n\n    av_frame_move_ref(dst, f->f);\n\n\n\n    p->num_released_buffers++;\n\n\n\nfail:\n\n    pthread_mutex_unlock(&fctx->buffer_mutex);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2240, "prediction": "0", "true_label": "1", "raw_text": "Question: void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))\n\n{\n\n    while (queue->p_head)\n\n        free_func(ff_schro_queue_pop(queue));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2241, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2242, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_op_addl_ESP_im(int32_t val)\n\n{\n\n    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);\n\n#ifdef TARGET_X86_64\n\n    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);\n\n#endif\n\n    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2243, "prediction": "0", "true_label": "0", "raw_text": "Question: static unsigned int dec_movu_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZ);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\tdec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);\n\n\tcris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2244, "prediction": "1", "true_label": "0", "raw_text": "Question: AVInputFormat *av_find_input_format(const char *short_name)\n\n{\n\n    AVInputFormat *fmt = NULL;\n\n    while ((fmt = av_iformat_next(fmt)))\n\n        if (match_format(short_name, fmt->name))\n\n            return fmt;\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2245, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,\n\n                                      int mm_flags)\n\n{\n\n#if HAVE_SSE2_INLINE\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {\n\n        c->idct_put              = ff_idct_xvid_sse2_put;\n\n        c->idct_add              = ff_idct_xvid_sse2_add;\n\n        c->idct                  = ff_idct_xvid_sse2;\n\n        c->idct_permutation_type = FF_SSE2_IDCT_PERM;\n\n    }\n\n#endif /* HAVE_SSE2_INLINE */\n\n\n\n#if HAVE_SSE2_EXTERNAL\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_sse2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2;\n\n    if (mm_flags & AV_CPU_FLAG_ATOM) {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_int_sse2;\n\n    } else {\n\n        c->vector_clip_int32 = ff_vector_clip_int32_sse2;\n\n    }\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_sse2;\n\n    } else if (!(mm_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        c->apply_window_int16 = ff_apply_window_int16_round_sse2;\n\n    }\n\n    c->bswap_buf = ff_bswap32_buf_sse2;\n\n#endif /* HAVE_SSE2_EXTERNAL */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2246, "prediction": "0", "true_label": "0", "raw_text": "Question: static int au_probe(AVProbeData *p)\n\n{\n\n    /* check file header */\n\n    if (p->buf_size <= 24)\n\n        return 0;\n\n    if (p->buf[0] == '.' && p->buf[1] == 's' &&\n\n        p->buf[2] == 'n' && p->buf[3] == 'd')\n\n        return AVPROBE_SCORE_MAX;\n\n    else\n\n        return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2247, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2248, "prediction": "0", "true_label": "0", "raw_text": "_state(afq);\n\n#endif\n\n\n\n    /* get output pts from the next frame or generated pts */\n\n    if (afq->frame_queue) {\n\n        if (afq->frame_queue->pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->frame_queue->pts - afq->remaining_delay;\n\n    } else {\n\n        if (afq->next_pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->next_pts - afq->remaining_delay;\n\n    }\n\n    if (pts) {\n\n        if (out_pts != AV_NOPTS_VALUE)\n\n            *pts = ff_samples_to_time_base(afq->avctx, out_pts);\n\n        else\n\n            *pts = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    /* if the delay is larger than the packet duration, we use up delay samples\n\n       for the output packet and leave all frames in the queue */\n\n    if (afq->remaining_delay >= nb_samples) {\n\n        removed_samples      += nb_samples;\n\n        afq->remaining_delay -= nb_samples;\n\n    }\n\n    /* remove frames from the queue until we have enough to cover the\n\n       requested number of samples or until the queue is empty */\n\n    while (removed_samples < nb_samples && afq->frame_queue) {\n\n        removed_samples += afq->frame_queue->duration;\n\n        delete_next_frame(afq);\n\n    }\n\n    afq->remaining_samples -= removed_samples;\n\n\n\n    /* if there are no frames left and we have room for more samples, use\n\n       any remaining delay samples */\n\n    if (removed_samples < nb_samples && afq->remaining_samples > 0) {\n\n        int add_samples = FFMIN(afq->remaining_samples,\n\n                                nb_samples - removed_samples);\n\n        removed_samples        += add_samples;\n\n        afq->remaining_samples -= add_samples;\n\n    }\n\n    if (removed_samples > nb_samples)\n\n        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");\n\n    if (duration)\n\n        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2249, "prediction": "0", "true_label": "1", "raw_text": "Question: void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2250, "prediction": "0", "true_label": "1", "raw_text": "Question: static double get_diff_limited_q(MpegEncContext *s, RateControlEntry *rce, double q){\n\n    RateControlContext *rcc= &s->rc_context;\n\n    AVCodecContext *a= s->avctx;\n\n    const int pict_type= rce->new_pict_type;\n\n    const double last_p_q    = rcc->last_qscale_for[P_TYPE];\n\n    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];\n\n\n\n    if     (pict_type==I_TYPE && (a->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))\n\n        q= last_p_q    *FFABS(a->i_quant_factor) + a->i_quant_offset;\n\n    else if(pict_type==B_TYPE && a->b_quant_factor>0.0)\n\n        q= last_non_b_q*    a->b_quant_factor  + a->b_quant_offset;\n\n\n\n\n    /* last qscale / qdiff stuff */\n\n    if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){\n\n        double last_q= rcc->last_qscale_for[pict_type];\n\n        const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;\n\n\n\n        if     (q > last_q + maxdiff) q= last_q + maxdiff;\n\n        else if(q < last_q - maxdiff) q= last_q - maxdiff;\n\n    }\n\n\n\n    rcc->last_qscale_for[pict_type]= q; //Note we cannot do that after blurring\n\n\n\n    if(pict_type!=B_TYPE)\n\n        rcc->last_non_b_pict_type= pict_type;\n\n\n\n    return q;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2251, "prediction": "0", "true_label": "0", "raw_text": ") { /* no media --> data handler */\n\n        hdlr      = \"dhlr\";\n\n        hdlr_type = \"url \";\n\n        descr     = \"DataHandler\";\n\n    } else {\n\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n\n        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            hdlr_type = \"vide\";\n\n            descr     = \"VideoHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            hdlr_type = \"soun\";\n\n            descr     = \"SoundHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = \"sbtl\";\n\n            else                                      hdlr_type = \"text\";\n\n            descr = \"SubtitleHandler\";\n\n        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {\n\n            hdlr_type = \"hint\";\n\n            descr     = \"HintHandler\";\n\n        }\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"hdlr\");\n\n    avio_wb32(pb, 0); /* Version & flags */\n\n    avio_write(pb, hdlr, 4); /* handler */\n\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track || track->mode == MODE_MOV)\n\n        avio_w8(pb, strlen(descr)); /* pascal string */\n\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n\n    if (track && track->mode != MODE_MOV)\n\n        avio_w8(pb, 0); /* c string */\n\n    return update_size(pb, pos);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2252, "prediction": "1", "true_label": "1", "raw_text": "Question: PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2253, "prediction": "0", "true_label": "1", "raw_text": "Question: void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2254, "prediction": "0", "true_label": "1", "raw_text": "Question: static int srt_probe(AVProbeData *p)\n\n{\n\n    const unsigned char *ptr = p->buf;\n\n    int i, v, num = 0;\n\n\n\n    if (AV_RB24(ptr) == 0xEFBBBF)\n\n        ptr += 3;  /* skip UTF-8 BOM */\n\n\n\n    while (*ptr == '\\r' || *ptr == '\\n')\n\n        ptr++;\n\n    for (i=0; i<2; i++) {\n\n        if ((num == i || num + 1 == i)\n\n            && sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1)\n\n            return AVPROBE_SCORE_MAX;\n\n        num = atoi(ptr);\n\n        ptr += strcspn(ptr, \"\\n\") + 1;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2255, "prediction": "0", "true_label": "1", "raw_text": "Question: static void piix4_update_hotplug(PIIX4PMState *s)\n\n{\n\n    PCIDevice *dev = &s->dev;\n\n    BusState *bus = qdev_get_parent_bus(&dev->qdev);\n\n    DeviceState *qdev, *next;\n\n\n\n    s->pci0_hotplug_enable = ~0;\n\n\n\n    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n\n        PCIDevice *pdev = PCI_DEVICE(qdev);\n\n        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);\n\n        int slot = PCI_SLOT(pdev->devfn);\n\n\n\n        if (pc->no_hotplug) {\n\n            s->pci0_hotplug_enable &= ~(1 << slot);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2256, "prediction": "0", "true_label": "1", "raw_text": "Question: static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    StreamBlockJob *s = container_of(job, StreamBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2257, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2258, "prediction": "0", "true_label": "1", "raw_text": "Question: int unix_start_incoming_migration(const char *path)\n\n{\n\n    struct sockaddr_un un;\n\n    int sock;\n\n\n\n    dprintf(\"Attempting to start an incoming migration\\n\");\n\n\n\n    sock = socket(PF_UNIX, SOCK_STREAM, 0);\n\n    if (sock < 0) {\n\n        fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno));\n\n        return -EINVAL;\n\n    }\n\n\n\n    memset(&un, 0, sizeof(un));\n\n    un.sun_family = AF_UNIX;\n\n    snprintf(un.sun_path, sizeof(un.sun_path), \"%s\", path);\n\n\n\n    unlink(un.sun_path);\n\n    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n\n        fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n    if (listen(sock, 1) < 0) {\n\n        fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sun_path, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,\n\n\t\t\t (void *)(unsigned long)sock);\n\n\n\n    return 0;\n\n\n\nerr:\n\n    close(sock);\n\n\n\n    return -EINVAL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2259, "prediction": "0", "true_label": "0", "raw_text": ");\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;\n\n        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;\n\n        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;\n\n        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;\n\n        bs->bl.max_iov = bs->file->bs->bl.max_iov;\n\n    } else {\n\n        bs->bl.min_mem_alignment = 512;\n\n        bs->bl.opt_mem_alignment = getpagesize();\n\n\n\n        /* Safe default since most protocols use readv()/writev()/etc */\n\n        bs->bl.max_iov = IOV_MAX;\n\n    }\n\n\n\n    if (bs->backing) {\n\n        bdrv_refresh_limits(bs->backing->bs, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n        bs->bl.opt_transfer = MAX(bs->bl.opt_transfer,\n\n                                  bs->backing->bs->bl.opt_transfer);\n\n        bs->bl.max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,\n\n                                           bs->backing->bs->bl.max_transfer);\n\n        bs->bl.opt_mem_alignment =\n\n            MAX(bs->bl.opt_mem_alignment,\n\n                bs->backing->bs->bl.opt_mem_alignment);\n\n        bs->bl.min_mem_alignment =\n\n            MAX(bs->bl.min_mem_alignment,\n\n                bs->backing->bs->bl.min_mem_alignment);\n\n        bs->bl.max_iov =\n\n            MIN(bs->bl.max_iov,\n\n                bs->backing->bs->bl.max_iov);\n\n    }\n\n\n\n    /* Then let the driver override it */\n\n    if (drv->bdrv_refresh_limits) {\n\n        drv->bdrv_refresh_limits(bs, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2260, "prediction": "0", "true_label": "0", "raw_text": " &local_err);\n\n                if (ret < 0) {\n\n                    error_report_err(local_err);\n\n                    goto resize_fail;\n\n                }\n\n                size = bdrv_getlength(bs->file->bs);\n\n                if (size < 0) {\n\n                    ret = size;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                new_nb_clusters = size_to_clusters(s, size);\n\n                assert(new_nb_clusters >= *nb_clusters);\n\n\n\n                ret = realloc_refcount_array(s, refcount_table,\n\n                                             nb_clusters, new_nb_clusters);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    return ret;\n\n                }\n\n\n\n                if (cluster >= *nb_clusters) {\n\n                    ret = -EINVAL;\n\n                    goto resize_fail;\n\n                }\n\n\n\n                res->corruptions_fixed++;\n\n                ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                    offset, s->cluster_size);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* No need to check whether the refcount is now greater than 1:\n\n                 * This area was just allocated and zeroed, so it can only be\n\n                 * exactly 1 after inc_refcounts() */\n\n                continue;\n\n\n\nresize_fail:\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n                fprintf(stderr, \"ERROR could not resize image: %s\\n\",\n\n                        strerror(-ret));\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        if (offset != 0) {\n\n            ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                                offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                return ret;\n\n            }\n\n            if (s->get_refcount(*refcount_table, cluster) != 1) {\n\n                fprintf(stderr, \"ERROR refcount block %\" PRId64\n\n                        \" refcount=%\" PRIu64 \"\\n\", i,\n\n                        s->get_refcount(*refcount_table, cluster));\n\n                res->corruptions++;\n\n                *rebuild = true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2261, "prediction": "1", "true_label": "1", "raw_text": "\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2262, "prediction": "0", "true_label": "1", "raw_text": "\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2263, "prediction": "0", "true_label": "0", "raw_text": "Question: static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)\n\n{\n\n    int16_t input[MDCT_SAMPLES];\n\n    int32_t output[AC3_MAX_COEFS];\n\n    float input1[MDCT_SAMPLES];\n\n    float output1[AC3_MAX_COEFS];\n\n    float s, a, err, e, emax;\n\n    int i, k, n;\n\n\n\n    for (i = 0; i < MDCT_SAMPLES; i++) {\n\n        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;\n\n        input1[i] = input[i];\n\n    }\n\n\n\n    mdct512(mdct, output, input);\n\n\n\n    /* do it by hand */\n\n    for (k = 0; k < AC3_MAX_COEFS; k++) {\n\n        s = 0;\n\n        for (n = 0; n < MDCT_SAMPLES; n++) {\n\n            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));\n\n            s += input1[n] * cos(a);\n\n        }\n\n        output1[k] = -2 * s / MDCT_SAMPLES;\n\n    }\n\n\n\n    err  = 0;\n\n    emax = 0;\n\n    for (i = 0; i < AC3_MAX_COEFS; i++) {\n\n        av_log(NULL, AV_LOG_DEBUG, \"%3d: %7d %7.0f\\n\", i, output[i], output1[i]);\n\n        e = output[i] - output1[i];\n\n        if (e > emax)\n\n            emax = e;\n\n        err += e * e;\n\n    }\n\n    av_log(NULL, AV_LOG_DEBUG, \"err2=%f emax=%f\\n\", err / AC3_MAX_COEFS, emax);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2264, "prediction": "0", "true_label": "1", "raw_text": "Question: static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)\n\n{\n\n    // attempt to keep aspect during typical resolution switches\n\n    if (!sar.num)\n\n        sar = (AVRational){1, 1};\n\n\n\n    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});\n\n    return sar;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2265, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2266, "prediction": "0", "true_label": "1", "raw_text": " 8;\n\n                } else {\n\n                    j = i + 8;\n\n                }\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            GET_BITS_SAFE(width, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    GET_BITS_SAFE(coeff, width);\n\n                    if (coeff) {\n\n                        int v;\n\n                        GET_BITS_SAFE(v, 1);\n\n                        if (v)\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        int j;\n\n        int count = s->overlap_len * s->channels;\n\n        if (!s->first) {\n\n            j = ch;\n\n            for (i = 0; i < s->overlap_len; i++, j += s->channels)\n\n                out[ch][i] = (s->previous[ch][i] * (count - j) +\n\n                                      out[ch][i] *          j) / count;\n\n        }\n\n        memcpy(s->previous[ch], &out[ch][s->frame_len - s->overlap_len],\n\n               s->overlap_len * sizeof(*s->previous[ch]));\n\n    }\n\n\n\n    s->first = 0;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2267, "prediction": "0", "true_label": "1", "raw_text": "Question: static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2268, "prediction": "0", "true_label": "1", "raw_text": "Question: static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)\n\n{\n\n    if (err == 0) {\n\n        v9fs_string_copy(&vs->fidp->path, &vs->fullname);\n\n        stat_to_qid(&vs->stbuf, &vs->qid);\n\n        vs->offset += pdu_marshal(vs->pdu, vs->offset, \"Qd\", &vs->qid,\n\n                &vs->iounit);\n\n        err = vs->offset;\n\n    } else {\n\n        vs->fidp->fid_type = P9_FID_NONE;\n\n        close(vs->fidp->fs.fd);\n\n        err = -errno;\n\n    }\n\n\n\n    complete_pdu(s, vs->pdu, err);\n\n    v9fs_string_free(&vs->name);\n\n    v9fs_string_free(&vs->fullname);\n\n    qemu_free(vs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2269, "prediction": "0", "true_label": "1", "raw_text": "Question: static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2270, "prediction": "0", "true_label": "1", "raw_text": "Question: static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2271, "prediction": "0", "true_label": "1", "raw_text": "Question: static void create_default_qtables(uint8_t *qtables, uint8_t q)\n\n{\n\n    int factor = q;\n\n    int i;\n\n\n\n    factor = av_clip(q, 1, 99);\n\n\n\n    if (q < 50)\n\n        q = 5000 / factor;\n\n    else\n\n        q = 200 - factor * 2;\n\n\n\n    for (i = 0; i < 128; i++) {\n\n        int val = (default_quantizers[i] * q + 50) / 100;\n\n\n\n        /* Limit the quantizers to 1 <= q <= 255. */\n\n        val = av_clip(val, 1, 255);\n\n        qtables[i] = val;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2272, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_af_queue_close(AudioFrameQueue *afq)\n\n{\n\n    /* remove/free any remaining frames */\n\n    while (afq->frame_queue)\n\n        delete_next_frame(afq);\n\n    memset(afq, 0, sizeof(*afq));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2273, "prediction": "0", "true_label": "1", "raw_text": "Question: static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n\n{\n\n    int i;\n\n    int32_t *dst = (int32_t *) _dst;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2274, "prediction": "1", "true_label": "1", "raw_text": "30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2275, "prediction": "0", "true_label": "1", "raw_text": "mv);\n\n\n\n                    center_x += mv.x;\n\n                    center_y += mv.y;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pos = FFMAX(1, pos);\n\n\n\n    center_x /= pos;\n\n    center_y /= pos;\n\n\n\n    t->angle = clean_mean(angles, pos);\n\n    if (t->angle < 0.001)\n\n        t->angle = 0;\n\n\n\n    // Find the most common motion vector in the frame and use it as the gmv\n\n    for (y = deshake->ry * 2; y >= 0; y--) {\n\n        for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n            //av_log(NULL, AV_LOG_ERROR, \"%5d \", counts[x][y]);\n\n            if (counts[x][y] > count_max_value) {\n\n                t->vector.x = x - deshake->rx;\n\n                t->vector.y = y - deshake->ry;\n\n                count_max_value = counts[x][y];\n\n            }\n\n        }\n\n        //av_log(NULL, AV_LOG_ERROR, \"\\n\");\n\n    }\n\n\n\n    p_x = (center_x - width / 2);\n\n    p_y = (center_y - height / 2);\n\n    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;\n\n    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;\n\n\n\n    // Clamp max shift & rotation?\n\n    t->vector.x = av_clipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2);\n\n    t->vector.y = av_clipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2);\n\n    t->angle = av_clipf(t->angle, -0.1, 0.1);\n\n\n\n    //av_log(NULL, AV_LOG_ERROR, \"%d x %d\\n\", avg->x, avg->y);\n\n    av_free(angles);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2276, "prediction": "0", "true_label": "1", "raw_text": "ERROR,\"Error in dirac_decode_data_unit\\n\");\n\n            return -1;\n\n        }\n\n        buf_idx += data_unit_size;\n\n    }\n\n\n\n    if (!s->current_picture)\n\n        return buf_size;\n\n\n\n    if (s->current_picture->avframe->display_picture_number > s->frame_number) {\n\n        DiracFrame *delayed_frame = remove_frame(s->delay_frames, s->frame_number);\n\n\n\n        s->current_picture->avframe->reference |= DELAYED_PIC_REF;\n\n\n\n        if (add_frame(s->delay_frames, MAX_DELAY, s->current_picture)) {\n\n            int min_num = s->delay_frames[0]->avframe->display_picture_number;\n\n            /* Too many delayed frames, so we display the frame with the lowest pts */\n\n            av_log(avctx, AV_LOG_ERROR, \"Delay frame overflow\\n\");\n\n\n\n            for (i = 1; s->delay_frames[i]; i++)\n\n                if (s->delay_frames[i]->avframe->display_picture_number < min_num)\n\n                    min_num = s->delay_frames[i]->avframe->display_picture_number;\n\n\n\n            delayed_frame = remove_frame(s->delay_frames, min_num);\n\n            add_frame(s->delay_frames, MAX_DELAY, s->current_picture);\n\n        }\n\n\n\n        if (delayed_frame) {\n\n            delayed_frame->avframe->reference ^= DELAYED_PIC_REF;\n\n            if((ret=av_frame_ref(data, delayed_frame->avframe)) < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    } else if (s->current_picture->avframe->display_picture_number == s->frame_number) {\n\n        /* The right frame at the right time :-) */\n\n        if((ret=av_frame_ref(data, s->current_picture->avframe)) < 0)\n\n            return ret;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    if (*got_frame)\n\n        s->frame_number = picture->display_picture_number + 1;\n\n\n\n    return buf_idx;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2277, "prediction": "0", "true_label": "1", "raw_text": " (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2278, "prediction": "0", "true_label": "1", "raw_text": "averageBitRate;\n\n    }\n\n\n\n    if (avctx->rc_max_rate > 0)\n\n        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;\n\n\n\n    if (ctx->rc < 0) {\n\n        if (ctx->flags & NVENC_ONE_PASS)\n\n            ctx->twopass = 0;\n\n        if (ctx->flags & NVENC_TWO_PASSES)\n\n            ctx->twopass = 1;\n\n\n\n        if (ctx->twopass < 0)\n\n            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;\n\n\n\n        if (ctx->cbr) {\n\n            if (ctx->twopass) {\n\n                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;\n\n            } else {\n\n                ctx->rc = NV_ENC_PARAMS_RC_CBR;\n\n            }\n\n        } else if (avctx->global_quality > 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_CONSTQP;\n\n        } else if (ctx->twopass) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_2_PASS_VBR;\n\n        } else if (avctx->qmin >= 0 && avctx->qmax >= 0) {\n\n            ctx->rc = NV_ENC_PARAMS_RC_VBR_MINQP;\n\n        }\n\n    }\n\n\n\n    if (ctx->flags & NVENC_LOSSLESS) {\n\n        set_lossless(avctx);\n\n    } else if (ctx->rc > 0) {\n\n        nvenc_override_rate_control(avctx);\n\n    } else {\n\n        ctx->encode_config.rcParams.rateControlMode = NV_ENC_PARAMS_RC_VBR;\n\n        set_vbr(avctx);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = avctx->rc_buffer_size;\n\n    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {\n\n        ctx->encode_config.rcParams.vbvBufferSize = 2 * ctx->encode_config.rcParams.averageBitRate;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2279, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int vp3_decode_end(AVCodecContext *avctx)\n\n{\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if (avctx->is_copy && !s->current_frame.data[0])\n\n        return 0;\n\n\n\n    av_free(s->superblock_coding);\n\n    av_free(s->all_fragments);\n\n    av_free(s->coded_fragment_list[0]);\n\n    av_free(s->dct_tokens_base);\n\n    av_free(s->superblock_fragments);\n\n    av_free(s->macroblock_coding);\n\n    av_free(s->motion_val[0]);\n\n    av_free(s->motion_val[1]);\n\n    av_free(s->edge_emu_buffer);\n\n\n\n    if (avctx->is_copy) return 0;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        free_vlc(&s->dc_vlc[i]);\n\n        free_vlc(&s->ac_vlc_1[i]);\n\n        free_vlc(&s->ac_vlc_2[i]);\n\n        free_vlc(&s->ac_vlc_3[i]);\n\n        free_vlc(&s->ac_vlc_4[i]);\n\n    }\n\n\n\n    free_vlc(&s->superblock_run_length_vlc);\n\n    free_vlc(&s->fragment_run_length_vlc);\n\n    free_vlc(&s->mode_code_vlc);\n\n    free_vlc(&s->motion_vector_vlc);\n\n\n\n    /* release all frames */\n\n    if (s->golden_frame.data[0])\n\n        ff_thread_release_buffer(avctx, &s->golden_frame);\n\n    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)\n\n        ff_thread_release_buffer(avctx, &s->last_frame);\n\n    /* no need to release the current_frame since it will always be pointing\n\n     * to the same frame as either the golden or last frame */\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2280, "prediction": "1", "true_label": "1", "raw_text": "Question: static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2281, "prediction": "0", "true_label": "0", "raw_text": "Question: void qemu_opts_print(QemuOpts *opts)\n\n{\n\n    QemuOpt *opt;\n\n    QemuOptDesc *desc = opts->list->desc;\n\n\n\n    if (desc[0].name == NULL) {\n\n        QTAILQ_FOREACH(opt, &opts->head, next) {\n\n            printf(\"%s=\\\"%s\\\" \", opt->name, opt->str);\n\n        }\n\n        return;\n\n    }\n\n    for (; desc && desc->name; desc++) {\n\n        const char *value;\n\n        QemuOpt *opt = qemu_opt_find(opts, desc->name);\n\n\n\n        value = opt ? opt->str : desc->def_value_str;\n\n        if (!value) {\n\n            continue;\n\n        }\n\n        if (desc->type == QEMU_OPT_STRING) {\n\n            printf(\"%s='%s' \", desc->name, value);\n\n        } else if ((desc->type == QEMU_OPT_SIZE ||\n\n                    desc->type == QEMU_OPT_NUMBER) && opt) {\n\n            printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint);\n\n        } else {\n\n            printf(\"%s=%s \", desc->name, value);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2282, "prediction": "0", "true_label": "0", "raw_text": " Bus Fault Address.  */\n\n    case 0xd3c: /* Aux Fault Status.  */\n\n        /* TODO: Implement fault status registers.  */\n\n        qemu_log_mask(LOG_UNIMP, \"Fault status registers unimplemented\\n\");\n\n        return 0;\n\n    case 0xd40: /* PFR0.  */\n\n        return 0x00000030;\n\n    case 0xd44: /* PRF1.  */\n\n        return 0x00000200;\n\n    case 0xd48: /* DFR0.  */\n\n        return 0x00100000;\n\n    case 0xd4c: /* AFR0.  */\n\n        return 0x00000000;\n\n    case 0xd50: /* MMFR0.  */\n\n        return 0x00000030;\n\n    case 0xd54: /* MMFR1.  */\n\n        return 0x00000000;\n\n    case 0xd58: /* MMFR2.  */\n\n        return 0x00000000;\n\n    case 0xd5c: /* MMFR3.  */\n\n        return 0x00000000;\n\n    case 0xd60: /* ISAR0.  */\n\n        return 0x01141110;\n\n    case 0xd64: /* ISAR1.  */\n\n        return 0x02111000;\n\n    case 0xd68: /* ISAR2.  */\n\n        return 0x21112231;\n\n    case 0xd6c: /* ISAR3.  */\n\n        return 0x01111110;\n\n    case 0xd70: /* ISAR4.  */\n\n        return 0x01310102;\n\n    /* TODO: Implement debug registers.  */\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"NVIC: Bad read offset 0x%x\\n\", offset);\n\n        return 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2283, "prediction": "0", "true_label": "0", "raw_text": "ID_MPEG1VIDEO:\n\n                sc->track_type = 9;\n\n                gxf->mpeg_tracks++;\n\n                media_info = 'L';\n\n                break;\n\n            case AV_CODEC_ID_MPEG2VIDEO:\n\n                sc->first_gop_closed = -1;\n\n                sc->track_type = 4;\n\n                gxf->mpeg_tracks++;\n\n                gxf->flags |= 0x00008000;\n\n                media_info = 'M';\n\n                break;\n\n            case AV_CODEC_ID_DVVIDEO:\n\n                if (st->codecpar->format == AV_PIX_FMT_YUV422P) {\n\n                    sc->media_type += 2;\n\n                    sc->track_type = 6;\n\n                    gxf->flags |= 0x00002000;\n\n                    media_info = 'E';\n\n                } else {\n\n                    sc->track_type = 5;\n\n                    gxf->flags |= 0x00001000;\n\n                    media_info = 'D';\n\n                }\n\n                break;\n\n            default:\n\n                av_log(s, AV_LOG_ERROR, \"video codec not supported\\n\");\n\n                return -1;\n\n            }\n\n        }\n\n        /* FIXME first 10 audio tracks are 0 to 9 next 22 are A to V */\n\n        sc->media_info = media_info<<8 | ('0'+tracks[media_info]++);\n\n        sc->order = s->nb_streams - st->index;\n\n    }\n\n\n\n    if (ff_audio_interleave_init(s, GXF_samples_per_frame, (AVRational){ 1, 48000 }) < 0)\n\n        return -1;\n\n\n\n    gxf_init_timecode_track(&gxf->timecode_track, vsc);\n\n    gxf->flags |= 0x200000; // time code track is non-drop frame\n\n\n\n    gxf_write_map_packet(s, 0);\n\n    gxf_write_flt_packet(s);\n\n    gxf_write_umf_packet(s);\n\n\n\n    gxf->packet_count = 3;\n\n\n\n    avio_flush(pb);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2284, "prediction": "0", "true_label": "0", "raw_text": " i;\n\n\n\n    if (qxl->guest_primary.resized) {\n\n        qxl->guest_primary.resized = 0;\n\n        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);\n\n        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);\n\n        qxl->num_dirty_rects = 1;\n\n        trace_qxl_render_guest_primary_resized(\n\n               qxl->guest_primary.surface.width,\n\n               qxl->guest_primary.surface.height,\n\n               qxl->guest_primary.qxl_stride,\n\n               qxl->guest_primary.bytes_pp,\n\n               qxl->guest_primary.bits_pp);\n\n        if (qxl->guest_primary.qxl_stride > 0) {\n\n            qemu_free_displaysurface(vga->ds);\n\n            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,\n\n                                            qxl->guest_primary.surface.height,\n\n                                            qxl->guest_primary.bits_pp,\n\n                                            qxl->guest_primary.abs_stride,\n\n                                            qxl->guest_primary.data);\n\n        } else {\n\n            qemu_resize_displaysurface(vga->ds,\n\n                    qxl->guest_primary.surface.width,\n\n                    qxl->guest_primary.surface.height);\n\n        }\n\n        dpy_gfx_resize(vga->ds);\n\n    }\n\n    for (i = 0; i < qxl->num_dirty_rects; i++) {\n\n        if (qemu_spice_rect_is_empty(qxl->dirty+i)) {\n\n            break;\n\n        }\n\n        qxl_blit(qxl, qxl->dirty+i);\n\n        dpy_gfx_update(vga->ds,\n\n                       qxl->dirty[i].left, qxl->dirty[i].top,\n\n                       qxl->dirty[i].right - qxl->dirty[i].left,\n\n                       qxl->dirty[i].bottom - qxl->dirty[i].top);\n\n    }\n\n    qxl->num_dirty_rects = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2285, "prediction": "0", "true_label": "0", "raw_text": "_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2286, "prediction": "0", "true_label": "0", "raw_text": "Question: static SocketAddress *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddress *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddress, 1);\n\n    saddr->type = SOCKET_ADDRESS_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2287, "prediction": "0", "true_label": "0", "raw_text": "Question: static void nbd_close(BlockDriverState *bs)\n\n{\n\n    BDRVNBDState *s = bs->opaque;\n\n\n\n    qemu_opts_del(s->socket_opts);\n\n    nbd_client_session_close(&s->client);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2288, "prediction": "0", "true_label": "0", "raw_text": "Question: static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2289, "prediction": "1", "true_label": "0", "raw_text": "Question: int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,\n\n                          target_ulong len, int type)\n\n{\n\n    struct kvm_sw_breakpoint *bp;\n\n    CPUState *env;\n\n    int err;\n\n\n\n    if (type == GDB_BREAKPOINT_SW) {\n\n        bp = kvm_find_sw_breakpoint(current_env, addr);\n\n        if (!bp)\n\n            return -ENOENT;\n\n\n\n        if (bp->use_count > 1) {\n\n            bp->use_count--;\n\n            return 0;\n\n        }\n\n\n\n        err = kvm_arch_remove_sw_breakpoint(current_env, bp);\n\n        if (err)\n\n            return err;\n\n\n\n        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);\n\n        qemu_free(bp);\n\n    } else {\n\n        err = kvm_arch_remove_hw_breakpoint(addr, len, type);\n\n        if (err)\n\n            return err;\n\n    }\n\n\n\n    for (env = first_cpu; env != NULL; env = env->next_cpu) {\n\n        err = kvm_update_guest_debug(env, 0);\n\n        if (err)\n\n            return err;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2290, "prediction": "0", "true_label": "0", "raw_text": "Question: void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)\n\n{\n\n    int relation;\n\n\n\n    set_float_exception_flags(0, &env->fp_status);\n\n    relation = float64_compare(t0, t1, &env->fp_status);\n\n    if (unlikely(relation == float_relation_unordered)) {\n\n        update_fpscr(env, GETPC());\n\n    } else {\n\n        env->sr_t = (relation == float_relation_greater);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2291, "prediction": "0", "true_label": "0", "raw_text": ";\n\n    const char *filename, *fmt, *output;\n\n    BlockDriverState *bs;\n\n    ImageInfo *info;\n\n\n\n    fmt = NULL;\n\n    output = NULL;\n\n    for(;;) {\n\n        int option_index = 0;\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"format\", required_argument, 0, 'f'},\n\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:h\",\n\n                        long_options, &option_index);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case OPTION_OUTPUT:\n\n            output = optarg;\n\n            break;\n\n        }\n\n    }\n\n    if (optind >= argc) {\n\n        help();\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (output && !strcmp(output, \"json\")) {\n\n        output_format = OFORMAT_JSON;\n\n    } else if (output && !strcmp(output, \"human\")) {\n\n        output_format = OFORMAT_HUMAN;\n\n    } else if (output) {\n\n        error_report(\"--output must be used with human or json as argument.\");\n\n        return 1;\n\n    }\n\n\n\n    bs = bdrv_new_open(filename, fmt, BDRV_O_FLAGS | BDRV_O_NO_BACKING);\n\n    if (!bs) {\n\n        return 1;\n\n    }\n\n\n\n    info = g_new0(ImageInfo, 1);\n\n    collect_image_info(bs, info, filename, fmt);\n\n\n\n    switch (output_format) {\n\n    case OFORMAT_HUMAN:\n\n        dump_human_image_info(info);\n\n        dump_snapshots(bs);\n\n        break;\n\n    case OFORMAT_JSON:\n\n        collect_snapshots(bs, info);\n\n        dump_json_image_info(info);\n\n        break;\n\n    }\n\n\n\n    qapi_free_ImageInfo(info);\n\n    bdrv_delete(bs);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2292, "prediction": "0", "true_label": "0", "raw_text": "Question: int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,\n\n                                 SocketAddressLegacy *addr,\n\n                                 size_t *naddrs,\n\n                                 SocketAddressLegacy ***addrs,\n\n                                 Error **errp)\n\n{\n\n    switch (addr->type) {\n\n    case SOCKET_ADDRESS_LEGACY_KIND_INET:\n\n        return qio_dns_resolver_lookup_sync_inet(resolver,\n\n                                                 addr,\n\n                                                 naddrs,\n\n                                                 addrs,\n\n                                                 errp);\n\n\n\n    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:\n\n    case SOCKET_ADDRESS_LEGACY_KIND_FD:\n\n        return qio_dns_resolver_lookup_sync_nop(resolver,\n\n                                                addr,\n\n                                                naddrs,\n\n                                                addrs,\n\n                                                errp);\n\n\n\n    default:\n\n        abort();\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2293, "prediction": "0", "true_label": "0", "raw_text": "lock(&s->lock);\n\n                if (ret < 0) {\n\n                    goto fail;\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                memset(buf, 0, 512 * n);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            if (decompress_cluster(bs, cluster_offset) < 0) {\n\n                goto fail;\n\n            }\n\n            memcpy(buf,\n\n                   s->cluster_cache + index_in_cluster * 512, 512 * n);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                goto fail;\n\n            }\n\n            hd_iov.iov_base = (void *)buf;\n\n            hd_iov.iov_len = n * 512;\n\n            qemu_iovec_init_external(&hd_qiov, &hd_iov, 1);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                n, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                break;\n\n            }\n\n            if (bs->encrypted) {\n\n                assert(s->cipher);\n\n                if (encrypt_sectors(s, sector_num, buf,\n\n                                    n, false, &err) < 0) {\n\n                    goto fail;\n\n                }\n\n            }\n\n        }\n\n        ret = 0;\n\n\n\n        nb_sectors -= n;\n\n        sector_num += n;\n\n        buf += n * 512;\n\n    }\n\n\n\ndone:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (qiov->niov > 1) {\n\n        qemu_iovec_from_buf(qiov, 0, orig_buf, qiov->size);\n\n        qemu_vfree(orig_buf);\n\n    }\n\n\n\n    return ret;\n\n\n\nfail:\n\n    error_free(err);\n\n    ret = -EIO;\n\n    goto done;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2294, "prediction": "0", "true_label": "0", "raw_text": "Question: static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n\n{\n\n    int hours, minutes, seconds;\n\n\n\n    if (!show_bits(gb, 23)) {\n\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    hours   = get_bits(gb, 5);\n\n    minutes = get_bits(gb, 6);\n\n    skip_bits1(gb);\n\n    seconds = get_bits(gb, 6);\n\n\n\n    s->time_base = seconds + 60*(minutes + 60*hours);\n\n\n\n    skip_bits1(gb);\n\n    skip_bits1(gb);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2295, "prediction": "1", "true_label": "0", "raw_text": "Question: static int ftp_restart(FTPContext *s, int64_t pos)\n\n{\n\n    char command[CONTROL_BUFFER_SIZE];\n\n    const int rest_codes[] = {350, 0};\n\n\n\n    snprintf(command, sizeof(command), \"REST %\"PRId64\"\\r\\n\", pos);\n\n    if (!ftp_send_command(s, command, rest_codes, NULL))\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2296, "prediction": "0", "true_label": "0", "raw_text": "bytes);\n\n\n\n    trace_bdrv_co_do_copy_on_readv(bs, offset, bytes,\n\n                                   cluster_offset, cluster_bytes);\n\n\n\n    iov.iov_len = cluster_bytes;\n\n    iov.iov_base = bounce_buffer = qemu_try_blockalign(bs, iov.iov_len);\n\n    if (bounce_buffer == NULL) {\n\n        ret = -ENOMEM;\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n    ret = bdrv_driver_preadv(bs, cluster_offset, cluster_bytes,\n\n                             &bounce_qiov, 0);\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    bdrv_debug_event(bs, BLKDBG_COR_WRITE);\n\n    if (drv->bdrv_co_pwrite_zeroes &&\n\n        buffer_is_zero(bounce_buffer, iov.iov_len)) {\n\n        /* FIXME: Should we (perhaps conditionally) be setting\n\n         * BDRV_REQ_MAY_UNMAP, if it will allow for a sparser copy\n\n         * that still correctly reads as zero? */\n\n        ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, cluster_bytes, 0);\n\n    } else {\n\n        /* This does not change the data on the disk, it is not necessary\n\n         * to flush even in cache=writethrough mode.\n\n         */\n\n        ret = bdrv_driver_pwritev(bs, cluster_offset, cluster_bytes,\n\n                                  &bounce_qiov, 0);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        /* It might be okay to ignore write errors for guest requests.  If this\n\n         * is a deliberate copy-on-read then we don't want to ignore the error.\n\n         * Simply report it in all cases.\n\n         */\n\n        goto err;\n\n    }\n\n\n\n    skip_bytes = offset - cluster_offset;\n\n    qemu_iovec_from_buf(qiov, 0, bounce_buffer + skip_bytes, bytes);\n\n\n\nerr:\n\n    qemu_vfree(bounce_buffer);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2297, "prediction": "1", "true_label": "0", "raw_text": "Question: int kvm_ioctl(KVMState *s, int type, ...)\n\n{\n\n    int ret;\n\n    void *arg;\n\n    va_list ap;\n\n\n\n    va_start(ap, type);\n\n    arg = va_arg(ap, void *);\n\n    va_end(ap);\n\n\n\n    ret = ioctl(s->fd, type, arg);\n\n    if (ret == -1)\n\n        ret = -errno;\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2298, "prediction": "0", "true_label": "0", "raw_text": "n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2299, "prediction": "1", "true_label": "0", "raw_text": "Question: theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)\n\n{\n\n    struct ogg *ogg = ctx->priv_data;\n\n    struct ogg_stream *os = ogg->streams + idx;\n\n    struct theora_params *thp = os->private;\n\n    uint64_t iframe = gp >> thp->gpshift;\n\n    uint64_t pframe = gp & thp->gpmask;\n\n\n\n    if (thp->version < 0x030201)\n\n        iframe++;\n\n\n\n    if(!pframe)\n\n        os->pflags |= AV_PKT_FLAG_KEY;\n\n\n\n    if (dts)\n\n        *dts = iframe + pframe;\n\n\n\n    return iframe + pframe;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2300, "prediction": "0", "true_label": "0", "raw_text": "Question: static void av_build_index_raw(AVFormatContext *s)\n\n{\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int ret;\n\n    AVStream *st;\n\n\n\n    st = s->streams[0];\n\n    av_read_frame_flush(s);\n\n    url_fseek(&s->pb, s->data_offset, SEEK_SET);\n\n\n\n    for(;;) {\n\n        ret = av_read_frame(s, pkt);\n\n        if (ret < 0)\n\n            break;\n\n        if (pkt->stream_index == 0 && st->parser &&\n\n            (pkt->flags & PKT_FLAG_KEY)) {\n\n            add_index_entry(st, st->parser->frame_offset, pkt->dts, \n\n                            AVINDEX_KEYFRAME);\n\n        }\n\n        av_free_packet(pkt);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2301, "prediction": "0", "true_label": "0", "raw_text": " }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2302, "prediction": "0", "true_label": "0", "raw_text": "Question: int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,\n\n                  target_ulong *raddr, int *flags)\n\n{\n\n    int r = -1;\n\n    uint8_t *sk;\n\n\n\n    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;\n\n    vaddr &= TARGET_PAGE_MASK;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_DAT)) {\n\n        *raddr = vaddr;\n\n        r = 0;\n\n        goto out;\n\n    }\n\n\n\n    switch (asc) {\n\n    case PSW_ASC_PRIMARY:\n\n    case PSW_ASC_HOME:\n\n        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);\n\n        break;\n\n    case PSW_ASC_SECONDARY:\n\n        /*\n\n         * Instruction: Primary\n\n         * Data: Secondary\n\n         */\n\n        if (rw == 2) {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_READ | PAGE_WRITE);\n\n        } else {\n\n            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,\n\n                                  rw);\n\n            *flags &= ~(PAGE_EXEC);\n\n        }\n\n        break;\n\n    case PSW_ASC_ACCREG:\n\n    default:\n\n        hw_error(\"guest switched to unknown asc mode\\n\");\n\n        break;\n\n    }\n\n\n\n out:\n\n    /* Convert real address -> absolute address */\n\n    *raddr = mmu_real2abs(env, *raddr);\n\n\n\n    if (*raddr <= ram_size) {\n\n        sk = &env->storage_keys[*raddr / TARGET_PAGE_SIZE];\n\n        if (*flags & PAGE_READ) {\n\n            *sk |= SK_R;\n\n        }\n\n\n\n        if (*flags & PAGE_WRITE) {\n\n            *sk |= SK_C;\n\n        }\n\n    }\n\n\n\n    return r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2303, "prediction": "0", "true_label": "0", "raw_text": ": static inline int decode_ac_coeffs(GetBitContext *gb, int16_t *out,\n\n                                   int blocks_per_slice,\n\n                                   int plane_size_factor,\n\n                                   const uint8_t *scan)\n\n{\n\n    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;\n\n    int max_coeffs, bits_left;\n\n\n\n    /* set initial prediction values */\n\n    run   = 4;\n\n    level = 2;\n\n\n\n    max_coeffs = blocks_per_slice << 6;\n\n    block_mask = blocks_per_slice - 1;\n\n\n\n    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {\n\n        run_cb_index = ff_prores_run_to_cb_index[FFMIN(run, 15)];\n\n        lev_cb_index = ff_prores_lev_to_cb_index[FFMIN(level, 9)];\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return 0;\n\n\n\n        run = decode_vlc_codeword(gb, ff_prores_ac_codebook[run_cb_index]);\n\n        if (run < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        bits_left = get_bits_left(gb);\n\n        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        level = decode_vlc_codeword(gb, ff_prores_ac_codebook[lev_cb_index]) + 1;\n\n        if (level < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        pos += run + 1;\n\n        if (pos >= max_coeffs)\n\n            break;\n\n\n\n        sign = get_sbits(gb, 1);\n\n        out[((pos & block_mask) << 6) + scan[pos >> plane_size_factor]] =\n\n            (level ^ sign) - sign;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2304, "prediction": "0", "true_label": "1", "raw_text": "Question: static int local_opendir(FsContext *ctx,\n\n                         V9fsPath *fs_path, V9fsFidOpenState *fs)\n\n{\n\n    int dirfd;\n\n    DIR *stream;\n\n\n\n    dirfd = local_opendir_nofollow(ctx, fs_path->data);\n\n    if (dirfd == -1) {\n\n        return -1;\n\n    }\n\n\n\n    stream = fdopendir(dirfd);\n\n    if (!stream) {\n\n\n        return -1;\n\n    }\n\n    fs->dir.stream = stream;\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2305, "prediction": "0", "true_label": "1", "raw_text": "stream_index == -1)\n\n        s->scr_stream_index = 0;\n\n\n\n    /* we increase slightly the bitrate to take into account the\n\n       headers. XXX: compute it exactly */\n\n    bitrate = 2000;\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        st = ctx->streams[i];\n\n        bitrate += st->codec.bit_rate;\n\n    }\n\n    s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n    \n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n       s->pack_header_freq = 1;\n\n    \n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* every 40 packets, this is my invention */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n    \n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        stream = ctx->streams[i]->priv_data;\n\n        stream->buffer_ptr = 0;\n\n        stream->packet_number = 0;\n\n        stream->start_pts = AV_NOPTS_VALUE;\n\n        stream->start_dts = AV_NOPTS_VALUE;\n\n    }\n\n    s->last_scr = 0;\n\n    return 0;\n\n fail:\n\n    for(i=0;i<ctx->nb_streams;i++) {\n\n        av_free(ctx->streams[i]->priv_data);\n\n    }\n\n    return -ENOMEM;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2306, "prediction": "0", "true_label": "1", "raw_text": " if (avio_tell(s->pb) > next) {\n\n                        av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n\n                               klv.offset);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    /* we need to do this before computing the index tables\n\n     * to be able to fill in zero IndexDurations with st->duration */\n\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n\n        return ret;\n\n\n\n    if (mxf->nb_index_tables > 1) {\n\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    mxf_handle_small_eubc(s);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2307, "prediction": "0", "true_label": "1", "raw_text": "Question: get_net_error_message(gint error)\n\n{\n\n    HMODULE module = NULL;\n\n    gchar *retval = NULL;\n\n    wchar_t *msg = NULL;\n\n    int flags;\n\n    size_t nchars;\n\n\n\n    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n\n        FORMAT_MESSAGE_IGNORE_INSERTS |\n\n        FORMAT_MESSAGE_FROM_SYSTEM;\n\n\n\n    if (error >= NERR_BASE && error <= MAX_NERR) {\n\n        module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOAD_LIBRARY_AS_DATAFILE);\n\n\n\n        if (module != NULL) {\n\n            flags |= FORMAT_MESSAGE_FROM_HMODULE;\n\n        }\n\n    }\n\n\n\n    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);\n\n\n\n    if (msg != NULL) {\n\n        nchars = wcslen(msg);\n\n\n\n        if (nchars > 2 &&\n\n            msg[nchars - 1] == L'\\n' &&\n\n            msg[nchars - 2] == L'\\r') {\n\n            msg[nchars - 2] = L'\\0';\n\n        }\n\n\n\n        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);\n\n\n\n        LocalFree(msg);\n\n    }\n\n\n\n    if (module != NULL) {\n\n        FreeLibrary(module);\n\n    }\n\n\n\n    return retval;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2308, "prediction": "0", "true_label": "0", "raw_text": "Question: static void kqemu_record_flush(void)\n\n{\n\n    PCRecord *r, *r_next;\n\n    int h;\n\n\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {\n\n            r_next = r->next;\n\n            free(r);\n\n        }\n\n        pc_rec_hash[h] = NULL;\n\n    }\n\n    nb_pc_records = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2309, "prediction": "0", "true_label": "0", "raw_text": "Question: static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,\n\n                                    int nb_sectors)\n\n{\n\n    int64_t cluster_num, nb_clusters;\n\n    if (iscsilun->allocationmap == NULL) {\n\n        return;\n\n    }\n\n    cluster_num = sector_num / iscsilun->cluster_sectors;\n\n    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,\n\n                               iscsilun->cluster_sectors) - cluster_num;\n\n    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2310, "prediction": "0", "true_label": "0", "raw_text": "EXIT_MASK);\n\n                        insns_left = cpu->icount_decr.u32;\n\n                        if (cpu->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            cpu->icount_extra += insns_left;\n\n                            if (cpu->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = cpu->icount_extra;\n\n                            }\n\n                            cpu->icount_extra -= insns_left;\n\n                            cpu->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(env, insns_left, tb);\n\n                                align_clocks(&sc, cpu);\n\n                            }\n\n                            cpu->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit(cpu);\n\n                        }\n\n                        break;\n\n                    }\n\n                    default:\n\n                        break;\n\n                    }\n\n                }\n\n                cpu->current_tb = NULL;\n\n                /* Try to align the host and virtual clocks\n\n                   if the guest is in advance */\n\n                align_clocks(&sc, cpu);\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        } else {\n\n            /* Reload env after longjmp - the compiler may have smashed all\n\n             * local variables as longjmp is marked 'noreturn'. */\n\n            cpu = current_cpu;\n\n            env = cpu->env_ptr;\n\n            cc = CPU_GET_CLASS(cpu);\n\n#ifdef TARGET_I386\n\n            x86_cpu = X86_CPU(cpu);\n\n#endif\n\n            if (have_tb_lock) {\n\n                spin_unlock(&tcg_ctx.tb_ctx.tb_lock);\n\n                have_tb_lock = false;\n\n            }\n\n        }\n\n    } /* for(;;) */\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2311, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2312, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2313, "prediction": "-1", "true_label": "1", "raw_text": "->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(cbpy<0){\n            av_log(s->avctx, AV_LOG_ERROR, \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        pb_mv_count += !!s->pb_frame;\n    while(pb_mv_count--){\n        ff_h263_decode_motion(s, 0, 1);\n        ff_h263_decode_motion(s, 0, 1);\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (h263_decode_block(s, block[i], i, cbp&32) < 0)\n            return -1;\n        cbp+=cbp;\n    if(s->pb_frame && h263_skip_b_part(s, cbpb) < 0)\n        return -1;\n    if(s->obmc && !s->mb_intra){\n        if(s->pict_type == AV_PICTURE_TYPE_P && s->mb_x+1<s->mb_width && s->mb_num_left != 1)\n            preview_obmc(s);\nend:\n        /* per-MB end of slice check */\n    {\n        int v= show_bits(&s->gb, 16);\n        if (get_bits_left(&s->gb) < 16) {\n            v >>= 16 - get_bits_left(&s->gb);\n        if(v==0)\n            return SLICE_END;\n    return SLICE_OK;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2314, "prediction": "0", "true_label": "0", "raw_text": "mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"movq   (%1), %%mm0             \\n\\t\"\n\n        \"movq   1(%1), %%mm1            \\n\\t\"\n\n        \"movq   (%1, %3), %%mm2         \\n\\t\"\n\n        \"movq   1(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, (%2)             \\n\\t\"\n\n        \"movq   %%mm5, (%2, %3)         \\n\\t\"\n\n        \"movq   8(%1), %%mm0            \\n\\t\"\n\n        \"movq   9(%1), %%mm1            \\n\\t\"\n\n        \"movq   8(%1, %3), %%mm2        \\n\\t\"\n\n        \"movq   9(%1, %3), %%mm3        \\n\\t\"\n\n        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)\n\n        \"movq   %%mm4, 8(%2)            \\n\\t\"\n\n        \"movq   %%mm5, 8(%2, %3)        \\n\\t\"\n\n        \"add    %%\"REG_a\", %1           \\n\\t\"\n\n        \"add    %%\"REG_a\", %2           \\n\\t\"\n\n        \"subl   $4, %0                  \\n\\t\"\n\n        \"jnz    1b                      \\n\\t\"\n\n        :\"+g\"(h), \"+S\"(pixels), \"+D\"(block)\n\n        :\"r\"((x86_reg)line_size)\n\n        :REG_a, \"memory\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2315, "prediction": "0", "true_label": "1", "raw_text": "Question: int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2316, "prediction": "0", "true_label": "1", "raw_text": "Question: static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2317, "prediction": "0", "true_label": "1", "raw_text": "4_coeff[chroma_idx+1+(IS_INTRA( mb_type ) ? 0:3)][chroma_qp];\n\n                for(i4x4=0; i4x4<4; i4x4++){\n\n                    const int index= 16 + 4*chroma_idx + i4x4;\n\n                    if( decode_residual(h, gb, h->mb + 16*index, index, scan + 1, qmul, 15) < 0){\n\n                        return -1;\n\n                    }\n\n                }\n\n            }\n\n        }else{\n\n            uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n            nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n            nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n        }\n\n    }else{\n\n        uint8_t * const nnz= &h->non_zero_count_cache[0];\n\n        fill_rectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1);\n\n        nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] =\n\n        nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0;\n\n    }\n\n    s->current_picture.qscale_table[mb_xy]= s->qscale;\n\n    write_back_non_zero_count(h);\n\n\n\n    if(MB_MBAFF){\n\n        h->ref_count[0] >>= 1;\n\n        h->ref_count[1] >>= 1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2318, "prediction": "0", "true_label": "1", "raw_text": " *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2319, "prediction": "0", "true_label": "1", "raw_text": "Question: static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2320, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2321, "prediction": "0", "true_label": "1", "raw_text": " | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2322, "prediction": "0", "true_label": "0", "raw_text": "Question: static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 64; i++) {\n\n        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];\n\n        int v = get_bits(&s->gb, 8);\n\n        if (v == 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"matrix damaged\\n\");\n\n            return -1;\n\n        }\n\n        if (intra && i == 0 && v != 8) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"intra matrix specifies invalid DC quantizer %d, ignoring\\n\", v);\n\n            v = 8; // needed by pink.mpg / issue1046\n\n        }\n\n        matrix0[j] = v;\n\n        if (matrix1)\n\n            matrix1[j] = v;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2323, "prediction": "0", "true_label": "1", "raw_text": "Question: static void child_handler(int sig)\n\n{\n\n    int status;\n\n    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2324, "prediction": "0", "true_label": "0", "raw_text": "Question: static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)\n\n{\n\n    int current_offset = s->pixel_ptr - dst->data[0];\n\n    int motion_offset = current_offset + delta_y * dst->linesize[0]\n\n                       + delta_x * (1 + s->is_16bpp);\n\n    if (motion_offset < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset < 0 (%d)\\n\", motion_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (motion_offset > s->upper_motion_limit_offset) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \" Interplay video: motion offset above limit (%d >= %d)\\n\",\n\n            motion_offset, s->upper_motion_limit_offset);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (src->data[0] == NULL) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid decode type, corrupted header?\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,\n\n                                            dst->linesize[0], 8);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2325, "prediction": "0", "true_label": "0", "raw_text": "Question: static void imx_epit_reset(DeviceState *dev)\n\n{\n\n    IMXEPITState *s = IMX_EPIT(dev);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);\n\n    s->sr = 0;\n\n    s->lr = TIMER_MAX;\n\n    s->cmp = 0;\n\n    s->cnt = 0;\n\n    /* stop both timers */\n\n    ptimer_stop(s->timer_cmp);\n\n    ptimer_stop(s->timer_reload);\n\n    /* compute new frequency */\n\n    imx_epit_set_freq(s);\n\n    /* init both timers to TIMER_MAX */\n\n    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);\n\n    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);\n\n    if (s->freq && (s->cr & CR_EN)) {\n\n        /* if the timer is still enabled, restart it */\n\n        ptimer_run(s->timer_reload, 0);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2326, "prediction": "0", "true_label": "0", "raw_text": "Question: static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2327, "prediction": "-1", "true_label": "1", "raw_text": " BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2328, "prediction": "0", "true_label": "0", "raw_text": "Question: static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2329, "prediction": "0", "true_label": "0", "raw_text": "Question: static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,\n\n    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,\n\n    BdrvRequestFlags flags)\n\n{\n\n    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,\n\n                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2330, "prediction": "0", "true_label": "0", "raw_text": "Question: static void sigchld_handler(int signal)\n\n{\n\n    qemu_bh_schedule(sigchld_bh);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2331, "prediction": "0", "true_label": "0", "raw_text": "Question: static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)\n\n{\n\n    MpegTSFilter *tss;\n\n    PESContext *pes;\n\n\n\n    /* if no pid found, then add a pid context */\n\n    pes = av_mallocz(sizeof(PESContext));\n\n    if (!pes)\n\n        return 0;\n\n    pes->ts = ts;\n\n    pes->stream = ts->stream;\n\n    pes->pid = pid;\n\n    pes->pcr_pid = pcr_pid;\n\n    pes->stream_type = stream_type;\n\n    pes->state = MPEGTS_SKIP;\n\n    pes->pts = AV_NOPTS_VALUE;\n\n    pes->dts = AV_NOPTS_VALUE;\n\n    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);\n\n    if (!tss) {\n\n        av_free(pes);\n\n        return 0;\n\n    }\n\n    return pes;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2332, "prediction": "0", "true_label": "1", "raw_text": "uvbuf= s->edge_emu_buffer+18*s->linesize;\n\n                s->vdsp.emulated_edge_mc(uvbuf ,\n\n                                    ptr_cb, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                s->vdsp.emulated_edge_mc(uvbuf+16,\n\n                                    ptr_cr, s->uvlinesize,\n\n                                    9, 9+field_based,\n\n                                    uvsrc_x, uvsrc_y<<field_based,\n\n                                    s->h_edge_pos>>1, s->v_edge_pos>>1);\n\n                ptr_cb= uvbuf;\n\n                ptr_cr= uvbuf+16;\n\n            }\n\n    }\n\n\n\n    if(bottom_field){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data\n\n        dest_y += s->linesize;\n\n        dest_cb+= s->uvlinesize;\n\n        dest_cr+= s->uvlinesize;\n\n    }\n\n\n\n    if(field_select){\n\n        ptr_y += s->linesize;\n\n        ptr_cb+= s->uvlinesize;\n\n        ptr_cr+= s->uvlinesize;\n\n    }\n\n\n\n    pix_op[0][dxy](dest_y, ptr_y, linesize, h);\n\n\n\n    if(!CONFIG_GRAY || !(s->flags&CODEC_FLAG_GRAY)){\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cb, ptr_cb, uvlinesize, h >> s->chroma_y_shift);\n\n        pix_op[s->chroma_x_shift][uvdxy]\n\n                (dest_cr, ptr_cr, uvlinesize, h >> s->chroma_y_shift);\n\n    }\n\n    if(!is_mpeg12 && (CONFIG_H261_ENCODER || CONFIG_H261_DECODER) &&\n\n         s->out_format == FMT_H261){\n\n        ff_h261_loop_filter(s);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2333, "prediction": "0", "true_label": "0", "raw_text": "Question: static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)\n\n{\n\n    if (kvm_enabled()) {\n\n        kvm_s390_virtio_irq(cpu, config_change, token);\n\n    } else {\n\n        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2334, "prediction": "0", "true_label": "0", "raw_text": "0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,\n\n    };\n\n\n\n    /* Read all the lengths in first */\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* At most we need to read 9 bits total to get indices up to 8 */\n\n        int val = show_bits(gb, 8);\n\n\n\n        // read reverse unary\n\n        if (val) {\n\n            val = LUT[val];\n\n            skip_bits(gb, val + 1);\n\n            ctx->len[i] = val;\n\n        } else {\n\n            skip_bits(gb, 8);\n\n            if (!get_bits1(gb))\n\n                return -1;\n\n            ctx->len[i] = 8;\n\n        }\n\n    }\n\n\n\n    /* For any values that have length 0 */\n\n    memset(ctx->val, 0, ctx->size);\n\n\n\n    for (i = 0; i < ctx->size; i++) {\n\n        /* Check we have enough bits left */\n\n        if (get_bits_left(gb) < ctx->len[i])\n\n            return -1;\n\n\n\n        /* get_bits can't take a length of 0 */\n\n        if (ctx->len[i])\n\n            ctx->val[i] = (1 << ctx->len[i]) + get_bits(gb, ctx->len[i]) - 1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2335, "prediction": "1", "true_label": "0", "raw_text": "Question: int ffurl_alloc(URLContext **puc, const char *filename, int flags,\n\n                const AVIOInterruptCB *int_cb)\n\n{\n\n    URLProtocol *up = NULL;\n\n    char proto_str[128], proto_nested[128], *ptr;\n\n    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n\n\n\n    if (filename[proto_len] != ':' || is_dos_path(filename))\n\n        strcpy(proto_str, \"file\");\n\n    else\n\n        av_strlcpy(proto_str, filename,\n\n                   FFMIN(proto_len + 1, sizeof(proto_str)));\n\n\n\n    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n\n    if ((ptr = strchr(proto_nested, '+')))\n\n        *ptr = '\\0';\n\n\n\n    while (up = ffurl_protocol_next(up)) {\n\n        if (!strcmp(proto_str, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n\n            !strcmp(proto_nested, up->name))\n\n            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n\n    }\n\n    *puc = NULL;\n\n    return AVERROR_PROTOCOL_NOT_FOUND;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2336, "prediction": "0", "true_label": "0", "raw_text": "Question: BlockDriverState *bdrv_next(BlockDriverState *bs)\n\n{\n\n    if (!bs) {\n\n        return QTAILQ_FIRST(&bdrv_states);\n\n    }\n\n    return QTAILQ_NEXT(bs, device_list);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2337, "prediction": "0", "true_label": "0", "raw_text": "Question: void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2338, "prediction": "0", "true_label": "0", "raw_text": "arch_post_run(CPUState *cs, struct kvm_run *run)\n\n{\n\n    ARMCPU *cpu;\n\n    uint32_t switched_level;\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        /*\n\n         * We only need to sync timer states with user-space interrupt\n\n         * controllers, so return early and save cycles if we don't.\n\n         */\n\n        return MEMTXATTRS_UNSPECIFIED;\n\n    }\n\n\n\n    cpu = ARM_CPU(cs);\n\n\n\n    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */\n\n    if (run->s.regs.device_irq_level != cpu->device_irq_level) {\n\n        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_VTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;\n\n        }\n\n\n\n        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {\n\n            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],\n\n                         !!(run->s.regs.device_irq_level &\n\n                            KVM_ARM_DEV_EL1_PTIMER));\n\n            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;\n\n        }\n\n\n\n        /* XXX PMU IRQ is missing */\n\n\n\n        if (switched_level) {\n\n            qemu_log_mask(LOG_UNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\",\n\n                          __func__, switched_level);\n\n        }\n\n\n\n        /* We also mark unknown levels as processed to not waste cycles */\n\n        cpu->device_irq_level = run->s.regs.device_irq_level;\n\n        qemu_mutex_unlock_iothread();\n\n    }\n\n\n\n    return MEMTXATTRS_UNSPECIFIED;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2339, "prediction": "0", "true_label": "0", "raw_text": ", avi->movi_list);\n\n            res = avi_write_idx1(s);\n\n            ff_end_tag(pb, avi->riff_start);\n\n        } else {\n\n            avi_write_ix(s);\n\n            ff_end_tag(pb, avi->movi_list);\n\n            ff_end_tag(pb, avi->riff_start);\n\n\n\n            file_size = avio_tell(pb);\n\n            avio_seek(pb, avi->odml_list - 8, SEEK_SET);\n\n            ffio_wfourcc(pb, \"LIST\"); /* Making this AVI OpenDML one */\n\n            avio_skip(pb, 16);\n\n\n\n            for (n = nb_frames = 0; n < s->nb_streams; n++) {\n\n                AVCodecParameters *par = s->streams[n]->codecpar;\n\n                AVIStream *avist       = s->streams[n]->priv_data;\n\n\n\n                if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                    if (nb_frames < avist->packet_count)\n\n                        nb_frames = avist->packet_count;\n\n                } else {\n\n                    if (par->codec_id == AV_CODEC_ID_MP2 ||\n\n                        par->codec_id == AV_CODEC_ID_MP3)\n\n                        nb_frames += avist->packet_count;\n\n                }\n\n            }\n\n            avio_wl32(pb, nb_frames);\n\n            avio_seek(pb, file_size, SEEK_SET);\n\n\n\n            avi_write_counters(s, avi->riff_id);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVIStream *avist = s->streams[i]->priv_data;\n\n        for (j = 0; j < avist->indexes.ents_allocated / AVI_INDEX_CLUSTER_SIZE; j++)\n\n            av_free(avist->indexes.cluster[j]);\n\n        av_freep(&avist->indexes.cluster);\n\n        avist->indexes.ents_allocated = avist->indexes.entry = 0;\n\n    }\n\n\n\n    return res;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2340, "prediction": "0", "true_label": "0", "raw_text": "Question: static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2341, "prediction": "0", "true_label": "0", "raw_text": "Question: static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIAC97LinkState *d = opaque;\n\n    AC97LinkState *s = &d->ac97;\n\n    dolog (\"U nam writeb %#x <- %#x\\n\", addr, val);\n\n    s->cas = 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2342, "prediction": "0", "true_label": "0", "raw_text": "Question: static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2343, "prediction": "0", "true_label": "0", "raw_text": "Question: static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)\n\n{\n\n    InputStream  *ist = s->opaque;\n\n    DXVA2Context *ctx = ist->hwaccel_ctx;\n\n\n\n    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2344, "prediction": "1", "true_label": "0", "raw_text": "]>>1);\n\n        const int a3 =  block[i+1*8] + block[i+7*8] - block[i+3*8] - (block[i+3*8]>>1);\n\n        const int a5 = -block[i+1*8] + block[i+7*8] + block[i+5*8] + (block[i+5*8]>>1);\n\n        const int a7 =  block[i+3*8] + block[i+5*8] + block[i+1*8] + (block[i+1*8]>>1);\n\n\n\n        const int b1 = (a7>>2) + a1;\n\n        const int b3 =  a3 + (a5>>2);\n\n        const int b5 = (a3>>2) - a5;\n\n        const int b7 =  a7 - (a1>>2);\n\n\n\n        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b7) >> 6) ];\n\n        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b2 + b5) >> 6) ];\n\n        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b4 + b3) >> 6) ];\n\n        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b6 + b1) >> 6) ];\n\n        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b6 - b1) >> 6) ];\n\n        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b4 - b3) >> 6) ];\n\n        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b2 - b5) >> 6) ];\n\n        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b7) >> 6) ];\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2345, "prediction": "0", "true_label": "0", "raw_text": "Question: void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2346, "prediction": "0", "true_label": "0", "raw_text": "section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    if (memory_region_is_ram(section->mr) ||\n\n        memory_region_is_romd(section->mr)) {\n\n        addend = (uintptr_t)memory_region_get_ram_ptr(section->mr)\n\n        + memory_region_section_addr(section, paddr);\n\n    } else {\n\n        addend = 0;\n\n    }\n\n\n\n    code_address = address;\n\n    iotlb = memory_region_section_get_iotlb(env, section, vaddr, paddr, prot,\n\n                                            &address);\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((memory_region_is_ram(section->mr) && section->readonly)\n\n            || memory_region_is_romd(section->mr)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if (memory_region_is_ram(section->mr)\n\n                   && !cpu_physical_memory_is_dirty(\n\n                           section->mr->ram_addr\n\n                           + memory_region_section_addr(section, paddr))) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2347, "prediction": "0", "true_label": "1", "raw_text": ", val);\n\n            break;\n\n        case TxConfig: /* windows driver sometimes writes using byte-lenth call */\n\n            rtl8139_TxConfig_writeb(s, val);\n\n            break;\n\n        case Config0:\n\n            rtl8139_Config0_write(s, val);\n\n            break;\n\n        case Config1:\n\n            rtl8139_Config1_write(s, val);\n\n            break;\n\n        case Config3:\n\n            rtl8139_Config3_write(s, val);\n\n            break;\n\n        case Config4:\n\n            rtl8139_Config4_write(s, val);\n\n            break;\n\n        case Config5:\n\n            rtl8139_Config5_write(s, val);\n\n            break;\n\n        case MediaStatus:\n\n            /* ignore */\n\n            DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\",\n\n                val);\n\n            break;\n\n\n\n        case HltClk:\n\n            DPRINTF(\"HltClk write val=0x%08x\\n\", val);\n\n            if (val == 'R')\n\n            {\n\n                s->clock_enabled = 1;\n\n            }\n\n            else if (val == 'H')\n\n            {\n\n                s->clock_enabled = 0;\n\n            }\n\n            break;\n\n\n\n        case TxThresh:\n\n            DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val);\n\n            s->TxThresh = val;\n\n            break;\n\n\n\n        case TxPoll:\n\n            DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val);\n\n            if (val & (1 << 7))\n\n            {\n\n                DPRINTF(\"C+ TxPoll high priority transmission (not \"\n\n                    \"implemented)\\n\");\n\n                //rtl8139_cplus_transmit(s);\n\n            }\n\n            if (val & (1 << 6))\n\n            {\n\n                DPRINTF(\"C+ TxPoll normal priority transmission\\n\");\n\n                rtl8139_cplus_transmit(s);\n\n            }\n\n\n\n            break;\n\n\n\n        default:\n\n            DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr,\n\n                val);\n\n            break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2348, "prediction": "0", "true_label": "1", "raw_text": "Question: static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,\n\n                                    const int filter_p1, const int filter_q1,\n\n                                    const int alpha, const int beta,\n\n                                    const int lim_p0q0, const int lim_q1,\n\n                                    const int lim_p1)\n\n{\n\n    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,\n\n                          alpha, beta, lim_p0q0, lim_q1, lim_p1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2349, "prediction": "0", "true_label": "1", "raw_text": ");\n\n            }\n\n    }\n\n    if (s->do_mclms)\n\n        revert_mclms(s, subframe_len);\n\n    if (s->do_inter_ch_decorr)\n\n        revert_inter_ch_decorr(s, subframe_len);\n\n    if (s->do_ac_filter)\n\n        revert_acfilter(s, subframe_len);\n\n\n\n    /* Dequantize */\n\n    if (s->quant_stepsize != 1)\n\n        for (i = 0; i < s->num_channels; i++)\n\n            for (j = 0; j < subframe_len; j++)\n\n                s->channel_residues[i][j] *= s->quant_stepsize;\n\n\n\n    /* Write to proper output buffer depending on bit-depth */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        int subframe_len = s->channel[c].subframe_len[s->channel[c].cur_subframe];\n\n\n\n        for (j = 0; j < subframe_len; j++) {\n\n            if (s->bits_per_sample == 16) {\n\n                *s->samples_16[c]++ = (int16_t) s->channel_residues[c][j] << padding_zeroes;\n\n            } else {\n\n                *s->samples_32[c]++ = s->channel_residues[c][j] << padding_zeroes;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handled one subframe */\n\n    for (i = 0; i < s->channels_for_cur_subframe; i++) {\n\n        int c = s->channel_indexes_for_cur_subframe[i];\n\n        if (s->channel[c].cur_subframe >= s->channel[c].num_subframes) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"broken subframe\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        ++s->channel[c].cur_subframe;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2350, "prediction": "0", "true_label": "1", "raw_text": "paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    } else {\n\n        __asm__ volatile(\n\n            \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n            \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n            \"push %%\"REG_BP\"                        \\n\\t\"\n\n            YSCALEYUV2RGB1b(%%REGBP, %5)\n\n            \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n            \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n            \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n            \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n            WRITERGB16(%%REGb, 8280(%5), %%REGBP)\n\n            \"pop %%\"REG_BP\"                         \\n\\t\"\n\n            \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n            :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n               \"a\" (&c->redDither)\n\n        );\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2351, "prediction": "1", "true_label": "1", "raw_text": "Question: void hmp_memchar_write(Monitor *mon, const QDict *qdict)\n\n{\n\n    uint32_t size;\n\n    const char *chardev = qdict_get_str(qdict, \"device\");\n\n    const char *data = qdict_get_str(qdict, \"data\");\n\n    Error *errp = NULL;\n\n\n\n    size = strlen(data);\n\n    qmp_memchar_write(chardev, size, data, false, 0, &errp);\n\n\n\n    hmp_handle_error(mon, &errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2352, "prediction": "0", "true_label": "0", "raw_text": "Question: static int do_bit_allocation(AC3DecodeContext *ctx, int flags)\n\n{\n\n    ac3_audio_block *ab = &ctx->audio_block;\n\n    int i, snroffst = 0;\n\n\n\n    if (!flags) /* bit allocation is not required */\n\n        return 0;\n\n\n\n    if (ab->flags & AC3_AB_SNROFFSTE) { /* check whether snroffsts are zero */\n\n        snroffst += ab->csnroffst;\n\n        if (ab->flags & AC3_AB_CPLINU)\n\n            snroffst += ab->cplfsnroffst;\n\n        for (i = 0; i < ctx->bsi.nfchans; i++)\n\n            snroffst += ab->fsnroffst[i];\n\n        if (ctx->bsi.flags & AC3_BSI_LFEON)\n\n            snroffst += ab->lfefsnroffst;\n\n        if (!snroffst) {\n\n            memset(ab->cplbap, 0, sizeof (ab->cplbap));\n\n            for (i = 0; i < ctx->bsi.nfchans; i++)\n\n                memset(ab->bap[i], 0, sizeof (ab->bap[i]));\n\n            memset(ab->lfebap, 0, sizeof (ab->lfebap));\n\n\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    /* perform bit allocation */\n\n    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))\n\n        if (_do_bit_allocation(ctx, 5))\n\n            return -1;\n\n    for (i = 0; i < ctx->bsi.nfchans; i++)\n\n        if (flags & (1 << i))\n\n            if (_do_bit_allocation(ctx, i))\n\n                return -1;\n\n    if ((ctx->bsi.flags & AC3_BSI_LFEON) && (flags & 32))\n\n        if (_do_bit_allocation(ctx, 6))\n\n            return -1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2353, "prediction": "1", "true_label": "0", "raw_text": " error_set(errp, QERR_INVALID_BLOCK_FORMAT, format);\n\n            return;\n\n        }\n\n    }\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n\n        return;\n\n    }\n\n\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n\n\n    /* See if we have a backing HD we can use to create our new image\n\n     * on top of. */\n\n    if (sync == MIRROR_SYNC_MODE_TOP) {\n\n        source = bs->backing_hd;\n\n        if (!source) {\n\n            sync = MIRROR_SYNC_MODE_FULL;\n\n        }\n\n    }\n\n    if (sync == MIRROR_SYNC_MODE_NONE) {\n\n        source = bs;\n\n    }\n\n\n\n    size = bdrv_getlength(bs);\n\n    if (size < 0) {\n\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n\n        return;\n\n    }\n\n\n\n    if (mode != NEW_IMAGE_MODE_EXISTING) {\n\n        assert(format && drv);\n\n        if (source) {\n\n            bdrv_img_create(target, format, source->filename,\n\n                            source->drv->format_name, NULL,\n\n                            size, flags, &local_err, false);\n\n        } else {\n\n            bdrv_img_create(target, format, NULL, NULL, NULL,\n\n                            size, flags, &local_err, false);\n\n        }\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    target_bs = NULL;\n\n    ret = bdrv_open(&target_bs, target, NULL, NULL, flags, drv, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    backup_start(bs, target_bs, speed, sync, on_source_error, on_target_error,\n\n                 block_job_cb, bs, &local_err);\n\n    if (local_err != NULL) {\n\n        bdrv_unref(target_bs);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2354, "prediction": "0", "true_label": "0", "raw_text": "0410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2355, "prediction": "0", "true_label": "0", "raw_text": " bd->quant_cof   = ctx->quant_cof[c];\n\n    bd->raw_samples = ctx->raw_samples[c] + offset;\n\n\n\n    dep = 0;\n\n    while (!ch[dep].stop_flag) {\n\n        unsigned int smp;\n\n        unsigned int begin = 1;\n\n        unsigned int end   = bd->block_length - 1;\n\n        int64_t y;\n\n        int32_t *master = ctx->raw_samples[ch[dep].master_channel] + offset;\n\n\n\n        if (ch[dep].time_diff_flag) {\n\n            int t = ch[dep].time_diff_index;\n\n\n\n            if (ch[dep].time_diff_sign) {\n\n                t      = -t;\n\n                begin -= t;\n\n            } else {\n\n                end   -= t;\n\n            }\n\n\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1    ]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp        ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1    ]) +\n\n                     MUL64(ch[dep].weighting[3], master[smp - 1 + t]) +\n\n                     MUL64(ch[dep].weighting[4], master[smp     + t]) +\n\n                     MUL64(ch[dep].weighting[5], master[smp + 1 + t]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        } else {\n\n            for (smp = begin; smp < end; smp++) {\n\n                y  = (1 << 6) +\n\n                     MUL64(ch[dep].weighting[0], master[smp - 1]) +\n\n                     MUL64(ch[dep].weighting[1], master[smp    ]) +\n\n                     MUL64(ch[dep].weighting[2], master[smp + 1]);\n\n\n\n                bd->raw_samples[smp] += y >> 7;\n\n            }\n\n        }\n\n\n\n        dep++;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2356, "prediction": "0", "true_label": "0", "raw_text": "Question: build_hpet(GArray *table_data, GArray *linker)\n\n{\n\n    Acpi20Hpet *hpet;\n\n\n\n    hpet = acpi_data_push(table_data, sizeof(*hpet));\n\n    /* Note timer_block_id value must be kept in sync with value advertised by\n\n     * emulated hpet\n\n     */\n\n    hpet->timer_block_id = cpu_to_le32(0x8086a201);\n\n    hpet->addr.address = cpu_to_le64(HPET_BASE);\n\n    build_header(linker, table_data,\n\n                 (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2357, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void downmix_3f_1r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2358, "prediction": "0", "true_label": "0", "raw_text": " frame_width  = frames_hwctx->surfaces[0].Info.Width;\n\n        frame_height = frames_hwctx->surfaces[0].Info.Height;\n\n    }\n\n\n\n    if (!iopattern)\n\n        iopattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;\n\n    q->iopattern = iopattern;\n\n\n\n    ret = qsv_init_session(avctx, q, session, avctx->hw_frames_ctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;\n\n    param.mfx.FrameInfo.FourCC         = q->fourcc;\n\n    param.mfx.FrameInfo.Width          = frame_width;\n\n    param.mfx.FrameInfo.Height         = frame_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0)\n\n        return ff_qsv_print_error(avctx, ret,\n\n                                  \"Error initializing the MFX video decoder\");\n\n\n\n    q->frame_info = param.mfx.FrameInfo;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2359, "prediction": "0", "true_label": "0", "raw_text": "Question: static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,\n\n                                         VirtIOPCIRegion *region,\n\n                                         struct virtio_pci_cap *cap)\n\n{\n\n    memory_region_add_subregion(&proxy->modern_bar,\n\n                                region->offset,\n\n                                &region->mr);\n\n\n\n    cap->cfg_type = region->type;\n\n    cap->offset = cpu_to_le32(region->offset);\n\n    cap->length = cpu_to_le32(memory_region_size(&region->mr));\n\n    virtio_pci_add_mem_cap(proxy, cap);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2360, "prediction": "0", "true_label": "0", "raw_text": "Mute         , 0x8808);\n\n    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);\n\n    mixer_store (s, AC97_General_Purpose         , 0x0000);\n\n    mixer_store (s, AC97_3D_Control              , 0x0000);\n\n    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);\n\n\n\n    /*\n\n     * Sigmatel 9700 (STAC9700)\n\n     */\n\n    mixer_store (s, AC97_Vendor_ID1              , 0x8384);\n\n    mixer_store (s, AC97_Vendor_ID2              , 0x7600); /* 7608 */\n\n\n\n    mixer_store (s, AC97_Extended_Audio_ID       , 0x0809);\n\n    mixer_store (s, AC97_Extended_Audio_Ctrl_Stat, 0x0009);\n\n    mixer_store (s, AC97_PCM_Front_DAC_Rate      , 0xbb80);\n\n    mixer_store (s, AC97_PCM_Surround_DAC_Rate   , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LFE_DAC_Rate        , 0xbb80);\n\n    mixer_store (s, AC97_PCM_LR_ADC_Rate         , 0xbb80);\n\n    mixer_store (s, AC97_MIC_ADC_Rate            , 0xbb80);\n\n\n\n    record_select (s, 0);\n\n    set_volume (s, AC97_Master_Volume_Mute, 0x8000);\n\n    set_volume (s, AC97_PCM_Out_Volume_Mute, 0x8808);\n\n    set_volume (s, AC97_Line_In_Volume_Mute, 0x8808);\n\n\n\n    reset_voices (s, active);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2361, "prediction": "0", "true_label": "0", "raw_text": "Question: int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2362, "prediction": "0", "true_label": "0", "raw_text": "Question: void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    switch (addr & 3) {\n\n    case 3:\n\n        cpu_stb_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 2:\n\n        cpu_stw_data_ra(env, addr, val, ra);\n\n        break;\n\n    case 1:\n\n        /* The 3 byte store must appear atomic.  */\n\n        if (parallel_cpus) {\n\n            atomic_store_3(env, addr, val, 0x00ffffffu, ra);\n\n        } else {\n\n            cpu_stb_data_ra(env, addr, val >> 16, ra);\n\n            cpu_stw_data_ra(env, addr + 1, val, ra);\n\n        }\n\n        break;\n\n    default:\n\n        cpu_stl_data_ra(env, addr, val, ra);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2363, "prediction": "0", "true_label": "1", "raw_text": "Question: int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)\n\n{\n\n    int64_t scaled_dim;\n\n\n\n    if (!sar.den)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!sar.num || sar.num == sar.den)\n\n        return 0;\n\n\n\n    if (sar.num < sar.den)\n\n        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);\n\n    else\n\n        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);\n\n\n\n    if (scaled_dim > 0)\n\n        return 0;\n\n\n\n    return AVERROR(EINVAL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2364, "prediction": "0", "true_label": "1", "raw_text": "Question: static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n    OPEN_READER(re, &s->gb);\n\n    count /= 2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2365, "prediction": "0", "true_label": "1", "raw_text": "Question: static void memory_region_destructor_alias(MemoryRegion *mr)\n\n{\n\n    memory_region_unref(mr->alias);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2366, "prediction": "0", "true_label": "1", "raw_text": "000000;\n\n        } else {\n\n            target_ulong dsisr = 0;\n\n\n\n            cs->exception_index = POWERPC_EXCP_DSI;\n\n            env->error_code = 0;\n\n            env->spr[SPR_DAR] = eaddr;\n\n            if (need_prot[rwx] & ~pp_prot) {\n\n                dsisr |= 0x08000000;\n\n            }\n\n            if (rwx == 1) {\n\n                dsisr |= 0x02000000;\n\n            }\n\n            if (need_prot[rwx] & ~amr_prot) {\n\n                dsisr |= 0x00200000;\n\n            }\n\n            env->spr[SPR_DSISR] = dsisr;\n\n        }\n\n        return 1;\n\n    }\n\n\n\n    qemu_log_mask(CPU_LOG_MMU, \"PTE access granted !\\n\");\n\n\n\n    /* 6. Update PTE referenced and changed bits if necessary */\n\n\n\n    new_pte1 = pte.pte1 | HPTE64_R_R; /* set referenced bit */\n\n    if (rwx == 1) {\n\n        new_pte1 |= HPTE64_R_C; /* set changed (dirty) bit */\n\n    } else {\n\n        /* Treat the page as read-only for now, so that a later write\n\n         * will pass through this function again to set the C bit */\n\n        prot &= ~PAGE_WRITE;\n\n    }\n\n\n\n    if (new_pte1 != pte.pte1) {\n\n        ppc_hash64_store_hpte(cpu, pte_offset / HASH_PTE_SIZE_64,\n\n                              pte.pte0, new_pte1);\n\n    }\n\n\n\n    /* 7. Determine the real address from the PTE */\n\n\n\n    raddr = deposit64(pte.pte1 & HPTE64_R_RPN, 0, slb->sps->page_shift, eaddr);\n\n\n\n    tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,\n\n                 prot, mmu_idx, TARGET_PAGE_SIZE);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2367, "prediction": "0", "true_label": "1", "raw_text": " 16 colors */\n\n        GetBitContext s;\n\n\n\n        for (y=0; y<h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n\n\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n\n\n    } else {    /* planar, 4, 8 or 16 colors */\n\n        int i;\n\n\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                int m = 0x80 >> (x&7), v = 0;\n\n                for (i=nplanes - 1; i>=0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n\n    } else if (bits_per_pixel * nplanes == 1) {\n\n        AV_WN32A(p->data[1]  , 0xFF000000);\n\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart+16;\n\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2368, "prediction": "1", "true_label": "1", "raw_text": "Question: QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2369, "prediction": "0", "true_label": "0", "raw_text": "Question: static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2370, "prediction": "0", "true_label": "0", "raw_text": "Question: static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n\n                               Jpeg2000Component *comp,\n\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n\n{\n\n    int i, j;\n\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n\n        int *src = t1->data[j];\n\n        if (band->i_stepsize == 16384) {\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = src[i] / 2;\n\n        } else {\n\n            // This should be VERY uncommon\n\n            for (i = 0; i < w; ++i)\n\n                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2371, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2372, "prediction": "0", "true_label": "0", "raw_text": " if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            mseq->conformance_window_flag = 1;\n\n            mseq->conf_win_left_offset   = 0;\n\n            mseq->conf_win_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            mseq->conf_win_top_offset    = 0;\n\n            mseq->conf_win_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            mseq->conformance_window_flag = 0;\n\n        }\n\n\n\n        mseq->num_short_term_ref_pic_sets = 0;\n\n        // STRPSs should ideally be here rather than repeated in each slice.\n\n\n\n        mseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            mseq->aspect_ratio_info_present_flag = 1;\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                mseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                mseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                mseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                mseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (1) {\n\n            // Should this be conditional on some of these being set?\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format = 5; // Unspecified.\n\n            mseq->video_full_range_flag = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            mseq->colour_primaries = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coeffs = avctx->colorspace;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2373, "prediction": "0", "true_label": "0", "raw_text": "_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n    /* i=0 is a special case because of packing, the DC term is real, so we\n\n       are going to throw the N/2 term (also real) in with it. */\n\n    ev.re = data[0];\n\n    data[0] = ev.re+data[1];\n\n    data[1] = ev.re-data[1];\n\n    for (i = 1; i < (n>>2); i++) {\n\n        i1 = 2*i;\n\n        i2 = n-i1;\n\n        /* Separate even and odd FFTs */\n\n        ev.re =  k1*(data[i1  ]+data[i2  ]);\n\n        od.im = -k2*(data[i1  ]-data[i2  ]);\n\n        ev.im =  k1*(data[i1+1]-data[i2+1]);\n\n        od.re =  k2*(data[i1+1]+data[i2+1]);\n\n        /* Apply twiddle factors to the odd FFT and add to the even FFT */\n\n        data[i1  ] =  ev.re + od.re*tcos[i] - od.im*tsin[i];\n\n        data[i1+1] =  ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n        data[i2  ] =  ev.re - od.re*tcos[i] + od.im*tsin[i];\n\n        data[i2+1] = -ev.im + od.im*tcos[i] + od.re*tsin[i];\n\n    }\n\n    data[2*i+1]=s->sign_convention*data[2*i+1];\n\n    if (s->inverse) {\n\n        data[0] *= k1;\n\n        data[1] *= k1;\n\n        s->fft.fft_permute(&s->fft, (FFTComplex*)data);\n\n        s->fft.fft_calc(&s->fft, (FFTComplex*)data);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2374, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int g726_init(AVCodecContext * avctx)\n\n{\n\n    AVG726Context* c = (AVG726Context*)avctx->priv_data;\n\n    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;\n\n\n\n    if (\n\n        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&\n\n         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"G726: unsupported audio format\\n\");\n\n        return -1;\n\n    }\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n    if(index>3){\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of bits %d\\n\", index+2);\n\n        return -1;\n\n    }\n\n    g726_reset(&c->c, index);\n\n    c->code_size = c->c.tbls->bits;\n\n    c->bit_buffer = 0;\n\n    c->bits_left = 0;\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2375, "prediction": "0", "true_label": "1", "raw_text": "Question: unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2376, "prediction": "0", "true_label": "1", "raw_text": "Question: void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2377, "prediction": "1", "true_label": "1", "raw_text": "Question: static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 2378, "prediction": "0", "true_label": "1", "raw_text": "Question: static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2379, "prediction": "0", "true_label": "1", "raw_text": ") == MO_SL) {\n\n            tcg_out_arithi(s, data, TCG_REG_O0, 0, SHIFT_SRA);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_REG, data, TCG_REG_O0);\n\n        }\n\n    } else {\n\n        if ((memop & MO_SIZE) == MO_64) {\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0, 32, SHIFT_SLLX);\n\n            tcg_out_arithi(s, TCG_REG_O1, TCG_REG_O1, 0, SHIFT_SRL);\n\n            tcg_out_arith(s, data, TCG_REG_O0, TCG_REG_O1, ARITH_OR);\n\n        } else if (is_64) {\n\n            /* Re-extend from 32-bit rather than reassembling when we\n\n               know the high register must be an extension.  */\n\n            tcg_out_arithi(s, data, TCG_REG_O1, 0,\n\n                           memop & MO_SIGN ? SHIFT_SRA : SHIFT_SRL);\n\n        } else {\n\n            tcg_out_mov(s, TCG_TYPE_I32, data, TCG_REG_O1);\n\n        }\n\n    }\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2380, "prediction": "1", "true_label": "1", "raw_text": "Question: opts_visitor_cleanup(OptsVisitor *ov)\n\n{\n\n    if (ov->unprocessed_opts != NULL) {\n\n        g_hash_table_destroy(ov->unprocessed_opts);\n\n    }\n\n    g_free(ov->fake_id_opt);\n\n    memset(ov, '\\0', sizeof *ov);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2381, "prediction": "0", "true_label": "0", "raw_text": "Question: static int usb_host_open(USBHostDevice *s, libusb_device *dev)\n\n{\n\n    USBDevice *udev = USB_DEVICE(s);\n\n    int bus_num = libusb_get_bus_number(dev);\n\n    int addr    = libusb_get_device_address(dev);\n\n    int rc;\n\n\n\n    trace_usb_host_open_started(bus_num, addr);\n\n\n\n    if (s->dh != NULL) {\n\n        goto fail;\n\n    }\n\n    rc = libusb_open(dev, &s->dh);\n\n    if (rc != 0) {\n\n        goto fail;\n\n    }\n\n\n\n    s->dev     = dev;\n\n    s->bus_num = bus_num;\n\n    s->addr    = addr;\n\n\n\n    usb_host_detach_kernel(s);\n\n\n\n    libusb_get_device_descriptor(dev, &s->ddesc);\n\n    usb_host_get_port(s->dev, s->port, sizeof(s->port));\n\n\n\n    usb_ep_init(udev);\n\n    usb_host_ep_update(s);\n\n\n\n    udev->speed     = speed_map[libusb_get_device_speed(dev)];\n\n    usb_host_speed_compat(s);\n\n\n\n    if (s->ddesc.iProduct) {\n\n        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,\n\n                                           (unsigned char *)udev->product_desc,\n\n                                           sizeof(udev->product_desc));\n\n    } else {\n\n        snprintf(udev->product_desc, sizeof(udev->product_desc),\n\n                 \"host:%d.%d\", bus_num, addr);\n\n    }\n\n\n\n    rc = usb_device_attach(udev);\n\n    if (rc) {\n\n        goto fail;\n\n    }\n\n\n\n    trace_usb_host_open_success(bus_num, addr);\n\n    return 0;\n\n\n\nfail:\n\n    trace_usb_host_open_failure(bus_num, addr);\n\n    if (s->dh != NULL) {\n\n        libusb_close(s->dh);\n\n        s->dh = NULL;\n\n        s->dev = NULL;\n\n    }\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2382, "prediction": "0", "true_label": "0", "raw_text": "Question: int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2383, "prediction": "0", "true_label": "0", "raw_text": "[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2384, "prediction": "0", "true_label": "0", "raw_text": "Question: static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2385, "prediction": "0", "true_label": "1", "raw_text": "Question: static int dynticks_start_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct sigevent ev;\n\n    timer_t host_timer;\n\n    struct sigaction act;\n\n\n\n    sigfillset(&act.sa_mask);\n\n    act.sa_flags = 0;\n\n    act.sa_handler = host_alarm_handler;\n\n\n\n    sigaction(SIGALRM, &act, NULL);\n\n\n\n\n\n\n\n\n    ev.sigev_value.sival_int = 0;\n\n    ev.sigev_notify = SIGEV_SIGNAL;\n\n    ev.sigev_signo = SIGALRM;\n\n\n\n    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {\n\n        perror(\"timer_create\");\n\n\n\n        /* disable dynticks */\n\n        fprintf(stderr, \"Dynamic Ticks disabled\\n\");\n\n\n\n        return -1;\n\n    }\n\n\n\n    t->priv = (void *)(long)host_timer;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2386, "prediction": "0", "true_label": "1", "raw_text": "Question: static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,\n\n                                    uint32_t fid, uint64_t faddr, uint32_t e)\n\n{\n\n    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(\n\n        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));\n\n\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    sei_cont->fh = fh;\n\n    sei_cont->fid = fid;\n\n    sei_cont->cc = cc;\n\n    sei_cont->pec = pec;\n\n    sei_cont->faddr = faddr;\n\n    sei_cont->e = e;\n\n\n\n    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);\n\n    css_generate_css_crws(0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2387, "prediction": "0", "true_label": "1", "raw_text": " {\n\n            /* Check to see if we are allowed to change the masking of FIQ\n\n             * exceptions from a non-secure state.\n\n             */\n\n            if (!(env->cp15.scr_el3 & SCR_FW)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to switch CPSR_F flag from \"\n\n                              \"non-secure world with SCR.FW bit clear\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n\n\n            /* Check whether non-maskable FIQ (NMFI) support is enabled.\n\n             * If this bit is set software is not allowed to mask\n\n             * FIQs, but is allowed to set CPSR_F to 0.\n\n             */\n\n            if ((A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_NMFI) &&\n\n                (val & CPSR_F)) {\n\n                qemu_log_mask(LOG_GUEST_ERROR,\n\n                              \"Ignoring attempt to enable CPSR_F flag \"\n\n                              \"(non-maskable FIQ [NMFI] support enabled)\\n\");\n\n                mask &= ~CPSR_F;\n\n            }\n\n        }\n\n    }\n\n\n\n    env->daif &= ~(CPSR_AIF & mask);\n\n    env->daif |= val & CPSR_AIF & mask;\n\n\n\n    if (write_type != CPSRWriteRaw &&\n\n        (env->uncached_cpsr & CPSR_M) != CPSR_USER &&\n\n        ((env->uncached_cpsr ^ val) & mask & CPSR_M)) {\n\n        if (bad_mode_switch(env, val & CPSR_M)) {\n\n            /* Attempt to switch to an invalid mode: this is UNPREDICTABLE.\n\n             * We choose to ignore the attempt and leave the CPSR M field\n\n             * untouched.\n\n             */\n\n            mask &= ~CPSR_M;\n\n        } else {\n\n            switch_mode(env, val & CPSR_M);\n\n        }\n\n    }\n\n    mask &= ~CACHED_CPSR_BITS;\n\n    env->uncached_cpsr = (env->uncached_cpsr & ~mask) | (val & mask);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2388, "prediction": "0", "true_label": "1", "raw_text": "irk = g_malloc0(sizeof(*quirk));\n\n    mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n    quirk->nr_mem = 1;\n\n    mirror->vdev = vdev;\n\n    mirror->offset = 0x88000;\n\n    mirror->bar = nr;\n\n\n\n    memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                          &vfio_nvidia_mirror_quirk, mirror,\n\n                          \"vfio-nvidia-bar0-88000-mirror-quirk\",\n\n                          PCIE_CONFIG_SPACE_SIZE);\n\n    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                        mirror->offset, mirror->mem, 1);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n\n\n    /* The 0x1800 offset mirror only seems to get used by legacy VGA */\n\n    if (vdev->has_vga) {\n\n        quirk = g_malloc0(sizeof(*quirk));\n\n        mirror = quirk->data = g_malloc0(sizeof(*mirror));\n\n        mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));\n\n        quirk->nr_mem = 1;\n\n        mirror->vdev = vdev;\n\n        mirror->offset = 0x1800;\n\n        mirror->bar = nr;\n\n\n\n        memory_region_init_io(mirror->mem, OBJECT(vdev),\n\n                              &vfio_nvidia_mirror_quirk, mirror,\n\n                              \"vfio-nvidia-bar0-1800-mirror-quirk\",\n\n                              PCI_CONFIG_SPACE_SIZE);\n\n        memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,\n\n                                            mirror->offset, mirror->mem, 1);\n\n\n\n        QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);\n\n    }\n\n\n\n    trace_vfio_quirk_nvidia_bar0_probe(vdev->vbasedev.name);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2389, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2390, "prediction": "0", "true_label": "1", "raw_text": "\n\n            if(h->delayed_pic[i]->poc < out->poc){\n\n                out = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        out_of_order = !cross_idr && prev && out->poc < prev->poc;\n\n        if(prev && pics <= s->avctx->has_b_frames)\n\n            out = prev;\n\n        else if((out_of_order && pics-1 == s->avctx->has_b_frames)\n\n           || (s->low_delay && \n\n            ((!cross_idr && prev && out->poc > prev->poc + 2)\n\n             || cur->pict_type == B_TYPE)))\n\n        {\n\n            s->low_delay = 0;\n\n            s->avctx->has_b_frames++;\n\n            out = prev;\n\n        }\n\n        else if(out_of_order)\n\n            out = prev;\n\n\n\n        if(out_of_order || pics > s->avctx->has_b_frames){\n\n            dropped_frame = (out != h->delayed_pic[out_idx]);\n\n            for(i=out_idx; h->delayed_pic[i]; i++)\n\n                h->delayed_pic[i] = h->delayed_pic[i+1];\n\n        }\n\n\n\n        if(prev == out && !dropped_frame)\n\n            *data_size = 0;\n\n        else\n\n            *data_size = sizeof(AVFrame);\n\n        if(prev && prev != out && prev->reference == 1)\n\n            prev->reference = 0;\n\n        h->delayed_output_pic = out;\n\n#endif\n\n\n\n        *pict= *(AVFrame*)out;\n\n    }\n\n\n\n    assert(pict->data[0]);\n\n    ff_print_debug_info(s, pict);\n\n//printf(\"out %d\\n\", (int)pict->data[0]);\n\n#if 0 //?\n\n\n\n    /* Return the Picture timestamp as the frame number */\n\n    /* we substract 1 because it is added on utils.c    */\n\n    avctx->frame_number = s->picture_number - 1;\n\n#endif\n\n    return get_consumed_bytes(s, buf_index, buf_size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2391, "prediction": "0", "true_label": "0", "raw_text": "Question: static void cpu_common_reset(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", cpu->cpu_index);\n\n        log_cpu_state(cpu, cc->reset_dump_flags);\n\n    }\n\n\n\n    cpu->interrupt_request = 0;\n\n    cpu->halted = 0;\n\n    cpu->mem_io_pc = 0;\n\n    cpu->mem_io_vaddr = 0;\n\n    cpu->icount_extra = 0;\n\n    cpu->icount_decr.u32 = 0;\n\n    cpu->can_do_io = 1;\n\n    cpu->exception_index = -1;\n\n    cpu->crash_occurred = false;\n\n\n\n    if (tcg_enabled()) {\n\n        cpu_tb_jmp_cache_clear(cpu);\n\n\n\n#ifdef CONFIG_SOFTMMU\n\n        tlb_flush(cpu, 0);\n\n#endif\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2392, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2393, "prediction": "0", "true_label": "0", "raw_text": "Question: static void subpage_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t value, unsigned len)\n\n{\n\n    subpage_t *mmio = opaque;\n\n    unsigned int idx = SUBPAGE_IDX(addr);\n\n    MemoryRegionSection *section;\n\n#if defined(DEBUG_SUBPAGE)\n\n    printf(\"%s: subpage %p len %d addr \" TARGET_FMT_plx\n\n           \" idx %d value %\"PRIx64\"\\n\",\n\n           __func__, mmio, len, addr, idx, value);\n\n#endif\n\n\n\n    section = &phys_sections[mmio->sub_section[idx]];\n\n    addr += mmio->base;\n\n    addr -= section->offset_within_address_space;\n\n    addr += section->offset_within_region;\n\n    io_mem_write(section->mr, addr, value, len);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2394, "prediction": "0", "true_label": "0", "raw_text": "Question: static int nvenc_find_free_reg_resource(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;\n\n    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;\n\n\n\n    int i;\n\n\n\n    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {\n\n        for (i = 0; i < ctx->nb_registered_frames; i++) {\n\n            if (!ctx->registered_frames[i].mapped) {\n\n                if (ctx->registered_frames[i].regptr) {\n\n                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,\n\n                                                ctx->registered_frames[i].regptr);\n\n                    ctx->registered_frames[i].regptr = NULL;\n\n                }\n\n                return i;\n\n            }\n\n        }\n\n    } else {\n\n        return ctx->nb_registered_frames++;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR, \"Too many registered CUDA frames\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2395, "prediction": "0", "true_label": "1", "raw_text": "Question: void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)\n\n{\n\n    unsigned int i;\n\n\n\n    /* Discard jump cache entries for any tb which might potentially\n\n       overlap the flushed page.  */\n\n    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n\n\n    i = tb_jmp_cache_hash_page(addr);\n\n    memset(&cpu->tb_jmp_cache[i], 0,\n\n           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2396, "prediction": "1", "true_label": "0", "raw_text": "Question: DeviceState *bdrv_get_attached(BlockDriverState *bs)\n\n{\n\n    return bs->peer;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2397, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)\n\n{\n\n    StackEntry *e = g_malloc0(sizeof(*e));\n\n\n\n    e->value = value;\n\n\n\n    /* see if we're just pushing a list head tracker */\n\n    if (value == NULL) {\n\n        e->is_list_head = true;\n\n    }\n\n    QTAILQ_INSERT_HEAD(&qov->stack, e, node);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2398, "prediction": "0", "true_label": "0", "raw_text": "Question: void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)\n\n{\n\n    void *p;\n\n\n\n    size *= items;\n\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n\n\n    p = qemu_mallocz(size);\n\n\n\n    return (p);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2399, "prediction": "0", "true_label": "0", "raw_text": ") *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2400, "prediction": "0", "true_label": "0", "raw_text": "Question: void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,\n\n                            FWCfgState *fw_cfg, Object *owner)\n\n{\n\n    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,\n\n                          \"nvdimm-acpi-io\", NVDIMM_ACPI_IO_LEN);\n\n    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);\n\n\n\n    state->dsm_mem = g_array_new(false, true /* clear */, 1);\n\n    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);\n\n    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,\n\n                    state->dsm_mem->len);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2401, "prediction": "0", "true_label": "0", "raw_text": "_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* encryption */\n\n    if (s->crypto_header.length) {\n\n        ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                            s->crypto_header.offset,\n\n                            s->crypto_header.length);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2402, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)\n\n{\n\n    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,\n\n                       get_field(qtd->token, QTD_TOKEN_TBYTES),\n\n                       get_field(qtd->token, QTD_TOKEN_CPAGE),\n\n                       get_field(qtd->token, QTD_TOKEN_CERR),\n\n                       get_field(qtd->token, QTD_TOKEN_PID),\n\n                       (bool)(qtd->token & QTD_TOKEN_IOC),\n\n                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),\n\n                       (bool)(qtd->token & QTD_TOKEN_HALT),\n\n                       (bool)(qtd->token & QTD_TOKEN_BABBLE),\n\n                       (bool)(qtd->token & QTD_TOKEN_XACTERR));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2403, "prediction": "0", "true_label": "1", "raw_text": "Question: static void megasas_scsi_uninit(PCIDevice *d)\n\n{\n\n    MegasasState *s = MEGASAS(d);\n\n\n\n    if (megasas_use_msix(s)) {\n\n        msix_uninit(d, &s->mmio_io, &s->mmio_io);\n\n    }\n\n    if (megasas_use_msi(s)) {\n\n        msi_uninit(d);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2404, "prediction": "0", "true_label": "0", "raw_text": " to skip\n\n    s->reduction_factor = s->lowres;\n\n\n\n    ff_jpeg2000_init_tier1_luts();\n\n\n\n    if (s->buf_end - s->buf < 2)\n\n        return AVERROR(EINVAL);\n\n\n\n    // check if the image is in jp2 format\n\n    if ((AV_RB32(s->buf) == 12) &&\n\n        (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&\n\n        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {\n\n        if (!jp2_find_codestream(s)) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"couldn't find jpeg2k codestream atom\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (bytestream_get_be16(&s->buf) != JPEG2000_SOC) {\n\n        av_log(avctx, AV_LOG_ERROR, \"SOC marker not present\\n\");\n\n        return -1;\n\n    }\n\n    if (ret = jpeg2000_read_main_headers(s))\n\n        goto end;\n\n\n\n    /* get picture buffer */\n\n    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"ff_thread_get_buffer() failed.\\n\");\n\n        goto end;\n\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n\n    picture->key_frame = 1;\n\n\n\n    if (ret = jpeg2000_read_bitstream_packets(s))\n\n        goto end;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++)\n\n        if (ret = jpeg2000_decode_tile(s, s->tile + tileno, picture))\n\n            goto end;\n\n\n\n    *got_frame = 1;\n\n\n\nend:\n\n    jpeg2000_dec_cleanup(s);\n\n    return ret ? ret : s->buf - s->buf_start;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2405, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2406, "prediction": "0", "true_label": "0", "raw_text": "Question: static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2407, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2408, "prediction": "0", "true_label": "0", "raw_text": "_K)) {\n\n            uint32_t addr;\n\n            /* Cancel pending packets for ED that have been paused.  */\n\n            addr = ed.head & OHCI_DPTR_MASK;\n\n            if (ohci->async_td && addr == ohci->async_td) {\n\n                usb_cancel_packet(&ohci->usb_packet);\n\n                ohci->async_td = 0;\n\n                usb_device_ep_stopped(ohci->usb_packet.ep->dev,\n\n                                      ohci->usb_packet.ep);\n\n            }\n\n            continue;\n\n        }\n\n\n\n        while ((ed.head & OHCI_DPTR_MASK) != ed.tail) {\n\n            trace_usb_ohci_ed_pkt(cur, (ed.head & OHCI_ED_H) != 0,\n\n                    (ed.head & OHCI_ED_C) != 0, ed.head & OHCI_DPTR_MASK,\n\n                    ed.tail & OHCI_DPTR_MASK, ed.next & OHCI_DPTR_MASK);\n\n            trace_usb_ohci_ed_pkt_flags(\n\n                    OHCI_BM(ed.flags, ED_FA), OHCI_BM(ed.flags, ED_EN),\n\n                    OHCI_BM(ed.flags, ED_D), (ed.flags & OHCI_ED_S)!= 0,\n\n                    (ed.flags & OHCI_ED_K) != 0, (ed.flags & OHCI_ED_F) != 0,\n\n                    OHCI_BM(ed.flags, ED_MPS));\n\n\n\n            active = 1;\n\n\n\n            if ((ed.flags & OHCI_ED_F) == 0) {\n\n                if (ohci_service_td(ohci, &ed))\n\n                    break;\n\n            } else {\n\n                /* Handle isochronous endpoints */\n\n                if (ohci_service_iso_td(ohci, &ed, completion))\n\n                    break;\n\n            }\n\n        }\n\n\n\n        if (ohci_put_ed(ohci, cur, &ed)) {\n\n            ohci_die(ohci);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return active;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2409, "prediction": "0", "true_label": "0", "raw_text": "Question: void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2410, "prediction": "0", "true_label": "0", "raw_text": "Question: int ffurl_connect(URLContext *uc, AVDictionary **options)\n\n{\n\n    int err =\n\n        uc->prot->url_open2 ? uc->prot->url_open2(uc,\n\n                                                  uc->filename,\n\n                                                  uc->flags,\n\n                                                  options) :\n\n        uc->prot->url_open(uc, uc->filename, uc->flags);\n\n    if (err)\n\n        return err;\n\n    uc->is_connected = 1;\n\n    /* We must be careful here as ffurl_seek() could be slow,\n\n     * for example for http */\n\n    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, \"file\"))\n\n        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)\n\n            uc->is_streamed = 1;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2411, "prediction": "0", "true_label": "0", "raw_text": ");\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2412, "prediction": "0", "true_label": "0", "raw_text": "Question: static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2413, "prediction": "0", "true_label": "0", "raw_text": "Question: void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2414, "prediction": "0", "true_label": "1", "raw_text": " }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2415, "prediction": "0", "true_label": "1", "raw_text": "pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2416, "prediction": "0", "true_label": "1", "raw_text": "Question: static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2417, "prediction": "0", "true_label": "1", "raw_text": "_SOD){\n\n            J2kTile *tile = s->tile + s->curtileno;\n\n            if (ret = init_tile(s, s->curtileno))\n\n                return ret;\n\n            if (ret = decode_packets(s, tile))\n\n                return ret;\n\n            continue;\n\n        }\n\n        if (marker == J2K_EOC)\n\n            break;\n\n\n\n        if (s->buf_end - s->buf < 2)\n\n            return AVERROR(EINVAL);\n\n        len = bytestream_get_be16(&s->buf);\n\n        switch(marker){\n\n            case J2K_SIZ:\n\n                ret = get_siz(s); break;\n\n            case J2K_COC:\n\n                ret = get_coc(s, codsty, properties); break;\n\n            case J2K_COD:\n\n                ret = get_cod(s, codsty, properties); break;\n\n            case J2K_QCC:\n\n                ret = get_qcc(s, len, qntsty, properties); break;\n\n            case J2K_QCD:\n\n                ret = get_qcd(s, len, qntsty, properties); break;\n\n            case J2K_SOT:\n\n                if (!(ret = get_sot(s))){\n\n                    codsty = s->tile[s->curtileno].codsty;\n\n                    qntsty = s->tile[s->curtileno].qntsty;\n\n                    properties = s->tile[s->curtileno].properties;\n\n                }\n\n                break;\n\n            case J2K_COM:\n\n                // the comment is ignored\n\n                s->buf += len - 2; break;\n\n            default:\n\n                av_log(s->avctx, AV_LOG_ERROR, \"unsupported marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->buf_start - 4);\n\n                s->buf += len - 2; break;\n\n        }\n\n        if (s->buf - oldbuf != len || ret){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"error during processing marker segment %.4x\\n\", marker);\n\n            return ret ? ret : -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2418, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int ass_decode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n\n    avctx->subtitle_header_size = avctx->extradata_size;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2419, "prediction": "0", "true_label": "1", "raw_text": " {\n\n        error_setg(errp, \"mount tag '%s' (%d bytes) is longer than \"\n\n                   \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        error_setg(errp, \"9pfs Failed to initialize fs-driver with id:%s\"\n\n                   \" and export path:%s\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        error_setg(errp,\n\n                   \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        error_setg(errp, \"share path %s does not exist\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        error_setg(errp, \"share path %s is not a directory\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    rc = 0;\n\nout:\n\n    if (rc) {\n\n        if (s->ops->cleanup && s->ctx.private) {\n\n            s->ops->cleanup(&s->ctx);\n\n        }\n\n        g_free(s->tag);\n\n        g_free(s->ctx.fs_root);\n\n        v9fs_path_free(&path);\n\n    }\n\n    return rc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2420, "prediction": "0", "true_label": "1", "raw_text": "->metadata, \"playback_time\", playback_time, 0);\n\n\n\n    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;\n\n    st->codecpar->codec_id    = s->iformat->raw_codec_id;\n\n    st->codecpar->sample_rate = avio_rb32(pb) / 8;\n\n    avio_skip(pb, 4);\n\n    st->codecpar->channels    = avio_r8(pb) & 0xF;\n\n    st->codecpar->bit_rate    = st->codecpar->channels * st->codecpar->sample_rate * 8LL;\n\n    if (!st->codecpar->channels)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    avio_skip(pb, 3);\n\n    channel_assign         = avio_rb32(pb);\n\n    if (!(channel_assign & 1)) {\n\n        int i;\n\n        for (i = 1; i < 32; i++)\n\n            if (channel_assign & (1 << i))\n\n                st->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s, i);\n\n    }\n\n\n\n    avio_skip(pb, 16);\n\n    if (avio_rb32(pb))\n\n       avpriv_request_sample(s, \"emphasis\");\n\n\n\n    if (avio_seek(pb, text_offset, SEEK_SET) >= 0) {\n\n        get_metadata(s, \"title\",       128);\n\n        get_metadata(s, \"composer\",    128);\n\n        get_metadata(s, \"song_writer\", 128);\n\n        get_metadata(s, \"artist\",      128);\n\n        get_metadata(s, \"album\",       128);\n\n        get_metadata(s, \"genre\",        32);\n\n        get_metadata(s, \"date\",         32);\n\n        get_metadata(s, \"location\",     32);\n\n        get_metadata(s, \"comment\",     512);\n\n        get_metadata(s, \"user\",        512);\n\n    }\n\n\n\n    return avio_seek(pb, data_offset, SEEK_SET);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2421, "prediction": "0", "true_label": "0", "raw_text": "i not supported ... aborting\\n\", image->bits_per_pixel);\n\n            av_log(s1, AV_LOG_ERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->red_mask, image->green_mask, image->blue_mask);\n\n            ret = AVERROR_PATCHWELCOME;\n\n            goto out;\n\n        }\n\n        break;\n\n    case 32:\n\n        input_pixfmt = AV_PIX_FMT_0RGB32;\n\n        break;\n\n    default:\n\n        av_log(s1, AV_LOG_ERROR, \"image depth %i not supported ... aborting\\n\", image->bits_per_pixel);\n\n        ret = AVERROR_PATCHWELCOME;\n\n        goto out;\n\n    }\n\n\n\n    x11grab->frame_size = x11grab->width * x11grab->height * image->bits_per_pixel/8;\n\n    x11grab->dpy = dpy;\n\n    x11grab->time_base  = av_inv_q(x11grab->framerate);\n\n    x11grab->time_frame = av_gettime() / av_q2d(x11grab->time_base);\n\n    x11grab->x_off = x_off;\n\n    x11grab->y_off = y_off;\n\n    x11grab->image = image;\n\n    x11grab->use_shm = use_shm;\n\n\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->width  = x11grab->width;\n\n    st->codec->height = x11grab->height;\n\n    st->codec->pix_fmt = input_pixfmt;\n\n    st->codec->time_base = x11grab->time_base;\n\n    st->codec->bit_rate = x11grab->frame_size * 1/av_q2d(x11grab->time_base) * 8;\n\n\n\nout:\n\n    av_free(dpyname);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2422, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 16; i++)\n\n        if (simple_limit(dst+i*stride, 1, flim))\n\n            filter_common(dst+i*stride, 1, 1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2423, "prediction": "1", "true_label": "1", "raw_text": "Question: void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES.\n"}], [{"ID": 2424, "prediction": "0", "true_label": "1", "raw_text": "Question: static void main_loop(void)\n\n{\n\n    bool nonblocking;\n\n    int last_io __attribute__ ((unused)) = 0;\n\n#ifdef CONFIG_PROFILER\n\n    int64_t ti;\n\n#endif\n\n    int r;\n\n\n\n    qemu_main_loop_start();\n\n\n\n    for (;;) {\n\n#ifdef CONFIG_IOTHREAD\n\n        nonblocking = !kvm_enabled() && last_io > 0;\n\n#else\n\n        nonblocking = cpu_exec_all();\n\n        if (vm_request_pending()) {\n\n            nonblocking = true;\n\n        }\n\n#endif\n\n#ifdef CONFIG_PROFILER\n\n        ti = profile_getclock();\n\n#endif\n\n        last_io = main_loop_wait(nonblocking);\n\n#ifdef CONFIG_PROFILER\n\n        dev_time += profile_getclock() - ti;\n\n#endif\n\n\n\n        if (qemu_debug_requested()) {\n\n            vm_stop(VMSTOP_DEBUG);\n\n        }\n\n        if (qemu_shutdown_requested()) {\n\n            qemu_kill_report();\n\n            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);\n\n            if (no_shutdown) {\n\n                vm_stop(VMSTOP_SHUTDOWN);\n\n            } else\n\n                break;\n\n        }\n\n        if (qemu_reset_requested()) {\n\n            pause_all_vcpus();\n\n            cpu_synchronize_all_states();\n\n            qemu_system_reset(VMRESET_REPORT);\n\n            resume_all_vcpus();\n\n        }\n\n        if (qemu_powerdown_requested()) {\n\n            monitor_protocol_event(QEVENT_POWERDOWN, NULL);\n\n            qemu_irq_raise(qemu_system_powerdown);\n\n        }\n\n        if ((r = qemu_vmstop_requested())) {\n\n            vm_stop(r);\n\n        }\n\n    }\n\n    bdrv_close_all();\n\n    pause_all_vcpus();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2425, "prediction": "1", "true_label": "0", "raw_text": "xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    } else {\n\n        static const char nak_msg[] = \"requested address not available\";\n\n\n\n        dprintf(\"nak'ed addr=%08x\\n\", ntohl(preq_addr->s_addr));\n\n\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPNAK;\n\n\n\n        *q++ = RFC2132_MESSAGE;\n\n        *q++ = sizeof(nak_msg) - 1;\n\n        memcpy(q, nak_msg, sizeof(nak_msg) - 1);\n\n        q += sizeof(nak_msg) - 1;\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2426, "prediction": "0", "true_label": "0", "raw_text": "Question: static void print_features(FILE *f,\n\n                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                           uint32_t features, const char *prefix)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < ARRAY_SIZE(feature_name); i++)\n\n        if (feature_name[i] && (features & (1 << i))) {\n\n            if (prefix)\n\n                (*cpu_fprintf)(f, \"%s\", prefix);\n\n            (*cpu_fprintf)(f, \"%s \", feature_name[i]);\n\n        }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2427, "prediction": "0", "true_label": "0", "raw_text": "ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2428, "prediction": "0", "true_label": "1", "raw_text": "Question: static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2429, "prediction": "1", "true_label": "1", "raw_text": "Question: static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 2430, "prediction": "0", "true_label": "1", "raw_text": "Question: bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2431, "prediction": "0", "true_label": "0", "raw_text": " 1] << 11;\n\n\n\n                A1 += 1 << 13;\n\n                A2 += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y1, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y1, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y1, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A1      , 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[6], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                output_pixel(&dest[7], av_clip_uintp2(A2      , 30) >> 14);\n\n                dest += 8;\n\n            } else {\n\n                output_pixel(&dest[3], av_clip_uintp2(R_B + Y2, 30) >> 14);\n\n                output_pixel(&dest[4], av_clip_uintp2(  G + Y2, 30) >> 14);\n\n                output_pixel(&dest[5], av_clip_uintp2(B_R + Y2, 30) >> 14);\n\n                dest += 6;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2432, "prediction": "0", "true_label": "1", "raw_text": "Question: void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2433, "prediction": "0", "true_label": "0", "raw_text": "_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);\n\n        hz_out7 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);\n\n        hz_out8 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst1 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst3 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n        out0 = PCKEV_XORI128_UB(dst0, dst1);\n\n        out1 = PCKEV_XORI128_UB(dst2, dst3);\n\n        ST8x4_UB(out0, out1, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out3 = hz_out7;\n\n        hz_out1 = hz_out5;\n\n        hz_out5 = hz_out4;\n\n        hz_out4 = hz_out8;\n\n        hz_out2 = hz_out6;\n\n        hz_out0 = hz_out5;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2434, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int pam_encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2435, "prediction": "1", "true_label": "0", "raw_text": "Question: static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)\n\n{\n\n    OggVorbisContext *context = avccontext->priv_data;\n\n    double cfreq;\n\n\n\n    if (avccontext->flags & CODEC_FLAG_QSCALE) {\n\n        /* variable bitrate */\n\n        if (vorbis_encode_setup_vbr(vi, avccontext->channels,\n\n                                    avccontext->sample_rate,\n\n                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))\n\n            return -1;\n\n    } else {\n\n        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;\n\n        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;\n\n\n\n        /* constant bitrate */\n\n        if (vorbis_encode_setup_managed(vi, avccontext->channels,\n\n                                        avccontext->sample_rate, minrate,\n\n                                        avccontext->bit_rate, maxrate))\n\n            return -1;\n\n\n\n        /* variable bitrate by estimate, disable slow rate management */\n\n        if (minrate == -1 && maxrate == -1)\n\n            if (vorbis_encode_ctl(vi, OV_ECTL_RATEMANAGE2_SET, NULL))\n\n                return -1;\n\n    }\n\n\n\n    /* cutoff frequency */\n\n    if (avccontext->cutoff > 0) {\n\n        cfreq = avccontext->cutoff / 1000.0;\n\n        if (vorbis_encode_ctl(vi, OV_ECTL_LOWPASS_SET, &cfreq))\n\n            return -1;\n\n    }\n\n\n\n    if (context->iblock) {\n\n        vorbis_encode_ctl(vi, OV_ECTL_IBLOCK_SET, &context->iblock);\n\n    }\n\n\n\n    return vorbis_encode_setup_init(vi);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2436, "prediction": "0", "true_label": "1", "raw_text": "Question: static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                        const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    NellyMoserEncodeContext *s = avctx->priv_data;\n\n    int ret;\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n\n\n    memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));\n\n    if (frame) {\n\n        memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],\n\n               frame->nb_samples * sizeof(*s->buf));\n\n        if (frame->nb_samples < NELLY_SAMPLES) {\n\n            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,\n\n                   (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));\n\n            if (frame->nb_samples >= NELLY_BUF_LEN)\n\n                s->last_frame = 1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame) < 0))\n\n            return ret;\n\n    } else {\n\n        memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));\n\n        s->last_frame = 1;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n    encode_block(s, avpkt->data, avpkt->size);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2437, "prediction": "0", "true_label": "1", "raw_text": " buf + 4*128, swindow,      bias, 64);\n\n            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n\n        } else {\n\n            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n\n            for (i = 576; i < 1024; i++)\n\n                out[i] = buf[i-512] + bias;\n\n        }\n\n    }\n\n\n\n    // buffer update\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        for (i = 0; i < 64; i++)\n\n            saved[i] = temp[64 + i] - bias;\n\n        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n\n        memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else { // LONG_STOP or ONLY_LONG\n\n        memcpy(                    saved,       buf + 512,        512 * sizeof(float));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2438, "prediction": "0", "true_label": "0", "raw_text": "_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;\n\n\n\n    c->clear_blocks = clear_blocks_axp;\n\n    }\n\n\n\n    /* amask clears all bits that correspond to present features.  */\n\n    if (amask(AMASK_MVI) == 0) {\n\n        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;\n\n        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;\n\n\n\n        if (!high_bit_depth)\n\n            c->get_pixels   = get_pixels_mvi;\n\n        c->diff_pixels      = diff_pixels_mvi;\n\n        c->sad[0]           = pix_abs16x16_mvi_asm;\n\n        c->sad[1]           = pix_abs8x8_mvi;\n\n        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;\n\n        c->pix_abs[1][0]    = pix_abs8x8_mvi;\n\n        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;\n\n        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;\n\n        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;\n\n    }\n\n\n\n    put_pixels_clamped_axp_p = c->put_pixels_clamped;\n\n    add_pixels_clamped_axp_p = c->add_pixels_clamped;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {\n\n        c->idct_put = ff_simple_idct_put_axp;\n\n        c->idct_add = ff_simple_idct_add_axp;\n\n        c->idct =     ff_simple_idct_axp;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2439, "prediction": "0", "true_label": "0", "raw_text": "Question: static char *check_nan_suffix(char *s)\n\n{\n\n    char *start = s;\n\n\n\n    if (*s++ != '(')\n\n        return start;\n\n\n\n    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||\n\n           (*s >= '0' && *s <= '9') ||  *s == '_')\n\n        s++;\n\n\n\n    return *s == ')' ? s + 1 : start;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2440, "prediction": "0", "true_label": "1", "raw_text": "Question: static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){\n\n    long i;\n\n#if !HAVE_FAST_UNALIGNED\n\n    if((long)src2 & (sizeof(long)-1)){\n\n        for(i=0; i+7<w; i+=8){\n\n            dst[i+0] = src1[i+0]-src2[i+0];\n\n            dst[i+1] = src1[i+1]-src2[i+1];\n\n            dst[i+2] = src1[i+2]-src2[i+2];\n\n            dst[i+3] = src1[i+3]-src2[i+3];\n\n            dst[i+4] = src1[i+4]-src2[i+4];\n\n            dst[i+5] = src1[i+5]-src2[i+5];\n\n            dst[i+6] = src1[i+6]-src2[i+6];\n\n            dst[i+7] = src1[i+7]-src2[i+7];\n\n        }\n\n    }else\n\n#endif\n\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n\n        long a = *(long*)(src1+i);\n\n        long b = *(long*)(src2+i);\n\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n\n    }\n\n    for(; i<w; i++)\n\n        dst[i+0] = src1[i+0]-src2[i+0];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2441, "prediction": "0", "true_label": "0", "raw_text": " 10 bit, ignore alpha\n\n                if (elements == 4)\n\n                    read10in32(&buf, &rgbBuffer,\n\n                               &n_datum, endian);\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 12:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2] = *((uint16_t*)buf);\n\n                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);\n\n                dst[2]++;\n\n                buf += 2;\n\n                *dst[0] = *((uint16_t*)buf);\n\n                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);\n\n                dst[0]++;\n\n                buf += 2;\n\n                *dst[1] = *((uint16_t*)buf);\n\n                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);\n\n                dst[1]++;\n\n                buf += 2;\n\n                // For 12 bit, ignore alpha\n\n                if (elements == 4)\n\n                    buf += 2;\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 16:\n\n        elements *= 2;\n\n    case 8:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            memcpy(ptr[0], buf, elements*avctx->width);\n\n            ptr[0] += p->linesize[0];\n\n            buf += elements*avctx->width;\n\n        }\n\n        break;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2442, "prediction": "0", "true_label": "1", "raw_text": "0:\n\n    case JALR16 + 1:\n\n        opc = OPC_JALR;\n\n        goto do_jalr;\n\n    case JALR16S + 0:\n\n    case JALR16S + 1:\n\n        opc = OPC_JALRS;\n\n    do_jalr:\n\n        {\n\n            int reg = ctx->opcode & 0x1f;\n\n\n\n            gen_compute_branch(ctx, opc, 2, reg, 31, 0);\n\n        }\n\n        *is_branch = 1;\n\n        break;\n\n    case MFHI16 + 0:\n\n    case MFHI16 + 1:\n\n        gen_HILO(ctx, OPC_MFHI, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case MFLO16 + 0:\n\n    case MFLO16 + 1:\n\n        gen_HILO(ctx, OPC_MFLO, 0, uMIPS_RS5(ctx->opcode));\n\n        break;\n\n    case BREAK16:\n\n        generate_exception(ctx, EXCP_BREAK);\n\n        break;\n\n    case SDBBP16:\n\n        /* XXX: not clear which exception should be raised\n\n         *      when in debug mode...\n\n         */\n\n        check_insn(ctx, ISA_MIPS32);\n\n        if (!(ctx->hflags & MIPS_HFLAG_DM)) {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        } else {\n\n            generate_exception(ctx, EXCP_DBp);\n\n        }\n\n        break;\n\n    case JRADDIUSP + 0:\n\n    case JRADDIUSP + 1:\n\n        {\n\n            int imm = ZIMM(ctx->opcode, 0, 5);\n\n\n\n            gen_compute_branch(ctx, OPC_JR, 2, 31, 0, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, 29, 29, imm << 2);\n\n            /* Let normal delay slot handling in our caller take us\n\n               to the branch target.  */\n\n        }\n\n        break;\n\n    default:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2443, "prediction": "0", "true_label": "1", "raw_text": "Question: int ff_filter_frame(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    int (*filter_frame)(AVFilterLink *, AVFrame *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    AVFrame *out;\n\n\n\n    FF_DPRINTF_START(NULL, filter_frame);\n\n    ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_frame = dst->filter_frame))\n\n        filter_frame = default_filter_frame;\n\n\n\n    /* copy the frame if needed */\n\n    if (dst->needs_writable && !av_frame_is_writable(frame)) {\n\n        av_log(link->dst, AV_LOG_DEBUG, \"Copying data in avfilter.\\n\");\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            out = ff_get_video_buffer(link, link->w, link->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            out = ff_get_audio_buffer(link, frame->nb_samples);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        av_frame_copy_props(out, frame);\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,\n\n                          frame->format, frame->width, frame->height);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            av_samples_copy(out->extended_data, frame->extended_data,\n\n                            0, 0, frame->nb_samples,\n\n                            av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                            frame->format);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n\n\n        av_frame_free(&frame);\n\n    } else\n\n        out = frame;\n\n\n\n    return filter_frame(link, out);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2444, "prediction": "0", "true_label": "1", "raw_text": "Question: static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,\n\n                            const void *data,\n\n                            size_t len) {\n\n    VncState *vs = (VncState *)transport;\n\n    int ret;\n\n\n\n retry:\n\n    ret = send(vs->csock, data, len, 0);\n\n    if (ret < 0) {\n\n        if (errno == EINTR)\n\n            goto retry;\n\n        return -1;\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2445, "prediction": "0", "true_label": "1", "raw_text": "Question: static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2446, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,\n\n                            int mb_x, int mb_y, uint8_t *img_y,\n\n                            uint8_t *img_cb, uint8_t *img_cr,\n\n                            unsigned int linesize, unsigned int uvlinesize)\n\n{\n\n    assert(!FRAME_MBAFF(h));\n\n    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {\n\n        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);\n\n        return;\n\n    }\n\n\n\n#if CONFIG_SMALL\n\n    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);\n\n#else\n\n    if(h->pixel_shift){\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);\n\n    }else{\n\n        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2447, "prediction": "1", "true_label": "0", "raw_text": "Question: void qmp_eject(const char *device, bool has_force, bool force, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int rc;\n\n\n\n    if (!has_force) {\n\n        force = false;\n\n    }\n\n\n\n    rc = do_open_tray(device, force, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    if (rc == EINPROGRESS) {\n\n        error_setg(errp, \"Device '%s' is locked and force was not specified, \"\n\n                   \"wait for tray to open and try again\", device);\n\n        return;\n\n    }\n\n\n\n    qmp_x_blockdev_remove_medium(device, errp);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2448, "prediction": "1", "true_label": "0", "raw_text": "Question: int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2449, "prediction": "0", "true_label": "1", "raw_text": " out;\n\n        }\n\n        buf_len = (extent->cluster_sectors << 9) * 2;\n\n        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));\n\n\n\n        compressed_data = g_malloc(n_bytes);\n\n        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);\n\n        ret = compress(data->data, &buf_len, compressed_data, n_bytes);\n\n        g_free(compressed_data);\n\n\n\n        if (ret != Z_OK || buf_len == 0) {\n\n            ret = -EINVAL;\n\n            goto out;\n\n        }\n\n\n\n        data->lba = offset >> BDRV_SECTOR_BITS;\n\n        data->size = buf_len;\n\n\n\n        n_bytes = buf_len + sizeof(VmdkGrainMarker);\n\n        iov = (struct iovec) {\n\n            .iov_base   = data,\n\n            .iov_len    = n_bytes,\n\n        };\n\n        qemu_iovec_init_external(&local_qiov, &iov, 1);\n\n    } else {\n\n        qemu_iovec_init(&local_qiov, qiov->niov);\n\n        qemu_iovec_concat(&local_qiov, qiov, qiov_offset, n_bytes);\n\n    }\n\n\n\n    write_offset = cluster_offset + offset_in_cluster,\n\n    ret = bdrv_co_pwritev(extent->file, write_offset, n_bytes,\n\n                          &local_qiov, 0);\n\n\n\n    write_end_sector = DIV_ROUND_UP(write_offset + n_bytes, BDRV_SECTOR_SIZE);\n\n\n\n    if (extent->compressed) {\n\n        extent->next_cluster_sector = write_end_sector;\n\n    } else {\n\n        extent->next_cluster_sector = MAX(extent->next_cluster_sector,\n\n                                          write_end_sector);\n\n    }\n\n\n\n    if (ret < 0) {\n\n        goto out;\n\n    }\n\n    ret = 0;\n\n out:\n\n    g_free(data);\n\n    if (!extent->compressed) {\n\n        qemu_iovec_destroy(&local_qiov);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2450, "prediction": "0", "true_label": "1", "raw_text": ";\n\n                }\n\n                break;\n\n            case HTTPSTATE_WAIT_REQUEST:\n\n            case HTTPSTATE_RECEIVE_DATA:\n\n            case HTTPSTATE_WAIT_FEED:\n\n            case RTSPSTATE_WAIT_REQUEST:\n\n                /* need to catch errors */\n\n                c->poll_entry = poll_entry;\n\n                poll_entry->fd = fd;\n\n                poll_entry->events = POLLIN;/* Maybe this will work */\n\n                poll_entry++;\n\n                break;\n\n            case HTTPSTATE_WAIT:\n\n                c->poll_entry = NULL;\n\n                delay1 = compute_send_delay(c);\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            case HTTPSTATE_WAIT_SHORT:\n\n                c->poll_entry = NULL;\n\n                delay1 = 10; /* one tick wait XXX: 10 ms assumed */\n\n                if (delay1 < delay)\n\n                    delay = delay1;\n\n                break;\n\n            default:\n\n                c->poll_entry = NULL;\n\n                break;\n\n            }\n\n            c = c->next;\n\n        }\n\n\n\n        /* wait for an event on one connection. We poll at least every\n\n           second to handle timeouts */\n\n        do {\n\n            ret = poll(poll_table, poll_entry - poll_table, delay);\n\n        } while (ret == -1);\n\n        \n\n        cur_time = gettime_ms();\n\n\n\n        if (need_to_start_children) {\n\n            need_to_start_children = 0;\n\n            start_children(first_feed);\n\n        }\n\n\n\n        /* now handle the events */\n\n        for(c = first_http_ctx; c != NULL; c = c_next) {\n\n            c_next = c->next;\n\n            if (handle_connection(c) < 0) {\n\n                /* close and free the connection */\n\n                log_connection(c);\n\n                close_connection(c);\n\n            }\n\n        }\n\n\n\n        poll_entry = poll_table;\n\n        /* new HTTP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(server_fd, 0);\n\n        }\n\n        poll_entry++;\n\n        /* new RTSP connection request ? */\n\n        if (poll_entry->revents & POLLIN) {\n\n            new_connection(rtsp_server_fd, 1);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2451, "prediction": "0", "true_label": "0", "raw_text": " 8;\n\n            ctx->decode_dct_block = dnxhd_decode_dct_block_8;\n\n        }\n\n    }\n\n\n\n    cid = AV_RB32(buf + 0x28);\n\n    av_dlog(ctx->avctx, \"compression id %d\\n\", cid);\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx, cid)) < 0)\n\n        return ret;\n\n\n\n    if (buf_size < ctx->cid_table->coding_unit_size) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR, \"incorrect frame size\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ctx->mb_width  = ctx->width >> 4;\n\n    ctx->mb_height = buf[0x16d];\n\n\n\n    av_dlog(ctx->avctx,\n\n            \"mb width %d, mb height %d\\n\", ctx->mb_width, ctx->mb_height);\n\n\n\n    if ((ctx->height + 15) >> 4 == ctx->mb_height && frame->interlaced_frame)\n\n        ctx->height <<= 1;\n\n\n\n    if (ctx->mb_height > 68 ||\n\n        (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n\n        av_log(ctx->avctx, AV_LOG_ERROR,\n\n               \"mb height too big: %d\\n\", ctx->mb_height);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (i = 0; i < ctx->mb_height; i++) {\n\n        ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));\n\n        av_dlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mb_scan_index[i]);\n\n        if (buf_size < ctx->mb_scan_index[i] + 0x280LL) {\n\n            av_log(ctx->avctx, AV_LOG_ERROR, \"invalid mb scan index\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2452, "prediction": "0", "true_label": "1", "raw_text": "Question: static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2453, "prediction": "-1", "true_label": "1", "raw_text": "Question: static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2454, "prediction": "0", "true_label": "0", "raw_text": "\n                             0, below_4g_mem_size);\n\n    memory_region_add_subregion(system_memory, 0, ram_below_4g);\n\n    e820_add_entry(0, below_4g_mem_size, E820_RAM);\n\n    if (above_4g_mem_size > 0) {\n\n        ram_above_4g = g_malloc(sizeof(*ram_above_4g));\n\n        memory_region_init_alias(ram_above_4g, NULL, \"ram-above-4g\", ram,\n\n                                 below_4g_mem_size, above_4g_mem_size);\n\n        memory_region_add_subregion(system_memory, 0x100000000ULL,\n\n                                    ram_above_4g);\n\n        e820_add_entry(0x100000000ULL, above_4g_mem_size, E820_RAM);\n\n    }\n\n\n\n\n\n    /* Initialize PC system firmware */\n\n    pc_system_firmware_init(rom_memory, guest_info->isapc_ram_fw);\n\n\n\n    option_rom_mr = g_malloc(sizeof(*option_rom_mr));\n\n    memory_region_init_ram(option_rom_mr, NULL, \"pc.rom\", PC_ROM_SIZE);\n\n    vmstate_register_ram_global(option_rom_mr);\n\n    memory_region_add_subregion_overlap(rom_memory,\n\n                                        PC_ROM_MIN_VGA,\n\n                                        option_rom_mr,\n\n                                        1);\n\n\n\n    fw_cfg = bochs_bios_init();\n\n    rom_set_fw(fw_cfg);\n\n\n\n    if (linux_boot) {\n\n        load_linux(fw_cfg, kernel_filename, initrd_filename, kernel_cmdline, below_4g_mem_size);\n\n    }\n\n\n\n    for (i = 0; i < nb_option_roms; i++) {\n\n        rom_add_option(option_rom[i].name, option_rom[i].bootindex);\n\n    }\n\n    guest_info->fw_cfg = fw_cfg;\n\n    return fw_cfg;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2455, "prediction": "0", "true_label": "0", "raw_text": "Question: static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2456, "prediction": "0", "true_label": "0", "raw_text": "(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);\n\n\n\n    num_vq = s390_virtio_device_num_vq(dev);\n\n    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);\n\n\n\n    /* Sync virtqueues */\n\n    for (i = 0; i < num_vq; i++) {\n\n        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +\n\n                        (i * VIRTIO_VQCONFIG_LEN);\n\n        ram_addr_t vring;\n\n\n\n        vring = s390_virtio_next_ring(bus);\n\n        virtio_queue_set_addr(dev->vdev, i, vring);\n\n        virtio_queue_set_vector(dev->vdev, i, i);\n\n        stq_phys(vq + VIRTIO_VQCONFIG_OFFS_ADDRESS, vring);\n\n        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));\n\n    }\n\n\n\n    cur_offs = dev->dev_offs;\n\n    cur_offs += VIRTIO_DEV_OFFS_CONFIG;\n\n    cur_offs += num_vq * VIRTIO_VQCONFIG_LEN;\n\n\n\n    /* Sync feature bitmap */\n\n    if (dev->vdev->get_features) {\n\n        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));\n\n    }\n\n\n\n    dev->feat_offs = cur_offs + dev->feat_len;\n\n    cur_offs += dev->feat_len * 2;\n\n\n\n    /* Sync config space */\n\n    if (dev->vdev->get_config) {\n\n        dev->vdev->get_config(dev->vdev, dev->vdev->config);\n\n    }\n\n\n\n    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);\n\n    cur_offs += dev->vdev->config_len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2457, "prediction": "0", "true_label": "1", "raw_text": "Question: static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n\n    int i;\n\n    int dc0, dc2;\n\n    pixel4 dc0splat, dc2splat;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    dc0=dc2=0;\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride];\n\n        dc2+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc0splat;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc2splat;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2458, "prediction": "0", "true_label": "1", "raw_text": "Question: static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n\n                           const uint8_t *sps_pps, uint32_t sps_pps_size,\n\n                           const uint8_t *in,      uint32_t in_size) {\n\n    uint32_t offset = *poutbuf_size;\n\n    uint8_t nal_header_size = offset ? 3 : 4;\n\n\n\n    *poutbuf_size += sps_pps_size+in_size+nal_header_size;\n\n    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n\n    if (sps_pps)\n\n        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n\n    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n\n    if (!offset)\n\n        AV_WB32(*poutbuf+sps_pps_size, 1);\n\n    else {\n\n        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;\n\n        (*poutbuf+offset)[2] = 1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2459, "prediction": "0", "true_label": "1", "raw_text": "Question: void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *e,\n\n                            EventNotifierHandler *io_notify,\n\n                            AioFlushEventNotifierHandler *io_flush)\n\n{\n\n    AioHandler *node;\n\n\n\n    QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n        if (node->e == e && !node->deleted) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Are we deleting the fd handler? */\n\n    if (!io_notify) {\n\n        if (node) {\n\n            g_source_remove_poll(&ctx->source, &node->pfd);\n\n\n\n            /* If the lock is held, just mark the node as deleted */\n\n            if (ctx->walking_handlers) {\n\n                node->deleted = 1;\n\n                node->pfd.revents = 0;\n\n            } else {\n\n                /* Otherwise, delete it for real.  We can't just mark it as\n\n                 * deleted because deleted nodes are only cleaned up after\n\n                 * releasing the walking_handlers lock.\n\n                 */\n\n                QLIST_REMOVE(node, node);\n\n                g_free(node);\n\n            }\n\n        }\n\n    } else {\n\n        if (node == NULL) {\n\n            /* Alloc and insert if it's not already there */\n\n            node = g_malloc0(sizeof(AioHandler));\n\n            node->e = e;\n\n            node->pfd.fd = (uintptr_t)event_notifier_get_handle(e);\n\n            node->pfd.events = G_IO_IN;\n\n            QLIST_INSERT_HEAD(&ctx->aio_handlers, node, node);\n\n\n\n            g_source_add_poll(&ctx->source, &node->pfd);\n\n        }\n\n        /* Update handler with latest information */\n\n        node->io_notify = io_notify;\n\n        node->io_flush = io_flush;\n\n    }\n\n\n\n    aio_notify(ctx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2460, "prediction": "1", "true_label": "0", "raw_text": "Question: int float_near_ulp(float a, float b, unsigned max_ulp)\n\n{\n\n    union av_intfloat32 x, y;\n\n\n\n    x.f = a;\n\n    y.f = b;\n\n\n\n    if (is_negative(x) != is_negative(y)) {\n\n        // handle -0.0 == +0.0\n\n        return a == b;\n\n    }\n\n\n\n    if (abs(x.i - y.i) <= max_ulp)\n\n        return 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2461, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)\n\n{\n\n    ROQDPCMContext *context = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be mono or stereo\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 22050) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be 22050 Hz\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be signed 16-bit\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;\n\n\n\n    context->lastSample[0] = context->lastSample[1] = 0;\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2462, "prediction": "0", "true_label": "1", "raw_text": "DT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2463, "prediction": "0", "true_label": "1", "raw_text": " %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_read failed!\");\n\n    }\n\n    printf(\"read: %d\\n\", ret);\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    /* test av_audio_fifo_peek */\n\n    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_peek failed!\");\n\n    }\n\n    printf(\"peek:\\n\");\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_peek_at */\n\n    printf(\"peek_at:\\n\");\n\n    for (i = 0; i < afifo->nb_samples; ++i){\n\n        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n\n        if (ret < 0){\n\n            ERROR(\"ERROR: av_audio_fifo_peek_at failed!\");\n\n        }\n\n        printf(\"%d:\\n\", i);\n\n        print_audio_bytes(&test_sample, output_data, ret);\n\n    }\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_drain */\n\n    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_drain failed!\");\n\n    }\n\n    if (afifo->nb_samples){\n\n        ERROR(\"drain failed to flush all samples in audio_fifo!\");\n\n    }\n\n\n\n    /* deallocate */\n\n    for (i = 0; i < afifo->nb_buffers; ++i){\n\n        av_freep(&output_data[i]);\n\n    }\n\n    av_freep(&output_data);\n\n    av_audio_fifo_free(afifo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2464, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)\n\n{\n\n    ff_wmv2_idct_c(block);\n\n    put_pixels_clamped_c(block, dest, line_size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2465, "prediction": "0", "true_label": "0", "raw_text": " + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (backward && offset >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (writeoffset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"Attempting to write out of bounds\");\n\n                break;\n\n            }\n\n\n\n            if (previous) {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            } else {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            }\n\n\n\n            if (swap) {\n\n                left         = count;\n\n                writeoffset -= count * 2;\n\n                while (left > 0) {\n\n                    swap = hnm->current[writeoffset];\n\n                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];\n\n                    hnm->current[writeoffset + 1] = swap;\n\n                    left--;\n\n                    writeoffset += 2;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2466, "prediction": "0", "true_label": "0", "raw_text": "sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2467, "prediction": "0", "true_label": "1", "raw_text": "Question: static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2468, "prediction": "-1", "true_label": "1", "raw_text": "Question: static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2469, "prediction": "0", "true_label": "0", "raw_text": " ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) == float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_sub(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) - farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_sub(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2470, "prediction": "0", "true_label": "0", "raw_text": "Question: static void dec_modu(DisasContext *dc)\n\n{\n\n    int l1;\n\n\n\n    LOG_DIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1);\n\n\n\n    if (!(dc->features & LM32_FEATURE_DIVIDE)) {\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"hardware divider is not available\\n\");\n\n        t_gen_illegal_insn(dc);\n\n        return;\n\n    }\n\n\n\n    l1 = gen_new_label();\n\n    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);\n\n    tcg_gen_movi_tl(cpu_pc, dc->pc);\n\n    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);\n\n    gen_set_label(l1);\n\n    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2471, "prediction": "0", "true_label": "0", "raw_text": "Question: static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;\n\n\n\n    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2472, "prediction": "0", "true_label": "0", "raw_text": " NULL) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_DEVICE) {\n\n        char ctype;\n\n        uint32_t major, minor;\n\n        mode_t nmode = 0;\n\n\n\n        if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major,\n\n                                        &minor) != 3) {\n\n            err = -errno;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        switch (ctype) {\n\n        case 'c':\n\n            nmode = S_IFCHR;\n\n            break;\n\n        case 'b':\n\n            nmode = S_IFBLK;\n\n            break;\n\n        default:\n\n            err = -EIO;\n\n            v9fs_post_create(s, vs, err);\n\n        }\n\n\n\n        nmode |= vs->perm & 0777;\n\n        err = v9fs_do_mknod(s, vs, nmode, makedev(major, minor));\n\n        v9fs_create_post_perms(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_NAMED_PIPE) {\n\n        err = v9fs_do_mknod(s, vs, S_IFIFO | (vs->perm & 0777), 0);\n\n        v9fs_post_create(s, vs, err);\n\n    } else if (vs->perm & P9_STAT_MODE_SOCKET) {\n\n        err = v9fs_do_mksock(s, &vs->fullname);\n\n        v9fs_create_post_mksock(s, vs, err);\n\n    } else {\n\n        vs->fidp->fd = v9fs_do_open2(s, vs);\n\n        v9fs_create_post_open2(s, vs, err);\n\n    }\n\n\n\n    return;\n\n\n\nout:\n\n    v9fs_post_create(s, vs, err);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2473, "prediction": "0", "true_label": "0", "raw_text": "Question: void pal_init (CPUState *env)\n\n{\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2474, "prediction": "0", "true_label": "0", "raw_text": "Question: target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2475, "prediction": "0", "true_label": "0", "raw_text": "Question: static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2476, "prediction": "0", "true_label": "0", "raw_text": "\n\n        max_duration = FFMAX(duration, max_duration);\n\n        end          = memchr(data, '\\n', data_size);\n\n        size         = line_size = end ? end - data + 1 : data_size;\n\n        size        -= end ? (end[-1] == '\\r') + 1 : 0;\n\n        start        = data;\n\n        for (i = 0; i < 3; i++, start++)\n\n            if (!(start = memchr(start, ',', size - (start - data))))\n\n                return max_duration;\n\n        size -= start - data;\n\n        sscanf(data, \"Dialogue: %d,\", &layer);\n\n        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",\n\n                     s->streams[pkt->stream_index]->nb_frames, layer);\n\n        size = FFMIN(i + size, sizeof(buffer));\n\n        memcpy(buffer + i, start, size - i);\n\n\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"Writing block at offset %\" PRIu64 \", size %d, \"\n\n               \"pts %\" PRId64 \", duration %d\\n\",\n\n               avio_tell(pb), size, pkt->pts, duration);\n\n        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n\n                                       mkv_blockgroup_size(size));\n\n        put_ebml_id(pb, MATROSKA_ID_BLOCK);\n\n        put_ebml_num(pb, size + 4, 0);\n\n        // this assumes stream_index is less than 126\n\n        avio_w8(pb, 0x80 | (pkt->stream_index + 1));\n\n        avio_wb16(pb, pkt->pts - mkv->cluster_pts);\n\n        avio_w8(pb, 0);\n\n        avio_write(pb, buffer, size);\n\n        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);\n\n        end_ebml_master(pb, blockgroup);\n\n\n\n        data      += line_size;\n\n        data_size -= line_size;\n\n    }\n\n\n\n    return max_duration;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2477, "prediction": "1", "true_label": "1", "raw_text": "Question: static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2478, "prediction": "0", "true_label": "0", "raw_text": ".0f + 0.5f;\n\n                    *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x] - ht) * rcp_h[x];\n\n                    *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n            /* u and v are skipped on yuv422p and yuv420p */\n\n            if (out->format == AV_PIX_FMT_YUV444P) {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                    *lpu++ = 128;\n\n                    *lpv++ = 128;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                    *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f;\n\n                    *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f;\n\n                }\n\n            } else {\n\n                if (h[x+1] <= ht) {\n\n                    *lpy++ = 16;\n\n                } else {\n\n                    mul = (h[x+1] - ht) * rcp_h[x+1];\n\n                    *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2479, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)\n\n{\n\n    const char *file_out = qemu_opt_get(opts, \"path\");\n\n    HANDLE fd_out;\n\n\n\n    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,\n\n                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n    if (fd_out == INVALID_HANDLE_VALUE) {\n\n        return -EIO;\n\n    }\n\n\n\n    return qemu_chr_open_win_file(fd_out, _chr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2480, "prediction": "0", "true_label": "1", "raw_text": "ref_list[1][0], h->default_ref_list[1][1]);\n\n            }\n\n        }\n\n    } else {\n\n        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                              h->short_ref, h->short_ref_count, 0, h->picture_structure);\n\n        len += build_def_list(h->default_ref_list[0] + len,\n\n                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                              h-> long_ref, 16, 1, h->picture_structure);\n\n        av_assert0(len <= 32);\n\n\n\n        if (len < sl->ref_count[0])\n\n            memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));\n\n    }\n\n#ifdef TRACE\n\n    for (i = 0; i < sl->ref_count[0]; i++) {\n\n        tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\",\n\n                (h->default_ref_list[0][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                h->default_ref_list[0][i].pic_id,\n\n                h->default_ref_list[0][i].parent->f.data[0]);\n\n    }\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        for (i = 0; i < sl->ref_count[1]; i++) {\n\n            tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\",\n\n                    (h->default_ref_list[1][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                    h->default_ref_list[1][i].pic_id,\n\n                    h->default_ref_list[1][i].parent->f.data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2481, "prediction": "0", "true_label": "1", "raw_text": " DMAR_IQT_REG, 0, 0x7fff0ULL, 0);\n\n    vtd_define_quad(s, DMAR_IQA_REG, 0, 0xfffffffffffff007ULL, 0);\n\n    vtd_define_long(s, DMAR_ICS_REG, 0, 0, 0x1UL);\n\n    vtd_define_long(s, DMAR_IECTL_REG, 0x80000000UL, 0x80000000UL, 0);\n\n    vtd_define_long(s, DMAR_IEDATA_REG, 0, 0xffffffffUL, 0);\n\n    vtd_define_long(s, DMAR_IEADDR_REG, 0, 0xfffffffcUL, 0);\n\n    /* Treadted as RsvdZ when EIM in ECAP_REG is not supported */\n\n    vtd_define_long(s, DMAR_IEUADDR_REG, 0, 0, 0);\n\n\n\n    /* IOTLB registers */\n\n    vtd_define_quad(s, DMAR_IOTLB_REG, 0, 0Xb003ffff00000000ULL, 0);\n\n    vtd_define_quad(s, DMAR_IVA_REG, 0, 0xfffffffffffff07fULL, 0);\n\n    vtd_define_quad_wo(s, DMAR_IVA_REG, 0xfffffffffffff07fULL);\n\n\n\n    /* Fault Recording Registers, 128-bit */\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_0, 0, 0, 0);\n\n    vtd_define_quad(s, DMAR_FRCD_REG_0_2, 0, 0, 0x8000000000000000ULL);\n\n\n\n    /*\n\n     * Interrupt remapping registers.\n\n     */\n\n    vtd_define_quad(s, DMAR_IRTA_REG, 0, 0xfffffffffffff80fULL, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2482, "prediction": "0", "true_label": "0", "raw_text": "Question: const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)\n\n{\n\n    av_assert2(p < end);\n\n\n\n    end-=2;\n\n    p++;\n\n    for(;p<end; p+=2){\n\n        if(!*p){\n\n            if     (!p[-1] && p[1]) return p - 1;\n\n            else if(!p[ 1] && p[2]) return p;\n\n        }\n\n    }\n\n    return end+2;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2483, "prediction": "0", "true_label": "0", "raw_text": "Question: void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)\n\n{\n\n    switch(reg) {\n\n    case 25:\n\n        if (arg1 & 0xffffff00)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |\n\n                     ((arg1 & 0x1) << 23);\n\n        break;\n\n    case 26:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);\n\n        break;\n\n    case 28:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |\n\n                     ((arg1 & 0x4) << 22);\n\n        break;\n\n    case 31:\n\n        if (arg1 & 0x007c0000)\n\n            return;\n\n        env->active_fpu.fcr31 = arg1;\n\n        break;\n\n    default:\n\n        return;\n\n    }\n\n    /* set rounding mode */\n\n    restore_rounding_mode(env);\n\n    /* set flush-to-zero mode */\n\n    restore_flush_mode(env);\n\n    set_float_exception_flags(0, &env->active_fpu.fp_status);\n\n    if ((GET_FP_ENABLE(env->active_fpu.fcr31) | 0x20) & GET_FP_CAUSE(env->active_fpu.fcr31))\n\n        do_raise_exception(env, EXCP_FPE, GETPC());\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2484, "prediction": "0", "true_label": "0", "raw_text": "Question: static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2485, "prediction": "0", "true_label": "0", "raw_text": "Question: static int get_stream_blocksize(BlockDriverState *bdrv)\n\n{\n\n    uint8_t cmd[6];\n\n    uint8_t buf[12];\n\n    uint8_t sensebuf[8];\n\n    sg_io_hdr_t io_header;\n\n    int ret;\n\n\n\n    memset(cmd, 0, sizeof(cmd));\n\n    memset(buf, 0, sizeof(buf));\n\n    cmd[0] = MODE_SENSE;\n\n    cmd[4] = sizeof(buf);\n\n\n\n    memset(&io_header, 0, sizeof(io_header));\n\n    io_header.interface_id = 'S';\n\n    io_header.dxfer_direction = SG_DXFER_FROM_DEV;\n\n    io_header.dxfer_len = sizeof(buf);\n\n    io_header.dxferp = buf;\n\n    io_header.cmdp = cmd;\n\n    io_header.cmd_len = sizeof(cmd);\n\n    io_header.mx_sb_len = sizeof(sensebuf);\n\n    io_header.sbp = sensebuf;\n\n    io_header.timeout = 6000; /* XXX */\n\n\n\n    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);\n\n    if (ret < 0 || io_header.driver_status || io_header.host_status) {\n\n        return -1;\n\n    }\n\n    return (buf[9] << 16) | (buf[10] << 8) | buf[11];\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2486, "prediction": "0", "true_label": "0", "raw_text": "Question: int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,\n\n                                  int64_t size)\n\n{\n\n    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (ret > 0) {\n\n        int metadata_ol_bitnr = ffs(ret) - 1;\n\n        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);\n\n\n\n        qcow2_signal_corruption(bs, true, offset, size, \"Preventing invalid \"\n\n                                \"write on metadata (overlaps with %s)\",\n\n                                metadata_ol_names[metadata_ol_bitnr]);\n\n        return -EIO;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2487, "prediction": "0", "true_label": "0", "raw_text": " s->next_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n\n                                                 s->last_picture_ptr->f.buf[0]));\n\n\n\n    if (s->picture_structure!= PICT_FRAME) {\n\n        int i;\n\n        for (i = 0; i < 4; i++) {\n\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n\n                s->current_picture.f.data[i] +=\n\n                    s->current_picture.f.linesize[i];\n\n            }\n\n            s->current_picture.f.linesize[i] *= 2;\n\n            s->last_picture.f.linesize[i]    *= 2;\n\n            s->next_picture.f.linesize[i]    *= 2;\n\n        }\n\n    }\n\n\n\n    s->err_recognition = avctx->err_recognition;\n\n\n\n    /* set dequantizer, we can't do it during init as\n\n     * it might change for mpeg4 and we can't do it in the header\n\n     * decode as init is not called for mpeg4 there yet */\n\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n\n    } else {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2488, "prediction": "1", "true_label": "1", "raw_text": "Question: static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2489, "prediction": "0", "true_label": "1", "raw_text": " uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width % 2); // padding if odd\n\n            }\n\n        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width & 1); // padding if odd\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else {\n\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2490, "prediction": "1", "true_label": "1", "raw_text": "Question: udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,\n\n           u_int lport, int flags)\n\n{\n\n\tstruct sockaddr_in addr;\n\n\tstruct socket *so;\n\n\tsocklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;\n\n\n\n\tso = socreate(slirp);\n\n\tif (!so) {\n\n\t    return NULL;\n\n\t}\n\n\tso->s = socket(AF_INET,SOCK_DGRAM,0);\n\n\tso->so_expire = curtime + SO_EXPIRE;\n\n\tinsque(so, &slirp->udb);\n\n\n\n\taddr.sin_family = AF_INET;\n\n\taddr.sin_addr.s_addr = haddr;\n\n\taddr.sin_port = hport;\n\n\n\n\tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {\n\n\t\tudp_detach(so);\n\n\t\treturn NULL;\n\n\t}\n\n\tsetsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));\n\n\n\n\tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen);\n\n\tso->so_fport = addr.sin_port;\n\n\tif (addr.sin_addr.s_addr == 0 ||\n\n\t    addr.sin_addr.s_addr == loopback_addr.s_addr) {\n\n\t   so->so_faddr = slirp->vhost_addr;\n\n\t} else {\n\n\t   so->so_faddr = addr.sin_addr;\n\n\t}\n\n\tso->so_lport = lport;\n\n\tso->so_laddr.s_addr = laddr;\n\n\tif (flags != SS_FACCEPTONCE)\n\n\t   so->so_expire = 0;\n\n\n\n\tso->so_state &= SS_PERSISTENT_MASK;\n\n\tso->so_state |= SS_ISFCONNECTED | flags;\n\n\n\n\treturn so;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2491, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2492, "prediction": "0", "true_label": "1", "raw_text": "Question: void qemu_sglist_destroy(QEMUSGList *qsg)\n\n{\n\n    g_free(qsg->sg);\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2493, "prediction": "0", "true_label": "1", "raw_text": ")\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2494, "prediction": "-1", "true_label": "0", "raw_text": ", header.size);\n\n    header.size += PROXY_HDR_SZ;\n\n\n\n    retval = qemu_write_full(proxy->sockfd, iovec->iov_base, header.size);\n\n    if (retval != header.size) {\n\n        goto close_error;\n\n    }\n\n\n\n    switch (type) {\n\n    case T_OPEN:\n\n    case T_CREATE:\n\n        /*\n\n         * A file descriptor is returned as response for\n\n         * T_OPEN,T_CREATE on success\n\n         */\n\n        if (v9fs_receivefd(proxy->sockfd, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_MKNOD:\n\n    case T_MKDIR:\n\n    case T_SYMLINK:\n\n    case T_LINK:\n\n    case T_CHMOD:\n\n    case T_CHOWN:\n\n    case T_RENAME:\n\n    case T_TRUNCATE:\n\n    case T_UTIME:\n\n    case T_REMOVE:\n\n    case T_LSETXATTR:\n\n    case T_LREMOVEXATTR:\n\n        if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LSTAT:\n\n    case T_READLINK:\n\n    case T_STATFS:\n\n    case T_GETVERSION:\n\n        if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n            goto close_error;\n\n        }\n\n        break;\n\n    case T_LGETXATTR:\n\n    case T_LLISTXATTR:\n\n        if (!size) {\n\n            if (v9fs_receive_status(proxy, reply, &retval) < 0) {\n\n                goto close_error;\n\n            }\n\n        } else {\n\n            if (v9fs_receive_response(proxy, type, &retval, response) < 0) {\n\n                goto close_error;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\nerr_out:\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return retval;\n\n\n\nclose_error:\n\n    close(proxy->sockfd);\n\n    proxy->sockfd = -1;\n\n    qemu_mutex_unlock(&proxy->mutex);\n\n    return -EIO;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2495, "prediction": "0", "true_label": "1", "raw_text": "Question: static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n\n\n    r->req.status = status;\n\n    scsi_disk_set_sense(s, sense_code);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2496, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)\n\n{\n\n    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {\n\n        return;\n\n    }\n\n    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;\n\n\n\n    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&\n\n            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {\n\n        if (s->stopped_state == sdhc_gap_read) {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;\n\n            SDHCI_GET_CLASS(s)->read_block_from_card(s);\n\n        } else {\n\n            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;\n\n            SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n        }\n\n        s->stopped_state = sdhc_not_stopped;\n\n    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {\n\n        if (s->prnsts & SDHC_DOING_READ) {\n\n            s->stopped_state = sdhc_gap_read;\n\n        } else if (s->prnsts & SDHC_DOING_WRITE) {\n\n            s->stopped_state = sdhc_gap_write;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2497, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,\n\n                              Error **errp)\n\n{\n\n    int val;\n\n\n\n    backend->vc = g_new0(ChardevVC, 1);\n\n\n\n    val = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_width = true;\n\n        backend->vc->width = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_height = true;\n\n        backend->vc->height = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"cols\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_cols = true;\n\n        backend->vc->cols = val;\n\n    }\n\n\n\n    val = qemu_opt_get_number(opts, \"rows\", 0);\n\n    if (val != 0) {\n\n        backend->vc->has_rows = true;\n\n        backend->vc->rows = val;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2498, "prediction": "0", "true_label": "1", "raw_text": "Question: static unsigned int find_best(struct vf_instance *vf){\n\n  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);\n\n  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))\n\n    return IMGFMT_YV12;\n\n  else\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2499, "prediction": "0", "true_label": "1", "raw_text": "Question: void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2500, "prediction": "1", "true_label": "1", "raw_text": "5;\n\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n\n    t4  = t0 * 2 + t2;\n\n    t5  = t1 * 2 + t3;\n\n    t6  = t2 - t3;\n\n    t7  = t3 * 2 + t6;\n\n    t8  = (t6 * 11585) >> 14;\n\n    t9  = (t7 * 11585) >> 14;\n\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n\n    tC  = (s0 >> 1) - (s4 >> 1);\n\n    tD  = (s4 >> 1) * 2 + tC;\n\n    tE  = tC - (tA >> 1);\n\n    tF  = tD - (tB >> 1);\n\n    t10 = tF - t5;\n\n    t11 = tE - t8;\n\n    t12 = tE + (tA >> 1) * 2 - t9;\n\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n\n\n    blk[0 * 8] = t13 + t4 * 2;\n\n    blk[1 * 8] = t12 + t9 * 2;\n\n    blk[2 * 8] = t11 + t8 * 2;\n\n    blk[3 * 8] = t10 + t5 * 2;\n\n    blk[4 * 8] = t10;\n\n    blk[5 * 8] = t11;\n\n    blk[6 * 8] = t12;\n\n    blk[7 * 8] = t13;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2501, "prediction": "0", "true_label": "0", "raw_text": "Question: static int fourxm_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 12)\n\n        return 0;\n\n\n\n    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||\n\n        (AV_RL32(&p->buf[8]) != _4XMV_TAG))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2502, "prediction": "0", "true_label": "0", "raw_text": "(p);\n\n    put_bits(p, 16, 0); /* patched later */\n\n    size = 2;\n\n\n\n    // Only MJPEG can have a variable Huffman variable. All other\n\n    // formats use the default Huffman table.\n\n    if (s->out_format == FMT_MJPEG && s->huffman == HUFFMAN_TABLE_OPTIMAL) {\n\n        size += put_huffman_table(p, 0, 0, s->mjpeg_ctx->bits_dc_luminance,\n\n                                  s->mjpeg_ctx->val_dc_luminance);\n\n        size += put_huffman_table(p, 0, 1, s->mjpeg_ctx->bits_dc_chrominance,\n\n                                  s->mjpeg_ctx->val_dc_chrominance);\n\n\n\n        size += put_huffman_table(p, 1, 0, s->mjpeg_ctx->bits_ac_luminance,\n\n                                  s->mjpeg_ctx->val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, s->mjpeg_ctx->bits_ac_chrominance,\n\n                                  s->mjpeg_ctx->val_ac_chrominance);\n\n    } else {\n\n        size += put_huffman_table(p, 0, 0, avpriv_mjpeg_bits_dc_luminance,\n\n                                  avpriv_mjpeg_val_dc);\n\n        size += put_huffman_table(p, 0, 1, avpriv_mjpeg_bits_dc_chrominance,\n\n                                  avpriv_mjpeg_val_dc);\n\n\n\n        size += put_huffman_table(p, 1, 0, avpriv_mjpeg_bits_ac_luminance,\n\n                                  avpriv_mjpeg_val_ac_luminance);\n\n        size += put_huffman_table(p, 1, 1, avpriv_mjpeg_bits_ac_chrominance,\n\n                                  avpriv_mjpeg_val_ac_chrominance);\n\n    }\n\n    AV_WB16(ptr, size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2503, "prediction": "0", "true_label": "0", "raw_text": "xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2504, "prediction": "0", "true_label": "0", "raw_text": "Question: static void n8x0_nand_setup(struct n800_s *s)\n\n{\n\n    char *otp_region;\n\n    DriveInfo *dinfo;\n\n\n\n    s->nand = qdev_create(NULL, \"onenand\");\n\n    qdev_prop_set_uint16(s->nand, \"manufacturer_id\", NAND_MFR_SAMSUNG);\n\n    /* Either 0x40 or 0x48 are OK for the device ID */\n\n    qdev_prop_set_uint16(s->nand, \"device_id\", 0x48);\n\n    qdev_prop_set_uint16(s->nand, \"version_id\", 0);\n\n    qdev_prop_set_int32(s->nand, \"shift\", 1);\n\n    dinfo = drive_get(IF_MTD, 0, 0);\n\n    if (dinfo) {\n\n        qdev_prop_set_drive_nofail(s->nand, \"drive\",\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)));\n\n    }\n\n    qdev_init_nofail(s->nand);\n\n    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,\n\n                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));\n\n    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,\n\n                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));\n\n    otp_region = onenand_raw_otp(s->nand);\n\n\n\n    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_mac));\n\n    memcpy(otp_region + 0x800, n8x0_cal_bt_id, sizeof(n8x0_cal_bt_id));\n\n    /* XXX: in theory should also update the OOB for both pages */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2505, "prediction": "0", "true_label": "0", "raw_text": "Question: void cpu_dump_state (CPUState *env, FILE *f, \n\n                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n\n                     int flags)\n\n{\n\n    uint32_t c0_status;\n\n    int i;\n\n    \n\n    cpu_fprintf(f, \"pc=0x\" TARGET_FMT_lx \" HI=0x\" TARGET_FMT_lx \" LO=0x\" TARGET_FMT_lx \" ds %04x \" TARGET_FMT_lx \" %d\\n\",\n\n                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);\n\n    for (i = 0; i < 32; i++) {\n\n        if ((i & 3) == 0)\n\n            cpu_fprintf(f, \"GPR%02d:\", i);\n\n        cpu_fprintf(f, \" %s \" TARGET_FMT_lx, regnames[i], env->gpr[i]);\n\n        if ((i & 3) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n    }\n\n\n\n    c0_status = env->CP0_Status;\n\n\n\n    cpu_fprintf(f, \"CP0 Status  0x%08x Cause   0x%08x EPC    0x\" TARGET_FMT_lx \"\\n\",\n\n                c0_status, env->CP0_Cause, env->CP0_EPC);\n\n    cpu_fprintf(f, \"    Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGET_FMT_lx \"\\n\",\n\n                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);\n\n    if (c0_status & (1 << CP0St_CU1))\n\n        fpu_dump_state(env, f, cpu_fprintf, flags);\n\n#if defined(TARGET_MIPS64) && defined(MIPS_DEBUG_SIGN_EXTENSIONS)\n\n    cpu_mips_check_sign_extensions(env, f, cpu_fprintf, flags);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2506, "prediction": "0", "true_label": "1", "raw_text": "Question: static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    GetBitContext bits;\n\n    AACADTSHeaderInfo hdr;\n\n    int size;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp;\n\n\n\n    tmp.u64 = av_be2ne64(state);\n\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n\n\n\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n\n        return 0;\n\n    *need_next_header = 0;\n\n    *new_frame_start  = 1;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n\n    hdr_info->samples     = hdr.samples;\n\n    hdr_info->bit_rate    = hdr.bit_rate;\n\n    return size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2507, "prediction": "0", "true_label": "1", "raw_text": " Primary LE */\n\n        {\n\n            switch (size) {\n\n            case 1:\n\n                ret = ldub_raw(addr);\n\n                break;\n\n            case 2:\n\n                ret = lduw_raw(addr);\n\n                break;\n\n            case 4:\n\n                ret = ldl_raw(addr);\n\n                break;\n\n            default:\n\n            case 8:\n\n                ret = ldq_raw(addr);\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    case 0x83: /* Secondary no-fault */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        if (page_check_range(addr, size, PAGE_READ) == -1) {\n\n#ifdef DEBUG_ASI\n\n            dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n            return 0;\n\n        }\n\n        /* Fall through */\n\n    case 0x81: /* Secondary */\n\n    case 0x89: /* Secondary LE */\n\n        /* XXX */\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert from little endian */\n\n    switch (asi) {\n\n    case 0x88: /* Primary LE */\n\n    case 0x89: /* Secondary LE */\n\n    case 0x8a: /* Primary no-fault LE */\n\n    case 0x8b: /* Secondary no-fault LE */\n\n        switch (size) {\n\n        case 2:\n\n            ret = bswap16(ret);\n\n            break;\n\n        case 4:\n\n            ret = bswap32(ret);\n\n            break;\n\n        case 8:\n\n            ret = bswap64(ret);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* Convert to signed number */\n\n    if (sign) {\n\n        switch (size) {\n\n        case 1:\n\n            ret = (int8_t) ret;\n\n            break;\n\n        case 2:\n\n            ret = (int16_t) ret;\n\n            break;\n\n        case 4:\n\n            ret = (int32_t) ret;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#ifdef DEBUG_ASI\n\n    dump_asi(\"read \", last_addr, asi, size, ret);\n\n#endif\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2508, "prediction": "0", "true_label": "1", "raw_text": "plane[i].coef_stride,\n\n                                      s->plane[i].dwt_height))\n\n            goto alloc_fail;\n\n    }\n\n\n\n    /* Slices */\n\n    s->num_x = s->plane[0].dwt_width/s->slice_width;\n\n    s->num_y = s->plane[0].dwt_height/s->slice_height;\n\n\n\n    s->slice_args = av_calloc(s->num_x*s->num_y, sizeof(SliceArgs));\n\n    if (!s->slice_args)\n\n        goto alloc_fail;\n\n\n\n    /* Lookup tables */\n\n    s->coef_lut_len = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_len));\n\n    if (!s->coef_lut_len)\n\n        goto alloc_fail;\n\n\n\n    s->coef_lut_val = av_malloc(COEF_LUT_TAB*(s->q_ceil+1)*sizeof(*s->coef_lut_val));\n\n    if (!s->coef_lut_val)\n\n        goto alloc_fail;\n\n\n\n    for (i = 0; i < s->q_ceil; i++) {\n\n        uint8_t  *len_lut = &s->coef_lut_len[i*COEF_LUT_TAB];\n\n        uint32_t *val_lut = &s->coef_lut_val[i*COEF_LUT_TAB];\n\n        for (j = 0; j < COEF_LUT_TAB; j++) {\n\n            get_vc2_ue_uint(QUANT(j, ff_dirac_qscale_tab[i]),\n\n                            &len_lut[j], &val_lut[j]);\n\n            if (len_lut[j] != 1) {\n\n                len_lut[j] += 1;\n\n                val_lut[j] <<= 1;\n\n            } else {\n\n                val_lut[j] = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nalloc_fail:\n\n    vc2_encode_end(avctx);\n\n    av_log(avctx, AV_LOG_ERROR, \"Unable to allocate memory!\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2509, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int rv40_decode_init(AVCodecContext *avctx)\n\n{\n\n    RV34DecContext *r = avctx->priv_data;\n\n\n\n    r->rv30 = 0;\n\n    ff_rv34_decode_init(avctx);\n\n    if(!aic_top_vlc.bits)\n\n        rv40_init_tables();\n\n    r->parse_slice_header = rv40_parse_slice_header;\n\n    r->decode_intra_types = rv40_decode_intra_types;\n\n    r->decode_mb_info     = rv40_decode_mb_info;\n\n    r->loop_filter        = rv40_loop_filter;\n\n    r->luma_dc_quant_i = rv40_luma_dc_quant[0];\n\n    r->luma_dc_quant_p = rv40_luma_dc_quant[1];\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2510, "prediction": "0", "true_label": "0", "raw_text": "Question: static void spr_write_dbatu_h (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);\n\n    RET_STOP(ctx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2511, "prediction": "0", "true_label": "0", "raw_text": "Question: sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2512, "prediction": "0", "true_label": "1", "raw_text": "ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n\n        AVBufferRef *filtered_buf;\n\n        uint8_t *extradata, *filtered_data;\n\n\n\n        if (s->remove) {\n\n            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!filtered_buf) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            filtered_data = filtered_buf->data;\n\n        }\n\n\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!extradata) {\n\n            av_buffer_unref(&filtered_buf);\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        *data = extradata;\n\n        *size = extradata_size;\n\n\n\n        for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n            H2645NAL *nal = &h2645_pkt.nals[i];\n\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n\n                             nal->type)) {\n\n                AV_WB24(extradata, 1); // startcode\n\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n\n                extradata += 3 + nal->raw_size;\n\n            } else if (s->remove) {\n\n                AV_WB24(filtered_data, 1); // startcode\n\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n\n                filtered_data += 3 + nal->raw_size;\n\n            }\n\n        }\n\n\n\n        if (s->remove) {\n\n            av_buffer_unref(&pkt->buf);\n\n            pkt->buf  = filtered_buf;\n\n            pkt->data = filtered_buf->data;\n\n            pkt->size = filtered_data - filtered_buf->data;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&h2645_pkt);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2513, "prediction": "0", "true_label": "1", "raw_text": "Question: static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,\n\n                                       int16_t *src2,\n\n                                       int height, int denom, int wx0, int wx1,\n\n                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)\n\n{\n\n    int x, y;\n\n    pixel *src = (pixel *)_src;\n\n    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);\n\n    pixel *dst          = (pixel *)_dst;\n\n    ptrdiff_t dststride = _dststride / sizeof(pixel);\n\n    const int8_t *filter = ff_hevc_epel_filters[mx - 1];\n\n    int shift = 14 + 1 - BIT_DEPTH;\n\n    int log2Wd = denom + shift - 1;\n\n\n\n    ox0     = ox0 * (1 << (BIT_DEPTH - 8));\n\n    ox1     = ox1 * (1 << (BIT_DEPTH - 8));\n\n    for (y = 0; y < height; y++) {\n\n        for (x = 0; x < width; x++)\n\n            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +\n\n                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));\n\n        src  += srcstride;\n\n        dst  += dststride;\n\n        src2 += MAX_PB_SIZE;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2514, "prediction": "0", "true_label": "1", "raw_text": "Question: void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2515, "prediction": "0", "true_label": "1", "raw_text": "Question: static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2516, "prediction": "0", "true_label": "1", "raw_text": " | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);\n\n    /* delay slot */\n\n    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n\n\n    /* TLB Miss.  */\n\n\n\n    param = TCG_REG_O1;\n\n    if (!SPARC64 && TARGET_LONG_BITS == 64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, addr);\n\n    if (!SPARC64 && (memop & MO_SIZE) == MO_64) {\n\n        /* Skip the high-part; we'll perform the extract in the trampoline.  */\n\n        param++;\n\n    }\n\n    tcg_out_mov(s, TCG_TYPE_REG, param++, data);\n\n\n\n    func = qemu_st_trampoline[memop & (MO_BSWAP | MO_SIZE)];\n\n    tcg_debug_assert(func != NULL);\n\n    tcg_out_call_nodelay(s, func);\n\n    /* delay slot */\n\n    tcg_out_movi(s, TCG_TYPE_I32, param, oi);\n\n\n\n    *label_ptr |= INSN_OFF19(tcg_ptr_byte_diff(s->code_ptr, label_ptr));\n\n#else\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, TCG_REG_T1, addr, 0, SHIFT_SRL);\n\n        addr = TCG_REG_T1;\n\n    }\n\n    tcg_out_ldst_rr(s, data, addr,\n\n                    (guest_base ? TCG_GUEST_BASE_REG : TCG_REG_G0),\n\n                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);\n\n#endif /* CONFIG_SOFTMMU */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2517, "prediction": "1", "true_label": "0", "raw_text": "Question: QEMUFile *qemu_fopen_fd(int fd)\n\n{\n\n    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));\n\n\n\n    if (s == NULL)\n\n        return NULL;\n\n\n\n    s->fd = fd;\n\n    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);\n\n    return s->file;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2518, "prediction": "0", "true_label": "1", "raw_text": " + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2519, "prediction": "0", "true_label": "1", "raw_text": "Question: static void boston_lcd_event(void *opaque, int event)\n\n{\n\n    BostonState *s = opaque;\n\n    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {\n\n        qemu_chr_fe_printf(&s->lcd_display, \"        \");\n\n        s->lcd_inited = true;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2520, "prediction": "0", "true_label": "1", "raw_text": "Question: void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2521, "prediction": "0", "true_label": "1", "raw_text": "_IRQ)\n\n{\n\n    IRQ_src_t *src;\n\n    int i;\n\n\n\n    src = &opp->src[n_IRQ];\n\n\n\n    if (!src->pending) {\n\n        /* no irq pending */\n\n        DPRINTF(\"%s: IRQ %d is not pending\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_MASK_MASK) {\n\n        /* Interrupt source is disabled */\n\n        DPRINTF(\"%s: IRQ %d is disabled\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (IPVP_PRIORITY(src->ipvp) == 0) {\n\n        /* Priority set to zero */\n\n        DPRINTF(\"%s: IRQ %d has 0 priority\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ipvp & IPVP_ACTIVITY_MASK) {\n\n        /* IRQ already active */\n\n        DPRINTF(\"%s: IRQ %d is already active\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n    if (src->ide == 0) {\n\n        /* No target */\n\n        DPRINTF(\"%s: IRQ %d has no target\\n\", __func__, n_IRQ);\n\n        return;\n\n    }\n\n\n\n    if (src->ide == (1 << src->last_cpu)) {\n\n        /* Only one CPU is allowed to receive this IRQ */\n\n        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);\n\n    } else if (!(src->ipvp & IPVP_MODE_MASK)) {\n\n        /* Directed delivery mode */\n\n        for (i = 0; i < opp->nb_cpus; i++) {\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n            }\n\n        }\n\n    } else {\n\n        /* Distributed delivery mode */\n\n        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {\n\n            if (i == opp->nb_cpus)\n\n                i = 0;\n\n            if (src->ide & (1 << i)) {\n\n                IRQ_local_pipe(opp, i, n_IRQ);\n\n                src->last_cpu = i;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2522, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,\n\n                struct usb_hci_out_fifo_s *fifo,\n\n                void (*send)(struct HCIInfo *, const uint8_t *, int),\n\n                int (*complete)(const uint8_t *, int),\n\n                const uint8_t *data, int len)\n\n{\n\n    if (fifo->len) {\n\n        memcpy(fifo->data + fifo->len, data, len);\n\n        fifo->len += len;\n\n        if (complete(fifo->data, fifo->len)) {\n\n            send(s->hci, fifo->data, fifo->len);\n\n            fifo->len = 0;\n\n        }\n\n    } else if (complete(data, len))\n\n        send(s->hci, data, len);\n\n    else {\n\n        memcpy(fifo->data, data, len);\n\n        fifo->len = len;\n\n    }\n\n\n\n    /* TODO: do we need to loop? */\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2523, "prediction": "0", "true_label": "0", "raw_text": " i = 0;\n\n    while (c1 != NULL) {\n\n        int bitrate;\n\n        int j;\n\n\n\n        bitrate = 0;\n\n        if (c1->stream) {\n\n            for (j = 0; j < c1->stream->nb_streams; j++) {\n\n                if (!c1->stream->feed)\n\n                    bitrate += c1->stream->streams[j]->codec->bit_rate;\n\n                else if (c1->feed_streams[j] >= 0)\n\n                    bitrate += c1->stream->feed->streams[c1->feed_streams[j]]->codec->bit_rate;\n\n            }\n\n        }\n\n\n\n        i++;\n\n        p = inet_ntoa(c1->from_addr.sin_addr);\n\n        avio_printf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>\",\n\n                    i,\n\n                    c1->stream ? c1->stream->filename : \"\",\n\n                    c1->state == HTTPSTATE_RECEIVE_DATA ? \"(input)\" : \"\",\n\n                    p,\n\n                    c1->protocol,\n\n                    http_state[c1->state]);\n\n        fmt_bytecount(pb, bitrate);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, compute_datarate(&c1->datarate, c1->data_count) * 8);\n\n        avio_printf(pb, \"<td align=right>\");\n\n        fmt_bytecount(pb, c1->data_count);\n\n        avio_printf(pb, \"\\n\");\n\n        c1 = c1->next;\n\n    }\n\n    avio_printf(pb, \"</table>\\n\");\n\n\n\n    /* date */\n\n    ti = time(NULL);\n\n    p = ctime(&ti);\n\n    avio_printf(pb, \"<hr size=1 noshade>Generated at %s\", p);\n\n    avio_printf(pb, \"</body>\\n</html>\\n\");\n\n\n\n    len = avio_close_dyn_buf(pb, &c->pb_buffer);\n\n    c->buffer_ptr = c->pb_buffer;\n\n    c->buffer_end = c->pb_buffer + len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2524, "prediction": "0", "true_label": "0", "raw_text": " = 0;\n\n    ret = ram_control_save_page(f, block->offset,\n\n                                offset, TARGET_PAGE_SIZE, &bytes_xmit);\n\n    if (bytes_xmit) {\n\n        *bytes_transferred += bytes_xmit;\n\n        pages = 1;\n\n    }\n\n    if (block == last_sent_block) {\n\n        offset |= RAM_SAVE_FLAG_CONTINUE;\n\n    }\n\n    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {\n\n        if (ret != RAM_SAVE_CONTROL_DELAYED) {\n\n            if (bytes_xmit > 0) {\n\n                acct_info.norm_pages++;\n\n            } else if (bytes_xmit == 0) {\n\n                acct_info.dup_pages++;\n\n            }\n\n        }\n\n    } else {\n\n        /* When starting the process of a new block, the first page of\n\n         * the block should be sent out before other pages in the same\n\n         * block, and all the pages in last block should have been sent\n\n         * out, keeping this order is important, because the 'cont' flag\n\n         * is used to avoid resending the block name.\n\n         */\n\n        if (block != last_sent_block) {\n\n            flush_compressed_data(f);\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                set_compress_params(&comp_param[0], block, offset);\n\n                /* Use the qemu thread to compress the data to make sure the\n\n                 * first page is sent out before other pages\n\n                 */\n\n                bytes_xmit = do_compress_ram_page(&comp_param[0]);\n\n                acct_info.norm_pages++;\n\n                qemu_put_qemu_file(f, comp_param[0].file);\n\n                *bytes_transferred += bytes_xmit;\n\n                pages = 1;\n\n            }\n\n        } else {\n\n            pages = save_zero_page(f, block, offset, p, bytes_transferred);\n\n            if (pages == -1) {\n\n                pages = compress_page_with_multi_thread(f, block, offset,\n\n                                                        bytes_transferred);\n\n            }\n\n        }\n\n    }\n\n\n\n    return pages;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2525, "prediction": "-1", "true_label": "0", "raw_text": ", BlockdevOnError on_error,\n\n                      Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    AioContext *aio_context;\n\n    Error *local_err = NULL;\n\n    const char *base_name = NULL;\n\n\n\n    if (!has_on_error) {\n\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    }\n\n\n\n    bs = qmp_get_root_bs(device, errp);\n\n    if (!bs) {\n\n        return;\n\n    }\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {\n\n        goto out;\n\n    }\n\n\n\n    if (has_base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_setg(errp, QERR_BASE_NOT_FOUND, base);\n\n            goto out;\n\n        }\n\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n        base_name = base;\n\n    }\n\n\n\n    /* if we are streaming the entire chain, the result will have no backing\n\n     * file, and specifying one is therefore an error */\n\n    if (base_bs == NULL && has_backing_file) {\n\n        error_setg(errp, \"backing file specified, but streaming the \"\n\n                         \"entire chain\");\n\n        goto out;\n\n    }\n\n\n\n    /* backing_file string overrides base bs filename */\n\n    base_name = has_backing_file ? backing_file : base_name;\n\n\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,\n\n                 has_speed ? speed : 0, on_error, block_job_cb, bs, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n\n\nout:\n\n    aio_context_release(aio_context);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2526, "prediction": "0", "true_label": "0", "raw_text": " {\n\n        memcpy(dxva_data, data, size);\n\n\n\n#if CONFIG_D3D11VA\n\n        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {\n\n            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;\n\n            memset(dsc11, 0, sizeof(*dsc11));\n\n            dsc11->BufferType           = type;\n\n            dsc11->DataSize             = size;\n\n            dsc11->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n#if CONFIG_DXVA2\n\n        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {\n\n            DXVA2_DecodeBufferDesc *dsc2 = dsc;\n\n            memset(dsc2, 0, sizeof(*dsc2));\n\n            dsc2->CompressedBufferType = type;\n\n            dsc2->DataSize             = size;\n\n            dsc2->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n\n\n        result = 0;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);\n\n        result = -1;\n\n    }\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to release buffer type %u: 0x%x\\n\",\n\n               type, hr);\n\n        result = -1;\n\n    }\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2527, "prediction": "0", "true_label": "0", "raw_text": "\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2528, "prediction": "0", "true_label": "0", "raw_text": "Question: static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;\n\n    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n\n        codec->codec_id == AV_CODEC_ID_H264 &&\n\n        atom.size > 11) {\n\n        avio_skip(pb, 10);\n\n        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n\n        if (avio_rb16(pb) == 0xd4d)\n\n            codec->width = 1440;\n\n        return 0;\n\n    }\n\n\n\n    return mov_read_avid(c, pb, atom);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2529, "prediction": "0", "true_label": "0", "raw_text": "Question: void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2530, "prediction": "0", "true_label": "1", "raw_text": "ov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2531, "prediction": "-1", "true_label": "1", "raw_text": "1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2532, "prediction": "0", "true_label": "1", "raw_text": " = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, end, SEEK_SET);\n\n\n\n    while (!ogg_read_page (s, &i)){\n\n        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&\n\n            ogg->streams[i].codec) {\n\n            s->streams[i]->duration =\n\n                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);\n\n            if (s->streams[i]->start_time != AV_NOPTS_VALUE){\n\n                s->streams[i]->duration -= s->streams[i]->start_time;\n\n                streams_left-= (ogg->streams[i].got_start==-1);\n\n                ogg->streams[i].got_start= 1;\n\n            }else if(!ogg->streams[i].got_start){\n\n                ogg->streams[i].got_start= -1;\n\n                streams_left++;\n\n            }\n\n        }\n\n    }\n\n\n\n    ogg_restore (s, 0);\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, s->data_offset, SEEK_SET);\n\n    ogg_reset(s);\n\n\n    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {\n\n\n        int64_t pts = ogg_calc_pts(s, i, NULL);\n\n        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            s->streams[i]->duration -= pts;\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }\n\n        }\n\n            if(streams_left<=0)\n\n                break;\n\n    }\n\n    ogg_restore (s, 0);\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2533, "prediction": "0", "true_label": "1", "raw_text": "])) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->next_prev_index = ctx->cur_index;\n\n    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;\n\n\n\n    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],\n\n                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    ff_thread_finish_setup(avctx);\n\n\n\n    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,\n\n                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if(!ctx->swap_buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ctx->dsp.bswap_buf(ctx->swap_buf,\n\n                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),\n\n                        swap_buf_size>>2);\n\n    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);\n\n\n\n    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {\n\n        if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);\n\n        else {\n\n            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ctx->prev_index = ctx->next_prev_index;\n\n    ctx->cur_index  = ctx->next_cur_index;\n\n\n\n    /* Only release frames that aren't used for backreferences anymore */\n\n    if(ctx->buf_ptrs[ctx->cur_index].data[0])\n\n        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2534, "prediction": "0", "true_label": "0", "raw_text": "++;\n\n                flags = bytestream_get_le16(&s->stream_ptr);\n\n            }\n\n\n\n            for (x = 0; x < 4; x++, flags >>= 1)\n\n                *s->pixel_ptr++ = P[flags & 1];\n\n            s->pixel_ptr += s->stride - 4;\n\n            // switch to right half\n\n            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;\n\n        }\n\n\n\n    } else {\n\n\n\n        /* need 10 more bytes */\n\n        CHECK_STREAM_PTR(10);\n\n\n\n        if (s->stream_ptr[4] <= s->stream_ptr[5]) {\n\n\n\n            flags = bytestream_get_le32(&s->stream_ptr);\n\n\n\n            /* vertical split; left & right halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 16; y++) {\n\n                for (x = 0; x < 4; x++, flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->stride - 4;\n\n                // switch to right half\n\n                if (y == 7) {\n\n                    s->pixel_ptr -= 8 * s->stride - 4;\n\n                    P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;\n\n                    flags = bytestream_get_le32(&s->stream_ptr);\n\n                }\n\n            }\n\n\n\n        } else {\n\n\n\n            /* horizontal split; top & bottom halves are 2-color encoded */\n\n\n\n            for (y = 0; y < 8; y++) {\n\n                if (y == 4) {\n\n                    P[0] = *s->stream_ptr++;\n\n                    P[1] = *s->stream_ptr++;\n\n                }\n\n                flags = *s->stream_ptr++ | 0x100;\n\n\n\n                for (; flags != 1; flags >>= 1)\n\n                    *s->pixel_ptr++ = P[flags & 1];\n\n                s->pixel_ptr += s->line_inc;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* report success */\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2535, "prediction": "0", "true_label": "1", "raw_text": "Question: static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2536, "prediction": "0", "true_label": "1", "raw_text": "1;\n\n                    }\n\n                    vga_draw_glyph9(d1, linesize,\n\n                                    font_ptr, cheight, fgcol, bgcol, dup9);\n\n                }\n\n                if (src == cursor_ptr &&\n\n                    !(s->cr[VGA_CRTC_CURSOR_START] & 0x20) &&\n\n                    s->cursor_visible_phase) {\n\n                    int line_start, line_last, h;\n\n                    /* draw the cursor */\n\n                    line_start = s->cr[VGA_CRTC_CURSOR_START] & 0x1f;\n\n                    line_last = s->cr[VGA_CRTC_CURSOR_END] & 0x1f;\n\n                    /* XXX: check that */\n\n                    if (line_last > cheight - 1)\n\n                        line_last = cheight - 1;\n\n                    if (line_last >= line_start && line_start < cheight) {\n\n                        h = line_last - line_start + 1;\n\n                        d = d1 + linesize * line_start;\n\n                        if (cw == 16) {\n\n                            vga_draw_glyph16(d, linesize,\n\n                                             cursor_glyph, h, fgcol, bgcol);\n\n                        } else if (cw != 9) {\n\n                            vga_draw_glyph8(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol);\n\n                        } else {\n\n                            vga_draw_glyph9(d, linesize,\n\n                                            cursor_glyph, h, fgcol, bgcol, 1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            d1 += x_incr;\n\n            src += 4;\n\n            ch_attr_ptr++;\n\n        }\n\n        if (cx_max != -1) {\n\n            dpy_gfx_update(s->con, cx_min * cw, cy * cheight,\n\n                           (cx_max - cx_min + 1) * cw, cheight);\n\n        }\n\n        dest += linesize * cheight;\n\n        line1 = line + cheight;\n\n        offset += line_offset;\n\n        if (line < s->line_compare && line1 >= s->line_compare) {\n\n            offset = 0;\n\n        }\n\n        line = line1;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2537, "prediction": "0", "true_label": "1", "raw_text": "Question: int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2538, "prediction": "0", "true_label": "1", "raw_text": "Question: static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    LibQuviContext *qc = s->priv_data;\n\n    return av_read_frame(qc->fmtctx, pkt);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2539, "prediction": "0", "true_label": "1", "raw_text": ", \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n        } else {\n\n            monitor_printf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"no if= specified\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"file\", opts)) {\n\n        dinfo = add_init_drive(opts);\n\n        if (!dinfo)\n\n            return NULL;\n\n        if (dinfo->devaddr) {\n\n            monitor_printf(mon, \"Parameter addr not supported\\n\");\n\n            return NULL;\n\n        }\n\n    } else {\n\n        dinfo = NULL;\n\n    }\n\n\n\n    bus = pci_get_bus_devfn(&devfn, devaddr);\n\n    if (!bus) {\n\n        monitor_printf(mon, \"Invalid PCI device address %s\\n\", devaddr);\n\n        return NULL;\n\n    }\n\n\n\n    switch (type) {\n\n    case IF_SCSI:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"scsi requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"lsi53c895a\");\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        if (dev) {\n\n            BusState *scsibus = QLIST_FIRST(&dev->qdev.child_bus);\n\n            scsi_bus_legacy_add_drive(DO_UPCAST(SCSIBus, qbus, scsibus),\n\n                                      dinfo, dinfo->unit);\n\n        }\n\n        break;\n\n    case IF_VIRTIO:\n\n        if (!dinfo) {\n\n            monitor_printf(mon, \"virtio requires a backing file/device.\\n\");\n\n            return NULL;\n\n        }\n\n        dev = pci_create(bus, devfn, \"virtio-blk-pci\");\n\n        qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n        if (qdev_init(&dev->qdev) < 0)\n\n            dev = NULL;\n\n        break;\n\n    default:\n\n        dev = NULL;\n\n    }\n\n    return dev;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2540, "prediction": "0", "true_label": "0", "raw_text": "Question: uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2541, "prediction": "0", "true_label": "0", "raw_text": " }\n\n        /* milkymist timer counts up */\n\n        value = s->regs[R_TIMER1_COUNTER] - value;\n\n        ptimer_set_count(s->ptimer1, value);\n\n        break;\n\n    case R_TIMER0_COMPARE:\n\n        ptimer_set_limit(s->ptimer0, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER1_COMPARE:\n\n        ptimer_set_limit(s->ptimer1, value, 0);\n\n        s->regs[addr] = value;\n\n        break;\n\n    case R_TIMER0_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER0_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer0, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer0);\n\n        }\n\n        break;\n\n    case R_TIMER1_CONTROL:\n\n        s->regs[addr] = value;\n\n        if (s->regs[R_TIMER1_CONTROL] & CTRL_ENABLE) {\n\n            trace_milkymist_sysctl_start_timer1();\n\n            ptimer_run(s->ptimer1, 0);\n\n        } else {\n\n            trace_milkymist_sysctl_stop_timer1();\n\n            ptimer_stop(s->ptimer1);\n\n        }\n\n        break;\n\n    case R_ICAP:\n\n        sysctl_icap_write(s, value);\n\n        break;\n\n    case R_SYSTEM_ID:\n\n        qemu_system_reset_request();\n\n        break;\n\n\n\n    case R_GPIO_IN:\n\n    case R_CAPABILITIES:\n\n        error_report(\"milkymist_sysctl: write to read-only register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n\n\n    default:\n\n        error_report(\"milkymist_sysctl: write access to unkown register 0x\"\n\n                TARGET_FMT_plx, addr << 2);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2542, "prediction": "1", "true_label": "0", "raw_text": "Question: AVFrame *avcodec_alloc_frame(void)\n\n{\n\n    AVFrame *frame = av_mallocz(sizeof(AVFrame));\n\n\n\n    if (frame == NULL)\n\n        return NULL;\n\n\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avcodec_get_frame_defaults(frame);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    return frame;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2543, "prediction": "0", "true_label": "1", "raw_text": "Question: static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){\n\n    int i;\n\n\n\n    for(i=0; i<w-1; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n        i++;\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    for(; i<w; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    return acc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2544, "prediction": "0", "true_label": "0", "raw_text": "Question: qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2545, "prediction": "0", "true_label": "0", "raw_text": "Question: int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,\n\n                 const char *name, VLANState *vlan)\n\n{\n\n    const char *sock;\n\n    const char *group;\n\n    int port, mode;\n\n\n\n    sock  = qemu_opt_get(opts, \"sock\");\n\n    group = qemu_opt_get(opts, \"group\");\n\n\n\n    port = qemu_opt_get_number(opts, \"port\", 0);\n\n    mode = qemu_opt_get_number(opts, \"mode\", 0700);\n\n\n\n    if (net_vde_init(vlan, \"vde\", name, sock, port, group, mode) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2546, "prediction": "0", "true_label": "1", "raw_text": "Question: static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)\n\n{\n\n    int i = 0;\n\n    while (ff_id3v2_extra_meta_funcs[i].tag3) {\n\n        if (!memcmp(tag,\n\n                    (isv34 ?\n\n                        ff_id3v2_extra_meta_funcs[i].tag4 :\n\n                        ff_id3v2_extra_meta_funcs[i].tag3),\n\n                    (isv34 ? 4 : 3)))\n\n            return &ff_id3v2_extra_meta_funcs[i];\n\n        i++;\n\n    }\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2547, "prediction": "-1", "true_label": "1", "raw_text": "Question: int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n\n                         AVFilterBufferRef *picref, int flags)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!picref) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n        ret = check_format_change(buffer_filter, picref);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)\n\n        buf = picref;\n\n    else\n\n        buf = copy_buffer_ref(buffer_filter, picref);\n\n\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        if (buf != picref)\n\n            avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n    c->nb_failed_requests = 0;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer:\n"}], [{"ID": 2548, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qstring_destroy_obj(QObject *obj)\n\n{\n\n    QString *qs;\n\n\n\n    assert(obj != NULL);\n\n    qs = qobject_to_qstring(obj);\n\n    g_free(qs->string);\n\n    g_free(qs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2549, "prediction": "0", "true_label": "0", "raw_text": "Question: bool aio_pending(AioContext *ctx)\n\n{\n\n    AioHandler *node;\n\n    bool result = false;\n\n\n\n    /*\n\n     * We have to walk very carefully in case aio_set_fd_handler is\n\n     * called while we're walking.\n\n     */\n\n    qemu_lockcnt_inc(&ctx->list_lock);\n\n    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {\n\n        if (node->pfd.revents && node->io_notify) {\n\n            result = true;\n\n            break;\n\n        }\n\n\n\n        if ((node->pfd.revents & G_IO_IN) && node->io_read) {\n\n            result = true;\n\n            break;\n\n        }\n\n        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {\n\n            result = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    qemu_lockcnt_dec(&ctx->list_lock);\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2550, "prediction": "0", "true_label": "0", "raw_text": "Question: static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2551, "prediction": "0", "true_label": "0", "raw_text": "Question: static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2552, "prediction": "0", "true_label": "0", "raw_text": ".0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2553, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int roq_decode_init(AVCodecContext *avctx)\n\n{\n\n    RoqContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n\n\n    if (avctx->width % 16 || avctx->height % 16) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Dimensions must be a multiple of 16\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    s->width = avctx->width;\n\n    s->height = avctx->height;\n\n\n\n    s->last_frame    = av_frame_alloc();\n\n    s->current_frame = av_frame_alloc();\n\n    if (!s->current_frame || !s->last_frame) {\n\n        av_frame_free(&s->current_frame);\n\n        av_frame_free(&s->last_frame);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV444P;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2554, "prediction": "0", "true_label": "1", "raw_text": "Question: static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2555, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,\n\n                                            sPAPREnvironment *spapr,\n\n                                            uint32_t token, uint32_t nargs,\n\n                                            target_ulong args, uint32_t nret,\n\n                                            target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    uint64_t buid;\n\n    int state, ret;\n\n\n\n    if ((nargs != 3) || (nret != 4 && nret != 5)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);\n\n    sphb = find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_get_state) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_get_state(sphb, &state);\n\n    rtas_st(rets, 0, ret);\n\n    if (ret != RTAS_OUT_SUCCESS) {\n\n        return;\n\n    }\n\n\n\n    rtas_st(rets, 1, state);\n\n    rtas_st(rets, 2, RTAS_EEH_SUPPORT);\n\n    rtas_st(rets, 3, RTAS_EEH_PE_UNAVAIL_INFO);\n\n    if (nret >= 5) {\n\n        rtas_st(rets, 4, RTAS_EEH_PE_RECOVER_INFO);\n\n    }\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2556, "prediction": "1", "true_label": "0", "raw_text": "Question: void qmp_migrate_set_cache_size(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s = migrate_get_current();\n\n\n\n    /* Check for truncation */\n\n    if (value != (size_t)value) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                  \"exceeding address space\");\n\n        return;\n\n    }\n\n\n\n    s->xbzrle_cache_size = xbzrle_cache_resize(value);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2557, "prediction": "0", "true_label": "1", "raw_text": "Question: int path_is_absolute(const char *path)\n\n{\n\n    const char *p;\n\n#ifdef _WIN32\n\n    /* specific case for names like: \"\\\\.\\d:\" */\n\n    if (*path == '/' || *path == '\\\\')\n\n        return 1;\n\n#endif\n\n    p = strchr(path, ':');\n\n    if (p)\n\n        p++;\n\n    else\n\n        p = path;\n\n#ifdef _WIN32\n\n    return (*p == '/' || *p == '\\\\');\n\n#else\n\n    return (*p == '/');\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2558, "prediction": "1", "true_label": "1", "raw_text": "Question: opts_end_struct(Visitor *v, Error **errp)\n\n{\n\n    OptsVisitor *ov = to_ov(v);\n\n    GHashTableIter iter;\n\n    GQueue *any;\n\n\n\n    if (--ov->depth > 0) {\n\n        return;\n\n    }\n\n\n\n    /* we should have processed all (distinct) QemuOpt instances */\n\n    g_hash_table_iter_init(&iter, ov->unprocessed_opts);\n\n    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {\n\n        const QemuOpt *first;\n\n\n\n        first = g_queue_peek_head(any);\n\n        error_setg(errp, QERR_INVALID_PARAMETER, first->name);\n\n    }\n\n    g_hash_table_destroy(ov->unprocessed_opts);\n\n    ov->unprocessed_opts = NULL;\n\n    if (ov->fake_id_opt) {\n\n        g_free(ov->fake_id_opt->name);\n\n        g_free(ov->fake_id_opt->str);\n\n        g_free(ov->fake_id_opt);\n\n    }\n\n    ov->fake_id_opt = NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2559, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int shorten_decode_close(AVCodecContext *avctx)\n\n{\n\n    ShortenContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    for (i = 0; i < s->channels; i++) {\n\n        s->decoded[i] -= s->nwrap;\n\n        av_freep(&s->decoded[i]);\n\n        av_freep(&s->offset[i]);\n\n    }\n\n    av_freep(&s->bitstream);\n\n    av_freep(&s->coeffs);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2560, "prediction": "0", "true_label": "0", "raw_text": "Question: void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,\n\n                                         src - (stride * 2),\n\n                                         stride, dst, stride);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2561, "prediction": "0", "true_label": "0", "raw_text": "vapic(s, SYNC_FROM_VAPIC);\n\n        if (apic_report_tpr_access) {\n\n            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);\n\n        }\n\n        val = s->tpr;\n\n        break;\n\n    case 0x09:\n\n        val = apic_get_arb_pri(s);\n\n        break;\n\n    case 0x0a:\n\n        /* ppr */\n\n        val = apic_get_ppr(s);\n\n        break;\n\n    case 0x0b:\n\n        val = 0;\n\n        break;\n\n    case 0x0d:\n\n        val = s->log_dest << 24;\n\n        break;\n\n    case 0x0e:\n\n        val = s->dest_mode << 28;\n\n        break;\n\n    case 0x0f:\n\n        val = s->spurious_vec;\n\n        break;\n\n    case 0x10 ... 0x17:\n\n        val = s->isr[index & 7];\n\n        break;\n\n    case 0x18 ... 0x1f:\n\n        val = s->tmr[index & 7];\n\n        break;\n\n    case 0x20 ... 0x27:\n\n        val = s->irr[index & 7];\n\n        break;\n\n    case 0x28:\n\n        val = s->esr;\n\n        break;\n\n    case 0x30:\n\n    case 0x31:\n\n        val = s->icr[index & 1];\n\n        break;\n\n    case 0x32 ... 0x37:\n\n        val = s->lvt[index - 0x32];\n\n        break;\n\n    case 0x38:\n\n        val = s->initial_count;\n\n        break;\n\n    case 0x39:\n\n        val = apic_get_current_count(s);\n\n        break;\n\n    case 0x3e:\n\n        val = s->divide_conf;\n\n        break;\n\n    default:\n\n        s->esr |= ESR_ILLEGAL_ADDRESS;\n\n        val = 0;\n\n        break;\n\n    }\n\n    trace_apic_mem_readl(addr, val);\n\n    return val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2562, "prediction": "0", "true_label": "0", "raw_text": "Question: static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)\n\n{\n\n    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);\n\n    SocketAddressLegacy *saddr;\n\n\n\n    if (inet_parse(iaddr, host_port, errp)) {\n\n        qapi_free_InetSocketAddress(iaddr);\n\n        return NULL;\n\n    }\n\n\n\n    saddr = g_new0(SocketAddressLegacy, 1);\n\n    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;\n\n    saddr->u.inet.data = iaddr;\n\n\n\n    return saddr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2563, "prediction": "0", "true_label": "1", "raw_text": "Question: static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { // optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base  = dy / adx;\n\n        int x     = x0;\n\n        uint8_t y = y0;\n\n        int err   = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2564, "prediction": "0", "true_label": "1", "raw_text": "Question: static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2565, "prediction": "0", "true_label": "1", "raw_text": "Question: static BufferPoolEntry *get_pool(AVBufferPool *pool)\n\n{\n\n    BufferPoolEntry *cur = NULL, *last = NULL;\n\n\n\n    do {\n\n        FFSWAP(BufferPoolEntry*, cur, last);\n\n        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);\n\n        if (!cur)\n\n            return NULL;\n\n    } while (cur != last);\n\n\n\n    return cur;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2566, "prediction": "0", "true_label": "1", "raw_text": "Question: static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,\n\n                          int *end_pos2)\n\n{\n\n    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {\n\n        s->gb           = s->in_gb;\n\n        s->in_gb.buffer = NULL;\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        skip_bits_long(&s->gb, *pos - *end_pos);\n\n        *end_pos2 =\n\n        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;\n\n        *pos      = get_bits_count(&s->gb);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2567, "prediction": "0", "true_label": "1", "raw_text": "Question: static int vpc_write(BlockDriverState *bs, int64_t sector_num,\n\n    const uint8_t *buf, int nb_sectors)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    int64_t offset;\n\n    int64_t sectors, sectors_per_block;\n\n    int ret;\n\n    VHDFooter *footer =  (VHDFooter *) s->footer_buf;\n\n\n\n    if (cpu_to_be32(footer->type) == VHD_FIXED) {\n\n        return bdrv_write(bs->file, sector_num, buf, nb_sectors);\n\n    }\n\n    while (nb_sectors > 0) {\n\n        offset = get_sector_offset(bs, sector_num, 1);\n\n\n\n        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;\n\n        sectors = sectors_per_block - (sector_num % sectors_per_block);\n\n        if (sectors > nb_sectors) {\n\n            sectors = nb_sectors;\n\n        }\n\n\n\n        if (offset == -1) {\n\n            offset = alloc_block(bs, sector_num);\n\n            if (offset < 0)\n\n                return -1;\n\n        }\n\n\n\n        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);\n\n        if (ret != sectors * BDRV_SECTOR_SIZE) {\n\n            return -1;\n\n        }\n\n\n\n        nb_sectors -= sectors;\n\n        sector_num += sectors;\n\n        buf += sectors * BDRV_SECTOR_SIZE;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2568, "prediction": "0", "true_label": "1", "raw_text": "Question: static int read_old_huffman_tables(HYuvContext *s){\n\n#if 1\n\n    GetBitContext gb;\n\n    int i;\n\n\n\n    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);\n\n    if(read_len_table(s->len[0], &gb)<0)\n\n        return -1;\n\n    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);\n\n    if(read_len_table(s->len[1], &gb)<0)\n\n        return -1;\n\n\n\n    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n\n    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n\n\n\n    if(s->bitstream_bpp >= 24){\n\n        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));\n\n        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));\n\n    }\n\n    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));\n\n    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));\n\n\n\n    for(i=0; i<3; i++){\n\n        ff_free_vlc(&s->vlc[i]);\n\n        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);\n\n    }\n\n\n\n    generate_joint_tables(s);\n\n\n\n    return 0;\n\n#else\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"v1 huffyuv is not supported \\n\");\n\n    return -1;\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2569, "prediction": "0", "true_label": "0", "raw_text": "new(Exynos4BoardState, 1);\n\n    MachineClass *mc = MACHINE_GET_CLASS(machine);\n\n\n\n    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {\n\n        error_report(\"%s board supports only %d CPU cores, ignoring smp_cpus\"\n\n                     \" value\",\n\n                     mc->name, EXYNOS4210_NCPUS);\n\n    }\n\n\n\n    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];\n\n    exynos4_board_binfo.board_id = exynos4_board_id[board_type];\n\n    exynos4_board_binfo.smp_bootreg_addr =\n\n            exynos4_board_smp_bootreg_addr[board_type];\n\n    exynos4_board_binfo.kernel_filename = machine->kernel_filename;\n\n    exynos4_board_binfo.initrd_filename = machine->initrd_filename;\n\n    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    exynos4_board_binfo.gic_cpu_if_addr =\n\n            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;\n\n\n\n    PRINT_DEBUG(\"\\n ram_size: %luMiB [0x%08lx]\\n\"\n\n            \" kernel_filename: %s\\n\"\n\n            \" kernel_cmdline: %s\\n\"\n\n            \" initrd_filename: %s\\n\",\n\n            exynos4_board_ram_size[board_type] / 1048576,\n\n            exynos4_board_ram_size[board_type],\n\n            machine->kernel_filename,\n\n            machine->kernel_cmdline,\n\n            machine->initrd_filename);\n\n\n\n    exynos4_boards_init_ram(s, get_system_memory(),\n\n                            exynos4_board_ram_size[board_type]);\n\n\n\n    s->soc = exynos4210_init(get_system_memory());\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2570, "prediction": "0", "true_label": "1", "raw_text": "Question: static void json_print_section_header(WriterContext *wctx)\n\n{\n\n    JSONContext *json = wctx->priv;\n\n    AVBPrint buf;\n\n    const struct section *section = wctx->section[wctx->level];\n\n    const struct section *parent_section = wctx->level ?\n\n        wctx->section[wctx->level-1] : NULL;\n\n\n\n    if (wctx->level && wctx->nb_item[wctx->level-1])\n\n        printf(\",\\n\");\n\n\n\n    if (section->flags & SECTION_FLAG_IS_WRAPPER) {\n\n        printf(\"{\\n\");\n\n        json->indent_level++;\n\n    } else {\n\n        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);\n\n        json_escape_str(&buf, section->name, wctx);\n\n        JSON_INDENT();\n\n\n\n        json->indent_level++;\n\n        if (section->flags & SECTION_FLAG_IS_ARRAY) {\n\n            printf(\"\\\"%s\\\": [\\n\", buf.str);\n\n        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {\n\n            printf(\"\\\"%s\\\": {%s\", buf.str, json->item_start_end);\n\n        } else {\n\n            printf(\"{%s\", json->item_start_end);\n\n\n\n            /* this is required so the parser can distinguish between packets and frames */\n\n            if (parent_section->id == SECTION_ID_PACKETS_AND_FRAMES) {\n\n                if (!json->compact)\n\n                    JSON_INDENT();\n\n                printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->item_sep);\n\n            }\n\n        }\n\n        av_bprint_finalize(&buf, NULL);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2571, "prediction": "0", "true_label": "0", "raw_text": " AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2572, "prediction": "1", "true_label": "0", "raw_text": "Question: int slirp_can_output(void)\n\n{\n\n    return !slirp_vc || qemu_can_send_packet(slirp_vc);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2573, "prediction": "0", "true_label": "0", "raw_text": "Question: static void usb_tablet_class_initfn(ObjectClass *klass, void *data)\n\n{\n\n    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);\n\n\n\n    uc->init           = usb_tablet_initfn;\n\n    uc->product_desc   = \"QEMU USB Tablet\";\n\n    uc->usb_desc       = &desc_tablet;\n\n    uc->handle_packet  = usb_generic_handle_packet;\n\n    uc->handle_reset   = usb_hid_handle_reset;\n\n    uc->handle_control = usb_hid_handle_control;\n\n    uc->handle_data    = usb_hid_handle_data;\n\n    uc->handle_destroy = usb_hid_handle_destroy;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2574, "prediction": "0", "true_label": "1", "raw_text": "gb);\n    w = FFALIGN(width,  1 << (NB_LEVELS + 1));\n    h = FFALIGN(height, 1 << (NB_LEVELS + 1));\n    ctx->levels = bytestream2_get_be32(&ctx->gb);\n    if (ctx->levels != NB_LEVELS)\n    ctx->depth = bytestream2_get_be32(&ctx->gb);\n    if (ctx->depth < 8 || ctx->depth > 15) {\n        avpriv_request_sample(avctx, \"Depth %d\", ctx->depth);\n    }\n    ret = ff_set_dimensions(avctx, w, h);\n    if (ret < 0)\n        return ret;\n    avctx->width  = width;\n    avctx->height = height;\n    if (ctx->w != w || ctx->h != h) {\n        free_buffers(avctx);\n        ctx->w = w;\n        ctx->h = h;\n        ret = init_decoder(avctx);\n        if (ret < 0) {\n            free_buffers(avctx);\n            ctx->w = 0;\n            ctx->h = 0;\n            return ret;\n        }\n    }\n    bytestream2_skip(&ctx->gb, 8);\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n    p->color_range = AVCOL_RANGE_JPEG;\n    ret = ff_thread_get_buffer(avctx, &frame, 0);\n    if (ret < 0)\n        return ret;\n    for (i = 0; i < 3; i++) {\n        ret = decode_plane(avctx, i, avpkt, frame.f);\n        if (ret < 0)\n            return ret;\n        if (avctx->flags & AV_CODEC_FLAG_GRAY)\n            break;\n    }\n    postprocess_luma(frame.f, ctx->w, ctx->h, ctx->depth);\n    postprocess_chroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth);\n    *got_frame = 1;\n    return pktsize;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2575, "prediction": "0", "true_label": "1", "raw_text": "Question: static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2576, "prediction": "0", "true_label": "1", "raw_text": "set(&st->metadata, \"mimetype\", attachements[j].mime, 0);\n\n            st->codec->codec_id = CODEC_ID_NONE;\n\n            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n\n            st->codec->extradata  = av_malloc(attachements[j].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if(st->codec->extradata == NULL)\n\n                break;\n\n            st->codec->extradata_size = attachements[j].bin.size;\n\n            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n\n\n\n            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n\n                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n\n                             strlen(ff_mkv_mime_tags[i].str))) {\n\n                    st->codec->codec_id = ff_mkv_mime_tags[i].id;\n\n                    break;\n\n                }\n\n            }\n\n            attachements[j].stream = st;\n\n        }\n\n    }\n\n\n\n    chapters = chapters_list->elem;\n\n    for (i=0; i<chapters_list->nb_elem; i++)\n\n        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid\n\n            && (max_start==0 || chapters[i].start > max_start)) {\n\n            chapters[i].chapter =\n\n            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n\n                           chapters[i].start, chapters[i].end,\n\n                           chapters[i].title);\n\n            av_dict_set(&chapters[i].chapter->metadata,\n\n                             \"title\", chapters[i].title, 0);\n\n            max_start = chapters[i].start;\n\n        }\n\n\n\n    matroska_add_index_entries(matroska);\n\n\n\n    matroska_convert_tags(s);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2577, "prediction": "0", "true_label": "1", "raw_text": "; i++) {\n\n            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);\n\n        }\n\n        sc->curcoarsesig2->last = fs;\n\n    }\n\n\n\n    sc->coarsecount = (sc->coarsecount+1)%90;\n\n\n\n    /* debug printing finesignature */\n\n    if (av_log_get_level() == AV_LOG_DEBUG) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"input %d, confidence: %d\\n\", FF_INLINK_IDX(inlink), fs->confidence);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"words:\");\n\n        for (i = 0; i < 5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d:\", fs->words[i] );\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->words[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->words[i] % pot3[j-1] / pot3[j] );\n\n            av_log(ctx, AV_LOG_DEBUG, \";\");\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"framesignature:\");\n\n        for (i = 0; i < SIGELEM_SIZE/5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->framesig[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->framesig[i] % pot3[j-1] / pot3[j] );\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n\n\n    if (FF_INLINK_IDX(inlink) == 0)\n\n        return ff_filter_frame(inlink->dst->outputs[0], picref);\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2578, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2579, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint32_t pcihotplug_read(void *opaque, uint32_t addr)\n\n{\n\n    uint32_t val = 0;\n\n    struct pci_status *g = opaque;\n\n    switch (addr) {\n\n        case PCI_BASE:\n\n            val = g->up;\n\n            break;\n\n        case PCI_BASE + 4:\n\n            val = g->down;\n\n            break;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    PIIX4_DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val);\n\n    return val;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2580, "prediction": "0", "true_label": "1", "raw_text": "Question: static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    int64_t size;\n\n    AVIOContext *pb  = s->pb;\n\n    WAVContext    *wav = s->priv_data;\n\n    AVStream *st;\n\n    uint8_t guid[16];\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_riff, 16))\n\n        return -1;\n\n\n\n    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */\n\n        return -1;\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_wave, 16)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find wave guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    size = find_guid(pb, guid_fmt);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find fmt guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* subtract chunk header size - normal wav file doesn't count it */\n\n    ff_get_wav_header(pb, st->codec, size - 24);\n\n    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);\n\n\n\n    st->need_parsing = AVSTREAM_PARSE_FULL;\n\n\n\n    av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n    size = find_guid(pb, guid_data);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find data guid\\n\");\n\n        return -1;\n\n    }\n\n    wav->data_end = avio_tell(pb) + size - 24;\n\n    wav->w64      = 1;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2581, "prediction": "0", "true_label": "1", "raw_text": "Question: void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2582, "prediction": "1", "true_label": "1", "raw_text": "Question: int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2583, "prediction": "0", "true_label": "0", "raw_text": " uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        return;\n\n    }\n\n\n\n    link = s->async_qh;\n\n    if (!link) {\n\n        /* This should never happen. It means a TD somehow got removed\n\n           without cancelling the associated async IO request.  */\n\n        return;\n\n    }\n\n    cpu_physical_memory_read(link & ~0xf, (uint8_t *)&qh, sizeof(qh));\n\n    le32_to_cpus(&qh.link);\n\n    le32_to_cpus(&qh.el_link);\n\n    /* Re-process the queue containing the async packet.  */\n\n    while (1) {\n\n        cpu_physical_memory_read(qh.el_link & ~0xf,\n\n                                 (uint8_t *)&td, sizeof(td));\n\n        le32_to_cpus(&td.link);\n\n        le32_to_cpus(&td.ctrl);\n\n        le32_to_cpus(&td.token);\n\n        le32_to_cpus(&td.buffer);\n\n        old_td_ctrl = td.ctrl;\n\n        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);\n\n\n\n        /* update the status bits of the TD */\n\n        if (old_td_ctrl != td.ctrl) {\n\n            val = cpu_to_le32(td.ctrl);\n\n            cpu_physical_memory_write((qh.el_link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n        }\n\n        if (ret < 0)\n\n            break; /* interrupted frame */\n\n        if (ret == 2) {\n\n            s->async_qh = link;\n\n            break;\n\n        } else if (ret == 0) {\n\n            /* update qh element link */\n\n            qh.el_link = td.link;\n\n            val = cpu_to_le32(qh.el_link);\n\n            cpu_physical_memory_write((link & ~0xf) + 4,\n\n                                      (const uint8_t *)&val,\n\n                                      sizeof(val));\n\n            if (!(qh.el_link & 4))\n\n                break;\n\n        }\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2584, "prediction": "0", "true_label": "0", "raw_text": "Question: static void tracked_request_end(BdrvTrackedRequest *req)\n\n{\n\n    if (req->serialising) {\n\n        req->bs->serialising_in_flight--;\n\n    }\n\n\n\n    QLIST_REMOVE(req, list);\n\n    qemu_co_queue_restart_all(&req->wait_queue);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2585, "prediction": "0", "true_label": "0", "raw_text": "6(&src);\n\n\n\n        /* Initialize the previous sample.  */\n\n        for (i = 0; i < 4; i++)\n\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n\n\n\n        if (samplecnt >= (samples_end - samples) /  (st + 1)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"allocated output buffer is too small\\n\");\n\n            return -1;\n\n        }\n\n\n\n        for (ch = 0; ch <= st; ch++) {\n\n            samples = (unsigned short *) data + ch;\n\n\n\n            /* Read in every sample for this channel.  */\n\n            for (i = 0; i < samplecnt / 14; i++) {\n\n                int index = (*src >> 4) & 7;\n\n                unsigned int exp = 28 - (*src++ & 15);\n\n                int factor1 = table[ch][index * 2];\n\n                int factor2 = table[ch][index * 2 + 1];\n\n\n\n                /* Decode 14 samples.  */\n\n                for (n = 0; n < 14; n++) {\n\n                    int32_t sampledat;\n\n                    if(n&1) sampledat=  *src++    <<28;\n\n                    else    sampledat= (*src&0xF0)<<24;\n\n\n\n                    sampledat = ((prev[ch][0]*factor1\n\n                                + prev[ch][1]*factor2) >> 11) + (sampledat>>exp);\n\n                    *samples = av_clip_int16(sampledat);\n\n                    prev[ch][1] = prev[ch][0];\n\n                    prev[ch][0] = *samples++;\n\n\n\n                    /* In case of stereo, skip one sample, this sample\n\n                       is for the other channel.  */\n\n                    samples += st;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* In the previous loop, in case stereo is used, samples is\n\n           increased exactly one time too often.  */\n\n        samples -= st;\n\n        break;\n\n    }\n\n\n\n    default:\n\n        return -1;\n\n    }\n\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n\n    return src - buf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2586, "prediction": "0", "true_label": "0", "raw_text": " 16);\n\n\n\n    last[0] = last[1] = last[2] = -1;\n\n\n\n    ctx.escapes[0] = escapes[0];\n\n    ctx.escapes[1] = escapes[1];\n\n    ctx.escapes[2] = escapes[2];\n\n    ctx.v1 = &vlc[0];\n\n    ctx.v2 = &vlc[1];\n\n    ctx.recode1 = tmp1.values;\n\n    ctx.recode2 = tmp2.values;\n\n    ctx.last = last;\n\n\n\n    huff.length = ((size + 3) >> 2) + 3;\n\n    huff.maxlength = 0;\n\n    huff.current = 0;\n\n    huff.values = av_mallocz(huff.length * sizeof(int));\n\n\n\n    if (smacker_decode_bigtree(gb, &huff, &ctx) < 0)\n\n        err = -1;\n\n    skip_bits1(gb);\n\n    if(ctx.last[0] == -1) ctx.last[0] = huff.current++;\n\n    if(ctx.last[1] == -1) ctx.last[1] = huff.current++;\n\n    if(ctx.last[2] == -1) ctx.last[2] = huff.current++;\n\n    if(huff.current > huff.length){\n\n        ctx.last[0] = ctx.last[1] = ctx.last[2] = 1;\n\n        av_log(smk->avctx, AV_LOG_ERROR, \"bigtree damaged\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    *recodes = huff.values;\n\n\n\n    if(vlc[0].table)\n\n        ff_free_vlc(&vlc[0]);\n\n    if(vlc[1].table)\n\n        ff_free_vlc(&vlc[1]);\n\n    av_free(tmp1.bits);\n\n    av_free(tmp1.lengths);\n\n    av_free(tmp1.values);\n\n    av_free(tmp2.bits);\n\n    av_free(tmp2.lengths);\n\n    av_free(tmp2.values);\n\n\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2587, "prediction": "0", "true_label": "1", "raw_text": "Question: static int standard_decode_picture_primary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0;\n\n\n\n    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);\n\n    skip_bits(gb, 2); //framecnt unused\n\n    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);\n\n    v->s.pict_type = get_bits(gb, 1);\n\n    if (v->s.avctx->max_b_frames)\n\n    {\n\n        if (!v->s.pict_type)\n\n        {\n\n            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;\n\n            else v->s.pict_type = B_TYPE;\n\n        }\n\n        else v->s.pict_type = P_TYPE;\n\n    }\n\n    else v->s.pict_type++;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case I_TYPE: status = decode_i_picture_header(v); break;\n\n    case P_TYPE: status = decode_p_picture_primary_header(v); break;\n\n    case BI_TYPE:\n\n    case B_TYPE: status = decode_b_picture_primary_header(v); break;\n\n    }\n\n\n\n    if (status == FRAME_SKIPED)\n\n    {\n\n      av_log(v->s.avctx, AV_LOG_INFO, \"Skipping frame...\\n\");\n\n      return status;\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2588, "prediction": "0", "true_label": "0", "raw_text": "Question: static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)\n\n{\n\n    FILE* f;\n\n    char line[1024];\n\n    char  cmd[1024];\n\n    FFServerIPAddressACL *acl = NULL;\n\n    int line_num = 0;\n\n    const char *p;\n\n\n\n    f = fopen(stream->dynamic_acl, \"r\");\n\n    if (!f) {\n\n        perror(stream->dynamic_acl);\n\n        return NULL;\n\n    }\n\n\n\n    acl = av_mallocz(sizeof(FFServerIPAddressACL));\n\n\n\n    /* Build ACL */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL)\n\n            break;\n\n        line_num++;\n\n        p = line;\n\n        while (av_isspace(*p))\n\n            p++;\n\n        if (*p == '\\0' || *p == '#')\n\n            continue;\n\n        ffserver_get_arg(cmd, sizeof(cmd), &p);\n\n\n\n        if (!av_strcasecmp(cmd, \"ACL\"))\n\n            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);\n\n    }\n\n    fclose(f);\n\n    return acl;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2589, "prediction": "0", "true_label": "0", "raw_text": "Question: static int discard_f(BlockBackend *blk, int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, qflag = 0;\n\n    int c, ret;\n\n    int64_t offset, count;\n\n\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n\n        switch (c) {\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return qemuio_command_usage(&discard_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return qemuio_command_usage(&discard_cmd);\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        print_cvtnum_err(offset, argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        print_cvtnum_err(count, argv[optind]);\n\n        return 0;\n\n    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {\n\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n\n               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,\n\n               argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    gettimeofday(&t1, NULL);\n\n    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,\n\n                      count >> BDRV_SECTOR_BITS);\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    if (!qflag) {\n\n        t2 = tsub(t2, t1);\n\n        print_report(\"discard\", &t2, offset, count, count, 1, Cflag);\n\n    }\n\n\n\nout:\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2590, "prediction": "0", "true_label": "0", "raw_text": "Question: void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,\n\n                             hwaddr size)\n\n{\n\n    assert(mr->terminates);\n\n    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,\n\n                                        memory_region_get_dirty_log_mask(mr));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2591, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vnc_display_print_local_addr(VncDisplay *vd)\n\n{\n\n    SocketAddressLegacy *addr;\n\n    Error *err = NULL;\n\n\n\n    if (!vd->nlsock) {\n\n        return;\n\n    }\n\n\n\n    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);\n\n    if (!addr) {\n\n        return;\n\n    }\n\n\n\n    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {\n\n        qapi_free_SocketAddressLegacy(addr);\n\n        return;\n\n    }\n\n    error_printf_unless_qmp(\"VNC server running on %s:%s\\n\",\n\n                            addr->u.inet.data->host,\n\n                            addr->u.inet.data->port);\n\n    qapi_free_SocketAddressLegacy(addr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2592, "prediction": "0", "true_label": "0", "raw_text": "Question: static int v9fs_synth_lstat(FsContext *fs_ctx,\n\n                            V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;\n\n\n\n    v9fs_synth_fill_statbuf(node, stbuf);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2593, "prediction": "0", "true_label": "1", "raw_text": "Question: static av_cold int qsv_decode_close(AVCodecContext *avctx)\n{\n    QSVOtherContext *s = avctx->priv_data;\n    ff_qsv_decode_close(&s->qsv);\n    qsv_clear_buffers(s);\n    av_fifo_free(s->packet_fifo);\n    return 0;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2594, "prediction": "0", "true_label": "1", "raw_text": "\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->cancel_overrides)\n\n                        callbacks->cancel_overrides(priv, tmp);\n\n                } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n\n                           sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n\n                } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n\n                } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->origin)\n\n                        callbacks->origin(priv, x1, y1);\n\n                } else {\n\n                    len = strcspn(buf+1, \"\\\\}\") + 2;  /* skip unknown code */\n\n                }\n\n                buf += len - 1;\n\n            }\n\n            if (*buf++ != '}')\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            if (!text) {\n\n                text = buf;\n\n                text_len = 1;\n\n            } else\n\n                text_len++;\n\n            buf++;\n\n        }\n\n    }\n\n    if (text && callbacks->text)\n\n        callbacks->text(priv, text, text_len);\n\n    if (callbacks->end)\n\n        callbacks->end(priv);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2595, "prediction": "0", "true_label": "1", "raw_text": " 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            assert(0); //cannot happen\n\n            code = 0;           /* kill warning */\n\n        }\n\n\n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j,\n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2596, "prediction": "0", "true_label": "0", "raw_text": "Question: static void armv7m_nvic_clear_pending(void *opaque, int irq)\n\n{\n\n    NVICState *s = (NVICState *)opaque;\n\n    VecInfo *vec;\n\n\n\n    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);\n\n\n\n    vec = &s->vectors[irq];\n\n    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);\n\n    if (vec->pending) {\n\n        vec->pending = 0;\n\n        nvic_irq_update(s);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2597, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vararg_string(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *decoded;\n\n    } test_cases[] = {\n\n        { \"hello world\" },\n\n        { \"the quick brown fox jumped over the fence\" },\n\n        {}\n\n    };\n\n\n\n    for (i = 0; test_cases[i].decoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_jsonf(\"%s\", test_cases[i].decoded);\n\n\n\n        g_assert(obj != NULL);\n\n        g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n        \n\n        str = qobject_to_qstring(obj);\n\n        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);\n\n\n\n        QDECREF(str);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2598, "prediction": "0", "true_label": "0", "raw_text": "Question: static int scsi_qdev_exit(DeviceState *qdev)\n\n{\n\n    SCSIDevice *dev = SCSI_DEVICE(qdev);\n\n\n\n    if (dev->vmsentry) {\n\n        qemu_del_vm_change_state_handler(dev->vmsentry);\n\n    }\n\n    scsi_device_destroy(dev);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2599, "prediction": "0", "true_label": "0", "raw_text": ", we want to allocate the palette on our own because AVSubtitle works this way\n\n    sub_rect->pict.data[1] = NULL;\n\n\n\n    vbi_draw_vt_page_region(page, VBI_PIXFMT_PAL8,\n\n                            sub_rect->pict.data[0], sub_rect->pict.linesize[0],\n\n                            0, chop_top, page->columns, page->rows - chop_top,\n\n                            /*reveal*/ 1, /*flash*/ 1);\n\n\n\n    fix_transparency(ctx, sub_rect, page, chop_top, cmax, resx, resy);\n\n    sub_rect->x = ctx->x_offset;\n\n    sub_rect->y = ctx->y_offset + chop_top * BITMAP_CHAR_HEIGHT;\n\n    sub_rect->w = resx;\n\n    sub_rect->h = resy;\n\n    sub_rect->nb_colors = (int)cmax + 1;\n\n    sub_rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n    if (!sub_rect->pict.data[1]) {\n\n        av_freep(&sub_rect->pict.data[0]);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    for (ci = 0; ci < cmax; ci++) {\n\n        int r, g, b, a;\n\n\n\n        r = VBI_R(page->color_map[ci]);\n\n        g = VBI_G(page->color_map[ci]);\n\n        b = VBI_B(page->color_map[ci]);\n\n        a = VBI_A(page->color_map[ci]);\n\n        ((uint32_t *)sub_rect->pict.data[1])[ci] = RGBA(r, g, b, a);\n\n        av_dlog(ctx, \"palette %0x\\n\", ((uint32_t *)sub_rect->pict.data[1])[ci]);\n\n    }\n\n    ((uint32_t *)sub_rect->pict.data[1])[cmax] = RGBA(0, 0, 0, 0);\n\n    sub_rect->type = SUBTITLE_BITMAP;\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2600, "prediction": "0", "true_label": "1", "raw_text": "SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||\n\n        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&\n\n         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))\n\n        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));\n\n    if ((of = av_opt_find(&fc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))\n\n        av_dict_set(&format_opts, opt, arg, FLAGS(of));\n\n#if CONFIG_SWSCALE\n\n    sc = sws_get_class();\n\n    if ((os = av_opt_find(&sc, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        // XXX we only support sws_flags, not arbitrary sws options\n\n        int ret = av_opt_set(sws_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n#endif\n\n    swr_class = swr_get_class();\n\n    if (!oc && !of && !os && (oswr = av_opt_find(&swr_class, opt, NULL, 0,\n\n                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ))) {\n\n        int ret = av_opt_set(swr_opts, opt, arg, 0);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Error setting option %s.\\n\", opt);\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    if (oc || of || os || oswr)\n\n        return 0;\n\n    av_log(NULL, AV_LOG_ERROR, \"Unrecognized option '%s'\\n\", opt);\n\n    return AVERROR_OPTION_NOT_FOUND;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2601, "prediction": "0", "true_label": "1", "raw_text": "Question: static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2602, "prediction": "0", "true_label": "1", "raw_text": "Question: int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)\n\n{\n\n    if (!mb_x) {\n\n        return mb_y ? VERT_VP8_PRED : DC_129_PRED;\n\n    } else {\n\n        return mb_y ? mode : HOR_VP8_PRED;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2603, "prediction": "0", "true_label": "1", "raw_text": " exact_rational){\n\n    soxr_error_t error;\n\n\n\n    soxr_datatype_t type =\n\n        format == AV_SAMPLE_FMT_S16P? SOXR_INT16_S :\n\n        format == AV_SAMPLE_FMT_S16 ? SOXR_INT16_I :\n\n        format == AV_SAMPLE_FMT_S32P? SOXR_INT32_S :\n\n        format == AV_SAMPLE_FMT_S32 ? SOXR_INT32_I :\n\n        format == AV_SAMPLE_FMT_FLTP? SOXR_FLOAT32_S :\n\n        format == AV_SAMPLE_FMT_FLT ? SOXR_FLOAT32_I :\n\n        format == AV_SAMPLE_FMT_DBLP? SOXR_FLOAT64_S :\n\n        format == AV_SAMPLE_FMT_DBL ? SOXR_FLOAT64_I : (soxr_datatype_t)-1;\n\n\n\n    soxr_io_spec_t io_spec = soxr_io_spec(type, type);\n\n\n\n    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);\n\n    q_spec.precision = linear? 0 : precision;\n\n#if !defined SOXR_VERSION /* Deprecated @ March 2013: */\n\n    q_spec.bw_pc = cutoff? FFMAX(FFMIN(cutoff,.995),.8)*100 : q_spec.bw_pc;\n\n#else\n\n    q_spec.passband_end = cutoff? FFMAX(FFMIN(cutoff,.995),.8) : q_spec.passband_end;\n\n#endif\n\n\n\n    soxr_delete((soxr_t)c);\n\n    c = (struct ResampleContext *)\n\n        soxr_create(in_rate, out_rate, 0, &error, &io_spec, &q_spec, 0);\n\n    if (!c)\n\n        av_log(NULL, AV_LOG_ERROR, \"soxr_create: %s\\n\", error);\n\n    return c;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2604, "prediction": "0", "true_label": "0", "raw_text": "Question: static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2605, "prediction": "1", "true_label": "0", "raw_text": "Question: static void qemu_clock_init(QEMUClockType type)\n\n{\n\n    QEMUClock *clock = qemu_clock_ptr(type);\n\n\n\n    /* Assert that the clock of type TYPE has not been initialized yet. */\n\n    assert(main_loop_tlg.tl[type] == NULL);\n\n\n\n    clock->type = type;\n\n    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);\n\n    clock->last = INT64_MIN;\n\n    QLIST_INIT(&clock->timerlists);\n\n    notifier_list_init(&clock->reset_notifiers);\n\n    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2606, "prediction": "0", "true_label": "1", "raw_text": "Question: static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    PtyCharDriver *s;\n\n    struct termios tty;\n\n    int master_fd, slave_fd, len;\n\n#if defined(__OpenBSD__) || defined(__DragonFly__)\n\n    char pty_name[PATH_MAX];\n\n#define q_ptsname(x) pty_name\n\n#else\n\n    char *pty_name = NULL;\n\n#define q_ptsname(x) ptsname(x)\n\n#endif\n\n\n\n    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {\n\n        return NULL;\n\n    }\n\n\n\n    /* Set raw attributes on the pty. */\n\n    tcgetattr(slave_fd, &tty);\n\n    cfmakeraw(&tty);\n\n    tcsetattr(slave_fd, TCSAFLUSH, &tty);\n\n    close(slave_fd);\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    len = strlen(q_ptsname(master_fd)) + 5;\n\n    chr->filename = g_malloc(len);\n\n    snprintf(chr->filename, len, \"pty:%s\", q_ptsname(master_fd));\n\n    qemu_opt_set(opts, \"path\", q_ptsname(master_fd));\n\n    fprintf(stderr, \"char device redirected to %s\\n\", q_ptsname(master_fd));\n\n\n\n    s = g_malloc0(sizeof(PtyCharDriver));\n\n    chr->opaque = s;\n\n    chr->chr_write = pty_chr_write;\n\n    chr->chr_update_read_handler = pty_chr_update_read_handler;\n\n    chr->chr_close = pty_chr_close;\n\n\n\n    s->fd = master_fd;\n\n    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);\n\n\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2607, "prediction": "1", "true_label": "0", "raw_text": "Question: uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2608, "prediction": "0", "true_label": "0", "raw_text": " 7;\n\n            int U  = ubuf1[i]        >> 7;\n\n            int V  = vbuf1[i]        >> 7;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    } else {\n\n        for (i = 0; i < (dstW >> 1); i++) {\n\n            int Y1 =  buf0[i * 2]          >> 7;\n\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n\n            int A1, A2;\n\n            const void *r =  c->table_rV[V],\n\n                       *g = (c->table_gU[U] + c->table_gV[V]),\n\n                       *b =  c->table_bU[U];\n\n\n\n            if (hasAlpha) {\n\n                A1 = abuf0[i * 2    ] >> 7;\n\n                A2 = abuf0[i * 2 + 1] >> 7;\n\n            }\n\n\n\n            yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                          r, g, b, y, target, hasAlpha);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2609, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,\n\n                void *src)\n\n{\n\n    int result = 0;\n\n\n\n    if (secn > 0) {\n\n        uint32_t size = (uint32_t)secn * 512;\n\n        const uint8_t *sp = (const uint8_t *)src;\n\n        uint8_t *dp = 0;\n\n        if (s->bdrv_cur) {\n\n            dp = g_malloc(size);\n\n            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {\n\n                result = 1;\n\n            }\n\n        } else {\n\n            if (sec + secn > s->secs_cur) {\n\n                result = 1;\n\n            } else {\n\n                dp = (uint8_t *)s->current + (sec << 9);\n\n            }\n\n        }\n\n        if (!result) {\n\n            uint32_t i;\n\n            for (i = 0; i < size; i++) {\n\n                dp[i] &= sp[i];\n\n            }\n\n            if (s->bdrv_cur) {\n\n                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;\n\n            }\n\n        }\n\n        if (dp && s->bdrv_cur) {\n\n            g_free(dp);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2610, "prediction": "1", "true_label": "0", "raw_text": "len != 0) {\n\n            error_setg(errp, \"length too long for option end\");\n\n            return -1;\n\n        }\n\n    } else if (type == NBD_REP_SERVER) {\n\n        if (len < sizeof(namelen) || len > NBD_MAX_BUFFER_SIZE) {\n\n            error_setg(errp, \"incorrect option length\");\n\n            return -1;\n\n        }\n\n        if (read_sync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) {\n\n            error_setg(errp, \"failed to read option name length\");\n\n            return -1;\n\n        }\n\n        namelen = be32_to_cpu(namelen);\n\n        len -= sizeof(namelen);\n\n        if (len < namelen) {\n\n            error_setg(errp, \"incorrect option name length\");\n\n            return -1;\n\n        }\n\n        if (namelen > 255) {\n\n            error_setg(errp, \"export name length too long %\" PRIu32, namelen);\n\n            return -1;\n\n        }\n\n\n\n        *name = g_new0(char, namelen + 1);\n\n        if (read_sync(ioc, *name, namelen) != namelen) {\n\n            error_setg(errp, \"failed to read export name\");\n\n            g_free(*name);\n\n            *name = NULL;\n\n            return -1;\n\n        }\n\n        (*name)[namelen] = '\\0';\n\n        len -= namelen;\n\n        if (len) {\n\n            char *buf = g_malloc(len + 1);\n\n            if (read_sync(ioc, buf, len) != len) {\n\n                error_setg(errp, \"failed to read export description\");\n\n                g_free(*name);\n\n                g_free(buf);\n\n                *name = NULL;\n\n                return -1;\n\n            }\n\n            buf[len] = '\\0';\n\n            TRACE(\"Ignoring export description: %s\", buf);\n\n            g_free(buf);\n\n        }\n\n    } else {\n\n        error_setg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\",\n\n                   type, NBD_REP_SERVER);\n\n        return -1;\n\n    }\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2611, "prediction": "0", "true_label": "1", "raw_text": "priv;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n\n    AVFilterFormats *input_formats = NULL;\n\n    int err, i;\n\n\n\n    if (!avctx->hw_device_ctx) {\n\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n\n               \"to upload frames to.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n\n    if (!ctx->hwdevice_ref)\n\n        return AVERROR(ENOMEM);\n\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n\n    if (!constraints) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n\n    output_pix_fmts = constraints->valid_hw_formats;\n\n\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n\n    if (!input_formats) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if (input_pix_fmts) {\n\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n\n            if (err < 0) {\n\n                ff_formats_unref(&input_formats);\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);\n\n\n\n    ff_formats_ref(ff_make_format_list(output_pix_fmts),\n\n                   &avctx->outputs[0]->in_formats);\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&ctx->hwdevice_ref);\n\n    av_hwframe_constraints_free(&constraints);\n\n    return err;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2612, "prediction": "0", "true_label": "1", "raw_text": "Question: void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)\n\n{\n\n    va_list ap;\n\n    char *msg1, *msg2;\n\n\n\n    if (errp == NULL) {\n\n        return;\n\n    }\n\n\n\n    va_start(ap, fmt);\n\n    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);\n\n    va_end(ap);\n\n\n\n    if (win32_err != 0) {\n\n        msg1 = (*errp)->msg;\n\n        msg2 = g_win32_error_message(win32_err);\n\n        (*errp)->msg = g_strdup_printf(\"%s: %s (error: %x)\", msg1, msg2,\n\n                                       (unsigned)win32_err);\n\n        g_free(msg2);\n\n        g_free(msg1);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2613, "prediction": "0", "true_label": "1", "raw_text": "pos >> hshift, s->v_edge_pos >> vshift,\n\n                          EDGE_WIDTH >> hshift, EDGE_WIDTH >> vshift,\n\n                          EDGE_TOP | EDGE_BOTTOM);\n\n    }\n\n\n\n    emms_c();\n\n\n\n    s->last_pict_type                 = s->pict_type;\n\n    s->last_lambda_for [s->pict_type] = s->current_picture_ptr->f.quality;\n\n    if (s->pict_type!= AV_PICTURE_TYPE_B) {\n\n        s->last_non_b_pict_type = s->pict_type;\n\n    }\n\n#if 0\n\n    /* copy back current_picture variables */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (s->picture[i].f.data[0] == s->current_picture.f.data[0]) {\n\n            s->picture[i] = s->current_picture;\n\n            break;\n\n        }\n\n    }\n\n    assert(i < MAX_PICTURE_COUNT);\n\n#endif\n\n\n\n    if (s->encoding) {\n\n        /* release non-reference frames */\n\n        for (i = 0; i < s->picture_count; i++) {\n\n            if (s->picture[i].f.data[0] && !s->picture[i].f.reference\n\n                /* && s->picture[i].type != FF_BUFFER_TYPE_SHARED */) {\n\n                free_frame_buffer(s, &s->picture[i]);\n\n            }\n\n        }\n\n    }\n\n    // clear copies, to avoid confusion\n\n#if 0\n\n    memset(&s->last_picture,    0, sizeof(Picture));\n\n    memset(&s->next_picture,    0, sizeof(Picture));\n\n    memset(&s->current_picture, 0, sizeof(Picture));\n\n#endif\n\n    s->avctx->coded_frame = &s->current_picture_ptr->f;\n\n\n\n    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.f.reference) {\n\n        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2614, "prediction": "0", "true_label": "0", "raw_text": "Question: int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2615, "prediction": "0", "true_label": "0", "raw_text": "Question: void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2616, "prediction": "0", "true_label": "0", "raw_text": "Question: static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2617, "prediction": "0", "true_label": "1", "raw_text": "Question: long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2618, "prediction": "0", "true_label": "0", "raw_text": "Question: static void apic_reset_common(DeviceState *dev)\n\n{\n\n    APICCommonState *s = APIC_COMMON(dev);\n\n    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);\n\n    bool bsp;\n\n\n\n    bsp = cpu_is_bsp(s->cpu);\n\n    s->apicbase = APIC_DEFAULT_ADDRESS |\n\n        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;\n\n\n\n    s->vapic_paddr = 0;\n\n    info->vapic_base_update(s);\n\n\n\n    apic_init_reset(dev);\n\n\n\n    if (bsp) {\n\n        /*\n\n         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization\n\n         * time typically by BIOS, so PIC interrupt can be delivered to the\n\n         * processor when local APIC is enabled.\n\n         */\n\n        s->lvt[APIC_LVT_LINT0] = 0x700;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2619, "prediction": "0", "true_label": "0", "raw_text": "Question: static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,\n\n                omap_clk clk)\n\n{\n\n    int iomemtype;\n\n\n\n    s->pwt.base = base;\n\n    s->pwt.clk = clk;\n\n    omap_pwt_reset(s);\n\n\n\n    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,\n\n                    omap_pwt_writefn, s);\n\n    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2620, "prediction": "0", "true_label": "0", "raw_text": "Question: int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n\n                                        int y, int w, int h)\n\n{\n\n    int i, j;\n\n    int has_fg, has_bg;\n\n    uint8_t *last_fg, *last_bg;\n\n    VncDisplay *vd = vs->vd;\n\n\n\n    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n\n    has_fg = has_bg = 0;\n\n    for (j = y; j < (y + h); j += 16) {\n\n        for (i = x; i < (x + w); i += 16) {\n\n            vs->send_hextile_tile(vs, i, j,\n\n                                  MIN(16, x + w - i), MIN(16, y + h - j),\n\n                                  last_bg, last_fg, &has_bg, &has_fg);\n\n        }\n\n    }\n\n    free(last_fg);\n\n    free(last_bg);\n\n\n\n    return 1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2621, "prediction": "0", "true_label": "0", "raw_text": "Question: static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,\n\n                        uint8_t *buf, int nb_sectors)\n\n{\n\n    int async_ret;\n\n    BlockDriverAIOCB *acb;\n\n    struct iovec iov;\n\n    QEMUIOVector qiov;\n\n\n\n    async_ret = NOT_DONE;\n\n    iov.iov_base = (void *)buf;\n\n    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;\n\n    qemu_iovec_init_external(&qiov, &iov, 1);\n\n\n\n    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,\n\n                                  bdrv_rw_em_cb, &async_ret);\n\n    if (acb == NULL) {\n\n        async_ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    while (async_ret == NOT_DONE) {\n\n        qemu_aio_wait();\n\n    }\n\n\n\n\n\nfail:\n\n    return async_ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2622, "prediction": "0", "true_label": "0", "raw_text": "), KVM_GET_SREGS, &sregs);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    if (!env->external_htab) {\n\n        ppc_store_sdr1(env, sregs.u.s.sdr1);\n\n    }\n\n\n\n    /* Sync SLB */\n\n#ifdef TARGET_PPC64\n\n    /*\n\n     * The packed SLB array we get from KVM_GET_SREGS only contains\n\n     * information about valid entries. So we flush our internal copy\n\n     * to get rid of stale ones, then put all valid SLB entries back\n\n     * in.\n\n     */\n\n    memset(env->slb, 0, sizeof(env->slb));\n\n    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {\n\n        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;\n\n        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;\n\n        /*\n\n         * Only restore valid entries\n\n         */\n\n        if (rb & SLB_ESID_V) {\n\n            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Sync SRs */\n\n    for (i = 0; i < 16; i++) {\n\n        env->sr[i] = sregs.u.s.ppc32.sr[i];\n\n    }\n\n\n\n    /* Sync BATs */\n\n    for (i = 0; i < 8; i++) {\n\n        env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff;\n\n        env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32;\n\n        env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff;\n\n        env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2623, "prediction": "0", "true_label": "0", "raw_text": "[0], PL011_ARM);\n\n    pl011_init(0x17000000, pic[2], serial_hds[1], PL011_ARM);\n\n    icp_control_init(0xcb000000);\n\n    pl050_init(0x18000000, pic[3], 0);\n\n    pl050_init(0x19000000, pic[4], 1);\n\n    sd = drive_get_index(IF_SD, 0, 0);\n\n    if (sd == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x1c000000, drives_table[sd].bdrv, pic[23], pic[24]);\n\n    if (nd_table[0].vlan) {\n\n        if (nd_table[0].model == NULL\n\n            || strcmp(nd_table[0].model, \"smc91c111\") == 0) {\n\n            smc91c111_init(&nd_table[0], 0xc8000000, pic[27]);\n\n        } else if (strcmp(nd_table[0].model, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\");\n\n            exit (1);\n\n        } else {\n\n            fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", nd_table[0].model);\n\n            exit (1);\n\n        }\n\n    }\n\n    pl110_init(ds, 0xc0000000, pic[22], 0);\n\n\n\n    integrator_binfo.ram_size = ram_size;\n\n    integrator_binfo.kernel_filename = kernel_filename;\n\n    integrator_binfo.kernel_cmdline = kernel_cmdline;\n\n    integrator_binfo.initrd_filename = initrd_filename;\n\n    arm_load_kernel(env, &integrator_binfo);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2624, "prediction": "0", "true_label": "1", "raw_text": "Question: void hmp_cont(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockInfoList *bdev_list, *bdev;\n\n    Error *err = NULL;\n\n\n\n    bdev_list = qmp_query_block(NULL);\n\n    for (bdev = bdev_list; bdev; bdev = bdev->next) {\n\n        if (key_is_missing(bdev->value)) {\n\n            monitor_read_block_device_key(mon, bdev->value->device,\n\n                                          hmp_cont_cb, NULL);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    qmp_cont(&err);\n\n    hmp_handle_error(mon, &err);\n\n\n\nout:\n\n    qapi_free_BlockInfoList(bdev_list);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2625, "prediction": "0", "true_label": "1", "raw_text": "Question: static int decode_5(SANMVideoContext *ctx)\n\n{\n\n#if HAVE_BIGENDIAN\n\n    uint16_t *frm;\n\n    int npixels;\n\n#endif\n\n    uint8_t *dst = (uint8_t*)ctx->frm0;\n\n\n\n    if (rle_decode(ctx, dst, ctx->buf_size))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n#if HAVE_BIGENDIAN\n\n    npixels = ctx->npixels;\n\n    frm = ctx->frm0;\n\n    while (npixels--)\n\n        *frm++ = av_bswap16(*frm);\n\n#endif\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2626, "prediction": "0", "true_label": "1", "raw_text": "Question: static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2627, "prediction": "0", "true_label": "1", "raw_text": "Question: static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2628, "prediction": "1", "true_label": "1", "raw_text": "Question: static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    const char *protocol  = qdict_get_str(qdict, \"protocol\");\n\n    const char *fdname = qdict_get_str(qdict, \"fdname\");\n\n    CharDriverState *s;\n\n\n\n    if (strcmp(protocol, \"spice\") == 0) {\n\n        int fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n        int tls = qdict_get_try_bool(qdict, \"tls\", 0);\n\n        if (!using_spice) {\n\n            /* correct one? spice isn't a device ,,, */\n\n            qerror_report(QERR_DEVICE_NOT_ACTIVE, \"spice\");\n\n            return -1;\n\n        }\n\n        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {\n\n            close(fd);\n\n        }\n\n        return 0;\n\n#ifdef CONFIG_VNC\n\n    } else if (strcmp(protocol, \"vnc\") == 0) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n        int skipauth = qdict_get_try_bool(qdict, \"skipauth\", 0);\n\n\tvnc_display_add_client(NULL, fd, skipauth);\n\n\treturn 0;\n\n#endif\n\n    } else if ((s = qemu_chr_find(protocol)) != NULL) {\n\n\tint fd = monitor_get_fd(mon, fdname, NULL);\n\n\tif (qemu_chr_add_client(s, fd) < 0) {\n\n\t    qerror_report(QERR_ADD_CLIENT_FAILED);\n\n\t    return -1;\n\n\t}\n\n\treturn 0;\n\n    }\n\n\n\n    qerror_report(QERR_INVALID_PARAMETER, \"protocol\");\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2629, "prediction": "1", "true_label": "1", "raw_text": "Question: static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: Yes.\n"}], [{"ID": 2630, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pm_update_sci(VT686PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0);\n\n    qemu_set_irq(s->dev.irq[0], sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2631, "prediction": "0", "true_label": "0", "raw_text": "Question: static void flat_print_key_prefix(WriterContext *wctx)\n\n{\n\n    FlatContext *flat = wctx->priv;\n\n    const struct section *parent_section = wctx->section[wctx->level-1];\n\n\n\n    printf(\"%s\", flat->section_header[wctx->level].str);\n\n\n\n    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {\n\n        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?\n\n            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];\n\n        printf(\"%d%s\", n, flat->sep_str);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2632, "prediction": "0", "true_label": "1", "raw_text": "\n\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n\n        codec->extradata_size = 0;\n\n        codec->extradata      = NULL;\n\n\n\n        while (*value) {\n\n            char base64packet[1024];\n\n            uint8_t decoded_packet[1024];\n\n            int packet_size;\n\n            char *dst = base64packet;\n\n\n\n            while (*value && *value != ','\n\n                   && (dst - base64packet) < sizeof(base64packet) - 1) {\n\n                *dst++ = *value++;\n\n            }\n\n            *dst++ = '\\0';\n\n\n\n            if (*value == ',')\n\n                value++;\n\n\n\n            packet_size = av_base64_decode(decoded_packet, base64packet,\n\n                                           sizeof(decoded_packet));\n\n            if (packet_size > 0) {\n\n                uint8_t *dest = av_malloc(packet_size + sizeof(start_sequence) +\n\n                                          codec->extradata_size +\n\n                                          FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!dest) {\n\n                    av_log(codec, AV_LOG_ERROR,\n\n                           \"Unable to allocate memory for extradata!\");\n\n                    return AVERROR(ENOMEM);\n\n                }\n\n                if (codec->extradata_size) {\n\n                    memcpy(dest, codec->extradata, codec->extradata_size);\n\n                    av_free(codec->extradata);\n\n                }\n\n\n\n                memcpy(dest + codec->extradata_size, start_sequence,\n\n                       sizeof(start_sequence));\n\n                memcpy(dest + codec->extradata_size + sizeof(start_sequence),\n\n                       decoded_packet, packet_size);\n\n                memset(dest + codec->extradata_size + sizeof(start_sequence) +\n\n                       packet_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n                codec->extradata       = dest;\n\n                codec->extradata_size += sizeof(start_sequence) + packet_size;\n\n            }\n\n        }\n\n        av_log(codec, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)!\",\n\n               codec->extradata, codec->extradata_size);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2633, "prediction": "1", "true_label": "1", "raw_text": "\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2634, "prediction": "0", "true_label": "0", "raw_text": "Question: static void idr(H264Context *h){\n\n    int i;\n\n    ff_h264_remove_all_refs(h);\n\n    h->prev_frame_num= -1;\n\n    h->prev_frame_num_offset= 0;\n\n    h->prev_poc_msb= 1<<16;\n\n    h->prev_poc_lsb= 0;\n\n    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)\n\n        h->last_pocs[i] = INT_MIN;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2635, "prediction": "0", "true_label": "0", "raw_text": "Question: static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xffffffff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2636, "prediction": "0", "true_label": "1", "raw_text": "Question: static void abort_codec_experimental(AVCodec *c, int encoder)\n\n{\n\n    const char *codec_string = encoder ? \"encoder\" : \"decoder\";\n\n    AVCodec *codec;\n\n    av_log(NULL, AV_LOG_FATAL, \"%s '%s' is experimental and might produce bad \"\n\n            \"results.\\nAdd '-strict experimental' if you want to use it.\\n\",\n\n            codec_string, c->name);\n\n    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);\n\n    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))\n\n        av_log(NULL, AV_LOG_FATAL, \"Or use the non experimental %s '%s'.\\n\",\n\n               codec_string, codec->name);\n\n    exit(1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2637, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                  const uint8_t *src, int srcW, int xInc)\n\n{\n\n    int i;\n\n    unsigned int xpos=0;\n\n    for (i=0;i<dstWidth;i++) {\n\n        register unsigned int xx=xpos>>16;\n\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n        xpos+=xInc;\n\n    }\n\n\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2638, "prediction": "0", "true_label": "1", "raw_text": "vlc = &vc9_ttmb_vlc[1];\n\n    else v->ttmb_vlc = &vc9_ttmb_vlc[2];\n\n\n\n    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)\n\n    {\n\n        /* Init CBPCY for line */\n\n        *((uint32_t*)previous_cbpcy) = 0x00000000;\n\n        p_cbpcy = v->previous_line_cbpcy+4;\n\n\n\n        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)\n\n        {\n\n            /* Get CBPCY */\n\n            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);\n\n\n\n            s->ac_pred = get_bits(gb, 1);\n\n\n\n            /* TODO: Decode blocks from that mb wrt cbpcy */\n\n\n\n            /* Update for next block */\n\n#if TRACE > 2\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,\"\n\n                   \" cbpcy=%i%i%i%i\\n\", current_mb,\n\n                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],\n\n                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],\n\n                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);\n\n#endif\n\n            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);\n\n            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);\n\n            current_mb++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2639, "prediction": "0", "true_label": "1", "raw_text": "Question: static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2640, "prediction": "0", "true_label": "0", "raw_text": "Question: dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)\n\n{\n\n        struct fs_dma_ctrl *ctrl = opaque;\n\n\tint c;\n\n\tuint32_t r = 0;\n\n\n\n\tif (size != 4) {\n\n\t\tdma_rinvalid(opaque, addr);\n\n\t}\n\n\n\n\t/* Make addr relative to this channel and bounded to nr regs.  */\n\n\tc = fs_channel(addr);\n\n\taddr &= 0xff;\n\n\taddr >>= 2;\n\n\tswitch (addr)\n\n\t{\n\n\t\tcase RW_STAT:\n\n\t\t\tr = ctrl->channels[c].state & 7;\n\n\t\t\tr |= ctrl->channels[c].eol << 5;\n\n\t\t\tr |= ctrl->channels[c].stream_cmd_src << 8;\n\n\t\t\tbreak;\n\n\n\n\t\tdefault:\n\n\t\t\tr = ctrl->channels[c].regs[addr];\n\n\t\t\tD(printf (\"%s c=%d addr=\" TARGET_FMT_plx \"\\n\",\n\n\t\t\t\t  __func__, c, addr));\n\n\t\t\tbreak;\n\n\t}\n\n\treturn r;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2641, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)\n\n{\n\n    struct pxa_frame_descriptor_s desc;\n\n    target_phys_addr_t descptr;\n\n    int i;\n\n\n\n    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {\n\n        s->dma_ch[i].source = 0;\n\n\n\n        if (!s->dma_ch[i].up)\n\n            continue;\n\n\n\n        if (s->dma_ch[i].branch & FBR_BRA) {\n\n            descptr = s->dma_ch[i].branch & FBR_SRCADDR;\n\n            if (s->dma_ch[i].branch & FBR_BINT)\n\n                pxa2xx_dma_bs_set(s, i);\n\n            s->dma_ch[i].branch &= ~FBR_BRA;\n\n        } else\n\n            descptr = s->dma_ch[i].descriptor;\n\n\n\n        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +\n\n                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))\n\n            continue;\n\n\n\n        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));\n\n        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);\n\n        s->dma_ch[i].source = tswap32(desc.fsaddr);\n\n        s->dma_ch[i].id = tswap32(desc.fidr);\n\n        s->dma_ch[i].command = tswap32(desc.ldcmd);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2642, "prediction": "0", "true_label": "0", "raw_text": "Question: int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2643, "prediction": "0", "true_label": "1", "raw_text": "Question: void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2644, "prediction": "0", "true_label": "0", "raw_text": "Question: uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)\n\n{\n\n    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);\n\n\n\n    return set_cc_nz_f32(env->fregs[f1].l.upper);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2645, "prediction": "1", "true_label": "0", "raw_text": ", \"http\", NULL)) {\n\n        ;\n\n    } else\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n\n        ;\n\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n\n        ;\n\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (c->http_persistent && *pb && av_strstart(proto_name, \"http\", NULL)) {\n\n        ret = open_url_keepalive(c->ctx, pb, url);\n\n        if (ret == AVERROR_EXIT) {\n\n            return ret;\n\n        } else if (ret < 0) {\n\n            if (ret != AVERROR_EOF)\n\n                av_log(s, AV_LOG_WARNING,\n\n                    \"keepalive request failed for '%s', retrying with new connection: %s\\n\",\n\n                    url, av_err2str(ret));\n\n            ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n        }\n\n    } else {\n\n        ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n\n    }\n\n    if (ret >= 0) {\n\n        // update cookies on http response with setcookies.\n\n        char *new_cookies = NULL;\n\n\n\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n\n\n\n        if (new_cookies) {\n\n            av_free(c->cookies);\n\n            c->cookies = new_cookies;\n\n        }\n\n\n\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n\n    }\n\n\n\n    av_dict_free(&tmp);\n\n\n\n    if (is_http)\n\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2646, "prediction": "0", "true_label": "0", "raw_text": "listen_id;\n\n    }\n\n\n\n    snprintf(port_str, 16, \"%d\", rdma->port);\n\n    port_str[15] = '\\0';\n\n\n\n    if (rdma->host && strcmp(\"\", rdma->host)) {\n\n        struct rdma_addrinfo *e;\n\n\n\n        ret = rdma_getaddrinfo(rdma->host, port_str, NULL, &res);\n\n        if (ret < 0) {\n\n            ERROR(errp, \"could not rdma_getaddrinfo address %s\", rdma->host);\n\n            goto err_dest_init_bind_addr;\n\n        }\n\n\n\n        for (e = res; e != NULL; e = e->ai_next) {\n\n            inet_ntop(e->ai_family,\n\n                &((struct sockaddr_in *) e->ai_dst_addr)->sin_addr, ip, sizeof ip);\n\n            trace_qemu_rdma_dest_init_trying(rdma->host, ip);\n\n            ret = rdma_bind_addr(listen_id, e->ai_dst_addr);\n\n            if (!ret) {\n\n                if (e->ai_family == AF_INET6) {\n\n                    ret = qemu_rdma_broken_ipv6_kernel(errp, listen_id->verbs);\n\n                    if (ret) {\n\n                        continue;\n\n                    }\n\n                }\n\n                    \n\n                goto listen;\n\n            }\n\n        }\n\n\n\n        ERROR(errp, \"Error: could not rdma_bind_addr!\");\n\n        goto err_dest_init_bind_addr;\n\n    } else {\n\n        ERROR(errp, \"migration host and port not specified!\");\n\n        ret = -EINVAL;\n\n        goto err_dest_init_bind_addr;\n\n    }\n\nlisten:\n\n\n\n    rdma->listen_id = listen_id;\n\n    qemu_rdma_dump_gid(\"dest_init\", listen_id);\n\n    return 0;\n\n\n\nerr_dest_init_bind_addr:\n\n    rdma_destroy_id(listen_id);\n\nerr_dest_init_create_listen_id:\n\n    rdma_destroy_event_channel(rdma->channel);\n\n    rdma->channel = NULL;\n\n    rdma->error_state = ret;\n\n    return ret;\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2647, "prediction": "0", "true_label": "0", "raw_text": "3];\n\n\t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];\n\n\t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];\n\n\t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];\n\n\t\tw += 16;\n\n\t}\n\n\tmlen += 32;\n\n\twhile ((mlen -= 8) >= 0) {\n\n\t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];\n\n\t\tw += 4;\n\n\t}\n\n\tmlen += 8;\n\n\tif (mlen == 0 && byte_swapped == 0)\n\n\t   goto cont;\n\n\tREDUCE;\n\n\twhile ((mlen -= 2) >= 0) {\n\n\t\tsum += *w++;\n\n\t}\n\n\n\n\tif (byte_swapped) {\n\n\t\tREDUCE;\n\n\t\tsum <<= 8;\n\n\t\tif (mlen == -1) {\n\n\t\t\ts_util.c[1] = *(uint8_t *)w;\n\n\t\t\tsum += s_util.s;\n\n\t\t\tmlen = 0;\n\n\t\t} else\n\n\n\n\t\t   mlen = -1;\n\n\t} else if (mlen == -1)\n\n\t   s_util.c[0] = *(uint8_t *)w;\n\n\n\ncont:\n\n#ifdef DEBUG\n\n\tif (len) {\n\n\t\tDEBUG_ERROR((dfd, \"cksum: out of data\\n\"));\n\n\t\tDEBUG_ERROR((dfd, \" len = %d\\n\", len));\n\n\t}\n\n#endif\n\n\tif (mlen == -1) {\n\n\t\t/* The last mbuf has odd # of bytes. Follow the\n\n\t\t standard (the odd byte may be shifted left by 8 bits\n\n\t\t\t   or not as determined by endian-ness of the machine) */\n\n\t\ts_util.c[1] = 0;\n\n\t\tsum += s_util.s;\n\n\t}\n\n\tREDUCE;\n\n\treturn (~sum & 0xffff);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2648, "prediction": "0", "true_label": "0", "raw_text": "Question: void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,\n\n                         int is_write, target_phys_addr_t access_len)\n\n{\n\n    if (buffer != bounce.buffer) {\n\n        if (is_write) {\n\n            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);\n\n            while (access_len) {\n\n                unsigned l;\n\n                l = TARGET_PAGE_SIZE;\n\n                if (l > access_len)\n\n                    l = access_len;\n\n                invalidate_and_set_dirty(addr1, l);\n\n                addr1 += l;\n\n                access_len -= l;\n\n            }\n\n        }\n\n        if (xen_enabled()) {\n\n            xen_invalidate_map_cache_entry(buffer);\n\n        }\n\n        return;\n\n    }\n\n    if (is_write) {\n\n        address_space_write(as, bounce.addr, bounce.buffer, access_len);\n\n    }\n\n    qemu_vfree(bounce.buffer);\n\n    bounce.buffer = NULL;\n\n    cpu_notify_map_clients();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2649, "prediction": "1", "true_label": "1", "raw_text": "_INVALIDDATA;\n\n    }\n\n\n\n    if (avctx->block_align >= UINT_MAX / 2)\n\n\n\n\n    q->decoded_bytes_buffer = av_mallocz(FFALIGN(avctx->block_align, 4) +\n\n                                         FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (q->decoded_bytes_buffer == NULL)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    /* initialize the MDCT transform */\n\n    if ((ret = ff_mdct_init(&q->mdct_ctx, 9, 1, 1.0 / 32768)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        av_freep(&q->decoded_bytes_buffer);\n\n        return ret;\n\n    }\n\n\n\n    /* init the joint-stereo decoding data */\n\n    q->weighting_delay[0] = 0;\n\n    q->weighting_delay[1] = 7;\n\n    q->weighting_delay[2] = 0;\n\n    q->weighting_delay[3] = 7;\n\n    q->weighting_delay[4] = 0;\n\n    q->weighting_delay[5] = 7;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        q->matrix_coeff_index_prev[i] = 3;\n\n        q->matrix_coeff_index_now[i]  = 3;\n\n        q->matrix_coeff_index_next[i] = 3;\n\n    }\n\n\n\n    avpriv_float_dsp_init(&q->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    ff_fmt_convert_init(&q->fmt_conv, avctx);\n\n\n\n    q->units = av_mallocz(sizeof(*q->units) * avctx->channels);\n\n    if (!q->units) {\n\n        atrac3_decode_close(avctx);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avcodec_get_frame_defaults(&q->frame);\n\n    avctx->coded_frame = &q->frame;\n\n\n\n    return 0;\n\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2650, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n#ifdef DEBUG_UNASSIGNED\n\n    printf(\"Unassigned mem read \" TARGET_FMT_plx \"\\n\", addr);\n\n#endif\n\n#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)\n\n    do_unassigned_access(addr, 0, 0, 0, 4);\n\n#endif\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2651, "prediction": "0", "true_label": "1", "raw_text": "Question: static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2652, "prediction": "0", "true_label": "0", "raw_text": "Question: static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2653, "prediction": "0", "true_label": "0", "raw_text": "Question: void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2654, "prediction": "0", "true_label": "0", "raw_text": "Question: static void sclp_set_write_mask(void)\n\n{\n\n    WriteEventMask *sccb = (void*)_sccb;\n\n\n\n    sccb->h.length = sizeof(WriteEventMask);\n\n    sccb->mask_length = sizeof(unsigned int);\n\n    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;\n\n\n\n    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2655, "prediction": "0", "true_label": "0", "raw_text": "Question: void json_prop_int(QJSON *json, const char *name, int64_t val)\n\n{\n\n    json_emit_element(json, name);\n\n    qstring_append_int(json->str, val);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2656, "prediction": "0", "true_label": "0", "raw_text": "Question: static void pm_update_sci(PIIX4PMState *s)\n\n{\n\n    int sci_level, pmsts;\n\n\n\n    pmsts = acpi_pm1_evt_get_sts(&s->ar);\n\n    sci_level = (((pmsts & s->ar.pm1.evt.en) &\n\n                  (ACPI_BITMASK_RT_CLOCK_ENABLE |\n\n                   ACPI_BITMASK_POWER_BUTTON_ENABLE |\n\n                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |\n\n                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||\n\n        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &\n\n          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);\n\n\n\n    qemu_set_irq(s->irq, sci_level);\n\n    /* schedule a timer interruption if needed */\n\n    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&\n\n                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2657, "prediction": "0", "true_label": "1", "raw_text": "Question: static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)\n\n{\n\n    int bit;\n\n\n\n    if(s->extra_bits){\n\n        S <<= s->extra_bits;\n\n\n\n        if(s->got_extra_bits){\n\n            S |= get_bits(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);\n\n        }\n\n    }\n\n    bit = (S & s->and) | s->or;\n\n    return (((S + bit) << s->shift) - bit) << s->post_shift;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2658, "prediction": "0", "true_label": "0", "raw_text": "\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t seconds;\n\n    MXFContext* mxf = s->priv_data;\n\n    int64_t seekpos;\n\n    int ret;\n\n    MXFIndexTable *t;\n\n\n\n    if (mxf->nb_index_tables <= 0) {\n\n    if (!s->bit_rate)\n\n        return AVERROR_INVALIDDATA;\n\n    if (sample_time < 0)\n\n        sample_time = 0;\n\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n\n\n    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)\n\n        return ret;\n\n    ff_update_cur_dts(s, st, sample_time);\n\n    mxf->current_edit_unit = sample_time;\n\n    } else {\n\n        t = &mxf->index_tables[0];\n\n\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n\n         * this also means we allow seeking before the start */\n\n        sample_time = FFMAX(sample_time, 0);\n\n\n\n        if (t->fake_index) {\n\n            /* behave as if we have a proper index */\n\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n\n                return sample_time;\n\n        } else {\n\n            /* no IndexEntryArray (one or more CBR segments)\n\n             * make sure we don't seek past the end */\n\n            sample_time = FFMIN(sample_time, st->duration - 1);\n\n        }\n\n\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)\n\n            return ret;\n\n\n\n        ff_update_cur_dts(s, st, sample_time);\n\n        mxf->current_edit_unit = sample_time;\n\n        avio_seek(s->pb, seekpos, SEEK_SET);\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2659, "prediction": "0", "true_label": "1", "raw_text": "\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2660, "prediction": "0", "true_label": "0", "raw_text": "Question: static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2661, "prediction": "0", "true_label": "0", "raw_text": "Question: float32 int32_to_float32( int32 a STATUS_PARAM )\n\n{\n\n    flag zSign;\n\n\n\n    if ( a == 0 ) return 0;\n\n    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );\n\n    zSign = ( a < 0 );\n\n    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );\n\n\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2662, "prediction": "0", "true_label": "1", "raw_text": "Question: static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2663, "prediction": "0", "true_label": "1", "raw_text": "Question: static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2664, "prediction": "0", "true_label": "0", "raw_text": "Question: void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#else\n\n    nmi_monitor_handle(monitor_get_cpu_index(), errp);\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2665, "prediction": "0", "true_label": "0", "raw_text": "Question: eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,\n\n                            void *l3hdr, size_t l3hdr_len,\n\n                            size_t l3payload_len,\n\n                            size_t frag_offset, bool more_frags)\n\n{\n\n    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {\n\n        uint16_t orig_flags;\n\n        struct ip_header *iphdr = (struct ip_header *) l3hdr;\n\n        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;\n\n        uint16_t new_ip_off;\n\n\n\n        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);\n\n        assert((frag_off_units & ~IP_OFFMASK) == 0);\n\n\n\n        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);\n\n        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);\n\n        iphdr->ip_off = cpu_to_be16(new_ip_off);\n\n        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2666, "prediction": "0", "true_label": "0", "raw_text": "Question: float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)\n\n{\n\n    return float32_sub(a, b, &env->ucf64.fp_status);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2667, "prediction": "1", "true_label": "0", "raw_text": "Question: do_cksum(uint8_t *dp, uint8_t *de)\n\n{\n\n    unsigned int bsum[2] = {0, 0}, i, sum;\n\n\n\n    for (i = 1; dp < de; bsum[i^=1] += *dp++)\n\n        ;\n\n    sum = (bsum[0] << 8) + bsum[1];\n\n    sum = (sum >> 16) + (sum & 0xffff);\n\n    return ~(sum + (sum >> 16));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2668, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ics_simple_realize(DeviceState *dev, Error **errp)\n\n{\n\n    ICSState *ics = ICS_SIMPLE(dev);\n\n\n\n    if (!ics->nr_irqs) {\n\n        error_setg(errp, \"Number of interrupts needs to be greater 0\");\n\n        return;\n\n    }\n\n    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));\n\n    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);\n\n\n\n    qemu_register_reset(ics_simple_reset, dev);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2669, "prediction": "0", "true_label": "0", "raw_text": "Question: static void vnc_flush(VncState *vs)\n\n{\n\n    if (vs->output.offset)\n\n\tvnc_client_write(vs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2670, "prediction": "0", "true_label": "0", "raw_text": "Question: static void do_subchannel_work(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    SCSW *s = &sch->curr_status.scsw;\n\n\n\n    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {\n\n        sch_handle_clear_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {\n\n        sch_handle_halt_func(sch);\n\n    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {\n\n        /* Triggered by both ssch and rsch. */\n\n        sch_handle_start_func(sch, orb);\n\n    } else {\n\n        /* Cannot happen. */\n\n        return;\n\n    }\n\n    css_inject_io_interrupt(sch);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2671, "prediction": "1", "true_label": "1", "raw_text": "DI,\n\n        .data_length = wlen,\n\n        .flags = SD_FLAG_CMD_WRITE,\n\n    };\n\n    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;\n\n\n\n    if (!remove_objects(s)) {\n\n        return -1;\n\n    }\n\n\n\n    memset(buf, 0, sizeof(buf));\n\n    memset(snap_tag, 0, sizeof(snap_tag));\n\n    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);\n\n    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);\n\n    if (ret || snap_id > UINT32_MAX) {\n\n        error_setg(errp, \"Invalid snapshot ID: %s\",\n\n                         snapshot_id ? snapshot_id : \"<null>\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (snap_id) {\n\n        hdr.snapid = (uint32_t) snap_id;\n\n    } else {\n\n        pstrcpy(snap_tag, sizeof(snap_tag), snapshot_id);\n\n        pstrcpy(buf + SD_MAX_VDI_LEN, SD_MAX_VDI_TAG_LEN, snap_tag);\n\n    }\n\n\n\n    ret = find_vdi_name(s, s->name, snap_id, snap_tag, &vid, true,\n\n                        &local_err);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    fd = connect_to_sdog(s, &local_err);\n\n    if (fd < 0) {\n\n        error_report_err(local_err);\n\n        return -1;\n\n    }\n\n\n\n    ret = do_req(fd, s->bs, (SheepdogReq *)&hdr,\n\n                 buf, &wlen, &rlen);\n\n    closesocket(fd);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    switch (rsp->result) {\n\n    case SD_RES_NO_VDI:\n\n        error_report(\"%s was already deleted\", s->name);\n\n    case SD_RES_SUCCESS:\n\n        break;\n\n    default:\n\n        error_report(\"%s, %s\", sd_strerror(rsp->result), s->name);\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2672, "prediction": "0", "true_label": "1", "raw_text": "Question: static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2673, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)\n\n{\n\n    int i, n, n2;\n\n    float alpha;\n\n\n\n    n  = 1 << ln;\n\n    n2 = n >> 1;\n\n\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);\n\n    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);\n\n\n\n    for (i = 0; i < n2; i++) {\n\n        alpha     = 2.0 * M_PI * i / n;\n\n        mdct->costab[i] = FIX15(cos(alpha));\n\n        mdct->sintab[i] = FIX15(sin(alpha));\n\n    }\n\n\n\n    return 0;\n\nfft_alloc_fail:\n\n    mdct_end(mdct);\n\n    return AVERROR(ENOMEM);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2674, "prediction": "0", "true_label": "1", "raw_text": "\\n\", insn, insn_count);\n\n#endif\n\n        num_insns++;\n\n        ctx.pc += 4;\n\n        ret = translate_one(ctxp, insn);\n\n        if (ret != 0)\n\n            break;\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (((ctx.pc & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n            num_insns >= max_insns) {\n\n            break;\n\n        }\n\n\n\n        if (env->singlestep_enabled) {\n\n            gen_excp(&ctx, EXCP_DEBUG, 0);\n\n            break;\n\n\t}\n\n\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ret != 1 && ret != 3) {\n\n        tcg_gen_movi_i64(cpu_pc, ctx.pc);\n\n    }\n\n#if defined (DO_TB_FLUSH)\n\n    gen_helper_tb_flush();\n\n#endif\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Generate the return instruction */\n\n    tcg_gen_exit_tb(0);\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = ctx.pc - pc_start;\n\n        tb->icount = num_insns;\n\n    }\n\n#if defined ALPHA_DEBUG_DISAS\n\n    log_cpu_state_mask(CPU_LOG_TB_CPU, env, 0);\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n\n        log_target_disas(pc_start, ctx.pc - pc_start, 1);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2675, "prediction": "0", "true_label": "1", "raw_text": "Question: VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2676, "prediction": "0", "true_label": "1", "raw_text": "Question: static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2677, "prediction": "0", "true_label": "1", "raw_text": "Question: static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2678, "prediction": "0", "true_label": "0", "raw_text": "_psd[bin] - s->slow_gain);\n\n            excite[bin] = FFMAX(fastleak - lowcomp, slowleak);\n\n        }\n\n        begin = 22;\n\n    } else {\n\n        /* coupling channel */\n\n        begin = bndstrt;\n\n\n\n        fastleak = (s->cpl_fast_leak << 8) + 768;\n\n        slowleak = (s->cpl_slow_leak << 8) + 768;\n\n    }\n\n\n\n    for (bin = begin; bin < bndend; bin++) {\n\n        fastleak = FFMAX(fastleak - s->fast_decay, band_psd[bin] - fast_gain);\n\n        slowleak = FFMAX(slowleak - s->slow_decay, band_psd[bin] - s->slow_gain);\n\n        excite[bin] = FFMAX(fastleak, slowleak);\n\n    }\n\n\n\n    /* compute masking curve */\n\n\n\n    for (bin = bndstrt; bin < bndend; bin++) {\n\n        tmp = s->db_per_bit - band_psd[bin];\n\n        if (tmp > 0) {\n\n            excite[bin] += tmp >> 2;\n\n        }\n\n        mask[bin] = FFMAX(ff_ac3_hearing_threshold_tab[bin >> s->sr_shift][s->sr_code], excite[bin]);\n\n    }\n\n\n\n    /* delta bit allocation */\n\n\n\n    if (dba_mode == DBA_REUSE || dba_mode == DBA_NEW) {\n\n        int band, seg, delta;\n\n        band = 0;\n\n        for (seg = 0; seg < FFMIN(8, dba_nsegs); seg++) {\n\n            band = FFMIN(49, band + dba_offsets[seg]);\n\n            if (dba_values[seg] >= 4) {\n\n                delta = (dba_values[seg] - 3) << 7;\n\n            } else {\n\n                delta = (dba_values[seg] - 4) << 7;\n\n            }\n\n            for (k = 0; k < dba_lengths[seg]; k++) {\n\n                mask[band] += delta;\n\n                band++;\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2679, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2680, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)\n\n{\n\n\tif (dc->flagx_known) {\n\n\t\tif (dc->flags_x) {\n\n\t\t\tTCGv c;\n\n            \n\n\t\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\tt_gen_mov_TN_preg(c, PR_CCS);\n\n\t\t\t/* C flag is already at bit 0.  */\n\n\t\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\t\ttcg_gen_add_tl(d, d, c);\n\n\t\t\ttcg_temp_free(c);\n\n\t\t}\n\n\t} else {\n\n\t\tTCGv x, c;\n\n\n\n\t\tx = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tc = tcg_temp_new(TCG_TYPE_TL);\n\n\t\tt_gen_mov_TN_preg(x, PR_CCS);\n\n\t\ttcg_gen_mov_tl(c, x);\n\n\n\n\t\t/* Propagate carry into d if X is set. Branch free.  */\n\n\t\ttcg_gen_andi_tl(c, c, C_FLAG);\n\n\t\ttcg_gen_andi_tl(x, x, X_FLAG);\n\n\t\ttcg_gen_shri_tl(x, x, 4);\n\n\n\n\t\ttcg_gen_and_tl(x, x, c);\n\n\t\ttcg_gen_add_tl(d, d, x);        \n\n\t\ttcg_temp_free(x);\n\n\t\ttcg_temp_free(c);\n\n\t}\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2681, "prediction": "0", "true_label": "0", "raw_text": "Question: static void rtas_start_cpu(sPAPREnvironment *spapr,\n\n                           uint32_t token, uint32_t nargs,\n\n                           target_ulong args,\n\n                           uint32_t nret, target_ulong rets)\n\n{\n\n    target_ulong id, start, r3;\n\n    CPUState *cs;\n\n\n\n    if (nargs != 3 || nret != 1) {\n\n        rtas_st(rets, 0, -3);\n\n        return;\n\n    }\n\n\n\n    id = rtas_ld(args, 0);\n\n    start = rtas_ld(args, 1);\n\n    r3 = rtas_ld(args, 2);\n\n\n\n    cs = qemu_get_cpu(id);\n\n    if (cs != NULL) {\n\n        PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n        CPUPPCState *env = &cpu->env;\n\n\n\n        if (!cs->halted) {\n\n            rtas_st(rets, 0, -1);\n\n            return;\n\n        }\n\n\n\n        /* This will make sure qemu state is up to date with kvm, and\n\n         * mark it dirty so our changes get flushed back before the\n\n         * new cpu enters */\n\n        kvm_cpu_synchronize_state(cs);\n\n\n\n        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);\n\n        env->nip = start;\n\n        env->gpr[3] = r3;\n\n        cs->halted = 0;\n\n\n\n        qemu_cpu_kick(cs);\n\n\n\n        rtas_st(rets, 0, 0);\n\n        return;\n\n    }\n\n\n\n    /* Didn't find a matching cpu */\n\n    rtas_st(rets, 0, -3);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2682, "prediction": "1", "true_label": "0", "raw_text": "Question: int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES\n"}], [{"ID": 2683, "prediction": "0", "true_label": "0", "raw_text": " (avctx->reget_buffer(avctx, &s->frame)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    compr = AV_RL32(buf);\n\n    buf += 4;\n\n    buf_size -= 4;\n\n    switch (avctx->codec_tag) {\n\n    case MKTAG('A', 'A', 'S', '4'):\n\n        bytestream2_init(&s->gb, buf - 4, buf_size + 4);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    case MKTAG('A', 'A', 'S', 'C'):\n\n    switch(compr){\n\n    case 0:\n\n        stride = (avctx->width * 3 + 3) & ~3;\n\n        for(i = avctx->height - 1; i >= 0; i--){\n\n            if(avctx->width*3 > buf_size){\n\n                av_log(avctx, AV_LOG_ERROR, \"Next line is beyond buffer bounds\\n\");\n\n                break;\n\n            }\n\n            memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);\n\n            buf += stride;\n\n            buf_size -= stride;\n\n        }\n\n        break;\n\n    case 1:\n\n        bytestream2_init(&s->gb, buf, buf_size);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type %d\\n\", compr);\n\n        return -1;\n\n    }\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown FourCC: %X\\n\", avctx->codec_tag);\n\n        return -1;\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2684, "prediction": "0", "true_label": "1", "raw_text": " h->poc_lsb;\n        }\n        h->prev_frame_num_offset = h->frame_num_offset;\n        h->prev_frame_num        = h->frame_num;\n        h->outputed_poc          = h->next_outputed_poc;\n    }\n    if (avctx->hwaccel) {\n        if (avctx->hwaccel->end_frame(avctx) < 0)\n            av_log(avctx, AV_LOG_ERROR,\n                   \"hardware accelerator failed to decode picture\\n\");\n    }\n    if (CONFIG_H264_VDPAU_DECODER &&\n        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)\n        ff_vdpau_h264_picture_complete(h);\n#if CONFIG_ERROR_RESILIENCE\n    /*\n     * FIXME: Error handling code does not seem to support interlaced\n     * when slices span multiple rows\n     * The ff_er_add_slice calls don't work right for bottom\n     * fields; they cause massive erroneous error concealing\n     * Error marking covers both fields (top and bottom).\n     * This causes a mismatched s->error_count\n     * and a bad error table. Further, the error count goes to\n     * INT_MAX when called for bottom field, because mb_y is\n     * past end by one (callers fault) and resync_mb_y != 0\n     * causes problems for the first MB line, too.\n     */\n    if (!FIELD_PICTURE(h) && h->current_slice && !h->sps.new) {\n        ff_h264_set_erpic(&h->er.cur_pic, h->cur_pic_ptr);\n        ff_er_frame_end(&h->er);\n    }\n#endif /* CONFIG_ERROR_RESILIENCE */\n    if (!in_setup && !h->droppable)\n        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                  h->picture_structure == PICT_BOTTOM_FIELD);\n    emms_c();\n    h->current_slice = 0;\n    return err;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2685, "prediction": "0", "true_label": "1", "raw_text": "Question: static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                sdhci_write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2686, "prediction": "0", "true_label": "1", "raw_text": "Question: static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2687, "prediction": "0", "true_label": "1", "raw_text": "sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5\n\n    // However the Coding Technologies decoder check uses 6 patches\n\n    if (sbr->num_patches > 6) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2688, "prediction": "0", "true_label": "0", "raw_text": "Question: static void *thread_func(void *p)\n\n{\n\n    struct thread_info *info = p;\n\n\n\n    rcu_register_thread();\n\n\n\n    atomic_inc(&n_ready_threads);\n\n    while (!atomic_mb_read(&test_start)) {\n\n        cpu_relax();\n\n    }\n\n\n\n    rcu_read_lock();\n\n    while (!atomic_read(&test_stop)) {\n\n        info->r = xorshift64star(info->r);\n\n        info->func(info);\n\n    }\n\n    rcu_read_unlock();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2689, "prediction": "0", "true_label": "0", "raw_text": "Question: static int http_start_receive_data(HTTPContext *c)\n\n{\n\n    int fd;\n\n\n\n    if (c->stream->feed_opened)\n\n        return -1;\n\n\n\n    /* Don't permit writing to this one */\n\n    if (c->stream->readonly)\n\n        return -1;\n\n\n\n    /* open feed */\n\n    fd = open(c->stream->feed_filename, O_RDWR);\n\n    if (fd < 0) {\n\n        http_log(\"Error opening feeder file: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    c->feed_fd = fd;\n\n\n\n    if (c->stream->truncate) {\n\n        /* truncate feed file */\n\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n\n        ftruncate(c->feed_fd, FFM_PACKET_SIZE);\n\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n\n    } else {\n\n        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n\n            http_log(\"Error reading write index from feed file: %s\\n\", strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n\n    lseek(fd, 0, SEEK_SET);\n\n\n\n    /* init buffer input */\n\n    c->buffer_ptr = c->buffer;\n\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n\n    c->stream->feed_opened = 1;\n\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2690, "prediction": "0", "true_label": "0", "raw_text": " }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2691, "prediction": "0", "true_label": "0", "raw_text": "reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2692, "prediction": "0", "true_label": "0", "raw_text": "Question: qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2693, "prediction": "0", "true_label": "1", "raw_text": "Question: void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2694, "prediction": "0", "true_label": "0", "raw_text": ", esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2695, "prediction": "0", "true_label": "0", "raw_text": "Question: static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2696, "prediction": "0", "true_label": "0", "raw_text": "Question: static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,\n\n                                     bool secondary, target_ulong ptem,\n\n                                     ppc_hash_pte64_t *pte)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    int i;\n\n    uint64_t token;\n\n    target_ulong pte0, pte1;\n\n    target_ulong pte_index;\n\n\n\n    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;\n\n    token = ppc_hash64_start_access(cpu, pte_index);\n\n    if (!token) {\n\n        return -1;\n\n    }\n\n    for (i = 0; i < HPTES_PER_GROUP; i++) {\n\n        pte0 = ppc_hash64_load_hpte0(cpu, token, i);\n\n        pte1 = ppc_hash64_load_hpte1(cpu, token, i);\n\n\n\n        if ((pte0 & HPTE64_V_VALID)\n\n            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))\n\n            && HPTE64_V_COMPARE(pte0, ptem)) {\n\n            pte->pte0 = pte0;\n\n            pte->pte1 = pte1;\n\n            ppc_hash64_stop_access(token);\n\n            return (pte_index + i) * HASH_PTE_SIZE_64;\n\n        }\n\n    }\n\n    ppc_hash64_stop_access(token);\n\n    /*\n\n     * We didn't find a valid entry.\n\n     */\n\n    return -1;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2697, "prediction": "0", "true_label": "0", "raw_text": "Question: static av_cold int dcadec_init(AVCodecContext *avctx)\n\n{\n\n    DCAContext *s = avctx->priv_data;\n\n\n\n    s->avctx = avctx;\n\n    s->core.avctx = avctx;\n\n    s->exss.avctx = avctx;\n\n    s->xll.avctx = avctx;\n\n    s->lbr.avctx = avctx;\n\n\n\n    ff_dca_init_vlcs();\n\n\n\n    if (ff_dca_core_init(&s->core) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (ff_dca_lbr_init(&s->lbr) < 0)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ff_dcadsp_init(&s->dcadsp);\n\n    s->core.dcadsp = &s->dcadsp;\n\n    s->xll.dcadsp = &s->dcadsp;\n\n    s->lbr.dcadsp = &s->dcadsp;\n\n\n\n    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);\n\n\n\n    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {\n\n    case 0:\n\n        s->request_channel_layout = 0;\n\n        break;\n\n    case AV_CH_LAYOUT_STEREO:\n\n    case AV_CH_LAYOUT_STEREO_DOWNMIX:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT0:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;\n\n        break;\n\n    case AV_CH_LAYOUT_5POINT1:\n\n        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT1;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_WARNING, \"Invalid request_channel_layout\\n\");\n\n        break;\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S32P;\n\n    avctx->bits_per_raw_sample = 24;\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2698, "prediction": "0", "true_label": "0", "raw_text": "gb, 8)+1;\n\n            mapping_setup->magnitude=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));\n\n            for(j=0;j<mapping_setup->coupling_steps;++j) {\n\n                mapping_setup->magnitude[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                mapping_setup->angle[j]=get_bits(gb, ilog(vc->audio_channels-1));\n\n                // FIXME: sanity checks\n\n            }\n\n        } else {\n\n            mapping_setup->coupling_steps=0;\n\n        }\n\n\n\n        AV_DEBUG(\"   %d mapping coupling steps: %d \\n\", i, mapping_setup->coupling_steps);\n\n\n\n        if(get_bits(gb, 2)) {\n\n            av_log(vc->avccontext, AV_LOG_ERROR, \"%d. mapping setup data invalid. \\n\", i);\n\n            return 1; // following spec.\n\n        }\n\n\n\n        if (mapping_setup->submaps>1) {\n\n            mapping_setup->mux=(uint_fast8_t *)av_mallocz(vc->audio_channels * sizeof(uint_fast8_t));\n\n            for(j=0;j<vc->audio_channels;++j) {\n\n                mapping_setup->mux[j]=get_bits(gb, 4);\n\n            }\n\n        }\n\n\n\n        for(j=0;j<mapping_setup->submaps;++j) {\n\n            skip_bits(gb, 8); // FIXME check?\n\n            mapping_setup->submap_floor[j]=get_bits(gb, 8);\n\n            mapping_setup->submap_residue[j]=get_bits(gb, 8);\n\n\n\n            AV_DEBUG(\"   %d mapping %d submap : floor %d, residue %d \\n\", i, j, mapping_setup->submap_floor[j], mapping_setup->submap_residue[j]);\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2699, "prediction": "0", "true_label": "1", "raw_text": "Question: void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2700, "prediction": "0", "true_label": "0", "raw_text": "6_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {\n\n                        def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    }\n\n\n\n    if (s->use_huffman) {\n\n        for (pt=0; pt<2; pt++) {\n\n            vp6_build_huff_tree(s, model->coeff_dccv[pt],\n\n                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);\n\n            vp6_build_huff_tree(s, model->coeff_runv[pt],\n\n                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);\n\n            for (ct=0; ct<3; ct++)\n\n                for (cg = 0; cg < 6; cg++)\n\n                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],\n\n                                        vp6_huff_coeff_map, 12,\n\n                                        &s->ract_vlc[pt][ct][cg]);\n\n        }\n\n        memset(s->nb_null, 0, sizeof(s->nb_null));\n\n    } else {\n\n    /* coeff_dcct is a linear combination of coeff_dccv */\n\n    for (pt=0; pt<2; pt++)\n\n        for (ctx=0; ctx<3; ctx++)\n\n            for (node=0; node<5; node++)\n\n                model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2701, "prediction": "0", "true_label": "1", "raw_text": "Question: test_opts_dict_unvisited(void)\n\n{\n\n    QemuOpts *opts;\n\n    Visitor *v;\n\n    UserDefOptions *userdef;\n\n\n\n    opts = qemu_opts_parse(qemu_find_opts(\"userdef\"), \"i64x=0,bogus=1\", false,\n\n                           &error_abort);\n\n\n\n    v = opts_visitor_new(opts);\n\n    /* BUG: bogus should be diagnosed */\n\n    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);\n\n    visit_free(v);\n\n    qemu_opts_del(opts);\n\n    qapi_free_UserDefOptions(userdef);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2702, "prediction": "0", "true_label": "0", "raw_text": "Question: static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, int *pnum)\n\n{\n\n    BDRVParallelsState *s = bs->opaque;\n\n    int64_t offset;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    offset = block_status(s, sector_num, nb_sectors, pnum);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    if (offset < 0) {\n\n        return 0;\n\n    }\n\n\n\n    return (offset << BDRV_SECTOR_BITS) |\n\n        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2703, "prediction": "0", "true_label": "0", "raw_text": " the ppc or ppc64 one\n\n     */\n\n    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {\n\n        cpu_abort(env, \"TLB size \" TARGET_FMT_lu \" < %u \"\n\n                  \"are not supported (%d)\\n\",\n\n                  tlb->size, TARGET_PAGE_SIZE, (int)((val >> 7) & 0x7));\n\n    }\n\n    tlb->EPN = val & ~(tlb->size - 1);\n\n    if (val & 0x40)\n\n        tlb->prot |= PAGE_VALID;\n\n    else\n\n        tlb->prot &= ~PAGE_VALID;\n\n    if (val & 0x20) {\n\n        /* XXX: TO BE FIXED */\n\n        cpu_abort(env, \"Little-endian TLB entries are not supported by now\\n\");\n\n    }\n\n    tlb->PID = env->spr[SPR_40x_PID]; /* PID */\n\n    LOG_SWTLB(\"%s: set up TLB %d RPN \" TARGET_FMT_plx \" EPN \" TARGET_FMT_lx\n\n              \" size \" TARGET_FMT_lx \" prot %c%c%c%c PID %d\\n\", __func__,\n\n              (int)entry, tlb->RPN, tlb->EPN, tlb->size,\n\n              tlb->prot & PAGE_READ ? 'r' : '-',\n\n              tlb->prot & PAGE_WRITE ? 'w' : '-',\n\n              tlb->prot & PAGE_EXEC ? 'x' : '-',\n\n              tlb->prot & PAGE_VALID ? 'v' : '-', (int)tlb->PID);\n\n    /* Invalidate new TLB (if valid) */\n\n    if (tlb->prot & PAGE_VALID) {\n\n        end = tlb->EPN + tlb->size;\n\n        LOG_SWTLB(\"%s: invalidate TLB %d start \" TARGET_FMT_lx \" end \"\n\n                  TARGET_FMT_lx \"\\n\", __func__, (int)entry, tlb->EPN, end);\n\n        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)\n\n            tlb_flush_page(env, page);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2704, "prediction": "0", "true_label": "1", "raw_text": "Question: static void kvm_update_msi_routes_all(void *private, bool global,\n\n                                      uint32_t index, uint32_t mask)\n\n{\n\n    int cnt = 0;\n\n    MSIRouteEntry *entry;\n\n    MSIMessage msg;\n\n    /* TODO: explicit route update */\n\n    QLIST_FOREACH(entry, &msi_route_list, list) {\n\n        cnt++;\n\n        msg = pci_get_msi_message(entry->dev, entry->vector);\n\n        kvm_irqchip_update_msi_route(kvm_state, entry->virq,\n\n                                     msg, entry->dev);\n\n    }\n\n    kvm_irqchip_commit_routes(kvm_state);\n\n    trace_kvm_x86_update_msi_routes(cnt);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2705, "prediction": "0", "true_label": "0", "raw_text": "Question: static void spr_write_601_ubatu (void *opaque, int sprn)\n\n{\n\n    DisasContext *ctx = opaque;\n\n\n\n    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);\n\n    RET_STOP(ctx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2706, "prediction": "0", "true_label": "0", "raw_text": "Question: static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2707, "prediction": "0", "true_label": "0", "raw_text": "Question: AioContext *iohandler_get_aio_context(void)\n\n{\n\n    iohandler_init();\n\n    return iohandler_ctx;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2708, "prediction": "0", "true_label": "0", "raw_text": "#endif\n\n#ifdef TARGET_NR_vmsplice\n\n\tcase TARGET_NR_vmsplice:\n\n        {\n\n            int count = arg3;\n\n            struct iovec *vec;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            if (lock_iovec(VERIFY_READ, vec, arg2, count, 1) < 0)\n\n                goto efault;\n\n            ret = get_errno(vmsplice(arg1, vec, count, arg4));\n\n            unlock_iovec(vec, arg2, count, 0);\n\n        }\n\n        break;\n\n#endif\n\n#endif /* CONFIG_SPLICE */\n\n#ifdef CONFIG_EVENTFD\n\n#if defined(TARGET_NR_eventfd)\n\n    case TARGET_NR_eventfd:\n\n        ret = get_errno(eventfd(arg1, 0));\n\n        break;\n\n#endif\n\n#if defined(TARGET_NR_eventfd2)\n\n    case TARGET_NR_eventfd2:\n\n        ret = get_errno(eventfd(arg1, arg2));\n\n        break;\n\n#endif\n\n#endif /* CONFIG_EVENTFD  */\n\n#if defined(CONFIG_FALLOCATE) && defined(TARGET_NR_fallocate)\n\n    case TARGET_NR_fallocate:\n\n        ret = get_errno(fallocate(arg1, arg2, arg3, arg4));\n\n        break;\n\n#endif\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"qemu: Unsupported syscall: %d\\n\", num);\n\n#if defined(TARGET_NR_setxattr) || defined(TARGET_NR_get_thread_area) || defined(TARGET_NR_getdomainname) || defined(TARGET_NR_set_robust_list)\n\n    unimplemented_nowarn:\n\n#endif\n\n        ret = -TARGET_ENOSYS;\n\n        break;\n\n    }\n\nfail:\n\n#ifdef DEBUG\n\n    gemu_log(\" = \" TARGET_ABI_FMT_ld \"\\n\", ret);\n\n#endif\n\n    if(do_strace)\n\n        print_syscall_ret(num, ret);\n\n    return ret;\n\nefault:\n\n    ret = -TARGET_EFAULT;\n\n    goto fail;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2709, "prediction": "0", "true_label": "0", "raw_text": " DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2710, "prediction": "1", "true_label": "1", "raw_text": "coef*)_block;\n\n    stride /= sizeof(pixel);\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: YES"}], [{"ID": 2711, "prediction": "0", "true_label": "0", "raw_text": "Question: static void disas_fp_ccomp(DisasContext *s, uint32_t insn)\n\n{\n\n    unsigned int mos, type, rm, cond, rn, op, nzcv;\n\n    TCGv_i64 tcg_flags;\n\n    int label_continue = -1;\n\n\n\n    mos = extract32(insn, 29, 3);\n\n    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */\n\n    rm = extract32(insn, 16, 5);\n\n    cond = extract32(insn, 12, 4);\n\n    rn = extract32(insn, 5, 5);\n\n    op = extract32(insn, 4, 1);\n\n    nzcv = extract32(insn, 0, 4);\n\n\n\n    if (mos || type > 1) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (!fp_access_check(s)) {\n\n        return;\n\n    }\n\n\n\n    if (cond < 0x0e) { /* not always */\n\n        int label_match = gen_new_label();\n\n        label_continue = gen_new_label();\n\n        arm_gen_test_cc(cond, label_match);\n\n        /* nomatch: */\n\n        tcg_flags = tcg_const_i64(nzcv << 28);\n\n        gen_set_nzcv(tcg_flags);\n\n        tcg_temp_free_i64(tcg_flags);\n\n        tcg_gen_br(label_continue);\n\n        gen_set_label(label_match);\n\n    }\n\n\n\n    handle_fp_compare(s, type, rn, rm, false, op);\n\n\n\n    if (cond < 0x0e) {\n\n        gen_set_label(label_continue);\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2712, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline int test_bit(unsigned int bit, const unsigned long *map)\n\n{\n\n    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2713, "prediction": "0", "true_label": "0", "raw_text": "Question: static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2714, "prediction": "0", "true_label": "1", "raw_text": "Question: static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2715, "prediction": "0", "true_label": "1", "raw_text": "_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2716, "prediction": "0", "true_label": "1", "raw_text": "Question: static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2717, "prediction": "0", "true_label": "1", "raw_text": "buf_pos);\n  buf_pos += 8;\n  hdr_pos = buf_pos;\n  if(fflags3 == 0x80) return 4;\n  if(fflags1 & 0x200) {\n    s->cur_frame = s->iv_frame + 1;\n    s->ref_frame = s->iv_frame;\n  } else {\n    s->cur_frame = s->iv_frame;\n    s->ref_frame = s->iv_frame + 1;\n  }\n  buf_pos = buf + 16 + offs1;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ybuf, s->ref_frame->Ybuf, hdr_width, \n    hdr_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(hdr_width, 160));\n  if (!(s->avctx->flags & CODEC_FLAG_GRAY))\n  {\n  buf_pos = buf + 16 + offs2;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Vbuf, s->ref_frame->Vbuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  buf_pos = buf + 16 + offs3;\n  offs = le2me_32(*(uint32_t *)buf_pos);\n  buf_pos += 4;\n  iv_Decode_Chunk(s, s->cur_frame->Ubuf, s->ref_frame->Ubuf, chroma_width, \n    chroma_height, buf_pos + offs * 2, fflags2, hdr_pos, buf_pos, \n    min(chroma_width, 40));\n  }\n  return 8;\n}\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2718, "prediction": "0", "true_label": "1", "raw_text": " != EXCP_SYSCALL_USER &&\n\n                      ctx.exception != EXCP_TRAP))) {\n\n            RET_EXCP(ctxp, EXCP_TRACE, 0);\n\n        }\n\n        /* if we reach a page boundary or are single stepping, stop\n\n         * generation\n\n         */\n\n        if (unlikely(((ctx.nip & (TARGET_PAGE_SIZE - 1)) == 0) ||\n\n                     (env->singlestep_enabled))) {\n\n            break;\n\n        }\n\n#if defined (DO_SINGLE_STEP)\n\n        break;\n\n#endif\n\n    }\n\n    if (ctx.exception == EXCP_NONE) {\n\n        gen_goto_tb(&ctx, 0, ctx.nip);\n\n    } else if (ctx.exception != EXCP_BRANCH) {\n\n        gen_op_reset_T0();\n\n        /* Generate the return instruction */\n\n        gen_op_exit_tb();\n\n    }\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (unlikely(search_pc)) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n        tb->size = 0;\n\n    } else {\n\n        tb->size = ctx.nip - pc_start;\n\n    }\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel & CPU_LOG_TB_CPU) {\n\n        fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception);\n\n        cpu_dump_state(env, logfile, fprintf, 0);\n\n    }\n\n    if (loglevel & CPU_LOG_TB_IN_ASM) {\n\n        int flags;\n\n        flags = msr_le;\n\n        fprintf(logfile, \"IN: %s\\n\", lookup_symbol(pc_start));\n\n        target_disas(logfile, pc_start, ctx.nip - pc_start, flags);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n    if (loglevel & CPU_LOG_TB_OP) {\n\n        fprintf(logfile, \"OP:\\n\");\n\n        dump_ops(gen_opc_buf, gen_opparam_buf);\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2719, "prediction": "0", "true_label": "1", "raw_text": "Question: static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2720, "prediction": "0", "true_label": "0", "raw_text": "_ver_id != 1) {\n\n            s->new_pred= get_bits1(gb);\n\n            if(s->new_pred){\n\n                printf(\"new pred not supported\\n\");\n\n                skip_bits(gb, 2); /* requested upstream message type */\n\n                skip_bits1(gb); /* newpred segment type */\n\n            }\n\n            s->reduced_res_vop= get_bits1(gb);\n\n            if(s->reduced_res_vop) printf(\"reduced resolution VOP not supported\\n\");\n\n        }\n\n        else{\n\n            s->new_pred=0;\n\n            s->reduced_res_vop= 0;\n\n        }\n\n\n\n        s->scalability= get_bits1(gb);\n\n\n\n        if (s->scalability) {\n\n            GetBitContext bak= *gb;\n\n            int ref_layer_id;\n\n            int ref_layer_sampling_dir;\n\n            int h_sampling_factor_n;\n\n            int h_sampling_factor_m;\n\n            int v_sampling_factor_n;\n\n            int v_sampling_factor_m;\n\n            \n\n            s->hierachy_type= get_bits1(gb);\n\n            ref_layer_id= get_bits(gb, 4);\n\n            ref_layer_sampling_dir= get_bits1(gb);\n\n            h_sampling_factor_n= get_bits(gb, 5);\n\n            h_sampling_factor_m= get_bits(gb, 5);\n\n            v_sampling_factor_n= get_bits(gb, 5);\n\n            v_sampling_factor_m= get_bits(gb, 5);\n\n            s->enhancement_type= get_bits1(gb);\n\n            \n\n            if(   h_sampling_factor_n==0 || h_sampling_factor_m==0 \n\n               || v_sampling_factor_n==0 || v_sampling_factor_m==0){\n\n               \n\n//                fprintf(stderr, \"illegal scalability header (VERY broken encoder), trying to workaround\\n\");\n\n                s->scalability=0;\n\n               \n\n                *gb= bak;\n\n            }else\n\n                printf(\"scalability not supported\\n\");\n\n            \n\n            // bin shape stuff FIXME\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2721, "prediction": "0", "true_label": "0", "raw_text": "sub_cmp&FF_CMP_CHROMA)\n\n            c->sub_motion_search= hpel_motion_search;\n\n        else if(   c->avctx->me_sub_cmp == FF_CMP_SAD \n\n                && c->avctx->    me_cmp == FF_CMP_SAD \n\n                && c->avctx->    mb_cmp == FF_CMP_SAD)\n\n            c->sub_motion_search= sad_hpel_motion_search; // 2050 vs. 2450 cycles\n\n        else\n\n            c->sub_motion_search= hpel_motion_search;\n\n    }\n\n    c->hpel_avg= s->dsp.avg_pixels_tab;\n\n    if(s->no_rounding) c->hpel_put= s->dsp.put_no_rnd_pixels_tab;\n\n    else               c->hpel_put= s->dsp.put_pixels_tab;\n\n\n\n    if(s->linesize){\n\n        c->stride  = s->linesize; \n\n        c->uvstride= s->uvlinesize;\n\n    }else{\n\n        c->stride  = 16*s->mb_width + 32;\n\n        c->uvstride=  8*s->mb_width + 16;\n\n    }\n\n\n\n    // 8x8 fullpel search would need a 4x4 chroma compare, which we dont have yet, and even if we had the motion estimation code doesnt expect it\n\n    if((c->avctx->me_cmp&FF_CMP_CHROMA) && !s->dsp.me_cmp[2]){\n\n        s->dsp.me_cmp[2]= zero_cmp;\n\n    }\n\n    if((c->avctx->me_sub_cmp&FF_CMP_CHROMA) && !s->dsp.me_sub_cmp[2]){\n\n        s->dsp.me_sub_cmp[2]= zero_cmp;\n\n    }\n\n    c->hpel_put[2][0]= c->hpel_put[2][1]=\n\n    c->hpel_put[2][2]= c->hpel_put[2][3]= zero_hpel;\n\n\n\n    c->temp= c->scratchpad;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2722, "prediction": "0", "true_label": "1", "raw_text": "*64];\n\n            sum += p[2*64] * q[2*64];\n\n            sum += p[3*64] * q[3*64];\n\n            sum += p[4*64] * q[4*64];\n\n            sum += p[5*64] * q[5*64];\n\n            sum += p[6*64] * q[6*64];\n\n            sum += p[7*64] * q[7*64];\n\n            tmp[i] = sum >> 14;\n\n            p++;\n\n            q++;\n\n        }\n\n        tmp1[0] = tmp[16];\n\n        for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i];\n\n        for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i];\n\n\n\n        /* integer IDCT 32 with normalization. XXX: There may be some\n\n           overflow left */\n\n        norm = 0;\n\n        for(i=0;i<32;i++) {\n\n            norm |= abs(tmp1[i]);\n\n        }\n\n        n = av_log2(norm) - 12;\n\n        if (n > 0) {\n\n            for(i=0;i<32;i++) \n\n                tmp1[i] >>= n;\n\n        } else {\n\n            n = 0;\n\n        }\n\n\n\n        idct32(out, tmp1, s->sblimit, n);\n\n\n\n        /* advance of 32 samples */\n\n        offset -= 32;\n\n        out += 32;\n\n        /* handle the wrap around */\n\n        if (offset < 0) {\n\n            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), \n\n                    s->samples_buf[ch], (512 - 32) * 2);\n\n            offset = SAMPLES_BUF_SIZE - 512;\n\n        }\n\n    }\n\n    s->samples_offset[ch] = offset;\n\n\n\n    //    print_pow(s->sb_samples, 1152);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2723, "prediction": "0", "true_label": "0", "raw_text": "Question: int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2724, "prediction": "0", "true_label": "0", "raw_text": "Question: AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)\n\n{\n\n    PCIBus *bus = PCI_BUS(dev->bus);\n\n    PCIBus *iommu_bus = bus;\n\n\n\n    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {\n\n        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);\n\n    }\n\n    if (iommu_bus && iommu_bus->iommu_fn) {\n\n        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);\n\n    }\n\n    return &address_space_memory;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2725, "prediction": "0", "true_label": "0", "raw_text": "Question: static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2726, "prediction": "0", "true_label": "0", "raw_text": "f) {\n\n        av_dlog(avctx, \"incomplete or broken packet\");\n\n        return -1;\n\n    }\n\n\n\n    p = buf;\n\n    p_end = buf + buf_size;\n\n\n\n    while (p_end - p >= 6 && *p == 0x0f) {\n\n        p += 1;\n\n        segment_type = *p++;\n\n        page_id = AV_RB16(p);\n\n        p += 2;\n\n        segment_length = AV_RB16(p);\n\n        p += 2;\n\n\n\n        if (p_end - p < segment_length) {\n\n            av_dlog(avctx, \"incomplete or broken packet\");\n\n            return -1;\n\n        }\n\n\n\n        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||\n\n            ctx->composition_id == -1 || ctx->ancillary_id == -1) {\n\n            switch (segment_type) {\n\n            case DVBSUB_PAGE_SEGMENT:\n\n                dvbsub_parse_page_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_REGION_SEGMENT:\n\n                dvbsub_parse_region_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_CLUT_SEGMENT:\n\n                dvbsub_parse_clut_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_OBJECT_SEGMENT:\n\n                dvbsub_parse_object_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAYDEFINITION_SEGMENT:\n\n                dvbsub_parse_display_definition_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAY_SEGMENT:\n\n                *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);\n\n                break;\n\n            default:\n\n                av_dlog(avctx, \"Subtitling segment type 0x%x, page id %d, length %d\\n\",\n\n                        segment_type, page_id, segment_length);\n\n                break;\n\n            }\n\n        }\n\n\n\n        p += segment_length;\n\n    }\n\n\n\n    return p - buf;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2727, "prediction": "0", "true_label": "0", "raw_text": "ret < 0)\n\n        fprintf(stderr, \"couldn't set /memory/reg\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-start\",\n\n                                    initrd_base);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\");\n\n\n\n    ret = qemu_devtree_setprop_cell(fdt, \"/chosen\", \"linux,initrd-end\",\n\n                                    (initrd_base + initrd_size));\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\");\n\n\n\n    ret = qemu_devtree_setprop_string(fdt, \"/chosen\", \"bootargs\",\n\n                                      kernel_cmdline);\n\n    if (ret < 0)\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n\n\n    if (kvm_enabled()) {\n\n        struct dirent *dirp;\n\n        DIR *dp;\n\n        char buf[128];\n\n\n\n        if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) {\n\n            printf(\"Can't open directory /proc/device-tree/cpus/\\n\");\n\n            goto out;\n\n        }\n\n\n\n        buf[0] = '\\0';\n\n        while ((dirp = readdir(dp)) != NULL) {\n\n            if (strncmp(dirp->d_name, \"PowerPC\", 7) == 0) {\n\n                snprintf(buf, 128, \"/cpus/%s\", dirp->d_name);\n\n                break;\n\n            }\n\n        }\n\n        closedir(dp);\n\n        if (buf[0] == '\\0') {\n\n            printf(\"Unknow host!\\n\");\n\n            goto out;\n\n        }\n\n\n\n        mpc8544_copy_soc_cell(fdt, buf, \"clock-frequency\");\n\n        mpc8544_copy_soc_cell(fdt, buf, \"timebase-frequency\");\n\n    }\n\n\n\n    cpu_physical_memory_write (addr, (void *)fdt, fdt_size);\n\n\n\nout:\n\n#endif\n\n\n\n    return fdt;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2728, "prediction": "0", "true_label": "0", "raw_text": "frame_size = av_rescale(sc->time_rate, st->codec->sample_rate, sc->time_scale);\n\n\n\n    if(st->duration != AV_NOPTS_VALUE){\n\n        assert(st->duration % sc->time_rate == 0);\n\n        st->duration /= sc->time_rate;\n\n    }\n\n    sc->ffindex = st->index;\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        if (url_fopen(&sc->pb, sc->drefs[sc->dref_id-1].path, URL_RDONLY) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR, \"stream %d, error opening file %s: %s\\n\",\n\n                   st->index, sc->drefs[sc->dref_id-1].path, strerror(errno));\n\n    } else\n\n        sc->pb = c->fc->pb;\n\n\n\n    switch (st->codec->codec_id) {\n\n#ifdef CONFIG_H261_DECODER\n\n    case CODEC_ID_H261:\n\n#endif\n\n#ifdef CONFIG_H263_DECODER\n\n    case CODEC_ID_H263:\n\n#endif\n\n#ifdef CONFIG_MPEG4_DECODER\n\n    case CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width= 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n#ifdef CONFIG_VORBIS_DECODER\n\n    case CODEC_ID_VORBIS:\n\n#endif\n\n        st->codec->sample_rate= 0; /* let decoder init parameters properly */\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->sample_to_chunk);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2729, "prediction": "0", "true_label": "0", "raw_text": "->encoder,\n\n                                             \"rate_control\",\n\n                                             SCHRO_ENCODER_RATE_CONTROL_CONSTANT_QUALITY);\n\n\n\n            quality = avctx->global_quality / FF_QP2LAMBDA;\n\n            if (quality > 10)\n\n                quality = 10;\n\n            schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                             \"quality\", quality);\n\n        }\n\n    } else {\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"rate_control\",\n\n                                         SCHRO_ENCODER_RATE_CONTROL_CONSTANT_BITRATE);\n\n\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"bitrate\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_INTERLACED_ME)\n\n        /* All material can be coded as interlaced or progressive\n\n           irrespective of the type of source material. */\n\n        schro_encoder_setting_set_double(p_schro_params->encoder,\n\n                                         \"interlaced_coding\", 1);\n\n\n\n    schro_encoder_setting_set_double(p_schro_params->encoder, \"open_gop\",\n\n                                     !(avctx->flags & CODEC_FLAG_CLOSED_GOP));\n\n\n\n    /* FIXME: Signal range hardcoded to 8-bit data until both libschroedinger\n\n     * and libdirac support other bit-depth data. */\n\n    schro_video_format_set_std_signal_range(p_schro_params->format,\n\n                                            SCHRO_SIGNAL_RANGE_8BIT_VIDEO);\n\n\n\n    /* Set the encoder format. */\n\n    schro_encoder_set_video_format(p_schro_params->encoder,\n\n                                   p_schro_params->format);\n\n\n\n    /* Set the debug level. */\n\n    schro_debug_set_level(avctx->debug);\n\n\n\n    schro_encoder_start(p_schro_params->encoder);\n\n\n\n    /* Initialize the encoded frame queue. */\n\n    ff_schro_queue_init(&p_schro_params->enc_frame_queue);\n\n    return 0;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}], [{"ID": 2730, "prediction": "0", "true_label": "0", "raw_text": "Question: static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO\n"}], [{"ID": 2731, "prediction": "0", "true_label": "0", "raw_text": " = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[dmv_no][0];\n\n    my += r->dmv[dmv_no][1];\n\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n\n        }\n\n    }\n\n}\n\nIs there a defect in the Code, and respond to YES or NO.\n\nAnswer: NO"}]]